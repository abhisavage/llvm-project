{"pr_number": 282, "url": "https://github.com/llvm/llvm-project/pull/282", "title": "[MLIR] Fix lowering of affine operations with return values.", "body": "This commit addresses the issue of lowering affine.for and affine.parallel having non zero return values. Relevant test cases are also added.\r\n\r\nSigned-off-by: Prateek Gupta <prateek@polymagelabs.com>", "feature_layers": ["ir"], "feature_directives": ["parallel", "for"], "files_changed": [{"filename": "mlir/lib/Conversion/AffineToStandard/AffineToStandard.cpp", "functions": ["success"]}]}
{"pr_number": 283, "url": "https://github.com/llvm/llvm-project/pull/283", "title": "[MLIR] Fix lowering of affine operations with return values.", "body": "This commit addresses the issue of lowering affine.for and affine.parallel having non zero return values. Relevant test cases are also added.\r\n\r\nSigned-off-by: Prateek Gupta <prateek@polymagelabs.com>", "feature_layers": ["ir"], "feature_directives": ["parallel", "for"], "files_changed": [{"filename": "mlir/lib/Conversion/AffineToStandard/AffineToStandard.cpp", "functions": ["success"]}]}
{"pr_number": 287, "url": "https://github.com/llvm/llvm-project/pull/287", "title": "BufferReuse", "body": "We created a pass for buffer reusing. This includes:\r\n- the search for each use range of an allocated value and their aliases\r\n-  finding all potential reuses for those values \r\n-  a fixpoint iteration which first finds a value which should be replaced\r\n-  and second updates the potential reuse lists of that value\r\n\r\nAlso we created tests for the implementation to ensure the right behavior.", "feature_layers": ["ir"], "feature_directives": ["for", "allocate"], "files_changed": [{"filename": "mlir/lib/Transforms/BufferOptimizations.cpp", "functions": ["isUsedBefore", "isRealUse", "usedInAliasBlock", "checkTypeCompatibility", "if", "isUsedBeforePostDom"]}]}
{"pr_number": 289, "url": "https://github.com/llvm/llvm-project/pull/289", "title": "Backport [analyzer] Fix cast evaluation on scoped enums in ExprEngine", "body": "It will prevent crashes during bugreport refutation.", "feature_layers": ["ast"], "feature_directives": [], "files_changed": [{"filename": "clang/test/Analysis/z3-refute-enum-crash.cpp", "functions": ["test_enum_types", "clang_analyzer_dump", "conjure"]}]}
{"pr_number": 307, "url": "https://github.com/llvm/llvm-project/pull/307", "title": "Unique stable name reimpl", "body": "Just a WIP to keep you guys up to date on my progress.  \r\n\r\nAs of the initial upload, this does the work to the instantiate-attr that needs to be done in order to have a place to mark all of the lambda types.  Additionally, it adds the Expr for the builtin-unique-stable-name that we'll need.  The CodeGen part doesn't work, and I've not started messing with the mangler yet, but I intend to do that soon.\r\n\r\nDon't worry about review, but if you have a 'todo' that you understand better than me, or spot some obvious error, feel free to share!\r\n\r\n@schittir Not sure why it won't let me add you as a 'reviewer', but here it is.", "feature_layers": ["codegen", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Parse/ParseExpr.cpp", "functions": ["ExprError", "T"]}, {"filename": "clang/lib/AST/ComputeDependence.cpp", "functions": ["toExprDependence"]}, {"filename": "clang/lib/AST/Expr.cpp", "functions": ["new", "Expr"]}, {"filename": "clang/lib/Sema/SemaExpr.cpp", "functions": ["ExprError", "BuildUniqueStableNameExpr"]}, {"filename": "clang/lib/Sema/SemaTemplateInstantiate.cpp", "functions": ["TransformUniqueStableNameExpr", "getSema"]}]}
{"pr_number": 317, "url": "https://github.com/llvm/llvm-project/pull/317", "title": "Added globalisel for m68k", "body": "", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/M68k/M68kCallLowering.cpp", "functions": ["CallLowering"]}, {"filename": "llvm/lib/Target/M68k/M68kInstructionSelector.cpp", "functions": ["select", "M68kInstructionSelector", "InstructionSelector", "selectImpl"]}, {"filename": "llvm/lib/Target/M68k/M68kRegisterBankInfo.cpp", "functions": ["M68kGenRegisterBankInfo"]}, {"filename": "llvm/lib/Target/M68k/M68kTargetMachine.cpp", "functions": ["addGlobalInstructionSelect", "addLegalizeMachineIR", "addRegBankSelect", "addIRTranslator"]}]}
{"pr_number": 339, "url": "https://github.com/llvm/llvm-project/pull/339", "title": "Add support for NOLINTBEGIN ... NOLINTEND markers to suppress ClangTi\u2026", "body": "\u2026dy warnings over multiple lines.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang-tools-extra/clang-tidy/ClangTidyDiagnosticConsumer.cpp", "functions": ["IsNOLINTFound"]}]}
{"pr_number": 353, "url": "https://github.com/llvm/llvm-project/pull/353", "title": "added not-tested LinalgTilingToParallelLoops pass", "body": "I have not tested this yet, but added a pass for registration in the table gen files. We can't use the createTilingPass within our pass, because that runs on functions and will tile every linalg op in the function with the same tiling parameters. this is not what we want. I will be using the rewrite patters that TilingPass uses to rewrite each linalg op individually.", "feature_layers": [], "feature_directives": ["parallel", "for"], "files_changed": [{"filename": "mlir/lib/Dialect/Linalg/Transforms/Tiling.cpp", "functions": ["runOnOperation", "findPreviousPowerOfTwo", "maxFootprint", "findNextPowerOfTwo", "MemoryFootPrintReducePass", "runOnFunction", "pm", "newShape", "getOperands"]}]}
{"pr_number": 363, "url": "https://github.com/llvm/llvm-project/pull/363", "title": "Aug rewrite", "body": "removed MOVri32 pseudo instruction, added functionality in MCInstLowering to fold large immediate directly into their target instructions with AUG*", "feature_layers": ["ir"], "feature_directives": ["target"], "files_changed": [{"filename": "clang/lib/Basic/Targets.cpp", "functions": ["P2TargetInfo"]}, {"filename": "clang/lib/CodeGen/TargetInfo.cpp", "functions": ["getNaturalAlignIndirect"]}, {"filename": "clang/lib/Driver/ToolChains/P2.cpp", "functions": ["getDriver", "Generic_ELF"]}, {"filename": "lld/ELF/Arch/P2.cpp", "functions": ["getRelExpr", "relocate"]}, {"filename": "lld/ELF/Target.cpp", "functions": ["getP2TargetInfo"]}, {"filename": "llvm/lib/Target/P2/AsmParser/P2AsmParser.cpp", "functions": ["getReg", "MatchAndEmitInstruction"]}, {"filename": "llvm/lib/Target/P2/Disassembler/P2Disassembler.cpp", "functions": ["decodeJump9Target", "decodeCogJumpTarget"]}, {"filename": "llvm/lib/Target/P2/MCTargetDesc/P2AsmBackend.cpp", "functions": ["adjustFixupValue"]}, {"filename": "llvm/lib/Target/P2/MCTargetDesc/P2ELFObjectWriter.cpp", "functions": ["getRelocType"]}, {"filename": "llvm/lib/Target/P2/MCTargetDesc/P2InstPrinter.cpp", "functions": ["StringRef"]}, {"filename": "llvm/lib/Target/P2/MCTargetDesc/P2MCCodeEmitter.cpp", "functions": ["P2MCCodeEmitter", "getExprOpValue"]}, {"filename": "llvm/lib/Target/P2/MCTargetDesc/P2MCTargetDesc.cpp", "functions": ["X"]}, {"filename": "llvm/lib/Target/P2/P2AsmPrinter.cpp", "functions": ["X"]}, {"filename": "llvm/lib/Target/P2/P2DelUselessJMP.cpp", "functions": ["getPassName", "runOnMachineBasicBlock", "EnableDelJmp", "runOnMachineFunction", "DelJmp"]}, {"filename": "llvm/lib/Target/P2/P2ExpandPseudos.cpp", "functions": ["expand_SELECTCC"]}, {"filename": "llvm/lib/Target/P2/P2FrameLowering.cpp", "functions": ["function", "first", "address", "pointer", "argument"]}, {"filename": "llvm/lib/Target/P2/P2ISelDAGToDAG.cpp", "functions": ["P2DAGToDAGISel", "DL"]}, {"filename": "llvm/lib/Target/P2/P2ISelLowering.cpp", "functions": ["getRegisterByName"]}, {"filename": "llvm/lib/Target/P2/P2InstrInfo.cpp", "functions": ["isTJOpcode"]}, {"filename": "llvm/lib/Target/P2/P2MCInstLower.cpp", "functions": ["MCOperand", "LowerSymbolOperand"]}, {"filename": "llvm/lib/Target/P2/P2RegisterInfo.cpp", "functions": ["Reserved"]}, {"filename": "llvm/lib/Target/P2/P2TargetMachine.cpp", "functions": ["X"]}, {"filename": "clang-tools-extra/clangd/refactor/tweaks/ExtractFunction.cpp", "functions": ["if", "decrementLoopSwitchCounters"]}, {"filename": "clang-tools-extra/clangd/refactor/tweaks/SwapIfBranches.cpp", "functions": ["hidden"]}, {"filename": "clang-tools-extra/clangd/unittests/TweakTests.cpp", "functions": ["foo"]}, {"filename": "clang-tools-extra/test/clang-tidy/checkers/bugprone-bad-signal-to-kill-thread-sigterm-not-a-literal.cpp", "functions": ["func", "pthread_kill"]}, {"filename": "clang-tools-extra/test/clang-tidy/checkers/bugprone-bad-signal-to-kill-thread-undef-sigterm.cpp", "functions": ["func", "pthread_kill"]}, {"filename": "clang-tools-extra/test/clang-tidy/checkers/bugprone-bool-pointer-implicit-conversion.cpp", "functions": ["foo"]}, {"filename": "clang/lib/AST/DeclPrinter.cpp", "functions": ["if"]}, {"filename": "clang/lib/AST/Type.cpp", "functions": ["MatrixType"]}, {"filename": "clang/lib/Analysis/CFG.cpp", "functions": ["VisitChildrenForTemporaryDtors"]}, {"filename": "clang/lib/CodeGen/CGStmtOpenMP.cpp", "functions": ["CGSI", "CapInfoRAII", "Scope"]}, {"filename": "clang/lib/Sema/SemaChecking.cpp", "functions": ["OtherPromotedValueRange", "OtherPromotedTypeRange", "OtherPromotedRange"]}, {"filename": "clang/lib/StaticAnalyzer/Checkers/WebKit/UncountedLambdaCapturesChecker.cpp", "functions": ["LocalVisitor", "visitor", "Os", "shouldVisitImplicitCode", "visitLambdaExpr", "BSLoc", "Checker", "VisitLambdaExpr", "shouldVisitTemplateInstantiations"]}, {"filename": "clang/test/Analysis/Checkers/WebKit/uncounted-lambda-captures.cpp", "functions": ["quiet", "raw_ptr", "references"]}, {"filename": "clang/test/Analysis/cfg.cpp", "functions": ["f"]}, {"filename": "clang/test/CodeGen/atomics-sema-alignment.c", "functions": ["braz"]}, {"filename": "clang/test/CodeGen/builtin-bpf-btf-type-id.c", "functions": ["__builtin_btf_type_id", "test3"]}, {"filename": "clang/test/CodeGen/builtins-bpf-preserve-field-info-3.c", "functions": ["unit1", "_", "unit2", "unit3"]}, {"filename": "clang/test/CodeGen/builtins-bpf-preserve-field-info-4.c", "functions": ["unit1", "_", "unit2"]}, {"filename": "clang/test/CodeGen/builtins-wasm.c", "functions": ["extract_lane_u_i8x16", "narrow_u_i16x8_i32x4", "min_u_i8x16", "min_u_i16x8", "max_u_i16x8", "sub_saturate_u_i8x16", "__attribute", "extract_lane_u_i16x8", "add_saturate_u_i8x16", "narrow_u_i8x16_i16x8", "max_u_i8x16", "avgr_u_i16x8", "avgr_u_i8x16", "add_saturate_u_i16x8", "sub_saturate_u_i16x8", "min_u_i32x4", "max_u_i32x4"]}, {"filename": "clang/test/CodeGen/ext-int.c", "functions": ["Size1ExtIntParam", "_ExtInt"]}, {"filename": "clang/test/Headers/wasm.c", "functions": ["main"]}, {"filename": "clang/test/Sema/builtins-bpf.c", "functions": ["valid13", "invalid18", "valid12", "valid14", "valid15", "__builtin_preserve_type_info", "invalid16", "int", "__builtin_preserve_enum_value", "invalid17"]}, {"filename": "clang/unittests/AST/DeclPrinterTest.cpp", "functions": ["Args"]}, {"filename": "clang/unittests/Tooling/Syntax/TreeTest.cpp", "functions": ["addFile", "f", "tokens", "test", "DiagnosticOptions"]}, {"filename": "compiler-rt/test/sanitizer_common/TestCases/Posix/recursion-in-qsort.cpp", "functions": ["descending_compare_ints", "main", "sort_and_compare", "ascending_compare_ints"]}, {"filename": "flang/lib/Parser/unparse.cpp", "functions": ["Unparse"]}, {"filename": "libc/src/ctype/isalnum.cpp", "functions": ["LLVM_LIBC_ENTRYPOINT"]}, {"filename": "libc/src/ctype/isblank.cpp", "functions": ["LLVM_LIBC_ENTRYPOINT"]}, {"filename": "libc/src/ctype/iscntrl.cpp", "functions": ["LLVM_LIBC_ENTRYPOINT"]}, {"filename": "libc/src/ctype/isgraph.cpp", "functions": ["LLVM_LIBC_ENTRYPOINT"]}, {"filename": "libc/src/ctype/isprint.cpp", "functions": ["LLVM_LIBC_ENTRYPOINT"]}, {"filename": "libc/src/ctype/ispunct.cpp", "functions": ["LLVM_LIBC_ENTRYPOINT"]}, {"filename": "libc/src/ctype/isspace.cpp", "functions": ["LLVM_LIBC_ENTRYPOINT"]}, {"filename": "libc/src/ctype/isxdigit.cpp", "functions": ["LLVM_LIBC_ENTRYPOINT"]}, {"filename": "libc/src/string/strspn.cpp", "functions": ["LLVM_LIBC_ENTRYPOINT"]}, {"filename": "libc/test/src/ctype/ispunct_test.cpp", "functions": ["is_punctuation_character"]}, {"filename": "lld/ELF/EhFrame.cpp", "functions": ["if"]}, {"filename": "lld/MachO/Driver.cpp", "functions": ["findLibrary"]}, {"filename": "lldb/source/API/SBTarget.cpp", "functions": ["LLDB_RECORD_RESULT"]}, {"filename": "lldb/source/Core/IOHandlerCursesGUI.cpp", "functions": ["GetCursorX", "GetMaxX", "GetParentOrigin", "PrintfTruncated", "GetParentX", "GetHeight", "TerminalSizeChanged", "LimitLengthToRestOfLine", "GetFrame", "GetParentY", "GetMaxY", "PutCStringTruncated", "GetBounds", "GetWidth", "SelectPreviousWindowAsActive", "GetSize", "GetCursorY", "ToggleBreakpointOnSelectedLine"]}, {"filename": "lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.cpp", "functions": ["PyUnicode_GetLength"]}, {"filename": "lldb/test/API/commands/gui/breakpoints/main.c", "functions": ["main"]}, {"filename": "lldb/test/API/commands/gui/viewlarge/main.c", "functions": ["main"]}, {"filename": "lldb/test/API/macosx/macCatalyst/main.c", "functions": ["main"]}, {"filename": "lldb/test/API/python_api/target/main.c", "functions": ["main"]}, {"filename": "llvm/lib/Analysis/BranchProbabilityInfo.cpp", "functions": ["BB", "SuccLB", "isLoopEnteringEdge", "if", "LB", "Edge"]}, {"filename": "llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp", "functions": ["print", "printTensor"]}, {"filename": "llvm/lib/Analysis/InstructionSimplify.cpp", "functions": ["getMaxMinLimit", "getFalse", "getTrue", "isMinMax", "getMaxMinOpposite"]}, {"filename": "llvm/lib/Analysis/TFUtils.cpp", "functions": ["Name", "TF_DataTypeSize", "TF_TensorData"]}, {"filename": "llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp", "functions": ["translateBinaryOp"]}, {"filename": "llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp", "functions": ["widenScalarAddSubShlSat", "lowerExtractVectorElt", "widenScalarAddSubSat", "lowerExtractInsertVectorElt", "lowerShlSat", "fewerElementsVectorExtractVectorElt"]}, {"filename": "llvm/lib/CodeGen/RDFLiveness.cpp", "functions": ["Tmp"]}, {"filename": "llvm/lib/CodeGen/RDFRegisters.cpp", "functions": ["AR", "AS", "Regs"]}, {"filename": "llvm/lib/CodeGen/SelectionDAG/FastISel.cpp", "functions": ["selectFNeg"]}, {"filename": "llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp", "functions": ["if"]}, {"filename": "llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp", "functions": ["NameStr", "getContext"]}, {"filename": "llvm/lib/Support/CommandLine.cpp", "functions": ["ExpandResponseFiles"]}, {"filename": "llvm/lib/Support/X86TargetParser.cpp", "functions": ["any"]}, {"filename": "llvm/lib/Target/AArch64/AArch64ISelLowering.cpp", "functions": ["LowerDIV", "convertFromScalableVector", "dl", "if", "LowerToScalableOp", "LowerToPredicatedOp", "LowerMUL", "LowerXOR"]}, {"filename": "llvm/lib/Target/AArch64/AArch64RegisterInfo.cpp", "functions": ["hasSVEArgsOrReturn"]}, {"filename": "llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp", "functions": ["EntryBuilder"]}, {"filename": "llvm/lib/Target/AMDGPU/AMDGPUCallLowering.cpp", "functions": ["getMultipleType"]}, {"filename": "llvm/lib/Target/AMDGPU/AMDGPUInstructionSelector.cpp", "functions": ["selectG_GLOBAL_VALUE", "selectReturnAddress", "getDSShaderTypeValue", "selectG_FRAME_INDEX_GLOBAL_VALUE"]}, {"filename": "llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp", "functions": ["insertLiveInCopy", "legalizeRsqClampIntrinsic", "getDSFPAtomicOpcode", "SGPR01", "if", "legalizeDSAtomicFPIntrinsic"]}, {"filename": "llvm/lib/Target/AMDGPU/SIFrameLowering.cpp", "functions": ["frameTriviallyRequiresSP"]}, {"filename": "llvm/lib/Target/AMDGPU/SIISelLowering.cpp", "functions": ["lowerStructBufferAtomicIntrin", "lowerRawBufferAtomicIntrin", "performMemSDNodeCombine"]}, {"filename": "llvm/lib/Target/AMDGPU/SIRegisterInfo.cpp", "functions": ["Register"]}, {"filename": "llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp", "functions": ["AccessStr"]}, {"filename": "llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp", "functions": ["if", "ICmpInst"]}, {"filename": "llvm/lib/Transforms/InstCombine/InstructionCombining.cpp", "functions": ["if", "CondVal", "replaceInstUsesWith"]}, {"filename": "llvm/lib/Transforms/Scalar/JumpThreading.cpp", "functions": ["ProcessBranchOnPHI"]}, {"filename": "llvm/lib/Transforms/Vectorize/LoopVectorize.cpp", "functions": ["B", "createInductionResumeValues", "completeLoopSkeleton", "collectInLoopReductions", "isInLoopReduction", "Hints"]}, {"filename": "llvm/tools/llvm-readobj/COFFDumper.cpp", "functions": ["createError"]}, {"filename": "llvm/tools/llvm-symbolizer/llvm-symbolizer.cpp", "functions": ["Hint", "parseIntArg", "ClVerbose", "ClBasenamesShort", "main", "Printer", "ClBasenames", "COM", "if", "ClBinaryNameAliasE", "ClPrettyPrintShort", "ClPrintFunctionsShort", "X", "Symbolizer", "V", "ClDefaultArch", "Saver"]}, {"filename": "llvm/tools/obj2yaml/elf2yaml.cpp", "functions": ["shouldPrintSection", "Obj", "elf2yaml", "Dumper"]}, {"filename": "mlir/lib/CAPI/IR/IR.cpp", "functions": ["mlirValueGetType", "mlirBlockGetNumArguments", "mlirTypeDump", "mlirRegionGetFirstBlock", "mlirBlockGetFirstOperation", "mlirBlockDestroy", "mlirLocationUnknownGet", "cppState", "mlirModuleDestroy", "wrap", "mlirOperationStateGet", "mlirRegionCreate", "mlirOperationGetAttribute", "mlirOperationGetNumSuccessors", "mlirOperationGetRegion", "mlirOperationGetNumAttributes", "mlirOperationIsNull", "mlirOperationCreate", "mlirAttributeDump", "mlirContextCreate", "mlirOperationGetResult", "mlirBlockCreate", "mlirAttributeParseGet", "mlirModuleCreateParse", "mlirModuleCreateEmpty", "mlirBlockGetNextInRegion", "mlirBlockAppendOwnedOperation", "mlirOperationGetNumResults", "unwrap", "mlirOperationGetOperand", "mlirNamedAttributeGet", "mlirOperationGetSuccessor", "mlirRegionAppendOwnedBlock", "mlirBlockIsNull", "mlirOperationGetNextInBlock", "mlirTypeParseGet", "mlirContextDestroy", "mlirRegionIsNull", "mlirOperationDump", "mlirModuleGetOperation", "mlirOperationGetNumOperands", "mlirBlockGetArgument", "mlirOperationDestroy", "mlirRegionDestroy", "mlirOperationGetNumRegions"]}, {"filename": "mlir/lib/CAPI/Registration/Registration.cpp", "functions": ["mlirRegisterAllDialects"]}, {"filename": "mlir/lib/Conversion/GPUCommon/ConvertLaunchFuncToRuntimeCalls.cpp", "functions": ["getInt64Type", "success", "getPointerPointerType", "allocatePointer", "getIntPtrType", "declareGpuRuntimeFunctions", "failure", "functionName", "setupParamsArray", "getInt32Type", "initializeCachedTypes", "getLLVMDialect", "converter", "OpBuilder", "translateGpuLaunchCalls", "target", "runOnOperation", "getInt8Type", "getVoidType", "ConvertOpToGpuRuntimeCallPattern", "signalPassFailure", "builder", "getPointerType"]}, {"filename": "mlir/lib/Conversion/GPUToVulkan/ConvertLaunchFuncToVulkanCalls.cpp", "functions": ["getLLVMDialect"]}, {"filename": "mlir/lib/Conversion/SPIRVToLLVM/ConvertSPIRVToLLVM.cpp", "functions": ["failure", "success"]}, {"filename": "mlir/lib/Conversion/StandardToLLVM/StandardToLLVM.cpp", "functions": ["success", "transformed", "createIndexConstant", "failure", "desc", "unrankedDesc", "getDialect"]}, {"filename": "mlir/lib/Conversion/VectorToLLVM/ConvertVectorToLLVM.cpp", "functions": ["success"]}, {"filename": "mlir/lib/Dialect/Linalg/IR/LinalgOps.cpp", "functions": ["foldMemRefCast", "RewritePattern", "success", "failure"]}, {"filename": "mlir/lib/Dialect/Shape/IR/Shape.cpp", "functions": ["failure", "Dialect"]}, {"filename": "mlir/lib/Dialect/Vector/VectorOps.cpp", "functions": ["Dialect"]}, {"filename": "mlir/lib/Dialect/Vector/VectorTransforms.cpp", "functions": ["failure", "pat3", "success"]}, {"filename": "mlir/lib/IR/AffineExpr.cpp", "functions": ["replace", "getAffineBinaryOpExpr"]}, {"filename": "mlir/lib/IR/OperationSupport.cpp", "functions": ["if", "TypeRange"]}, {"filename": "mlir/lib/IR/StandardTypes.cpp", "functions": ["getImpl"]}, {"filename": "mlir/lib/IR/TypeRange.cpp", "functions": ["if", "TypeRange"]}, {"filename": "mlir/lib/Target/LLVMIR/ConvertFromLLVMIR.cpp", "functions": ["os"]}, {"filename": "mlir/lib/Target/LLVMIR/TypeTranslation.cpp", "functions": ["TypeFromLLVMIRTranslator", "impl", "TypeToLLVMIRTranslator"]}, {"filename": "mlir/test/CAPI/ir.c", "functions": ["collectStats", "collectStatsSingle", "main", "makeAdd"]}, {"filename": "mlir/test/lib/Dialect/LLVMIR/LLVMTypeTestDialect.cpp", "functions": ["registerLLVMTypeTestDialect", "printType", "parseType", "getDialectNamespace"]}, {"filename": "mlir/test/lib/Target/TestLLVMTypeTranslation.cpp", "functions": ["registerTestLLVMTypeTranslation", "success"]}, {"filename": "mlir/tools/mlir-opt/mlir-opt.cpp", "functions": ["registerLLVMTypeTestDialect"]}, {"filename": "mlir/tools/mlir-translate/mlir-translate.cpp", "functions": ["registerLLVMTypeTestDialect", "registerTestLLVMTypeTranslation"]}, {"filename": "openmp/libomptarget/src/omptarget.cpp", "functions": ["MapperArgs", "MapperArgsBase", "MapperArgTypes", "MapperArgSizes"]}, {"filename": "openmp/libomptarget/test/mapping/present/target_array_extension.c", "functions": ["main"]}, {"filename": "openmp/libomptarget/test/mapping/present/target_data_array_extension.c", "functions": ["main"]}, {"filename": "openmp/libomptarget/test/mapping/present/target_data_at_exit.c", "functions": ["main"]}, {"filename": "openmp/libomptarget/test/mapping/present/target_update_array_extension.c", "functions": ["main"]}, {"filename": "openmp/libomptarget/test/mapping/target_data_array_extension_at_exit.c", "functions": ["check_is_present", "check_not_present", "main"]}, {"filename": "openmp/libomptarget/test/mapping/target_update_array_extension.c", "functions": ["main"]}, {"filename": "clang-tools-extra/clang-tidy/modernize/UseAutoCheck.cpp", "functions": ["hasStdIteratorName", "hasStdContainerName", "hasAnyName"]}, {"filename": "clang-tools-extra/clangd/SemanticHighlighting.cpp", "functions": ["TraverseTemplateArgumentLoc"]}, {"filename": "clang-tools-extra/clangd/unittests/DiagnosticsTests.cpp", "functions": ["func", "pthread_kill"]}, {"filename": "clang/lib/AST/DeclOpenMP.cpp", "functions": ["new"]}, {"filename": "clang/lib/AST/ExprConstant.cpp", "functions": ["if"]}, {"filename": "clang/lib/AST/StmtOpenMP.cpp", "functions": ["new", "getRawStmt", "sizeof", "getInnermostCapturedStmt"]}, {"filename": "clang/lib/Basic/FixedPoint.cpp", "functions": ["APFixedPoint", "if"]}, {"filename": "clang/lib/Sema/SemaExpr.cpp", "functions": ["getOpenMPDeclareMapperVarName", "if", "InvalidOperands"]}, {"filename": "clang/lib/Sema/SemaExprCXX.cpp", "functions": ["ExprError"]}, {"filename": "clang/lib/Sema/SemaOpenMP.cpp", "functions": ["addDeclareMapperVarRef", "VisitCXXOperatorCallExpr"]}, {"filename": "clang/lib/Sema/SemaOverload.cpp", "functions": ["ExprError"]}, {"filename": "clang/lib/Sema/SemaTemplateInstantiateDecl.cpp", "functions": ["Locs", "ThisScope"]}, {"filename": "clang/lib/Sema/SemaTemplateVariadic.cpp", "functions": ["ExprError", "DiagnoseUnexpandedParameterPacks", "new"]}, {"filename": "clang/lib/Tooling/Syntax/BuildTree.cpp", "functions": ["getDeclarationRange", "getRange", "WalkUpFromDependentScopeDeclRefExpr", "new", "foldNode", "getStmtRange", "getLocalSourceRange", "isImplicitExpr", "getExprRange", "assignRole"]}, {"filename": "clang/test/Analysis/use-after-move.cpp", "functions": ["test"]}, {"filename": "clang/test/CodeGen/builtins-ppc-p10vector.c", "functions": ["test_vec_extractl_uc", "test_vec_extractl_ui", "test_vec_extracth_us", "test_vec_extractl_us", "vec_extracth", "test_vec_extracth_ui", "vec_extractl", "test_vec_extracth_uc", "test_vec_extractl_ul", "test_vec_extracth_ul"]}, {"filename": "clang/test/OpenMP/sections_misc_messages.c", "functions": ["if"]}, {"filename": "clang/test/OpenMP/target_map_codegen.cpp", "functions": ["implicit_maps_parameter", "array_shaping", "bar", "implicit_maps_array", "implicit_maps_templated_class", "explicit_maps_template_args_and_members", "implicit_maps_float_complex", "explicit_maps_with_private_class_members", "foo", "modify", "implicit_maps_pointer", "implicit_maps_float", "implicit_maps_variable_length_array", "implicit_maps_template_type_capture", "c", "explicit_maps_inside_captured", "implicit_maps_templated_function", "implicit_maps_struct", "implicit_maps_class", "sa", "explicit_maps_globals", "explicit_maps_struct_fields", "explicit_maps_member_pointer_references", "explicit_maps_single", "zero_size_section_and_private_maps", "test", "map_with_deep_copy", "sb", "explicit_maps_pointer_references", "implicit_maps_reference", "implicit_maps_nested_integer_and_enum", "implicit_maps_double_complex", "ssst", "explicit_maps_references_and_function_args", "sss", "implicit_maps_double", "implicit_maps_host_global", "implicit_maps_integer", "test_present_members", "implicit_maps_nested_integer", "explicit_maps_with_inner_lambda"]}, {"filename": "clang/test/OpenMP/target_map_codegen_00.cpp", "functions": ["implicit_maps_integer", "modify"]}, {"filename": "clang/test/OpenMP/target_map_codegen_01.cpp", "functions": ["implicit_maps_reference"]}, {"filename": "clang/test/OpenMP/target_map_codegen_02.cpp", "functions": ["implicit_maps_parameter"]}, {"filename": "clang/test/OpenMP/target_map_codegen_03.cpp", "functions": ["implicit_maps_nested_integer"]}, {"filename": "clang/test/OpenMP/target_map_codegen_04.cpp", "functions": ["implicit_maps_nested_integer_and_enum"]}, {"filename": "clang/test/OpenMP/target_map_codegen_05.cpp", "functions": ["implicit_maps_host_global"]}, {"filename": "clang/test/OpenMP/target_map_codegen_06.cpp", "functions": ["implicit_maps_double"]}, {"filename": "clang/test/OpenMP/target_map_codegen_07.cpp", "functions": ["implicit_maps_float"]}, {"filename": "clang/test/OpenMP/target_map_codegen_08.cpp", "functions": ["implicit_maps_array"]}, {"filename": "clang/test/OpenMP/target_map_codegen_09.cpp", "functions": ["implicit_maps_pointer"]}, {"filename": "clang/test/OpenMP/target_map_codegen_10.cpp", "functions": ["implicit_maps_double_complex"]}, {"filename": "clang/test/OpenMP/target_map_codegen_11.cpp", "functions": ["implicit_maps_float_complex"]}, {"filename": "clang/test/OpenMP/target_map_codegen_12.cpp", "functions": ["implicit_maps_variable_length_array"]}, {"filename": "clang/test/OpenMP/target_map_codegen_13.cpp", "functions": ["sss", "foo", "implicit_maps_class"]}, {"filename": "clang/test/OpenMP/target_map_codegen_14.cpp", "functions": ["bar", "foo", "implicit_maps_templated_class", "ssst"]}, {"filename": "clang/test/OpenMP/target_map_codegen_15.cpp", "functions": ["foo", "implicit_maps_templated_function"]}, {"filename": "clang/test/OpenMP/target_map_codegen_16.cpp", "functions": ["implicit_maps_struct"]}, {"filename": "clang/test/OpenMP/target_map_codegen_17.cpp", "functions": ["implicit_maps_template_type_capture", "foo"]}, {"filename": "clang/test/OpenMP/target_map_codegen_18.cpp", "functions": ["explicit_maps_single"]}, {"filename": "clang/test/OpenMP/target_map_codegen_19.cpp", "functions": ["explicit_maps_references_and_function_args"]}, {"filename": "clang/test/OpenMP/target_map_codegen_20.cpp", "functions": ["foo", "explicit_maps_template_args_and_members"]}, {"filename": "clang/test/OpenMP/target_map_codegen_21.cpp", "functions": ["explicit_maps_globals"]}, {"filename": "clang/test/OpenMP/target_map_codegen_22.cpp", "functions": ["explicit_maps_inside_captured"]}, {"filename": "clang/test/OpenMP/target_map_codegen_23.cpp", "functions": ["explicit_maps_struct_fields"]}, {"filename": "clang/test/OpenMP/target_map_codegen_24.cpp", "functions": ["foo", "explicit_maps_with_inner_lambda"]}, {"filename": "clang/test/OpenMP/target_map_codegen_25.cpp", "functions": ["c", "foo", "explicit_maps_with_private_class_members"]}, {"filename": "clang/test/OpenMP/target_map_codegen_26.cpp", "functions": ["zero_size_section_and_private_maps"]}, {"filename": "clang/test/OpenMP/target_map_codegen_27.cpp", "functions": ["explicit_maps_pointer_references"]}, {"filename": "clang/test/OpenMP/target_map_codegen_28.cpp", "functions": ["sa", "foo", "sb", "explicit_maps_member_pointer_references"]}, {"filename": "clang/test/OpenMP/target_map_codegen_29.cpp", "functions": ["map_with_deep_copy"]}, {"filename": "clang/test/OpenMP/target_map_codegen_30.cpp", "functions": ["explicit_maps_single"]}, {"filename": "clang/test/OpenMP/target_map_codegen_31.cpp", "functions": ["explicit_maps_single"]}, {"filename": "clang/test/OpenMP/target_map_codegen_32.cpp", "functions": ["test_present_members", "test"]}, {"filename": "clang/test/OpenMP/target_map_codegen_33.cpp", "functions": ["array_shaping"]}, {"filename": "clang/test/OpenMP/target_map_messages.cpp", "functions": ["operator"]}, {"filename": "clang/test/Sema/arm-bfloat.cpp", "functions": ["test_vector"]}, {"filename": "clang/test/Sema/warn-bad-function-cast.c", "functions": ["ff1"]}, {"filename": "clang/test/SemaTemplate/cxx1z-fold-expressions.cpp", "functions": ["g"]}, {"filename": "clang/test/SemaTemplate/recovery-tree-transform-crash.cpp", "functions": ["call", "run", "test"]}, {"filename": "compiler-rt/test/msan/libatomic.c", "functions": ["copy", "__attribute", "main"]}, {"filename": "compiler-rt/test/msan/scanf-allocate.cpp", "functions": ["main"]}, {"filename": "flang/lib/Semantics/check-data.cpp", "functions": ["ValueListIterator", "HasSurplusValues", "IsAtEnd", "Scan", "SetRepetitionCount", "hasFatalError", "InitElement", "LocateSource", "InitDesignator"]}, {"filename": "flang/lib/Semantics/check-declarations.cpp", "functions": ["SayWithDeclaration"]}, {"filename": "flang/lib/Semantics/compute-offsets.cpp", "functions": ["DoEquivalenceBlockBase"]}, {"filename": "flang/lib/Semantics/data-to-inits.cpp", "functions": ["ValueListIterator", "HasSurplusValues", "IsAtEnd", "Scan", "SetRepetitionCount", "hasFatalError", "InitElement", "LocateSource", "InitDesignator"]}, {"filename": "flang/runtime/io-api.cpp", "functions": ["EditIntegerInput", "InputReal", "OutputReal", "EditDefaultCharacterOutput", "EditDefaultCharacterInput", "EditLogicalInput", "ListDirectedLogicalOutput", "EditIntegerOutput", "EditLogicalOutput", "ListDirectedDefaultCharacterOutput", "InputComplex", "OutputComplex", "IONAME"]}, {"filename": "libc/loader/linux/x86_64/start.cpp", "functions": ["initTLS"]}, {"filename": "libc/src/ctype/islower.cpp", "functions": ["LLVM_LIBC_ENTRYPOINT"]}, {"filename": "libc/src/ctype/isupper.cpp", "functions": ["LLVM_LIBC_ENTRYPOINT"]}, {"filename": "libc/src/ctype/tolower.cpp", "functions": ["LLVM_LIBC_ENTRYPOINT"]}, {"filename": "libc/src/ctype/toupper.cpp", "functions": ["LLVM_LIBC_ENTRYPOINT"]}, {"filename": "libc/src/string/strcspn.cpp", "functions": ["LLVM_LIBC_ENTRYPOINT"]}, {"filename": "libc/test/loader/linux/tls_test.cpp", "functions": ["main"]}, {"filename": "libc/utils/FPUtil/TestHelpers.cpp", "functions": ["bits", "s"]}, {"filename": "libc/utils/UnitTest/Test.cpp", "functions": ["S", "s", "LHSBits", "Bits", "describeValue"]}, {"filename": "lld/MachO/Arch/X86_64.cpp", "functions": ["getSymbolVA"]}, {"filename": "lld/MachO/InputSection.cpp", "functions": ["if"]}, {"filename": "lldb/source/API/SBThreadPlan.cpp", "functions": ["thread_plan_sp"]}, {"filename": "lldb/source/Plugins/ExpressionParser/Clang/ClangASTImporter.cpp", "functions": ["DeclOrigin"]}, {"filename": "lldb/source/Plugins/Platform/MacOSX/PlatformAppleSimulator.cpp", "functions": ["PlatformDarwin", "Initialize", "if", "Terminate", "platform_module_spec", "resolved_module_spec", "PlatformSP", "CreateInstance"]}, {"filename": "lldb/source/Plugins/Platform/MacOSX/PlatformAppleTVSimulator.cpp", "functions": ["platform_module_spec", "resolved_module_spec", "PlatformSP", "g_name"]}, {"filename": "lldb/source/Plugins/Platform/MacOSX/PlatformAppleWatchSimulator.cpp", "functions": ["platform_module_spec", "resolved_module_spec", "PlatformSP", "g_name"]}, {"filename": "lldb/source/Plugins/Platform/MacOSX/PlatformiOSSimulator.cpp", "functions": ["platform_module_spec", "resolved_module_spec", "PlatformSP", "g_name"]}, {"filename": "lldb/unittests/Utility/ArchSpecTest.cpp", "functions": ["B", "A"]}, {"filename": "llvm/lib/CodeGen/AsmPrinter/DIE.cpp", "functions": ["Die"]}, {"filename": "llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp", "functions": ["DIEUnit"]}, {"filename": "llvm/lib/CodeGen/BasicBlockSections.cpp", "functions": ["BBSectionsPrepare", "BasicBlockSections"]}, {"filename": "llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp", "functions": ["if"]}, {"filename": "llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp", "functions": ["ExpandIntRes_SHLSAT"]}, {"filename": "llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp", "functions": ["dl"]}, {"filename": "llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp", "functions": ["regBankBoolUnion", "regBankUnion"]}, {"filename": "llvm/lib/Target/VE/VEISelLowering.cpp", "functions": ["SDValue", "combineTRUNCATE", "isI32Insn", "DL"]}, {"filename": "llvm/lib/Transforms/IPO/AttributorAttributes.cpp", "functions": ["trackStatistics", "AAPotentialValuesImpl", "getAsStr", "AAPotentialValues", "AAPotentialValuesFunction", "getAssociatedValue", "updateImpl", "OS", "getState", "indicatePessimisticFixpoint", "AAPotentialValuesFloating", "Base", "initialize"]}, {"filename": "llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp", "functions": ["if"]}, {"filename": "llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp", "functions": ["replaceInstUsesWith"]}, {"filename": "llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp", "functions": ["NextIRB", "visitLibAtomicStore", "IRB", "visitLibAtomicLoad"]}, {"filename": "llvm/lib/Transforms/Utils/SimplifyCFG.cpp", "functions": ["isCleanupBlockEmpty"]}, {"filename": "llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp", "functions": ["getAggregateSize"]}, {"filename": "llvm/tools/llvm-libtool-darwin/llvm-libtool-darwin.cpp", "functions": ["parseCommandLine", "createFileError", "if", "createStaticLibrary", "processFileList", "I"]}, {"filename": "llvm/unittests/CodeGen/GlobalISel/KnownBitsTest.cpp", "functions": ["MIB", "NewMMO", "Info", "Mask"]}, {"filename": "llvm/unittests/CodeGen/PassManagerTest.cpp", "functions": ["parseIR", "LAM", "NestedMFPM", "MAM", "PB", "Result", "M", "parseAssemblyString", "CGAM", "Count", "run", "doFinalization", "doInitialization", "FAM"]}, {"filename": "mlir/examples/standalone/lib/Standalone/StandaloneDialect.cpp", "functions": ["Dialect"]}, {"filename": "mlir/lib/Analysis/AffineAnalysis.cpp", "functions": ["failure", "srcAccess", "dstAccess", "getIndexSet"]}, {"filename": "mlir/lib/Analysis/AffineStructures.cpp", "functions": ["cst"]}, {"filename": "mlir/lib/Conversion/GPUToSPIRV/ConvertGPUToSPIRV.cpp", "functions": ["success"]}, {"filename": "mlir/lib/Dialect/AVX512/IR/AVX512Dialect.cpp", "functions": ["Dialect"]}, {"filename": "mlir/lib/Dialect/Affine/IR/AffineOps.cpp", "functions": ["Dialect"]}, {"filename": "mlir/lib/Dialect/Affine/Transforms/LoopTiling.cpp", "functions": ["success", "srcAccess", "failure", "dstAccess", "Twine"]}, {"filename": "mlir/lib/Dialect/GPU/IR/GPUDialect.cpp", "functions": ["Dialect"]}, {"filename": "mlir/lib/Dialect/LLVMIR/IR/LLVMAVX512Dialect.cpp", "functions": ["Dialect"]}, {"filename": "mlir/lib/Dialect/LLVMIR/IR/LLVMDialect.cpp", "functions": ["cantFail", "Dialect", "os", "bufferRef"]}, {"filename": "mlir/lib/Dialect/Linalg/IR/LinalgTypes.cpp", "functions": ["Dialect"]}, {"filename": "mlir/lib/Dialect/Linalg/Transforms/Transforms.cpp", "functions": ["failure", "substWithMin", "success"]}, {"filename": "mlir/lib/Dialect/OpenMP/IR/OpenMPDialect.cpp", "functions": ["Dialect"]}, {"filename": "mlir/lib/Dialect/Quant/IR/QuantOps.cpp", "functions": ["Dialect"]}, {"filename": "mlir/lib/Dialect/Quant/IR/TypeParser.cpp", "functions": ["if"]}, {"filename": "mlir/lib/Dialect/SCF/SCF.cpp", "functions": ["Dialect"]}, {"filename": "mlir/lib/Dialect/SCF/Transforms/Utils.cpp", "functions": ["g", "values"]}, {"filename": "mlir/lib/Dialect/SDBM/SDBMDialect.cpp", "functions": ["Dialect"]}, {"filename": "mlir/lib/Dialect/SPIRV/LayoutUtils.cpp", "functions": ["decorateType"]}, {"filename": "mlir/lib/Dialect/SPIRV/SPIRVDialect.cpp", "functions": ["Dialect"]}, {"filename": "mlir/lib/Dialect/SPIRV/SPIRVOps.cpp", "functions": ["success"]}, {"filename": "mlir/lib/Dialect/SPIRV/SPIRVTypes.cpp", "functions": ["getDim", "pointeeType", "setDim", "getImpl", "setArrayedInfo", "getScope", "getArrayedInfo", "isValid", "getStorageClass", "getDepthInfo", "setSamplerUseInfo", "getSamplerUseInfo", "getImageFormat", "elementType", "TypeStorage", "setImageFormat", "setSamplingInfo", "getSamplingInfo", "memberTypes", "setDepthInfo"]}, {"filename": "mlir/lib/Dialect/SPIRV/TargetAndABI.cpp", "functions": ["failure"]}, {"filename": "mlir/lib/Dialect/StandardOps/IR/Ops.cpp", "functions": ["Dialect"]}, {"filename": "mlir/lib/ExecutionEngine/ExecutionEngine.cpp", "functions": ["tsm"]}, {"filename": "mlir/lib/IR/AsmPrinter.cpp", "functions": ["printDialectAttribute"]}, {"filename": "mlir/lib/IR/Dialect.cpp", "functions": ["name"]}, {"filename": "mlir/lib/IR/MLIRContext.cpp", "functions": ["dialect", "Dialect", "BuiltinDialect", "getDialectNamespace"]}, {"filename": "mlir/lib/Support/StorageUniquer.cpp", "functions": ["lock", "getHashValue", "getEmptyKey", "isEqual", "getOrCreateUnsafe", "typeLock", "mutationFn", "getTombstoneKey"]}, {"filename": "mlir/lib/Target/LLVMIR/LLVMAVX512Intr.cpp", "functions": ["translateLLVMAVX512ModuleToLLVMIR"]}, {"filename": "mlir/lib/Target/LLVMIR/ModuleTranslation.cpp", "functions": ["builder", "scopedLock", "lock"]}, {"filename": "mlir/test/lib/Dialect/Test/TestDialect.cpp", "functions": ["Dialect"]}, {"filename": "mlir/test/lib/Transforms/TestLinalgTransforms.cpp", "functions": ["applyAffineMinSCFCanonicalizationPatterns"]}, {"filename": "mlir/test/lib/Transforms/TestSCFUtils.cpp", "functions": ["TestSCFForUtilsPass", "runOnFunction", "TestSCFUtilsPass", "TestSCFIfUtilsPass", "b"]}, {"filename": "mlir/tools/mlir-reduce/Passes/FunctionReducer.cpp", "functions": ["countFunctions", "ReductionNode"]}, {"filename": "mlir/tools/mlir-reduce/ReductionNode.cpp", "functions": ["module", "out", "ptrVariant"]}, {"filename": "mlir/tools/mlir-reduce/mlir-reduce.cpp", "functions": ["pm", "test"]}, {"filename": "mlir/tools/mlir-rocm-runner/mlir-rocm-runner.cpp", "functions": ["compileModuleToROCDLIR"]}, {"filename": "mlir/tools/mlir-tblgen/DialectGen.cpp", "functions": ["initialize"]}, {"filename": "mlir/unittests/IR/DialectTest.cpp", "functions": ["Dialect", "getDialectNamespace", "TestDialect"]}, {"filename": "openmp/libomptarget/test/mapping/target_implicit_partial_map.c", "functions": ["main"]}, {"filename": "clang/lib/Sema/SemaDeclAttr.cpp", "functions": ["handleCogtextAttr", "handleCogmainAttr"]}, {"filename": "llvm/lib/Target/P2/TargetInfo/P2TargetInfo.cpp", "functions": ["X"]}, {"filename": "llvm/lib/Target/P2/P2DelJmp0.cpp", "functions": ["DelJmp0", "getPassName", "runOnMachineFunction", "runOnMachineBasicBlock"]}, {"filename": "llvm/lib/Target/P2/MCTargetDesc/P2MCInstLower.cpp", "functions": ["lowerSymbolOperand", "LowerSymbolOperand"]}]}
{"pr_number": 16481, "url": "https://github.com/llvm/llvm-project/pull/16481", "title": "[RISCV] Add target specific loop unrolling and peeling preferences", "body": "Both these preference helper functions have initial support with\r\nthis change. The loop unrolling preferences are set with initial\r\nsettings to control thresholds, size and attributes of loops to\r\nunroll with some tuning done.  The peeling preferences may need\r\nsome tuning as well as the initial support looks much like what\r\nother architectures utilize.\r\n\r\nReviewed By: craig.topper\r\n\r\nDifferential Revision: https://reviews.llvm.org/D113798\r\n\r\n# **DO NOT FILE A PULL REQUEST**\r\n\r\nWe are in the process of a github migration.  Please do not create a pull request as this could interfere with the process.\r\n", "feature_layers": [], "feature_directives": ["target"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp", "functions": ["Operands"]}]}
{"pr_number": 16482, "url": "https://github.com/llvm/llvm-project/pull/16482", "title": "[RISCV] Add target specific loop unrolling and peeling preferences", "body": "Both these preference helper functions have initial support with\r\nthis change. The loop unrolling preferences are set with initial\r\nsettings to control thresholds, size and attributes of loops to\r\nunroll with some tuning done.  The peeling preferences may need\r\nsome tuning as well as the initial support looks much like what\r\nother architectures utilize.\r\n\r\nReviewed By: craig.topper\r\n\r\nDifferential Revision: https://reviews.llvm.org/D113798\r\n\r\n# **DO NOT FILE A PULL REQUEST**\r\n\r\nWe are in the process of a github migration.  Please do not create a pull request as this could interfere with the process.\r\n", "feature_layers": [], "feature_directives": ["target"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp", "functions": ["Operands"]}]}
{"pr_number": 52926, "url": "https://github.com/llvm/llvm-project/pull/52926", "title": "13.x", "body": "# **DO NOT FILE A PULL REQUEST**\r\n\r\nThis repository does not accept pull requests. Please follow http://llvm.org/docs/Contributing.html#how-to-submit-a-patch for contribution to LLVM.\r\n\r\n# **DO NOT FILE A PULL REQUEST**\r\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp", "functions": ["pushConst"]}, {"filename": "lld/ELF/Driver.cpp", "functions": ["if"]}, {"filename": "clang/lib/Lex/PPLexerChange.cpp", "functions": ["HandleEndOfFile"]}, {"filename": "clang/lib/Sema/SemaType.cpp", "functions": ["if"]}, {"filename": "clang/test/CodeGen/aarch64-ls64-inline-asm.c", "functions": ["store", "store2", "volatile", "load"]}, {"filename": "llvm/lib/Target/AArch64/AArch64AsmPrinter.cpp", "functions": ["printAsmMRegister"]}, {"filename": "llvm/lib/Target/AArch64/AArch64ISelLowering.cpp", "functions": ["EVT"]}, {"filename": "clang/lib/Parse/ParseDecl.cpp", "functions": ["getLangOpts"]}, {"filename": "llvm/lib/Target/RISCV/RISCVISelLowering.cpp", "functions": ["SDValue"]}, {"filename": "clang/lib/Frontend/PrintPreprocessedOutput.cpp", "functions": ["MoveToLine", "HandleFirstTokOnLine", "if", "startNewLineIfNeeded", "isMinimizeWhitespace"]}, {"filename": "clang/lib/Sema/SemaConcept.cpp", "functions": ["NewConjunction"]}, {"filename": "lldb/source/Commands/CommandObjectMemoryTag.cpp", "functions": ["GetDefinitions", "OptionParsingStarting"]}, {"filename": "lldb/source/Plugins/Process/Linux/NativeThreadLinux.cpp", "functions": ["manager"]}, {"filename": "lldb/test/API/linux/aarch64/mte_tag_faults/main.c", "functions": ["if", "main"]}, {"filename": "lldb/source/Plugins/Process/gdb-remote/GDBRemoteCommunicationServerLLGS.cpp", "functions": ["SendIllFormedResponse"]}, {"filename": "clang/test/CodeGenCXX/static-member-variable-explicit-specialization.cpp", "functions": ["f", "__declspec"]}, {"filename": "llvm/lib/Transforms/Utils/PredicateInfo.cpp", "functions": ["replaceCreatedSSACopys"]}, {"filename": "llvm/lib/IR/Module.cpp", "functions": ["getValueSymbolTable"]}, {"filename": "llvm/lib/IR/ConstantFold.cpp", "functions": ["getFoldedSizeOf", "getFoldedAlignOf"]}, {"filename": "clang/lib/AST/Expr.cpp", "functions": ["Path", "MakeStringLiteral"]}, {"filename": "clang/test/CodeGenCXX/builtin-source-location.cpp", "functions": ["testRemap"]}, {"filename": "openmp/runtime/test/tasking/kmp_taskwait_depend_in.c", "functions": ["__kmpc_global_thread_num", "main", "__kmpc_omp_wait_deps"]}, {"filename": "clang-tools-extra/test/clang-tidy/checkers/bugprone-easily-swappable-parameters-implicits.cpp", "functions": ["crefToArrayTypedef3", "crefToArrayTypedef2", "templatedArrayRefTest", "arrays1", "crefToArrayTypedefBoth1", "templatedArrayRef", "crefToArrayTypedef1"]}, {"filename": "clang-tools-extra/test/clang-tidy/checkers/bugprone-easily-swappable-parameters-len2.cpp", "functions": ["crefToArrayTypedef3", "crefToArrayTypedef2", "templatedArrayRefTest", "arrays1", "crefToArrayTypedefBoth1", "templatedArrayRef", "crefToArrayTypedef1"]}, {"filename": "lld/ELF/SymbolTable.cpp", "functions": ["if"]}, {"filename": "clang/test/CXX/temp/temp.constr/temp.constr.normal/p1.cpp", "functions": ["t1"]}, {"filename": "llvm/lib/Transforms/IPO/AttributorAttributes.cpp", "functions": ["Offset", "HandlePassthroughUser"]}, {"filename": "llvm/tools/llvm-mca/Views/TimelineView.cpp", "functions": ["format"]}, {"filename": "clang-tools-extra/clang-tidy/cppcoreguidelines/InitVariablesCheck.cpp", "functions": ["if"]}, {"filename": "clang-tools-extra/test/clang-tidy/checkers/cppcoreguidelines-init-variables.cpp", "functions": ["uninitialized_enum"]}, {"filename": "compiler-rt/lib/profile/InstrProfilingBuffer.c", "functions": ["sizeof"]}, {"filename": "llvm/lib/Analysis/ValueTracking.cpp", "functions": ["llvm_unreachable"]}, {"filename": "llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp", "functions": ["match", "ICmpInst"]}, {"filename": "clang/lib/Driver/ToolChains/Hexagon.cpp", "functions": ["ResourceDirInclude"]}, {"filename": "clang/lib/Sema/SemaTemplateInstantiate.cpp", "functions": ["Info", "ExprInst"]}, {"filename": "clang/test/CXX/expr/expr.prim/expr.prim.req/type-requirement.cpp", "functions": ["m"]}, {"filename": "llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp", "functions": ["SDValue"]}, {"filename": "libcxx/test/std/language.support/support.start.term/at_quick_exit.compile.fail.cpp", "functions": ["main", "f"]}, {"filename": "libcxx/test/std/language.support/support.start.term/quick_exit.compile.fail.cpp", "functions": ["main"]}, {"filename": "libcxx/test/std/language.support/support.start.term/quick_exit.pass.cpp", "functions": ["main"]}, {"filename": "libcxx/test/std/utilities/time/date.time/ctime.pass.cpp", "functions": ["main"]}, {"filename": "compiler-rt/lib/profile/InstrProfilingPlatformLinux.c", "functions": ["WriteBinaryIds", "WriteBinaryIdForNote", "ElfW"]}, {"filename": "llvm/lib/Target/AArch64/AArch64InstrInfo.cpp", "functions": ["removeCmpToZeroOrOne"]}, {"filename": "clang/test/CodeGen/ffp-contract-option.c", "functions": ["mymuladd"]}, {"filename": "clang/test/CodeGen/arm64-microsoft-intrinsics.c", "functions": ["__mulh", "__umulh", "check_umulh", "check_mulh"]}, {"filename": "clang/test/Headers/amdgcn_openmp_device_math.c", "functions": ["test_math_f32_suffix", "test_math_f32", "test_math_f64"]}, {"filename": "llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp", "functions": ["allowPromotionAlias"]}, {"filename": "llvm/lib/Target/M68k/AsmParser/M68kAsmParser.cpp", "functions": ["isMemOp"]}, {"filename": "llvm/lib/Target/WebAssembly/WebAssemblyFastISel.cpp", "functions": ["getRegForI1Value", "getRegForValue"]}, {"filename": "clang/lib/AST/ASTContext.cpp", "functions": ["mergeTypes"]}, {"filename": "clang/test/AST/ast-dump-openmp-begin-declare-variant_reference.cpp", "functions": ["test3", "test4", "also_before", "also_after", "test1", "test", "test2"]}, {"filename": "clang/test/CXX/class/class.init/class.copy.elision/p3.cpp", "functions": ["g", "__attribute__", "f"]}, {"filename": "clang/test/Headers/amdgcn-openmp-device-math-complex.cpp", "functions": ["test_dcall", "test_dcmplx", "test_scall", "test_template_math_calls", "test_scmplx"]}, {"filename": "clang/lib/Format/UnwrappedLineParser.cpp", "functions": ["isC78ParameterDecl"]}, {"filename": "llvm/unittests/ExecutionEngine/Orc/RTDyldObjectLinkingLayerTest.cpp", "functions": ["ObjLayer"]}, {"filename": "llvm/lib/Target/AArch64/GISel/AArch64LegalizerInfo.cpp", "functions": ["legalizeBSwap"]}, {"filename": "lldb/test/API/commands/register/register/aarch64_sve_registers/rw_access_static_config/main.c", "functions": ["write_sve_regs", "main", "expr_eval_func"]}, {"filename": "llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp", "functions": ["Users"]}, {"filename": "llvm/lib/Transforms/IPO/OpenMPOpt.cpp", "functions": ["AllocaInst"]}, {"filename": "clang/test/AST/nrvo.c", "functions": ["f1", "f2"]}, {"filename": "clang/test/Analysis/blocks-nrvo.c", "functions": ["foo"]}, {"filename": "clang/test/OpenMP/parallel_if_codegen_PR51349.cpp", "functions": ["foo"]}, {"filename": "clang/lib/Analysis/ThreadSafety.cpp", "functions": ["join"]}, {"filename": "clang/test/SemaCXX/warn-thread-safety-analysis.cpp", "functions": ["loopDemoteContinue", "loopPromoteContinue", "scope", "loopPromote", "loopDemote"]}, {"filename": "clang/test/CodeGen/nrvo-tracking.cpp", "functions": ["int", "test"]}, {"filename": "clang/test/CodeGenCXX/copy-elision.cpp", "functions": ["int", "T", "test"]}, {"filename": "clang/lib/Analysis/CFG.cpp", "functions": ["VisitChildren", "VisitAttributedStmt", "isFallthroughStatement"]}, {"filename": "clang/test/SemaCXX/unreachable-code.cpp", "functions": ["g", "f"]}, {"filename": "llvm/lib/CodeGen/DwarfEHPrepare.cpp", "functions": ["doFinalization"]}, {"filename": "libcxx/test/std/thread/thread.semaphore/ctor.compile.pass.cpp", "functions": ["cs", "bs"]}, {"filename": "libcxx/src/support/win32/thread_win32.cpp", "functions": ["__libcpp_semaphore_wait", "__libcpp_semaphore_init", "__libcpp_semaphore_destroy", "ReleaseSemaphore", "WaitForSingleObjectEx", "__libcpp_semaphore_post"]}, {"filename": "libcxx/test/std/strings/basic.string/string.capacity/shrink_to_fit.explicit_instantiation.sh.cpp", "functions": ["move", "assign", "find", "to_char_type", "eof", "copy", "main", "length", "eq_int_type", "eq", "lt", "not_eof", "compare", "to_int_type"]}, {"filename": "llvm/lib/MC/MCParser/ELFAsmParser.cpp", "functions": ["hasPrefix"]}, {"filename": "clang/test/Analysis/uninit-asm-goto.cpp", "functions": ["goto", "test6"]}, {"filename": "llvm/lib/Analysis/AliasAnalysis.cpp", "functions": ["getModRefInfo"]}]}
{"pr_number": 53422, "url": "https://github.com/llvm/llvm-project/pull/53422", "title": "[llvm-objdump] Add initial --chained_fixups option support", "body": "iOS15 introduces fixup chain as a new format for rebase & binding in dynamic linking process; when building application targeting OS higher than iOS15 / macOS12, Mach-O uses fixup chain for dynamic linking, in replacement of rebase / binding information.\r\nThis option aims to behave like the -chained_fixups option of MacOS's otool-classic, which dumps information related to fixup chain in Mach-O object file, which dumps fixup chain related contents including dyld_chained_fixups_header, dyld_chained_starts_in_image, dyld_chained_starts_in_segment and dyld_chained_import[_addend][64].", "feature_layers": [], "feature_directives": ["for", "target"], "files_changed": [{"filename": "llvm/tools/llvm-objdump/MachODump.cpp", "functions": ["format"]}]}
{"pr_number": 53431, "url": "https://github.com/llvm/llvm-project/pull/53431", "title": "sparse_tensor.linalg operation", "body": "New operation used when sparse_tensor rewrites `linalg.generic`, allowing for\r\nuser-defined behavior within an Intersect or Union operation. The user-defined\r\nlogic is embedded in a block within `sparse_tensor.linalg`.\r\n\r\nMerger has been updated to handle passing an `Operation *` as part of `TensorExp`.\r\n", "feature_layers": ["parse"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/IR/SparseTensorDialect.cpp", "functions": ["success", "verify"]}, {"filename": "mlir/lib/Dialect/SparseTensor/Utils/Merger.cpp", "functions": ["kind", "addExp"]}]}
{"pr_number": 54275, "url": "https://github.com/llvm/llvm-project/pull/54275", "title": "Branch fix merge", "body": "# **DO NOT FILE A PULL REQUEST**\r\n\r\nThis repository does not accept pull requests. Please follow http://llvm.org/docs/Contributing.html#how-to-submit-a-patch for contribution to LLVM.\r\n\r\n# **DO NOT FILE A PULL REQUEST**\r\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/CodeGen/WinEHPrepare.cpp", "functions": ["if"]}]}
{"pr_number": 54400, "url": "https://github.com/llvm/llvm-project/pull/54400", "title": "Revert \"Revert \"[Coverage] Fix branch coverage merging in FunctionCoverageSummary::get() for instantiation\"\"", "body": "", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Lex/PPDirectives.cpp", "functions": ["IfdefMacroNameScope"]}, {"filename": "clang/lib/Lex/PPExpressions.cpp", "functions": ["IfdefMacroNameScope"]}, {"filename": "clang/lib/AST/ItaniumMangle.cpp", "functions": ["setDeviceMangleContext", "isDeviceMangleContext"]}, {"filename": "clang/test/CodeGenCXX/mangle-alignof.cpp", "functions": ["f1", "f2", "f3", "f4"]}, {"filename": "clang/test/CodeGenCXX/microsoft-uuidof-mangling.cpp", "functions": ["test_uuidofType", "test_uuidofExpr2", "test_uuidofExpr"]}, {"filename": "clang/test/CodeGenCXX/clang-abi-compat.cpp", "functions": ["test9"]}, {"filename": "clang-tools-extra/clangd/ConfigCompile.cpp", "functions": ["Result", "compileRegex"]}, {"filename": "clang-tools-extra/clangd/ConfigYAML.cpp", "functions": ["Dict", "parse"]}, {"filename": "llvm/lib/Transforms/Vectorize/LoopVectorize.cpp", "functions": ["hasIrregularType"]}, {"filename": "llvm/lib/ProfileData/SampleProfReader.cpp", "functions": ["FContext"]}, {"filename": "llvm/lib/Transforms/IPO/SampleContextTracker.cpp", "functions": ["getHottestChildContext", "getChildContext"]}, {"filename": "llvm/lib/Transforms/IPO/SampleProfile.cpp", "functions": ["ProfileCG", "addCallGraphEdges", "replaceCallGraphEdges"]}, {"filename": "llvm/lib/IR/PseudoProbe.cpp", "functions": ["Builder", "setProbeDistributionFactor"]}, {"filename": "llvm/lib/Transforms/IPO/SampleProfileProbe.cpp", "functions": ["if", "format"]}, {"filename": "clang/test/OpenMP/target_attribute_convergent.cpp", "functions": ["foo"]}, {"filename": "openmp/libomptarget/test/offloading/bug49021.cpp", "functions": ["sum", "nblock", "a", "main", "test_map", "test_complex", "test_reduction"]}, {"filename": "openmp/libomptarget/src/omptarget.cpp", "functions": ["syncDevice"]}, {"filename": "openmp/libomptarget/test/offloading/assert.cpp", "functions": ["main"]}, {"filename": "clang/test/SemaCXX/constant-expression-cxx2a.cpp", "functions": ["S"]}, {"filename": "clang/test/SemaCXX/cxx2a-constexpr-dynalloc.cpp", "functions": ["g", "h", "f"]}, {"filename": "clang/lib/AST/ExprConstant.cpp", "functions": ["Info"]}, {"filename": "clang/test/CodeGenCXX/builtin-is-constant-evaluated.cpp", "functions": ["global_dtor_bce_3", "global_dtor_bce_2", "test_dtor_bce_static_1", "test_dtor_bce_static_2", "test_dtor_bce_2", "global_dtor_bce_1", "test_dtor_bce_1", "test_dtor_bce_static_3", "DestructorBCE", "local", "test_dtor_bce_3"]}, {"filename": "llvm/lib/Transforms/Utils/BuildLibCalls.cpp", "functions": ["setRetNonNull"]}, {"filename": "clang/test/OpenMP/nvptx_unsupported_type_messages.cpp", "functions": ["foo2", "ld_return1c", "dead_static_declare_target", "ld_return1e", "ld_arg1f", "ld_arg1d", "ld_arg1c", "ld_arg1e", "ld_arg1b", "dead_inline_declare_target", "ld_return2b", "dead_template", "ld_use4", "ld_return1d", "dead_inline", "ld_return1a", "dead_static", "dead_template_declare_target", "external", "ld_return1f", "ld_use1", "foo1", "ld_arg2a", "foo3", "ld_arg1a", "ld_return2a", "ld_return1b", "ld_arg2b", "ld_use3", "ld_use2"]}, {"filename": "clang/lib/Sema/Sema.cpp", "functions": ["diagIfOpenMPHostCode", "CUDADiagIfHostCode"]}, {"filename": "clang/lib/Sema/SemaOpenMP.cpp", "functions": ["SemaDiagnosticBuilder"]}, {"filename": "clang/lib/AST/MicrosoftCXXABI.cpp", "functions": ["getDeviceManglingNumber"]}, {"filename": "clang/test/CodeGen/X86/avx512-reduceIntrin.c", "functions": ["_mm512_reduce_add_epi32", "test_mm512_reduce_mul_pd", "_mm512_mask_reduce_add_epi64", "_mm512_reduce_mul_epi64", "_mm512_mask_reduce_and_epi64", "_mm512_mask_reduce_add_pd", "_mm512_mask_reduce_add_epi32", "_mm512_mask_reduce_mul_epi64", "_mm512_mask_reduce_mul_ps", "_mm512_reduce_add_ps", "_mm512_mask_reduce_mul_epi32", "_mm512_reduce_or_epi64", "_mm512_reduce_mul_ps", "_mm512_reduce_or_epi32", "_mm512_reduce_mul_pd", "_mm512_mask_reduce_or_epi64", "_mm512_mask_reduce_or_epi32", "_mm512_reduce_mul_epi32", "_mm512_reduce_add_pd", "test_mm512_reduce_add_pd", "_mm512_reduce_and_epi32", "_mm512_mask_reduce_add_ps", "_mm512_mask_reduce_and_epi32", "_mm512_mask_reduce_mul_pd"]}, {"filename": "clang/lib/ASTMatchers/ASTMatchFinder.cpp", "functions": ["RAII"]}, {"filename": "clang/unittests/ASTMatchers/ASTMatchersTraversalTest.cpp", "functions": ["func1"]}, {"filename": "clang-tools-extra/clangd/GlobalCompilationDatabase.cpp", "functions": ["maybeCaseFoldPath"]}, {"filename": "clang-tools-extra/clangd/Protocol.cpp", "functions": ["fromJSON"]}, {"filename": "llvm/tools/llvm-dwp/llvm-dwp.cpp", "functions": ["DWOPath"]}, {"filename": "llvm/tools/llvm-symbolizer/llvm-symbolizer.cpp", "functions": ["DILineInfo"]}, {"filename": "llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp", "functions": ["Tag"]}, {"filename": "llvm/lib/IR/Operator.cpp", "functions": ["Index"]}, {"filename": "llvm/tools/llvm-profgen/ProfileGenerator.cpp", "functions": ["getCallSite"]}, {"filename": "llvm/tools/llvm-profgen/PseudoProbe.cpp", "functions": ["getFuncDescForGUID"]}, {"filename": "llvm/tools/llvm-profgen/ProfiledBinary.cpp", "functions": ["IP"]}, {"filename": "llvm/tools/llvm-profgen/PerfReader.cpp", "functions": ["Unwinder", "getOrCreateCounterForProbe", "Stack", "ContextId"]}, {"filename": "llvm/lib/ProfileData/ProfileSummaryBuilder.cpp", "functions": ["getSummary"]}, {"filename": "llvm/lib/CodeGen/MachineInstr.cpp", "functions": ["mayStore"]}, {"filename": "llvm/tools/llvm-profgen/llvm-profgen.cpp", "functions": ["Reader"]}, {"filename": "clang/lib/Frontend/CompilerInvocation.cpp", "functions": ["if"]}, {"filename": "clang/test/CodeGen/attr-mustprogress-0.c", "functions": ["d1", "f1", "W", "w1", "w2", "D", "f2", "d2", "F"]}, {"filename": "clang/test/CodeGen/attr-mustprogress-0.cpp", "functions": ["d1", "f1", "W", "w1", "w2", "D", "f2", "d2", "F"]}, {"filename": "clang/test/CodeGen/attr-mustprogress-1.c", "functions": ["d1", "f0", "f1", "W", "w1", "w2", "D", "f2", "d2", "F"]}, {"filename": "clang/test/CodeGen/attr-mustprogress-1.cpp", "functions": ["D2", "d1", "f0", "f1", "W", "d2", "w1", "w2", "D", "f2", "W2", "F2", "F"]}, {"filename": "clang/test/CodeGen/attr-mustprogress.c", "functions": ["d1", "f0", "f1", "W", "w1", "w2", "D", "f2", "d2", "F"]}, {"filename": "clang/test/CodeGenCXX/attr-mustprogress.cpp", "functions": ["D2", "d1", "f0", "f1", "W", "d2", "w1", "w2", "D", "f2", "W2", "F2", "F"]}, {"filename": "llvm/tools/llvm-objdump/llvm-objdump.cpp", "functions": ["Obj"]}, {"filename": "clang-tools-extra/clangd/support/Path.cpp", "functions": ["maybeCaseFoldPath", "pathEqual"]}, {"filename": "clang-tools-extra/clangd/unittests/RenameTests.cpp", "functions": ["Code"]}, {"filename": "clang-tools-extra/clang-tidy/cppcoreguidelines/PreferMemberInitializerCheck.cpp", "functions": ["isControlStatement", "isLiteral", "shouldBeDefaultMemberInitializer", "isNoReturnCallStatement", "isUnaryExprOfLiteral", "ClangTidyCheck"]}, {"filename": "clang-tools-extra/test/clang-tidy/checkers/cppcoreguidelines-prefer-member-initializer.cpp", "functions": ["something_int", "not_returning", "risky", "something_double", "Complex19", "returning", "dice"]}, {"filename": "clang/test/CodeCompletion/member-access.c", "functions": ["test4"]}, {"filename": "clang/unittests/Sema/CodeCompleteTest.cpp", "functions": ["foo"]}, {"filename": "openmp/libomptarget/test/offloading/bug49334.cpp", "functions": ["BlockMatMul_TargetNowait", "Initialize", "a", "main", "Compare", "c", "rowsPerBlock", "b"]}, {"filename": "llvm/lib/Support/Windows/Path.inc", "functions": ["mapWindowsError"]}, {"filename": "openmp/runtime/test/tasking/hidden_helper_task/capacity_mix_threads.cpp", "functions": ["data", "main", "omp_get_num_procs", "root", "dummy_root"]}, {"filename": "openmp/runtime/test/tasking/hidden_helper_task/capacity_nthreads.cpp", "functions": ["omp_get_num_procs", "data", "main"]}, {"filename": "llvm/lib/ExecutionEngine/Orc/OrcV2CBindings.cpp", "functions": ["lLVMOrcDisposeObjectLayer", "LLVMOrcDisposeObjectLayer"]}, {"filename": "llvm/lib/Target/X86/X86ISelLowering.cpp", "functions": ["SDValue"]}, {"filename": "llvm/lib/Target/BPF/BPFTargetMachine.cpp", "functions": ["TargetTransformInfo"]}, {"filename": "polly/lib/External/ppcg/external.c", "functions": ["pet_scop_get_must_writes", "pet_loc_get_end", "pet_stmt_build_ast_exprs", "pet_scop_compute_outer_to_inner", "pet_scop_collect_tagged_may_writes", "pet_scop_has_data_dependent_conditions", "pet_tree_foreach_access_expr", "pet_expr_call_get_name", "pet_scop_collect_may_writes", "pet_expr_access_get_index", "pet_scop_collect_must_writes", "pet_scop_print_original", "generate_opencl", "pet_scop_get_tagged_must_writes", "pet_tree_get_type", "pet_expr_new_cast", "pet_scop_collect_tagged_must_kills", "pet_scop_get_may_writes", "pet_expr_access_get_may_read", "pet_scop_collect_tagged_may_reads", "pet_scop_get_may_reads", "pet_tree_map_call_expr", "pet_scop_align_params", "pet_tree_foreach_expr", "pet_scop_get_tagged_may_writes", "pet_scop_can_build_ast_exprs", "ppcg_version", "pet_stmt_print_body", "pet_options_set_encapsulate_dynamic_control", "pet_expr_get_ctx", "pet_scop_get_must_kills", "pet_scop_collect_may_reads", "pet_scop_get_tagged_may_reads", "pet_options_args", "pet_expr_access_get_must_write", "print_cpu", "pet_tree_copy", "pet_stmt_is_kill", "pet_scop_get_tagged_must_kills", "pet_scop_collect_tagged_must_writes", "pet_expr_set_arg", "pet_loc_get_start", "pet_expr_call_set_name", "pet_tree_free", "pet_expr_get_arg", "pet_expr_access_get_may_write", "pet_expr_foreach_call_expr", "pet_expr_access_is_read", "generate_cpu", "pet_expr_access_is_write", "pet_expr_access_get_tagged_may_write", "pet_expr_access_get_tagged_may_read", "ppcg_print_guarded", "pet_expr_access_get_ref_id", "pet_scop_compute_outer_to_any", "pet_transform_C_source", "pet_scop_free"]}, {"filename": "clang/test/CodeGen/builtins-bpf-preserve-field-info-4.c", "functions": ["_", "unit3"]}, {"filename": "llvm/lib/CodeGen/StackProtector.cpp", "functions": ["if", "B"]}, {"filename": "llvm/lib/Transforms/Utils/InlineFunction.cpp", "functions": ["PropagateCallSiteMetadata", "remap"]}, {"filename": "llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp", "functions": ["narrowScalarFPTOI"]}, {"filename": "llvm/lib/Analysis/ConstantFolding.cpp", "functions": ["isManifestConstant"]}, {"filename": "llvm/lib/Target/PowerPC/PPCISelLowering.cpp", "functions": ["LowerINLINEASM"]}, {"filename": "clang-tools-extra/clangd/ConfigProvider.cpp", "functions": ["RelPath", "Cache"]}, {"filename": "llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp", "functions": ["SDValue"]}, {"filename": "llvm/lib/Target/BPF/BTFDebug.cpp", "functions": ["Name"]}, {"filename": "clang/lib/CodeGen/CGOpenMPRuntime.cpp", "functions": ["CGF", "Region"]}, {"filename": "clang/test/OpenMP/critical_codegen.cpp", "functions": ["lambda_critical"]}, {"filename": "clang/test/OpenMP/master_codegen.cpp", "functions": ["lambda_master"]}, {"filename": "libcxx/test/libcxx/depr/depr.default.allocator/allocator_types.cxx2a.pass.cpp", "functions": ["test", "main"]}, {"filename": "libcxx/test/std/utilities/memory/default.allocator/allocator.ctor.pass.cpp", "functions": ["test", "main"]}, {"filename": "libcxx/test/std/utilities/memory/default.allocator/allocator_types.deprecated_in_cxx17.verify.cpp", "functions": ["main"]}, {"filename": "libcxx/test/std/utilities/memory/default.allocator/allocator_types.pass.cpp", "functions": ["test", "main"]}, {"filename": "libcxx/test/std/utilities/memory/default.allocator/allocator_types.void.compile.pass.cpp", "functions": ["main"]}, {"filename": "libcxx/test/std/utilities/memory/default.allocator/allocator_void.deprecated_in_cxx17.verify.cpp", "functions": ["main"]}, {"filename": "libcxx/test/std/experimental/language.support/support.coroutines/end.to.end/expected.pass.cpp", "functions": ["get_return_object"]}, {"filename": "llvm/lib/Target/SystemZ/SystemZISelLowering.cpp", "functions": ["RetCCInfo", "ArgCCInfo"]}, {"filename": "compiler-rt/lib/sanitizer_common/sanitizer_posix_libcdep.cpp", "functions": ["GetAltStackSize"]}, {"filename": "libcxx/test/std/utilities/memory/util.smartptr/util.smartptr.shared/util.smartptr.shared.assign/unique_ptr_Y.pass.cpp", "functions": ["ptr", "operator"]}, {"filename": "libcxx/test/std/utilities/memory/util.smartptr/util.smartptr.shared/util.smartptr.shared.const/unique_ptr.pass.cpp", "functions": ["ptr", "p", "operator"]}, {"filename": "libcxx/test/std/input.output/filesystems/fs.req.macros/feature_macro.pass.cpp", "functions": ["main"]}, {"filename": "llvm/lib/Support/Host.cpp", "functions": ["getVendorSignature"]}, {"filename": "llvm/lib/IR/Core.cpp", "functions": ["LLVMGetTypeAttributeValue", "unwrap", "LLVMIsTypeAttribute", "wrap"]}]}
{"pr_number": 54414, "url": "https://github.com/llvm/llvm-project/pull/54414", "title": "Ollvm 13.0.1", "body": "# **DO NOT FILE A PULL REQUEST**\r\n\r\nThis repository does not accept pull requests. Please follow http://llvm.org/docs/Contributing.html#how-to-submit-a-patch for contribution to LLVM.\r\n\r\n# **DO NOT FILE A PULL REQUEST**\r\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp", "functions": ["pushConst"]}, {"filename": "lld/ELF/Driver.cpp", "functions": ["if"]}, {"filename": "clang/lib/Lex/PPLexerChange.cpp", "functions": ["HandleEndOfFile"]}, {"filename": "clang/lib/Sema/SemaType.cpp", "functions": ["if"]}, {"filename": "clang/test/CodeGen/aarch64-ls64-inline-asm.c", "functions": ["store", "store2", "volatile", "load"]}, {"filename": "llvm/lib/Target/AArch64/AArch64AsmPrinter.cpp", "functions": ["printAsmMRegister"]}, {"filename": "llvm/lib/Target/AArch64/AArch64ISelLowering.cpp", "functions": ["EVT"]}, {"filename": "clang/lib/Parse/ParseDecl.cpp", "functions": ["getLangOpts"]}, {"filename": "llvm/lib/Target/RISCV/RISCVISelLowering.cpp", "functions": ["SDValue"]}, {"filename": "clang/lib/Frontend/PrintPreprocessedOutput.cpp", "functions": ["MoveToLine", "HandleFirstTokOnLine", "if", "startNewLineIfNeeded", "isMinimizeWhitespace"]}, {"filename": "clang/lib/Sema/SemaConcept.cpp", "functions": ["NewConjunction"]}, {"filename": "lldb/source/Commands/CommandObjectMemoryTag.cpp", "functions": ["GetDefinitions", "OptionParsingStarting"]}, {"filename": "lldb/source/Plugins/Process/Linux/NativeThreadLinux.cpp", "functions": ["manager"]}, {"filename": "lldb/test/API/linux/aarch64/mte_tag_faults/main.c", "functions": ["if", "main"]}, {"filename": "lldb/source/Plugins/Process/gdb-remote/GDBRemoteCommunicationServerLLGS.cpp", "functions": ["SendIllFormedResponse"]}, {"filename": "clang/test/CodeGenCXX/static-member-variable-explicit-specialization.cpp", "functions": ["f", "__declspec"]}, {"filename": "llvm/lib/Transforms/Utils/PredicateInfo.cpp", "functions": ["replaceCreatedSSACopys"]}, {"filename": "llvm/lib/IR/Module.cpp", "functions": ["getValueSymbolTable"]}, {"filename": "llvm/lib/IR/ConstantFold.cpp", "functions": ["getFoldedSizeOf", "getFoldedAlignOf"]}, {"filename": "clang/lib/AST/Expr.cpp", "functions": ["Path", "MakeStringLiteral"]}, {"filename": "clang/test/CodeGenCXX/builtin-source-location.cpp", "functions": ["testRemap"]}, {"filename": "openmp/runtime/test/tasking/kmp_taskwait_depend_in.c", "functions": ["__kmpc_global_thread_num", "main", "__kmpc_omp_wait_deps"]}, {"filename": "clang-tools-extra/test/clang-tidy/checkers/bugprone-easily-swappable-parameters-implicits.cpp", "functions": ["crefToArrayTypedef3", "crefToArrayTypedef2", "templatedArrayRefTest", "arrays1", "crefToArrayTypedefBoth1", "templatedArrayRef", "crefToArrayTypedef1"]}, {"filename": "clang-tools-extra/test/clang-tidy/checkers/bugprone-easily-swappable-parameters-len2.cpp", "functions": ["crefToArrayTypedef3", "crefToArrayTypedef2", "templatedArrayRefTest", "arrays1", "crefToArrayTypedefBoth1", "templatedArrayRef", "crefToArrayTypedef1"]}, {"filename": "lld/ELF/SymbolTable.cpp", "functions": ["if"]}, {"filename": "clang/test/CXX/temp/temp.constr/temp.constr.normal/p1.cpp", "functions": ["t1"]}, {"filename": "llvm/lib/Transforms/IPO/AttributorAttributes.cpp", "functions": ["Offset", "HandlePassthroughUser"]}, {"filename": "llvm/tools/llvm-mca/Views/TimelineView.cpp", "functions": ["format"]}, {"filename": "clang-tools-extra/clang-tidy/cppcoreguidelines/InitVariablesCheck.cpp", "functions": ["if"]}, {"filename": "clang-tools-extra/test/clang-tidy/checkers/cppcoreguidelines-init-variables.cpp", "functions": ["uninitialized_enum"]}, {"filename": "compiler-rt/lib/profile/InstrProfilingBuffer.c", "functions": ["sizeof"]}, {"filename": "llvm/lib/Analysis/ValueTracking.cpp", "functions": ["llvm_unreachable"]}, {"filename": "llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp", "functions": ["match", "ICmpInst"]}, {"filename": "clang/lib/Driver/ToolChains/Hexagon.cpp", "functions": ["ResourceDirInclude"]}, {"filename": "clang/lib/Sema/SemaTemplateInstantiate.cpp", "functions": ["Info", "ExprInst"]}, {"filename": "clang/test/CXX/expr/expr.prim/expr.prim.req/type-requirement.cpp", "functions": ["m"]}, {"filename": "llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp", "functions": ["SDValue"]}, {"filename": "libcxx/test/std/language.support/support.start.term/at_quick_exit.compile.fail.cpp", "functions": ["main", "f"]}, {"filename": "libcxx/test/std/language.support/support.start.term/quick_exit.compile.fail.cpp", "functions": ["main"]}, {"filename": "libcxx/test/std/language.support/support.start.term/quick_exit.pass.cpp", "functions": ["main"]}, {"filename": "libcxx/test/std/utilities/time/date.time/ctime.pass.cpp", "functions": ["main"]}, {"filename": "compiler-rt/lib/profile/InstrProfilingPlatformLinux.c", "functions": ["WriteBinaryIds", "WriteBinaryIdForNote", "ElfW"]}, {"filename": "llvm/lib/Target/AArch64/AArch64InstrInfo.cpp", "functions": ["removeCmpToZeroOrOne"]}, {"filename": "clang/test/CodeGen/ffp-contract-option.c", "functions": ["mymuladd"]}, {"filename": "clang/test/CodeGen/arm64-microsoft-intrinsics.c", "functions": ["__mulh", "__umulh", "check_umulh", "check_mulh"]}, {"filename": "clang/test/Headers/amdgcn_openmp_device_math.c", "functions": ["test_math_f32_suffix", "test_math_f32", "test_math_f64"]}, {"filename": "llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp", "functions": ["allowPromotionAlias"]}, {"filename": "llvm/lib/Target/M68k/AsmParser/M68kAsmParser.cpp", "functions": ["isMemOp"]}, {"filename": "llvm/lib/Target/WebAssembly/WebAssemblyFastISel.cpp", "functions": ["getRegForI1Value", "getRegForValue"]}, {"filename": "clang/lib/AST/ASTContext.cpp", "functions": ["mergeTypes"]}, {"filename": "clang/test/AST/ast-dump-openmp-begin-declare-variant_reference.cpp", "functions": ["test3", "test4", "also_before", "also_after", "test1", "test", "test2"]}, {"filename": "clang/test/CXX/class/class.init/class.copy.elision/p3.cpp", "functions": ["g", "__attribute__", "f"]}, {"filename": "clang/test/Headers/amdgcn-openmp-device-math-complex.cpp", "functions": ["test_dcall", "test_dcmplx", "test_scall", "test_template_math_calls", "test_scmplx"]}, {"filename": "clang/lib/Format/UnwrappedLineParser.cpp", "functions": ["isC78ParameterDecl"]}, {"filename": "llvm/unittests/ExecutionEngine/Orc/RTDyldObjectLinkingLayerTest.cpp", "functions": ["ObjLayer"]}, {"filename": "llvm/lib/Target/AArch64/GISel/AArch64LegalizerInfo.cpp", "functions": ["legalizeBSwap"]}, {"filename": "lldb/test/API/commands/register/register/aarch64_sve_registers/rw_access_static_config/main.c", "functions": ["write_sve_regs", "main", "expr_eval_func"]}, {"filename": "llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp", "functions": ["Users"]}, {"filename": "llvm/lib/Transforms/IPO/OpenMPOpt.cpp", "functions": ["AllocaInst"]}, {"filename": "clang/test/AST/nrvo.c", "functions": ["f1", "f2"]}, {"filename": "clang/test/Analysis/blocks-nrvo.c", "functions": ["foo"]}, {"filename": "clang/test/OpenMP/parallel_if_codegen_PR51349.cpp", "functions": ["foo"]}, {"filename": "clang/lib/Analysis/ThreadSafety.cpp", "functions": ["join"]}, {"filename": "clang/test/SemaCXX/warn-thread-safety-analysis.cpp", "functions": ["loopDemoteContinue", "loopPromoteContinue", "scope", "loopPromote", "loopDemote"]}, {"filename": "clang/test/CodeGen/nrvo-tracking.cpp", "functions": ["int", "test"]}, {"filename": "clang/test/CodeGenCXX/copy-elision.cpp", "functions": ["int", "T", "test"]}, {"filename": "clang/lib/Analysis/CFG.cpp", "functions": ["VisitChildren"]}, {"filename": "clang/test/SemaCXX/unreachable-code.cpp", "functions": ["g", "f"]}, {"filename": "llvm/lib/CodeGen/DwarfEHPrepare.cpp", "functions": ["doFinalization"]}, {"filename": "libcxx/test/std/thread/thread.semaphore/ctor.compile.pass.cpp", "functions": ["cs", "bs"]}, {"filename": "libcxx/src/support/win32/thread_win32.cpp", "functions": ["__libcpp_semaphore_wait", "__libcpp_semaphore_init", "__libcpp_semaphore_destroy", "ReleaseSemaphore", "WaitForSingleObjectEx", "__libcpp_semaphore_post"]}, {"filename": "libcxx/test/std/strings/basic.string/string.capacity/shrink_to_fit.explicit_instantiation.sh.cpp", "functions": ["move", "assign", "find", "to_char_type", "eof", "copy", "main", "length", "eq_int_type", "eq", "lt", "not_eof", "compare", "to_int_type"]}, {"filename": "llvm/lib/MC/MCParser/ELFAsmParser.cpp", "functions": ["hasPrefix"]}, {"filename": "clang/test/Analysis/uninit-asm-goto.cpp", "functions": ["test7", "goto", "test8"]}, {"filename": "llvm/lib/Analysis/AliasAnalysis.cpp", "functions": ["getModRefInfo"]}, {"filename": "llvm/unittests/IR/DebugInfoTest.cpp", "functions": ["M", "I2", "DIB", "I1"]}, {"filename": "clang/test/Analysis/asm-goto.cpp", "functions": ["baz", "goto"]}, {"filename": "clang/test/Sema/array-bounds-ptr-arith.c", "functions": ["goto", "pr51682"]}, {"filename": "llvm/lib/Analysis/InlineCost.cpp", "functions": ["simplifyIntrinsicCallIsConstant"]}, {"filename": "llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp", "functions": ["ComplexPatternFuncMutatesDAG"]}]}
{"pr_number": 55374, "url": "https://github.com/llvm/llvm-project/pull/55374", "title": "Target in reduction", "body": "# **DO NOT FILE A PULL REQUEST**\r\n\r\nThis repository does not accept pull requests. Please follow http://llvm.org/docs/Contributing.html#how-to-submit-a-patch for contribution to LLVM.\r\n\r\n# **DO NOT FILE A PULL REQUEST**\r\n", "feature_layers": [], "feature_directives": ["for", "target"], "files_changed": [{"filename": "clang/lib/CodeGen/CGStmtOpenMP.cpp", "functions": ["IfCond", "TrueOrFalse", "LexScope", "InRedScope", "RedCG"]}, {"filename": "clang/test/OpenMP/target_in_reduction_codegen.cpp", "functions": ["main"]}]}
{"pr_number": 56844, "url": "https://github.com/llvm/llvm-project/pull/56844", "title": "[mlir][Shape] add outline shape computation pass", "body": "", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/Shape/IR/Shape.cpp", "functions": ["builder", "state", "create"]}, {"filename": "mlir/lib/Dialect/Shape/Transforms/InsertDimensionSymbols.cpp", "functions": ["runOnOperation", "InsertDimensionSymbolsBase"]}, {"filename": "mlir/lib/Dialect/Shape/Transforms/OutlineShapeComputation.cpp", "functions": ["runOnOperation", "signalPassFailure", "builder", "calOnlyUsedByWithShapesRecursively", "init", "symbolTable", "isDimOpNotFromFuncArg"]}]}
{"pr_number": 58267, "url": "https://github.com/llvm/llvm-project/pull/58267", "title": "Dev", "body": "# **DO NOT FILE A PULL REQUEST**\r\n\r\nThis repository does not accept pull requests. Please follow http://llvm.org/docs/Contributing.html#how-to-submit-a-patch for contribution to LLVM.\r\n\r\n# **DO NOT FILE A PULL REQUEST**\r\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/CodeGen/WinEHPrepare.cpp", "functions": ["if"]}, {"filename": "clang/tools/driver/driver.cpp", "functions": ["ExecuteCC1Tool"]}]}
{"pr_number": 58268, "url": "https://github.com/llvm/llvm-project/pull/58268", "title": "Dev", "body": "# **DO NOT FILE A PULL REQUEST**\r\n\r\nThis repository does not accept pull requests. Please follow http://llvm.org/docs/Contributing.html#how-to-submit-a-patch for contribution to LLVM.\r\n\r\n# **DO NOT FILE A PULL REQUEST**\r\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/CodeGen/WinEHPrepare.cpp", "functions": ["if"]}, {"filename": "clang/tools/driver/driver.cpp", "functions": ["ExecuteCC1Tool"]}]}
{"pr_number": 58917, "url": "https://github.com/llvm/llvm-project/pull/58917", "title": "Summary", "body": "# **DO NOT FILE A PULL REQUEST**\r\n\r\nThis repository does not accept pull requests. Please follow http://llvm.org/docs/Contributing.html#how-to-submit-a-patch for contribution to LLVM.\r\n\r\n# **DO NOT FILE A PULL REQUEST**\r\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp", "functions": ["Summary", "enumeration", "mapping"]}, {"filename": "clang/test/Analysis/std-c-library-functions-config.c", "functions": ["ARR38_C_F", "test_notnull_symbolic", "test_notnull_concrete", "typeof", "test_notnull_symbolic2", "clang_analyzer_eval", "fread"]}]}
{"pr_number": 56877, "url": "https://github.com/llvm/llvm-project/pull/56877", "title": "Feature/t4pb 18499 riscv change branch structure", "body": "Add Optimization PATH <riscv-cfg> after <riscv-expand-atomic-pseudo>\r\n\r\nThis is enabled as default. ", "feature_layers": [], "feature_directives": ["atomic"], "files_changed": [{"filename": "llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp", "functions": ["pushConst"]}, {"filename": "lld/ELF/Driver.cpp", "functions": ["if"]}, {"filename": "clang/lib/Lex/PPLexerChange.cpp", "functions": ["HandleEndOfFile"]}, {"filename": "clang/lib/Sema/SemaType.cpp", "functions": ["if"]}, {"filename": "clang/test/CodeGen/aarch64-ls64-inline-asm.c", "functions": ["store", "store2", "volatile", "load"]}, {"filename": "llvm/lib/Target/AArch64/AArch64AsmPrinter.cpp", "functions": ["printAsmMRegister"]}, {"filename": "llvm/lib/Target/AArch64/AArch64ISelLowering.cpp", "functions": ["EVT"]}, {"filename": "clang/lib/Parse/ParseDecl.cpp", "functions": ["getLangOpts"]}, {"filename": "llvm/lib/Target/RISCV/RISCVISelLowering.cpp", "functions": ["SDValue"]}, {"filename": "clang/lib/Frontend/PrintPreprocessedOutput.cpp", "functions": ["MoveToLine", "HandleFirstTokOnLine", "if", "startNewLineIfNeeded", "isMinimizeWhitespace"]}, {"filename": "clang/lib/Sema/SemaConcept.cpp", "functions": ["NewConjunction"]}, {"filename": "lldb/source/Commands/CommandObjectMemoryTag.cpp", "functions": ["GetDefinitions", "OptionParsingStarting"]}, {"filename": "lldb/source/Plugins/Process/Linux/NativeThreadLinux.cpp", "functions": ["manager"]}, {"filename": "lldb/test/API/linux/aarch64/mte_tag_faults/main.c", "functions": ["if", "main"]}, {"filename": "lldb/source/Plugins/Process/gdb-remote/GDBRemoteCommunicationServerLLGS.cpp", "functions": ["SendIllFormedResponse"]}, {"filename": "clang/test/CodeGenCXX/static-member-variable-explicit-specialization.cpp", "functions": ["f", "__declspec"]}, {"filename": "llvm/lib/Transforms/Utils/PredicateInfo.cpp", "functions": ["replaceCreatedSSACopys"]}, {"filename": "llvm/lib/IR/Module.cpp", "functions": ["getValueSymbolTable"]}, {"filename": "llvm/lib/IR/ConstantFold.cpp", "functions": ["getFoldedSizeOf", "getFoldedAlignOf"]}, {"filename": "clang/lib/AST/Expr.cpp", "functions": ["Path", "MakeStringLiteral"]}, {"filename": "clang/test/CodeGenCXX/builtin-source-location.cpp", "functions": ["testRemap"]}, {"filename": "openmp/runtime/test/tasking/kmp_taskwait_depend_in.c", "functions": ["__kmpc_global_thread_num", "main", "__kmpc_omp_wait_deps"]}, {"filename": "clang-tools-extra/test/clang-tidy/checkers/bugprone-easily-swappable-parameters-implicits.cpp", "functions": ["crefToArrayTypedef3", "crefToArrayTypedef2", "templatedArrayRefTest", "arrays1", "crefToArrayTypedefBoth1", "templatedArrayRef", "crefToArrayTypedef1"]}, {"filename": "clang-tools-extra/test/clang-tidy/checkers/bugprone-easily-swappable-parameters-len2.cpp", "functions": ["crefToArrayTypedef3", "crefToArrayTypedef2", "templatedArrayRefTest", "arrays1", "crefToArrayTypedefBoth1", "templatedArrayRef", "crefToArrayTypedef1"]}, {"filename": "lld/ELF/SymbolTable.cpp", "functions": ["if"]}, {"filename": "clang/test/CXX/temp/temp.constr/temp.constr.normal/p1.cpp", "functions": ["t1"]}, {"filename": "llvm/lib/Transforms/IPO/AttributorAttributes.cpp", "functions": ["Offset", "HandlePassthroughUser"]}, {"filename": "llvm/tools/llvm-mca/Views/TimelineView.cpp", "functions": ["format"]}, {"filename": "clang-tools-extra/clang-tidy/cppcoreguidelines/InitVariablesCheck.cpp", "functions": ["if"]}, {"filename": "clang-tools-extra/test/clang-tidy/checkers/cppcoreguidelines-init-variables.cpp", "functions": ["uninitialized_enum"]}, {"filename": "compiler-rt/lib/profile/InstrProfilingBuffer.c", "functions": ["sizeof"]}, {"filename": "llvm/lib/Analysis/ValueTracking.cpp", "functions": ["llvm_unreachable"]}, {"filename": "llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp", "functions": ["match", "ICmpInst"]}, {"filename": "clang/lib/Driver/ToolChains/Hexagon.cpp", "functions": ["ResourceDirInclude"]}, {"filename": "clang/lib/Sema/SemaTemplateInstantiate.cpp", "functions": ["Info", "ExprInst"]}, {"filename": "clang/test/CXX/expr/expr.prim/expr.prim.req/type-requirement.cpp", "functions": ["m"]}, {"filename": "llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp", "functions": ["SDValue"]}, {"filename": "libcxx/test/std/language.support/support.start.term/at_quick_exit.compile.fail.cpp", "functions": ["main", "f"]}, {"filename": "libcxx/test/std/language.support/support.start.term/quick_exit.compile.fail.cpp", "functions": ["main"]}, {"filename": "libcxx/test/std/language.support/support.start.term/quick_exit.pass.cpp", "functions": ["main"]}, {"filename": "libcxx/test/std/utilities/time/date.time/ctime.pass.cpp", "functions": ["main"]}, {"filename": "compiler-rt/lib/profile/InstrProfilingPlatformLinux.c", "functions": ["WriteBinaryIds", "WriteBinaryIdForNote", "ElfW"]}, {"filename": "llvm/lib/Target/AArch64/AArch64InstrInfo.cpp", "functions": ["removeCmpToZeroOrOne"]}, {"filename": "clang/test/CodeGen/ffp-contract-option.c", "functions": ["mymuladd"]}, {"filename": "clang/test/CodeGen/arm64-microsoft-intrinsics.c", "functions": ["__mulh", "__umulh", "check_umulh", "check_mulh"]}, {"filename": "clang/test/Headers/amdgcn_openmp_device_math.c", "functions": ["test_math_f32_suffix", "test_math_f32", "test_math_f64"]}, {"filename": "llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp", "functions": ["allowPromotionAlias"]}, {"filename": "llvm/lib/Target/M68k/AsmParser/M68kAsmParser.cpp", "functions": ["isMemOp"]}, {"filename": "llvm/lib/Target/WebAssembly/WebAssemblyFastISel.cpp", "functions": ["getRegForI1Value", "getRegForValue"]}, {"filename": "clang/lib/AST/ASTContext.cpp", "functions": ["mergeTypes"]}, {"filename": "clang/test/AST/ast-dump-openmp-begin-declare-variant_reference.cpp", "functions": ["test3", "test4", "also_before", "also_after", "test1", "test", "test2"]}, {"filename": "clang/test/CXX/class/class.init/class.copy.elision/p3.cpp", "functions": ["g", "__attribute__", "f"]}, {"filename": "clang/test/Headers/amdgcn-openmp-device-math-complex.cpp", "functions": ["test_dcall", "test_dcmplx", "test_scall", "test_template_math_calls", "test_scmplx"]}, {"filename": "clang/lib/Format/UnwrappedLineParser.cpp", "functions": ["isC78ParameterDecl"]}, {"filename": "llvm/unittests/ExecutionEngine/Orc/RTDyldObjectLinkingLayerTest.cpp", "functions": ["ObjLayer"]}, {"filename": "llvm/lib/Target/AArch64/GISel/AArch64LegalizerInfo.cpp", "functions": ["legalizeBSwap"]}, {"filename": "lldb/test/API/commands/register/register/aarch64_sve_registers/rw_access_static_config/main.c", "functions": ["write_sve_regs", "main", "expr_eval_func"]}, {"filename": "llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp", "functions": ["Users"]}, {"filename": "llvm/lib/Transforms/IPO/OpenMPOpt.cpp", "functions": ["AllocaInst"]}, {"filename": "clang/test/AST/nrvo.c", "functions": ["f1", "f2"]}, {"filename": "clang/test/Analysis/blocks-nrvo.c", "functions": ["foo"]}, {"filename": "clang/test/OpenMP/parallel_if_codegen_PR51349.cpp", "functions": ["foo"]}, {"filename": "clang/lib/Analysis/ThreadSafety.cpp", "functions": ["join"]}, {"filename": "clang/test/SemaCXX/warn-thread-safety-analysis.cpp", "functions": ["loopDemoteContinue", "loopPromoteContinue", "scope", "loopPromote", "loopDemote"]}, {"filename": "clang/test/CodeGen/nrvo-tracking.cpp", "functions": ["int", "test"]}, {"filename": "clang/test/CodeGenCXX/copy-elision.cpp", "functions": ["int", "T", "test"]}, {"filename": "clang/lib/Analysis/CFG.cpp", "functions": ["VisitChildren"]}, {"filename": "clang/test/SemaCXX/unreachable-code.cpp", "functions": ["g", "f"]}, {"filename": "llvm/lib/CodeGen/DwarfEHPrepare.cpp", "functions": ["doFinalization"]}, {"filename": "libcxx/test/std/thread/thread.semaphore/ctor.compile.pass.cpp", "functions": ["cs", "bs"]}, {"filename": "libcxx/src/support/win32/thread_win32.cpp", "functions": ["__libcpp_semaphore_wait", "__libcpp_semaphore_init", "__libcpp_semaphore_destroy", "ReleaseSemaphore", "WaitForSingleObjectEx", "__libcpp_semaphore_post"]}, {"filename": "libcxx/test/std/strings/basic.string/string.capacity/shrink_to_fit.explicit_instantiation.sh.cpp", "functions": ["move", "assign", "find", "to_char_type", "eof", "copy", "main", "length", "eq_int_type", "eq", "lt", "not_eof", "compare", "to_int_type"]}, {"filename": "llvm/lib/MC/MCParser/ELFAsmParser.cpp", "functions": ["hasPrefix"]}, {"filename": "clang/test/Analysis/uninit-asm-goto.cpp", "functions": ["test7", "goto", "test8"]}, {"filename": "llvm/lib/Analysis/AliasAnalysis.cpp", "functions": ["getModRefInfo"]}, {"filename": "llvm/unittests/IR/DebugInfoTest.cpp", "functions": ["M", "I2", "DIB", "I1"]}, {"filename": "clang/test/Analysis/asm-goto.cpp", "functions": ["baz", "goto"]}, {"filename": "clang/test/Sema/array-bounds-ptr-arith.c", "functions": ["goto", "pr51682"]}, {"filename": "llvm/lib/Analysis/InlineCost.cpp", "functions": ["simplifyIntrinsicCallIsConstant"]}, {"filename": "llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp", "functions": ["ComplexPatternFuncMutatesDAG"]}, {"filename": "llvm/lib/Target/RISCV/RISCVCFGOptimizer.cpp", "functions": ["getPassName", "IsUnconditionalJump", "initializeRISCVCFGOptimizerPass", "MachineFunctionProperties", "getRequiredProperties", "runOnMachineFunction", "GetNotBranchOpecode", "IsConditionalBranch", "RISCVCFGOptimizer", "isOnFallThroughPath"]}]}
{"pr_number": 59401, "url": "https://github.com/llvm/llvm-project/pull/59401", "title": "Ib/dlib advisor final", "body": "# **DO NOT FILE A PULL REQUEST**\r\n\r\nThis repository does not accept pull requests. Please follow http://llvm.org/docs/Contributing.html#how-to-submit-a-patch for contribution to LLVM.\r\n\r\n# **DO NOT FILE A PULL REQUEST**\r\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/unittests/Transforms/IPO/DAdvisor.cpp", "functions": ["DA", "run", "DefaultInlineAdvisor", "getDefaultDynamicAdvisorPluginInfo"]}, {"filename": "llvm/unittests/Transforms/IPO/DynamicallyLoadedInliningAdvisor.cpp", "functions": ["run_dynamic", "libPath", "anchor", "run_default", "setupPlugin"]}, {"filename": "llvm/unittests/Analysis/InlineAdvisorPlugin.cpp", "functions": ["DA"]}, {"filename": "llvm/unittests/Analysis/PluginInlineAdvisorAnalysisTest.cpp", "functions": ["FooOnlyInlineAdvisor", "setupFooOnly", "libPath", "getAdviceImpl", "InlineAdvisor"]}]}
{"pr_number": 60154, "url": "https://github.com/llvm/llvm-project/pull/60154", "title": "wip", "body": "# **DO NOT FILE A PULL REQUEST**\r\n\r\nThis repository does not accept pull requests. Please follow http://llvm.org/docs/Contributing.html#how-to-submit-a-patch for contribution to LLVM.\r\n\r\n# **DO NOT FILE A PULL REQUEST**\r\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Bindings/Python/IRCore.cpp", "functions": ["PyAttribute", "PyLocation"]}, {"filename": "mlir/lib/CAPI/IR/BuiltinAttributes.cpp", "functions": ["mlirAttributeIsALocation", "unwrap"]}, {"filename": "mlir/lib/CAPI/IR/IR.cpp", "functions": ["mlirLocationFromAttr", "mlirLocationGetAttr", "wrap"]}]}
{"pr_number": 60758, "url": "https://github.com/llvm/llvm-project/pull/60758", "title": "Add OpMutations Pass", "body": "# **DO NOT FILE A PULL REQUEST**\r\n\r\nThis repository does not accept pull requests. Please follow http://llvm.org/docs/Contributing.html#how-to-submit-a-patch for contribution to LLVM.\r\n\r\n# **DO NOT FILE A PULL REQUEST**\r\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Transforms/OpMutations.cpp", "functions": ["runOnOperation"]}]}
{"pr_number": 60950, "url": "https://github.com/llvm/llvm-project/pull/60950", "title": "Clang11 d1u diu", "body": "# **DO NOT FILE A PULL REQUEST**\r\n\r\nThis repository does not accept pull requests. Please follow http://llvm.org/docs/Contributing.html#how-to-submit-a-patch for contribution to LLVM.\r\n\r\n# **DO NOT FILE A PULL REQUEST**\r\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Analysis/InstructionSimplify.cpp", "functions": ["if"]}, {"filename": "clang/lib/Sema/SemaOpenMP.cpp", "functions": ["if"]}, {"filename": "clang/lib/CodeGen/CGOpenMPRuntimeNVPTX.cpp", "functions": ["Address"]}, {"filename": "llvm/lib/IR/IRBuilder.cpp", "functions": ["CreateAssumption", "CreateAlignmentAssumptionHelper", "AlignOpB", "createCallHelper"]}, {"filename": "llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp", "functions": ["eraseInstFromFunction"]}, {"filename": "llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp", "functions": ["if"]}, {"filename": "clang-tools-extra/clangd/GlobalCompilationDatabase.cpp", "functions": ["Lock"]}, {"filename": "clang-tools-extra/clangd/unittests/GlobalCompilationDatabaseTests.cpp", "functions": ["DB"]}, {"filename": "llvm/lib/Target/X86/X86ISelLowering.cpp", "functions": ["SplitOpsAndApply"]}, {"filename": "llvm/lib/CodeGen/TwoAddressInstructionPass.cpp", "functions": ["if"]}, {"filename": "compiler-rt/lib/tsan/rtl/tsan_rtl_report.cpp", "functions": ["lock", "FindRacyAddress", "FindRacyStacks", "HandleRacyAddress", "HandleRacyStacks"]}, {"filename": "compiler-rt/lib/tsan/tests/rtl/tsan_test_util_posix.cpp", "functions": ["event"]}, {"filename": "clang/lib/Driver/ToolChains/Arch/RISCV.cpp", "functions": ["if"]}, {"filename": "llvm/lib/Support/TargetParser.cpp", "functions": ["fillValidCPUArchList", "is64Bit", "getMArchFromMcpu", "parseCPUKind", "checkCPUKind"]}, {"filename": "lld/COFF/SymbolTable.cpp", "functions": ["getSymbolLocations"]}, {"filename": "llvm/lib/Analysis/ScalarEvolution.cpp", "functions": ["getAddExpr"]}, {"filename": "clang/test/Sema/typo-correction-no-hang.cpp", "functions": ["rdar38642201_caller", "latit", "Foo", "rdar38642201_callee", "longit", "depar", "Bar", "hour", "minut"]}, {"filename": "clang/test/Sema/typo-correction-recursive.cpp", "functions": ["from_dog_years", "get_dog_years"]}, {"filename": "clang/test/OpenMP/taskloop_codegen.cpp", "functions": ["int", "taskloop_with_class"]}, {"filename": "llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp", "functions": ["SDValue"]}, {"filename": "llvm/lib/Target/AArch64/AArch64ISelLowering.cpp", "functions": ["SDValue"]}, {"filename": "llvm/lib/Target/AArch64/AArch64RegisterInfo.cpp", "functions": ["hasSVEArgsOrReturn"]}, {"filename": "llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp", "functions": ["SelectPredicatedLoad", "getPackedVectorTypeFromPredicateType"]}, {"filename": "clang/test/PCH/cxx2a-constraints-crash.cpp", "functions": ["main", "s"]}, {"filename": "llvm/lib/Analysis/LoopAccessAnalysis.cpp", "functions": ["Access", "AccessWrite"]}, {"filename": "llvm/lib/Target/AMDGPU/AMDGPUAnnotateUniformValues.cpp", "functions": ["if"]}, {"filename": "clang-tools-extra/test/clang-tidy/checkers/readability-identifier-naming.cpp", "functions": ["GetRes"]}, {"filename": "clang/lib/AST/ExprConstant.cpp", "functions": ["VIE"]}, {"filename": "clang/test/SemaCXX/constant-expression-cxx2a.cpp", "functions": ["test"]}, {"filename": "llvm/lib/Target/AArch64/AArch64FrameLowering.cpp", "functions": ["printReg", "Comment"]}, {"filename": "flang/tools/f18/f18.cpp", "functions": ["printVersion"]}, {"filename": "clang/lib/Basic/Targets/WebAssembly.cpp", "functions": ["if"]}, {"filename": "llvm/lib/Support/X86TargetParser.cpp", "functions": ["any"]}, {"filename": "llvm/lib/Target/RISCV/RISCVInstrInfo.cpp", "functions": ["isIntN"]}, {"filename": "clang/lib/Sema/SemaChecking.cpp", "functions": ["ExprError"]}, {"filename": "clang/lib/Sema/SemaType.cpp", "functions": ["if"]}, {"filename": "libcxx/test/libcxx/atomics/ext-int.verify.cpp", "functions": ["main"]}, {"filename": "clang/lib/Driver/ToolChains/OpenBSD.cpp", "functions": ["Path"]}, {"filename": "clang/test/SemaTemplate/friend.cpp", "functions": ["z1", "y1", "x1"]}, {"filename": "clang/lib/CodeGen/CGOpenMPRuntime.cpp", "functions": ["getOrCreateDefaultLocation", "Address", "IPG", "FlagsKey", "OS2"]}, {"filename": "llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp", "functions": ["getOrCreateSrcLocStr"]}, {"filename": "clang/test/OpenMP/nvptx_target_parallel_reduction_codegen_tbaa_PR46146.cpp", "functions": ["test", "complex_reduction"]}, {"filename": "openmp/libomptarget/test/env/base_ptr_ref_count.c", "functions": ["deallocate", "foo", "main"]}, {"filename": "lld/ELF/SyntheticSections.cpp", "functions": ["if", "nameAttrs", "getDebugInfoSections", "chunks"]}, {"filename": "clang/lib/AST/ASTContext.cpp", "functions": ["SVE_ELTTY", "SVE_INT_ELTTY"]}, {"filename": "clang/lib/CodeGen/CodeGenTypes.cpp", "functions": ["GET_SVE_INT_VEC", "GET_SVE_FP_VEC"]}, {"filename": "clang/lib/CodeGen/CGDebugInfo.cpp", "functions": ["CreateType"]}, {"filename": "clang/test/CodeGen/aarch64-debug-sve-vector-types.c", "functions": ["test_locals"]}, {"filename": "clang/test/CodeGen/aarch64-debug-sve-vectorx2-types.c", "functions": ["test_locals"]}, {"filename": "clang/test/CodeGen/aarch64-debug-sve-vectorx3-types.c", "functions": ["test_locals"]}, {"filename": "clang/test/CodeGen/aarch64-debug-sve-vectorx4-types.c", "functions": ["test_locals"]}, {"filename": "clang/lib/StaticAnalyzer/Core/DynamicType.cpp", "functions": ["unbox"]}, {"filename": "clang/lib/StaticAnalyzer/Checkers/CastValueChecker.cpp", "functions": ["if", "Out"]}, {"filename": "clang/test/Analysis/cast-value-logic.cpp", "functions": ["test_regions_isa_variadic", "test_regions_isa_and_nonnull", "test_regions_isa_and_nonnull_variadic"]}, {"filename": "compiler-rt/lib/profile/GCDAProfiling.c", "functions": ["length_of_string"]}, {"filename": "clang/test/CodeGen/builtins-ppc-xl-xst.c", "functions": ["test5", "test7", "test4", "test3", "test1", "test6", "test9", "test2", "test8", "test10"]}, {"filename": "llvm/lib/Extensions/Extensions.cpp", "functions": ["extensions_anchor"]}, {"filename": "clang/lib/Format/TokenAnnotator.cpp", "functions": ["isKeywordWithCondition"]}, {"filename": "llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp", "functions": ["if"]}, {"filename": "clang/test/CodeGenCXX/mangle-neon-vectors.cpp", "functions": ["__attribute__", "f12"]}, {"filename": "llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.cpp", "functions": ["isFoldableLiteralV216"]}, {"filename": "llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp", "functions": ["SimplifyBinOp"]}, {"filename": "llvm/lib/IR/LegacyPassManager.cpp", "functions": ["update", "StructuralHash", "getHash"]}, {"filename": "llvm/lib/CodeGen/RegAllocFast.cpp", "functions": ["dumpState", "verifyRegStateMapping", "printReg"]}, {"filename": "llvm/lib/IR/Globals.cpp", "functions": ["hasDefaultVisibility"]}, {"filename": "llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp", "functions": ["getABIRegCopyCC"]}, {"filename": "llvm/lib/CodeGen/GlobalISel/CallLowering.cpp", "functions": ["alignTo"]}, {"filename": "llvm/lib/IR/Core.cpp", "functions": ["LLVMGetUndefMaskElem"]}, {"filename": "llvm/tools/llvm-c-test/echo.cpp", "functions": ["if", "LLVMConstVector"]}, {"filename": "llvm/unittests/ADT/APFloatTest.cpp", "functions": ["payload"]}, {"filename": "clang/test/SemaTemplate/pr47676.cpp", "functions": ["g", "f"]}, {"filename": "clang/test/SemaCXX/init-priority-attr.cpp", "functions": ["__attribute__"]}, {"filename": "clang/lib/Driver/ToolChains/Cuda.cpp", "functions": ["getCudaVersion", "parseCudaVersionFile", "parseCudaHFile"]}, {"filename": "clang/lib/Sema/SemaTemplateInstantiateDecl.cpp", "functions": ["R"]}, {"filename": "clang/test/SemaTemplate/instantiate-var-template.cpp", "functions": ["decltype"]}, {"filename": "llvm/lib/Target/WebAssembly/WebAssemblyFastISel.cpp", "functions": ["isSet"]}, {"filename": "llvm/lib/Target/AArch64/AArch64CallingConvention.cpp", "functions": ["if"]}, {"filename": "clang/test/CodeGen/aarch64-varargs-sve.c", "functions": ["foo"]}, {"filename": "llvm/lib/Target/AArch64/AArch64AsmPrinter.cpp", "functions": ["emitFunctionEntryLabel"]}, {"filename": "llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp", "functions": ["TokError", "if", "addErrorSuffix", "parseDirectiveVariantPCS"]}, {"filename": "llvm/lib/Target/AArch64/MCTargetDesc/AArch64ELFStreamer.cpp", "functions": ["emitDirectiveVariantPCS"]}, {"filename": "clang/test/CodeGen/riscv32-ilp32d-abi.cpp", "functions": ["f_empty_complex_f", "f_empty_complex_d"]}, {"filename": "clang/lib/CodeGen/TargetInfo.cpp", "functions": ["if"]}, {"filename": "lldb/source/Target/Platform.cpp", "functions": ["module_resolver"]}, {"filename": "lldb/source/Plugins/Process/minidump/ProcessMinidump.cpp", "functions": ["basename_module_spec"]}, {"filename": "lldb/source/Target/Target.cpp", "functions": ["module_spec_copy"]}, {"filename": "lldb/source/Core/ModuleList.cpp", "functions": ["test_module_sp", "module_sp"]}, {"filename": "clang/test/CodeGen/asan-globals-alias.cpp", "functions": ["__attribute__"]}, {"filename": "llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp", "functions": ["canInstrumentAliasedGlobal"]}, {"filename": "clang/test/AST/deduction-guides.cpp", "functions": ["init"]}, {"filename": "clang/lib/Serialization/ASTReader.cpp", "functions": ["if"]}, {"filename": "clang/test/CodeGen/builtin-redeclaration.c", "functions": ["exp", "non_builtin", "attribute"]}, {"filename": "clang/test/CodeGenCXX/builtins.cpp", "functions": ["__builtin_fabsf", "__builtin_fabs"]}, {"filename": "clang/test/CodeGen/setjmp.c", "functions": ["__sigsetjmp", "sigsetjmp", "f", "setjmp", "_setjmp"]}, {"filename": "clang/test/Sema/builtin-setjmp.c", "functions": ["use_mingw", "_setjmp", "setjmp"]}, {"filename": "clang/test/Sema/implicit-builtin-decl.c", "functions": ["sigsetjmp", "longjmp"]}, {"filename": "llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp", "functions": ["if"]}]}
{"pr_number": 61516, "url": "https://github.com/llvm/llvm-project/pull/61516", "title": "Click house/release/15.x", "body": "# **DO NOT FILE A PULL REQUEST**\r\n\r\nThis repository does not accept pull requests. Please follow http://llvm.org/docs/Contributing.html#how-to-submit-a-patch for contribution to LLVM.\r\n\r\n# **DO NOT FILE A PULL REQUEST**\r\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "libcxx/test/std/containers/sequences/vector.bool/assign_copy.pass.cpp", "functions": ["tests", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector.bool/assign_initializer_list.pass.cpp", "functions": ["tests", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector.bool/assign_move.pass.cpp", "functions": ["tests", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector.bool/capacity.pass.cpp", "functions": ["tests", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector.bool/compare.pass.cpp", "functions": ["test", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector.bool/const_reference.pass.cpp", "functions": ["test"]}, {"filename": "libcxx/test/std/containers/sequences/vector.bool/construct_default.pass.cpp", "functions": ["test0", "tests", "main", "test1"]}, {"filename": "libcxx/test/std/containers/sequences/vector.bool/construct_iter_iter.pass.cpp", "functions": ["tests", "test", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector.bool/construct_iter_iter_alloc.pass.cpp", "functions": ["tests", "test", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector.bool/construct_size.pass.cpp", "functions": ["tests", "test", "main", "test1"]}, {"filename": "libcxx/test/std/containers/sequences/vector.bool/construct_size_value.pass.cpp", "functions": ["tests", "test", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector.bool/construct_size_value_alloc.pass.cpp", "functions": ["tests", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector.bool/copy.pass.cpp", "functions": ["tests", "test", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector.bool/copy_alloc.pass.cpp", "functions": ["tests", "test", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector.bool/emplace.pass.cpp", "functions": ["tests", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector.bool/emplace_back.pass.cpp", "functions": ["tests", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector.bool/empty.pass.cpp", "functions": ["tests", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector.bool/enabled_hash.pass.cpp", "functions": ["test"]}, {"filename": "libcxx/test/std/containers/sequences/vector.bool/erase_iter.pass.cpp", "functions": ["tests", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector.bool/erase_iter_iter.pass.cpp", "functions": ["tests", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector.bool/find.pass.cpp", "functions": ["tests", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector.bool/get_allocator.pass.cpp", "functions": ["test", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector.bool/initializer_list.pass.cpp", "functions": ["tests", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector.bool/initializer_list_alloc.pass.cpp", "functions": ["tests", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector.bool/insert_iter_initializer_list.pass.cpp", "functions": ["tests", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector.bool/insert_iter_iter_iter.pass.cpp", "functions": ["tests", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector.bool/insert_iter_size_value.pass.cpp", "functions": ["tests", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector.bool/insert_iter_value.pass.cpp", "functions": ["tests", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector.bool/iterators.pass.cpp", "functions": ["tests", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector.bool/move.pass.cpp", "functions": ["tests", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector.bool/move_alloc.pass.cpp", "functions": ["tests", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector.bool/op_equal_initializer_list.pass.cpp", "functions": ["tests", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector.bool/push_back.pass.cpp", "functions": ["tests", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector.bool/reference.swap.pass.cpp", "functions": ["tests", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector.bool/reference/assign_bool.pass.cpp", "functions": ["test"]}, {"filename": "libcxx/test/std/containers/sequences/vector.bool/reference/assign_copy.pass.cpp", "functions": ["test"]}, {"filename": "libcxx/test/std/containers/sequences/vector.bool/reference/ctor_copy.pass.cpp", "functions": ["test"]}, {"filename": "libcxx/test/std/containers/sequences/vector.bool/reference/flip.pass.cpp", "functions": ["test"]}, {"filename": "libcxx/test/std/containers/sequences/vector.bool/reference/operator_bool.pass.cpp", "functions": ["test"]}, {"filename": "libcxx/test/std/containers/sequences/vector.bool/reserve.pass.cpp", "functions": ["tests", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector.bool/resize_size.pass.cpp", "functions": ["tests", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector.bool/resize_size_value.pass.cpp", "functions": ["tests", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector.bool/shrink_to_fit.pass.cpp", "functions": ["tests", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector.bool/size.pass.cpp", "functions": ["tests", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector.bool/swap.pass.cpp", "functions": ["tests", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector.bool/vector_bool.pass.cpp", "functions": ["tests", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector/access.pass.cpp", "functions": ["main", "make", "test", "test_get", "test_set", "tests", "test_get_basic"]}, {"filename": "libcxx/test/std/containers/sequences/vector/compare.pass.cpp", "functions": ["test", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector/constant_initialization.pass.cpp", "functions": ["main"]}, {"filename": "libcxx/test/std/containers/sequences/vector/contiguous.pass.cpp", "functions": ["tests", "main", "test_contiguous"]}, {"filename": "libcxx/test/std/containers/sequences/vector/get_allocator.pass.cpp", "functions": ["test", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector/iterators.pass.cpp", "functions": ["tests", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector/reverse_iterators.pass.cpp", "functions": ["check_vector_reverse_iterators", "test", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector/vector.capacity/capacity.pass.cpp", "functions": ["tests", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector/vector.capacity/empty.pass.cpp", "functions": ["tests", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector/vector.capacity/max_size.pass.cpp", "functions": ["test", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector/vector.capacity/reserve.pass.cpp", "functions": ["tests", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector/vector.capacity/resize_size.pass.cpp", "functions": ["tests", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector/vector.capacity/resize_size_value.pass.cpp", "functions": ["tests", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector/vector.capacity/shrink_to_fit.pass.cpp", "functions": ["tests", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector/vector.capacity/size.pass.cpp", "functions": ["tests", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector/vector.capacity/swap.pass.cpp", "functions": ["tests", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector/vector.cons/assign_copy.pass.cpp", "functions": ["tests", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector/vector.cons/assign_initializer_list.pass.cpp", "functions": ["tests", "test", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector/vector.cons/assign_iter_iter.pass.cpp", "functions": ["test"]}, {"filename": "libcxx/test/std/containers/sequences/vector/vector.cons/assign_move.pass.cpp", "functions": ["tests", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector/vector.cons/assign_size_value.pass.cpp", "functions": ["is6", "test", "main", "tests"]}, {"filename": "libcxx/test/std/containers/sequences/vector/vector.cons/construct_default.pass.cpp", "functions": ["test0", "tests", "main", "test1"]}, {"filename": "libcxx/test/std/containers/sequences/vector/vector.cons/construct_iter_iter.pass.cpp", "functions": ["basic_test_cases", "main", "test", "test_ctor_with_different_value_type", "tests", "emplaceable_concept_tests"]}, {"filename": "libcxx/test/std/containers/sequences/vector/vector.cons/construct_iter_iter_alloc.pass.cpp", "functions": ["basic_tests", "main", "test", "implicit_conv_allocator", "emplaceable_concept_tests"]}, {"filename": "libcxx/test/std/containers/sequences/vector/vector.cons/construct_size.pass.cpp", "functions": ["tests", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector/vector.cons/construct_size_value.pass.cpp", "functions": ["tests", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector/vector.cons/construct_size_value_alloc.pass.cpp", "functions": ["tests", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector/vector.cons/copy.pass.cpp", "functions": ["tests", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector/vector.cons/copy_alloc.pass.cpp", "functions": ["tests", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector/vector.cons/deduct.pass.cpp", "functions": ["tests", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector/vector.cons/default_noexcept.pass.cpp", "functions": ["tests", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector/vector.cons/dtor_noexcept.pass.cpp", "functions": ["tests", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector/vector.cons/initializer_list.pass.cpp", "functions": ["tests", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector/vector.cons/initializer_list_alloc.pass.cpp", "functions": ["tests", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector/vector.cons/move.pass.cpp", "functions": ["tests", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector/vector.cons/move_alloc.pass.cpp", "functions": ["tests", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector/vector.cons/op_equal_initializer_list.pass.cpp", "functions": ["tests", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector/vector.data/data.pass.cpp", "functions": ["tests", "Nasty", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector/vector.data/data_const.pass.cpp", "functions": ["tests", "Nasty", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector/vector.erasure/erase.pass.cpp", "functions": ["test0", "test", "main", "tests"]}, {"filename": "libcxx/test/std/containers/sequences/vector/vector.erasure/erase_if.pass.cpp", "functions": ["test0", "test", "main", "tests"]}, {"filename": "libcxx/test/std/containers/sequences/vector/vector.modifiers/clear.pass.cpp", "functions": ["tests", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector/vector.modifiers/emplace.pass.cpp", "functions": ["A", "geti", "getd", "main", "tests"]}, {"filename": "libcxx/test/std/containers/sequences/vector/vector.modifiers/emplace_back.pass.cpp", "functions": ["A", "geti", "getd", "main", "tests"]}, {"filename": "libcxx/test/std/containers/sequences/vector/vector.modifiers/emplace_extra.pass.cpp", "functions": ["tests", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector/vector.modifiers/erase_iter.pass.cpp", "functions": ["tests", "main", "v"]}, {"filename": "libcxx/test/std/containers/sequences/vector/vector.modifiers/erase_iter_iter.pass.cpp", "functions": ["tests", "main", "v"]}, {"filename": "libcxx/test/std/containers/sequences/vector/vector.modifiers/insert_iter_initializer_list.pass.cpp", "functions": ["tests", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector/vector.modifiers/insert_iter_iter_iter.pass.cpp", "functions": ["tests", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector/vector.modifiers/insert_iter_lvalue.pass.cpp", "functions": ["test", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector/vector.modifiers/insert_iter_rvalue.pass.cpp", "functions": ["tests", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector/vector.modifiers/insert_iter_size_value.pass.cpp", "functions": ["tests", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector/vector.modifiers/pop_back.pass.cpp", "functions": ["tests", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector/vector.modifiers/push_back.pass.cpp", "functions": ["tests", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector/vector.modifiers/push_back_rvalue.pass.cpp", "functions": ["tests", "main"]}, {"filename": "libcxx/test/std/containers/sequences/vector/vector.special/swap.pass.cpp", "functions": ["tests", "main"]}, {"filename": "openmp/libomptarget/DeviceRTL/src/Mapping.cpp", "functions": ["__kmpc_get_hardware_thread_id_in_block", "__kmpc_get_hardware_num_threads_in_block", "__kmpc_get_warp_size"]}, {"filename": "openmp/libomptarget/DeviceRTL/src/Parallelism.cpp", "functions": ["__kmpc_kernel_parallel", "__kmpc_kernel_end_parallel"]}, {"filename": "openmp/libomptarget/DeviceRTL/src/State.cpp", "functions": ["__kmpc_free_shared"]}, {"filename": "openmp/libomptarget/DeviceRTL/src/Synchronization.cpp", "functions": ["__kmpc_barrier_simple_generic", "__kmpc_barrier_simple_spmd"]}, {"filename": "lld/MachO/InputFiles.cpp", "functions": ["reader", "pointerEncodingToSize"]}, {"filename": "libcxx/test/std/algorithms/alg.sorting/alg.merge/ranges_inplace_merge.pass.cpp", "functions": ["testImpl", "withAllPermutationsOfIter", "testInplaceMergeImpl", "test", "decltype"]}, {"filename": "libcxx/test/std/algorithms/ranges_robust_against_nonbool_predicates.pass.cpp", "functions": ["test", "test_mid"]}, {"filename": "libcxx/test/std/algorithms/ranges_robust_against_omitting_invoke.pass.cpp", "functions": ["test", "test_mid"]}, {"filename": "libcxx/test/std/algorithms/alg.modifying.operations/alg.copy/ranges.copy.pass.cpp", "functions": ["test_sentinels"]}, {"filename": "libcxx/test/libcxx/algorithms/bad_iterator_traits.verify.cpp", "functions": ["test", "swap"]}, {"filename": "libcxx/test/std/algorithms/alg.modifying.operations/alg.unique/ranges_unique.pass.cpp", "functions": ["testImpl", "withAllPermutationsOfIter", "decltype", "testUniqueImpl"]}, {"filename": "libcxx/test/std/algorithms/alg.modifying.operations/alg.unique/ranges_unique_copy.pass.cpp", "functions": ["testImpl", "withAllPermutationsOfInIterAndOutIter", "CopyAssignableNotCopyConstructible", "withAllPermutationsOfInIter", "testUniqueCopyImpl"]}, {"filename": "libcxx/src/verbose_abort.cpp", "functions": ["__libcpp_verbose_abort", "__libcpp_assertion_handler"]}, {"filename": "libcxx/test/std/algorithms/alg.sorting/alg.sort/partial.sort.copy/ranges_partial_sort_copy.pass.cpp", "functions": ["test_iterators", "test_iterators_in", "test_all_subsequences", "constexpr", "A", "test_iterators_in_sent1_out_sent2", "test_iterators_in_sent1_out", "decltype", "test_iterators_in_sent1"]}, {"filename": "clang/test/CodeGen/inline-asm-x86-flag-output.c", "functions": ["test_assume_boolean_flag"]}, {"filename": "libcxx/test/std/numerics/rand/rand.dist/rand.dist.samp/rand.dist.samp.discrete/eval.pass.cpp", "functions": ["u"]}, {"filename": "libcxx/test/std/algorithms/alg.modifying.operations/alg.remove/ranges_remove_copy.pass.cpp", "functions": ["test_output_iterators", "test_sentinels", "operator", "int", "test", "tests", "decltype"]}, {"filename": "libcxx/test/std/algorithms/alg.modifying.operations/alg.remove/ranges_remove_copy_if.pass.cpp", "functions": ["testImpl", "withAllPermutationsOfInIterOutIter", "withAllPermutationsOfInIter", "operator", "testRemoveCopyIfImpl", "decltype"]}, {"filename": "libcxx/test/std/algorithms/alg.modifying.operations/alg.replace/ranges_replace_copy.pass.cpp", "functions": ["test_output_iterators", "test_sentinels", "int", "test", "tests"]}, {"filename": "libcxx/test/std/algorithms/alg.modifying.operations/alg.replace/ranges_replace_copy_if.pass.cpp", "functions": ["test_output_iterators", "test_sentinels", "operator", "int", "test", "tests"]}, {"filename": "libcxx/test/std/algorithms/alg.modifying.operations/alg.random.sample/ranges_sample.pass.cpp", "functions": ["test_one", "constexpr", "test_generator", "main", "operator", "test_iterators_iter_sent", "test", "min", "test_iterators_iter", "decltype", "test_generators", "max", "test_iterators", "test_iterators_iter_sent_out"]}, {"filename": "libcxx/test/std/algorithms/ranges_robust_against_proxy_iterators.pass.cpp", "functions": ["constexpr"]}, {"filename": "libcxx/test/std/algorithms/alg.sorting/alg.permutation.generators/ranges.next_permutation.pass.cpp", "functions": ["comp", "factorial", "test_iter_sent", "test_one", "negate", "main", "test_iter", "test_next_permutations", "test", "run_next_permutation", "test_all_permutations", "decltype", "test_iterators"]}, {"filename": "libcxx/test/std/algorithms/alg.sorting/alg.permutation.generators/ranges.prev_permutation.pass.cpp", "functions": ["comp", "factorial", "test_all_permutations", "test_one", "test_iter_sent", "negate", "main", "run_prev_permutation", "test_iter", "test", "test_prev_permutations", "decltype", "test_iterators"]}, {"filename": "llvm/lib/Target/RISCV/RISCVISelLowering.cpp", "functions": ["SDValue"]}, {"filename": "openmp/libomptarget/plugins/amdgpu/src/rtl.cpp", "functions": ["__tgt_rtl_init_plugin", "__tgt_rtl_deinit_plugin"]}, {"filename": "clang/test/Modules/merge-concepts.cpp", "functions": ["bar", "foo"]}, {"filename": "llvm/lib/ExecutionEngine/Orc/MemoryMapper.cpp", "functions": ["EPC"]}, {"filename": "libcxx/test/std/algorithms/alg.modifying.operations/alg.rotate/ranges_rotate.pass.cpp", "functions": ["test_iter_sent", "test_one", "main", "test_iter", "test", "decltype", "test_iterators"]}, {"filename": "libcxx/test/std/algorithms/alg.sorting/alg.clamp/assert.ranges_clamp.pass.cpp", "functions": ["main"]}, {"filename": "libcxx/test/std/algorithms/alg.sorting/alg.clamp/ranges.clamp.pass.cpp", "functions": ["prvalue_proj", "lvalue_proj", "main", "operator", "test", "decltype", "CheckDoubleMove"]}, {"filename": "libcxx/test/std/algorithms/alg.nonmodifying/alg.is_permutation/ranges.is_permutation.pass.cpp", "functions": ["x2", "main", "proj2", "pred", "test_iterators1", "test", "div2", "decltype", "test_iterators", "proj1"]}, {"filename": "libcxx/test/libcxx/assertions/default_verbose_abort.availability.verify.cpp", "functions": ["f"]}, {"filename": "llvm/lib/Target/AArch64/AArch64ISelLowering.cpp", "functions": ["SDValue", "DL", "performBuildVectorCombine"]}, {"filename": "lld/ELF/SyntheticSections.cpp", "functions": ["sizeof"]}, {"filename": "libcxx/test/std/utilities/format/format.fmt.string/ctor.verify.cpp", "functions": ["run"]}, {"filename": "libcxx/test/std/utilities/format/format.fmt.string/get.pass.cpp", "functions": ["test", "main"]}, {"filename": "llvm/tools/llvm-ar/llvm-ar.cpp", "functions": ["performOperation"]}, {"filename": "clang-tools-extra/test/clang-tidy/checkers/misc/unused-using-decls.cpp", "functions": ["j"]}, {"filename": "clang/test/AST/ast-dump-overloaded-operators.cpp", "functions": ["f"]}, {"filename": "clang/test/SemaCXX/try-print-as-string-literal-type-check.cpp", "functions": ["f", "X", "modify"]}, {"filename": "clang/lib/Serialization/ASTReader.cpp", "functions": ["checkPreprocessorOptions"]}, {"filename": "clang/test/Sema/prototype-redecls.c", "functions": ["rintf"]}, {"filename": "libcxx/test/support/test.support/test_proxy.pass.cpp", "functions": ["main"]}, {"filename": "lld/COFF/Driver.cpp", "functions": ["exporter"]}, {"filename": "lld/COFF/DriverUtils.cpp", "functions": ["if"]}, {"filename": "lld/COFF/MinGW.cpp", "functions": ["manualExcludeSymbols"]}, {"filename": "llvm/lib/Target/X86/X86ISelLowering.cpp", "functions": ["LowerFP_TO_BF16", "SDValue", "DL"]}, {"filename": "clang/test/CodeGen/X86/bfloat-abi.c", "functions": ["h3", "fh2", "hf", "h2", "fh", "h2f", "fh3", "h1", "h4", "h5"]}, {"filename": "clang/test/CodeGen/X86/bfloat-half-abi.c", "functions": ["h3", "fh2", "hf", "h2", "fh", "h2f", "fh3", "h1", "h4", "h5"]}, {"filename": "clang/test/CodeGen/X86/bfloat-mangle.cpp", "functions": ["foo"]}, {"filename": "mlir/lib/ExecutionEngine/Float16bits.cpp", "functions": ["__truncsfbf2"]}, {"filename": "clang/test/OpenMP/parallel_default_messages.cpp", "functions": ["a"]}, {"filename": "clang/lib/Sema/SemaExpr.cpp", "functions": ["TransformLambdaExpr"]}, {"filename": "clang/test/CodeGen/aarch64-sve-vector-arith-ops.c", "functions": ["prom_u8", "neg_u32", "neg_i16", "prom_i32", "prom_i8", "prom_u32", "prom_u64", "neg_i64", "neg_u8", "neg_u16", "neg_u64", "neg_i8", "neg_i32", "prom_i16", "prom_i64", "prom_u16"]}, {"filename": "clang/test/OpenMP/bug56913.c", "functions": ["loop"]}, {"filename": "llvm/lib/MC/MCContext.cpp", "functions": ["P"]}, {"filename": "llvm/lib/MC/MCDwarf.cpp", "functions": ["StringRef"]}, {"filename": "clang-tools-extra/clangd/unittests/InlayHintTests.cpp", "functions": ["test"]}, {"filename": "clang/test/CodeGen/RISCV/riscv-abi.cpp", "functions": ["float_float_diamond_struct_inheritance", "int32_float_virtual_struct_inheritance"]}, {"filename": "llvm/lib/Target/RISCV/TargetInfo/RISCVTargetInfo.cpp", "functions": ["Y", "X"]}, {"filename": "clang-tools-extra/clangd/ClangdLSPServer.cpp", "functions": ["serializeTHIForExtension"]}, {"filename": "clang-tools-extra/clangd/Protocol.cpp", "functions": ["O", "toJSON", "fromJSON"]}, {"filename": "libcxx/test/libcxx/containers/views/views.span/span.cons/assert.iter_sent.pass.cpp", "functions": ["main"]}, {"filename": "libcxx/test/libcxx/containers/views/views.span/span.cons/assert.iter_size.pass.cpp", "functions": ["main"]}, {"filename": "libcxx/test/libcxx/containers/views/views.span/span.cons/assert.other_span.pass.cpp", "functions": ["other", "main"]}, {"filename": "libcxx/test/libcxx/containers/views/views.span/span.cons/assert.range.pass.cpp", "functions": ["main"]}, {"filename": "llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp", "functions": ["SDValue"]}, {"filename": "clang/lib/Lex/PPMacroExpansion.cpp", "functions": ["OS", "isTargetVariantEnvironment", "isTargetVariantOS", "Env"]}, {"filename": "llvm/lib/DebugInfo/Symbolize/MarkupFilter.cpp", "functions": ["lineEnding"]}, {"filename": "llvm/tools/llvm-symbolizer/llvm-symbolizer.cpp", "functions": ["Symbolizer", "filterMarkup", "Filter"]}, {"filename": "clang/test/SemaCXX/cxx2a-consteval.cpp", "functions": ["g", "zero", "foo", "bar", "apply", "test3", "pop_front", "fn", "test1", "f", "test2"]}, {"filename": "clang/test/CoverageMapping/if.cpp", "functions": ["check_consteval"]}, {"filename": "mlir/lib/ExecutionEngine/CRunnerUtils.cpp", "functions": ["aligned_alloc"]}, {"filename": "clang/test/C/drs/dr0xx.c", "functions": ["dr009_f"]}, {"filename": "clang/test/FixIt/fixit.c", "functions": ["f1"]}, {"filename": "clang/test/Parser/attributes.c", "functions": ["g3", "f3"]}, {"filename": "clang/test/Parser/declarators.c", "functions": ["f4"]}, {"filename": "clang/test/Sema/function.c", "functions": ["t6"]}, {"filename": "clang/test/Sema/implicit-decl.c", "functions": ["_CFCalendarDecomposeAbsoluteTimeV", "printf", "sformatf"]}, {"filename": "clang/test/Sema/invalid-decl.c", "functions": ["xtype"]}, {"filename": "clang/test/Sema/redefinition.c", "functions": ["foo"]}, {"filename": "clang/test/Sema/typo-correction.c", "functions": ["foo"]}, {"filename": "llvm/tools/llvm-objdump/ELFDump.cpp", "functions": ["format", "StringRef"]}, {"filename": "libcxxabi/src/cxa_thread_atexit.cpp", "functions": ["__cxa_thread_atexit_impl", "__cxa_thread_atexit"]}, {"filename": "compiler-rt/lib/gwp_asan/guarded_pool_allocator.cpp", "functions": ["L"]}]}
{"pr_number": 62222, "url": "https://github.com/llvm/llvm-project/pull/62222", "title": "llvm-stress with mutate feature", "body": "This PR migrates IRFuzzer's FuzzMutate driver to llvm-stress while retaining the latter's original functionality.\r\n", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "llvm/tools/llvm-stress/llvm-stress.cpp", "functions": ["BitCastInst", "Rand64", "FPToSIInst", "SExtInst", "SIToFPInst", "InFile", "operator", "getRandom", "FPExtInst", "R", "VectorValue", "if", "mix", "FPTruncInst", "UIToFPInst", "AllocaInst", "llvm_unreachable", "ShuffleVectorInst", "ZExtInst", "Buffer", "FPToUIInst", "TruncInst"]}, {"filename": "llvm/tools/llvm-stress/mutator.cpp", "functions": ["createISelMutator", "writeModule", "addVectorTypeGetters", "BasicTypeGetters"]}]}
{"pr_number": 62239, "url": "https://github.com/llvm/llvm-project/pull/62239", "title": "[mlir][llvm] Use attributes to store access groups.", "body": "The revision replaces the existing access group operations by attributes. The access group operations are currently stored in a global metadata operation. This solution is problematic when inlining since the access groups cannot be modified in parallel - the inliner splits the call graph into strongly connected components and inlines them in parallel - resulting in possible race conditions.\r\n\r\nThe revision introduces an access group attribute that uses an integer identifier to model the semantics of distinct metadata. A distinct sequence attribute is used to generate the unique identifiers for a specific function. Having a sequence generator per function ensures deterministic identifiers can be generated even if functions are manipulated in parallel.\r\n\r\nExample:\r\n\r\n llvm.metadata @metadata {\r\n   llvm.access_group @group\r\n   llvm.return\r\n }\r\n\r\n llvm.store %0, %ptr { access_groups = [@metadata::@group] }\r\n\r\ntranslates to:\r\n\r\n #sequence = #llvm.distinct_sequence<scope = @foo, state = 1>\r\n #group = #llvm.access_group<id = 0, elem_of = #sequence>\r\n\r\n llvm.store %0, %ptr { access_groups = [#group] }\r\n\r\nDepends on D148007\r\n\r\nDifferential Revision: https://reviews.llvm.org/D148106\r\n\r\n# **DO NOT FILE A PULL REQUEST**\r\n\r\nThis repository does not accept pull requests. Please follow http://llvm.org/docs/Contributing.html#how-to-submit-a-patch for contribution to LLVM.\r\n\r\n# **DO NOT FILE A PULL REQUEST**\r\n", "feature_layers": ["sema", "ir"], "feature_directives": ["parallel", "for"], "files_changed": [{"filename": "mlir/lib/Dialect/LLVMIR/IR/LLVMAttrs.cpp", "functions": ["success", "new", "getImpl", "mutate", "getScope", "getState"]}, {"filename": "mlir/lib/Dialect/LLVMIR/IR/LLVMDialect.cpp", "functions": ["verifyLoopAnnotationAttr", "success", "verifyAccessGroups", "decltype"]}, {"filename": "mlir/lib/Dialect/LLVMIR/IR/LLVMInterfaces.cpp", "functions": ["failure", "success"]}, {"filename": "mlir/lib/Target/LLVMIR/LoopAnnotationImporter.cpp", "functions": ["emitWarning", "guard", "convertParallelAccesses"]}, {"filename": "mlir/lib/Target/LLVMIR/LoopAnnotationTranslation.cpp", "functions": ["success"]}]}
{"pr_number": 62624, "url": "https://github.com/llvm/llvm-project/pull/62624", "title": "Llvm debug delete lit test", "body": "# **DO NOT FILE A PULL REQUEST**\r\n\r\nThis repository does not accept pull requests. Please follow http://llvm.org/docs/Contributing.html#how-to-submit-a-patch for contribution to LLVM.\r\n\r\n# **DO NOT FILE A PULL REQUEST**\r\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/MyHello/Hello.cpp", "functions": ["runOnFunction"]}, {"filename": "llvm/lib/Transforms/Utils/DbgInstructionPrint.cpp", "functions": ["dbgRegex"]}]}
{"pr_number": 62727, "url": "https://github.com/llvm/llvm-project/pull/62727", "title": "Added mmap usage for -fPIC files", "body": "", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Hello/Hello.cpp", "functions": ["getAnalysisUsage", "runOnFunction"]}, {"filename": "llvm/lib/Transforms/CallGraph/CallGraph.cpp", "functions": ["createDummyLogger"]}, {"filename": "llvm/lib/Transforms/CallGraph/Logger.cpp", "functions": ["Logger", "setCall", "writeGraph", "fillNameMap"]}, {"filename": "llvm/lib/Transforms/CallGraph/Logger/Logger.cpp", "functions": ["Logger"]}, {"filename": "elf-parser/src/lib.cpp", "functions": ["initializeArrOfPointers", "getNumberOfStrings", "getHash"]}, {"filename": "elf-parser/src/main.cpp", "functions": ["main"]}, {"filename": "elf-parser/src/parser.cpp", "functions": ["if"]}]}
{"pr_number": 63275, "url": "https://github.com/llvm/llvm-project/pull/63275", "title": "initial patch for source level mapping", "body": "1. Currently focuses on the `llvm.dbg.declare` and its corresponding `store` instruction.\r\n2. But we can find `llvm.dbg.declare` only when the source code build with no optimization.\r\n3. Optimization passes that fully promote the variable from memory to SSA values will replace this call with possibly multiple calls to `llvm.dbg.value `\r\n4. So, there is more probability of encountering `llvm.dbg.value` in the cases when the source code is build with optimization on.\r\n\r\nI will be going to spent more time on the `llvm.dbg.value` because it seems much important when we are talking about the optimized build. ", "feature_layers": [], "feature_directives": ["for", "declare"], "files_changed": [{"filename": "llvm/lib/Transforms/SourceExprMap/pass.cpp", "functions": ["valueStream", "visitor", "load", "getExpressionFromOpcode", "run", "isRequired", "exprStream", "getSourceExprPluginInfo"]}]}
{"pr_number": 63514, "url": "https://github.com/llvm/llvm-project/pull/63514", "title": "[MLIR][ANALYSIS] Add liveness analysis utility", "body": "This commit adds a utility to implement liveness analysis using the sparse backward data-flow analysis framework. Theoritically, liveness analysis assigns liveness to each (value, program point) pair in the program and it is thus a dense analysis. However, since values are immutable in MLIR, a sparse analysis, which will assign liveness to each value in the program, suffices here.\r\n\r\nCurrently, a value is considered \"live\" iff it is being written to memory using a `memref.store` operation or is needed to compute a value that is written to memory using a `memref.store` operation. This definition of \"live\" needs to be enhanced to make it more accurate. Currently some values will be marked \"not live\" which are theoretically live.\r\n\r\nSigned-off-by: Srishti Srivastava <srishtisrivastava.ai@gmail.com>", "feature_layers": ["parse", "ir", "ast"], "feature_directives": [], "files_changed": [{"filename": "mlir/test/lib/Analysis/DataFlow/TestLivenessAnalysis.cpp", "functions": ["registerTestLivenessAnalysisPass", "runOnOperation", "getArgument", "signalPassFailure"]}, {"filename": "mlir/tools/mlir-opt/mlir-opt.cpp", "functions": ["registerTestLivenessAnalysisPass"]}]}
{"pr_number": 63766, "url": "https://github.com/llvm/llvm-project/pull/63766", "title": "[Support] Add xxh3_64bits", "body": "This can be used to accelerate some XXH64 use cases, primarily:\r\n\r\n* llvm/ADT/StringMap.h StringMapImpl::LookupBucketFor\r\n* lld (e.g. ELF SHF_MERGE|SHF_STRINGS duplicate elimination, --icf)\r\n\r\nLink: https://github.com/llvm/llvm-project/issues/63750", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Support/xxhash.cpp", "functions": ["XXH3_len_9to16_64b", "XXH3_mul128_fold64", "XXH3_hashLong_64b", "XXH3_len_17to128_64b", "XXH3_len_0to16_64b", "if", "XXH3_len_1to3_64b", "XXH3_hashLong_64b_withSeed", "XXH3_len_0_64b", "XXH_write64", "XXH3_hashShort_64b", "XXH_read32", "XXH3_len_129to240_64b", "XXH3_len_4to8_64b", "XXH_swap32", "xxh3_64bits", "XXH_read64", "XXH3_avalanche", "XXH3_scrambleAcc", "XXH_swap64"]}]}
{"pr_number": 64084, "url": "https://github.com/llvm/llvm-project/pull/64084", "title": "Fix compiler crash in memset optimisation", "body": "The legacy `getDestAlignment` member used to get alignment for existing `memset` intrinsics can use a value of 0 to represent undefined alignment, which will cause the alignment offset calculation to fail as it uses this as the denominator of a modulo operation. ", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp", "functions": ["pushConst"]}, {"filename": "lld/ELF/Driver.cpp", "functions": ["if"]}, {"filename": "clang/lib/Lex/PPLexerChange.cpp", "functions": ["HandleEndOfFile"]}, {"filename": "clang/lib/Sema/SemaType.cpp", "functions": ["if"]}, {"filename": "clang/test/CodeGen/aarch64-ls64-inline-asm.c", "functions": ["store", "store2", "volatile", "load"]}, {"filename": "llvm/lib/Target/AArch64/AArch64AsmPrinter.cpp", "functions": ["printAsmMRegister"]}, {"filename": "llvm/lib/Target/AArch64/AArch64ISelLowering.cpp", "functions": ["EVT"]}, {"filename": "clang/lib/Parse/ParseDecl.cpp", "functions": ["getLangOpts"]}, {"filename": "llvm/lib/Target/RISCV/RISCVISelLowering.cpp", "functions": ["SDValue"]}, {"filename": "clang/lib/Frontend/PrintPreprocessedOutput.cpp", "functions": ["MoveToLine", "HandleFirstTokOnLine", "if", "startNewLineIfNeeded", "isMinimizeWhitespace"]}, {"filename": "clang/lib/Sema/SemaConcept.cpp", "functions": ["NewConjunction"]}, {"filename": "lldb/source/Commands/CommandObjectMemoryTag.cpp", "functions": ["GetDefinitions", "OptionParsingStarting"]}, {"filename": "lldb/source/Plugins/Process/Linux/NativeThreadLinux.cpp", "functions": ["manager"]}, {"filename": "lldb/test/API/linux/aarch64/mte_tag_faults/main.c", "functions": ["if", "main"]}, {"filename": "lldb/source/Plugins/Process/gdb-remote/GDBRemoteCommunicationServerLLGS.cpp", "functions": ["SendIllFormedResponse"]}, {"filename": "clang/test/CodeGenCXX/static-member-variable-explicit-specialization.cpp", "functions": ["f", "__declspec"]}, {"filename": "llvm/lib/Transforms/Utils/PredicateInfo.cpp", "functions": ["replaceCreatedSSACopys"]}, {"filename": "llvm/lib/IR/Module.cpp", "functions": ["getValueSymbolTable"]}, {"filename": "llvm/lib/IR/ConstantFold.cpp", "functions": ["getFoldedSizeOf", "getFoldedAlignOf"]}, {"filename": "clang/lib/AST/Expr.cpp", "functions": ["Path", "MakeStringLiteral"]}, {"filename": "clang/test/CodeGenCXX/builtin-source-location.cpp", "functions": ["testRemap"]}, {"filename": "openmp/runtime/test/tasking/kmp_taskwait_depend_in.c", "functions": ["__kmpc_global_thread_num", "main", "__kmpc_omp_wait_deps"]}, {"filename": "clang-tools-extra/test/clang-tidy/checkers/bugprone-easily-swappable-parameters-implicits.cpp", "functions": ["crefToArrayTypedef3", "crefToArrayTypedef2", "templatedArrayRefTest", "arrays1", "crefToArrayTypedefBoth1", "templatedArrayRef", "crefToArrayTypedef1"]}, {"filename": "clang-tools-extra/test/clang-tidy/checkers/bugprone-easily-swappable-parameters-len2.cpp", "functions": ["crefToArrayTypedef3", "crefToArrayTypedef2", "templatedArrayRefTest", "arrays1", "crefToArrayTypedefBoth1", "templatedArrayRef", "crefToArrayTypedef1"]}, {"filename": "lld/ELF/SymbolTable.cpp", "functions": ["if"]}, {"filename": "clang/test/CXX/temp/temp.constr/temp.constr.normal/p1.cpp", "functions": ["t1"]}, {"filename": "llvm/lib/Transforms/IPO/AttributorAttributes.cpp", "functions": ["Offset", "HandlePassthroughUser"]}, {"filename": "llvm/tools/llvm-mca/Views/TimelineView.cpp", "functions": ["format"]}, {"filename": "clang-tools-extra/clang-tidy/cppcoreguidelines/InitVariablesCheck.cpp", "functions": ["if"]}, {"filename": "clang-tools-extra/test/clang-tidy/checkers/cppcoreguidelines-init-variables.cpp", "functions": ["uninitialized_enum"]}, {"filename": "compiler-rt/lib/profile/InstrProfilingBuffer.c", "functions": ["sizeof"]}, {"filename": "llvm/lib/Analysis/ValueTracking.cpp", "functions": ["llvm_unreachable"]}, {"filename": "llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp", "functions": ["match", "ICmpInst"]}, {"filename": "clang/lib/Driver/ToolChains/Hexagon.cpp", "functions": ["ResourceDirInclude"]}, {"filename": "clang/lib/Sema/SemaTemplateInstantiate.cpp", "functions": ["Info", "ExprInst"]}, {"filename": "clang/test/CXX/expr/expr.prim/expr.prim.req/type-requirement.cpp", "functions": ["m"]}, {"filename": "llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp", "functions": ["SDValue"]}, {"filename": "libcxx/test/std/language.support/support.start.term/at_quick_exit.compile.fail.cpp", "functions": ["main", "f"]}, {"filename": "libcxx/test/std/language.support/support.start.term/quick_exit.compile.fail.cpp", "functions": ["main"]}, {"filename": "libcxx/test/std/language.support/support.start.term/quick_exit.pass.cpp", "functions": ["main"]}, {"filename": "libcxx/test/std/utilities/time/date.time/ctime.pass.cpp", "functions": ["main"]}, {"filename": "compiler-rt/lib/profile/InstrProfilingPlatformLinux.c", "functions": ["WriteBinaryIds", "WriteBinaryIdForNote", "ElfW"]}, {"filename": "llvm/lib/Target/AArch64/AArch64InstrInfo.cpp", "functions": ["removeCmpToZeroOrOne"]}, {"filename": "clang/test/CodeGen/ffp-contract-option.c", "functions": ["mymuladd"]}, {"filename": "clang/test/CodeGen/arm64-microsoft-intrinsics.c", "functions": ["__mulh", "__umulh", "check_umulh", "check_mulh"]}, {"filename": "clang/test/Headers/amdgcn_openmp_device_math.c", "functions": ["test_math_f32_suffix", "test_math_f32", "test_math_f64"]}, {"filename": "llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp", "functions": ["allowPromotionAlias"]}, {"filename": "llvm/lib/Target/M68k/AsmParser/M68kAsmParser.cpp", "functions": ["isMemOp"]}, {"filename": "llvm/lib/Target/WebAssembly/WebAssemblyFastISel.cpp", "functions": ["getRegForI1Value", "getRegForValue"]}, {"filename": "clang/lib/AST/ASTContext.cpp", "functions": ["Size"]}, {"filename": "clang/test/AST/ast-dump-openmp-begin-declare-variant_reference.cpp", "functions": ["test3", "test4", "also_before", "also_after", "test1", "test", "test2"]}, {"filename": "clang/test/CXX/class/class.init/class.copy.elision/p3.cpp", "functions": ["g", "__attribute__", "f"]}, {"filename": "clang/test/Headers/amdgcn-openmp-device-math-complex.cpp", "functions": ["test_dcall", "test_dcmplx", "test_scall", "test_template_math_calls", "test_scmplx"]}, {"filename": "clang/lib/Format/UnwrappedLineParser.cpp", "functions": ["isC78ParameterDecl"]}, {"filename": "llvm/unittests/ExecutionEngine/Orc/RTDyldObjectLinkingLayerTest.cpp", "functions": ["ObjLayer"]}, {"filename": "llvm/lib/Target/AArch64/GISel/AArch64LegalizerInfo.cpp", "functions": ["legalizeBSwap"]}, {"filename": "lldb/test/API/commands/register/register/aarch64_sve_registers/rw_access_static_config/main.c", "functions": ["write_sve_regs", "main", "expr_eval_func"]}, {"filename": "llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp", "functions": ["Users"]}, {"filename": "llvm/lib/Transforms/IPO/OpenMPOpt.cpp", "functions": ["AllocaInst"]}, {"filename": "clang/test/AST/nrvo.c", "functions": ["f1", "f2"]}, {"filename": "clang/test/Analysis/blocks-nrvo.c", "functions": ["foo"]}, {"filename": "clang/test/OpenMP/parallel_if_codegen_PR51349.cpp", "functions": ["foo"]}, {"filename": "clang/lib/Analysis/ThreadSafety.cpp", "functions": ["join"]}, {"filename": "clang/test/SemaCXX/warn-thread-safety-analysis.cpp", "functions": ["loopDemoteContinue", "loopPromoteContinue", "scope", "loopPromote", "loopDemote"]}, {"filename": "clang/test/CodeGen/nrvo-tracking.cpp", "functions": ["int", "test"]}, {"filename": "clang/test/CodeGenCXX/copy-elision.cpp", "functions": ["int", "T", "test"]}, {"filename": "llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp", "functions": ["getSTI", "hasNanoMips"]}, {"filename": "llvm/lib/Target/Mips/MipsAsmPrinter.cpp", "functions": ["OS"]}, {"filename": "llvm/lib/Target/Mips/MipsTargetMachine.cpp", "functions": ["addPreEmitPass2"]}, {"filename": "llvm/lib/Target/Mips/MipsSEInstrInfo.cpp", "functions": ["if"]}, {"filename": "llvm/lib/Target/Mips/MCTargetDesc/MipsMCTargetDesc.cpp", "functions": ["if"]}, {"filename": "llvm/lib/Target/Mips/MipsSubtarget.cpp", "functions": ["if"]}, {"filename": "llvm/lib/Target/Mips/MCTargetDesc/MipsABIInfo.cpp", "functions": ["makeArrayRef"]}, {"filename": "llvm/lib/Target/Mips/MipsISelLowering.cpp", "functions": ["SDValue"]}, {"filename": "clang/lib/Basic/Targets.cpp", "functions": ["MipsTargetInfo"]}, {"filename": "clang/lib/Basic/Targets/Mips.cpp", "functions": ["getTriple"]}, {"filename": "llvm/lib/Target/Mips/MipsInstrInfo.cpp", "functions": ["if", "Scale", "getMemopOffsetRange"]}, {"filename": "clang/lib/Driver/ToolChains/Gnu.cpp", "functions": ["isSoftFloatABI", "findMipsMtiMultilibs"]}, {"filename": "llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp", "functions": ["isNot", "isBoolean", "isCopyZero", "SL"]}, {"filename": "clang/lib/CodeGen/TargetInfo.cpp", "functions": ["getNaturalAlignIndirect"]}, {"filename": "clang/test/CodeGen/sanitize-coverage-old-pm.c", "functions": ["2c4958ebdae8"]}, {"filename": "llvm/lib/Target/Mips/NanoMipsLoadStoreOptimizer.cpp", "functions": ["isValidUse", "isLoadStoreOrAddiuWithReg", "isLoadStoreShortChar"]}, {"filename": "llvm/lib/Target/Mips/NanoMipsMoveOptimizer.cpp", "functions": ["copyImplicitOps"]}, {"filename": "llvm/lib/Target/Mips/NanoMipsRegisterReAllocation.cpp", "functions": ["tryGPR4ReAlloc", "getPassName", "isValidForReplacement", "getAnalysisUsage", "isGPR4", "hintRegister", "Register", "runOnMachineFunction", "hasNoInterference", "isGPR3"]}, {"filename": "llvm/lib/Target/Mips/MipsSEISelLowering.cpp", "functions": ["dl", "CLI", "DL", "SDValue", "lowerRemOrDiv"]}, {"filename": "llvm/lib/Target/Mips/NanoMipsRedundantCopyElimination.cpp", "functions": ["getPassName", "MachineFunctionProperties", "getRequiredProperties", "runOnMachineFunction", "optimizeBlock"]}, {"filename": "llvm/lib/Target/Mips/NanoMipsTargetTransformInfo.cpp", "functions": ["selectCost"]}, {"filename": "llvm/lib/LTO/LTOBackend.cpp", "functions": ["DojFile", "AsmFile", "TempName", "AsmStream"]}, {"filename": "llvm/lib/CodeGen/MachineOutliner.cpp", "functions": ["InstrDumpStream"]}, {"filename": "llvm/lib/Target/Mips/MipsRegisterInfo.cpp", "functions": ["getReservedRegs"]}, {"filename": "clang/test/CodeGen/nanomips-align.c", "functions": ["__attribute__"]}, {"filename": "llvm/lib/Target/Mips/NanoMipsCompressJumpTables.cpp", "functions": ["getPassName", "compressJumpTable", "computeBlockSize", "runOnMachineFunction", "scanFunction", "NMCompressJumpTables"]}, {"filename": "llvm/tools/llvm-lto-predict-sections/llvm-lto-predict-sections.cpp", "functions": ["SectionsReport", "main", "GlobalSectionName", "SymbolsReport", "FunctionSectionName", "OptionsCategory"]}]}
{"pr_number": 64386, "url": "https://github.com/llvm/llvm-project/pull/64386", "title": "ISSUE #21 #22 #23 RESOLVED", "body": "Above mentioned issues have been resolved. To run the files use the below guidelines\r\n- Compile the Code in your preferred language to intermediate code (ll)\r\n\tclang -S sample.c -emit-llvm -o file.ll \r\n- The file \u201cLoadStoreAnalysis.cpp\u201d contains the code which will help us run analysis on IR.\r\n- Now, create a file \u201ccmakeLists.txt\u201d which will have build configuration for our needs.\r\n- Then cmake is run which will generate platform specific build files which can be used by the platform specific build system.\r\n- Once generated use them and the platform specific build system(in our case make) to build the final loadable module(LoadStoreAnalysis.so)\r\n- In the previously mentioned cpp code we would have registered a pass \u201cloadstoreanalysispass\u201d with the LLVM pass manager.\r\n- Now, simply use opt and load the loadable module and also specify the pass you want to run. The opt runs the pass (if registered) and then outputs the output generated.\r\n \topt -load ./build/libLoadStoreAnalysisPass.so -loadstoreanalysis -S hello.ll -enable-new-pm=0\r\n- Now we can use opt and specify the desired file name and run the analysis\r\n-------------------------------------------------------------------------------------------------------------\r\n\r\nPROBLEM1:\r\nWrite an LLVM analysis pass that identifies load/store instructions within each function in the program. The pass should be able to handle different memory access patterns, such as direct loads/stores, pointer arithmetic, and nested structures.\r\n\r\n-------------------------------------------------------------------------------------------------------------\r\n\r\nPROBLEM2:\r\nIn the pass described in #21, determine details of the memory being accessed, such as the type and size.\r\nFor each memory location being accessed, track the total amount of memory accessed and the number of times the memory is accessed (i.e. frequency).\r\n\r\n-------------------------------------------------------------------------------------------------------------\r\n\r\nPROBLEM3:\r\nProvide a neat report of the memory access patterns for each function, including the memory locations being accessed, the amount of data being accessed and the number of times the location is accessed.\r\n\r\nAn example output expected from the pass would be something like:\r\n\r\nfile1.c:foo()\r\n   myArray: 12 bytes (3 times)\r\n   myStruct.field1: 8 bytes (2 times)\r\n   myArray2: 4 bytes (1 time)\r\n   myStruct.field2: 8 bytes (2 times)\r\n\r\nfile2.c:bar()\r\n   myArray3: 24 bytes (3 times)\r\n   myStruct.field2: 16 bytes (4 times)", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "ISSUE 21,22,23/ISSUE 21/load_store_analysis/LoadStoreAnalysisPass.cpp", "functions": ["info", "runOnFunction", "pattern"]}, {"filename": "ISSUE 21,22,23/ISSUE 21/load_store_analysis/build/CMakeFiles/3.20.0/CompilerIdC/CMakeCCompilerId.c", "functions": ["main"]}, {"filename": "ISSUE 21,22,23/ISSUE 21/load_store_analysis/build/CMakeFiles/3.20.0/CompilerIdCXX/CMakeCXXCompilerId.cpp", "functions": ["main"]}, {"filename": "ISSUE 21,22,23/ISSUE 21/load_store_analysis/hello.c", "functions": ["main"]}, {"filename": "ISSUE 21,22,23/ISSUE 21/load_store_analysis/test.c", "functions": ["main"]}, {"filename": "ISSUE 21,22,23/ISSUE 22/load_store_analysis/LoadStoreAnalysisPass.cpp", "functions": ["reportResults", "info", "processLoadInstruction", "getAccessPattern", "runOnFunction", "processStoreInstruction", "pattern", "getMemorySize"]}, {"filename": "ISSUE 21,22,23/ISSUE 22/load_store_analysis/build/CMakeFiles/3.20.0/CompilerIdC/CMakeCCompilerId.c", "functions": ["main"]}, {"filename": "ISSUE 21,22,23/ISSUE 22/load_store_analysis/build/CMakeFiles/3.20.0/CompilerIdCXX/CMakeCXXCompilerId.cpp", "functions": ["main"]}, {"filename": "ISSUE 21,22,23/ISSUE 22/load_store_analysis/hello.c", "functions": ["main"]}, {"filename": "ISSUE 21,22,23/ISSUE 22/load_store_analysis/test.c", "functions": ["main"]}, {"filename": "ISSUE 21,22,23/ISSUE 23/LoadStoreAnalysisPass.cpp", "functions": ["reportResults", "info", "processLoadInstruction", "getAccessPattern", "runOnFunction", "processStoreInstruction", "pattern", "getMemorySize"]}, {"filename": "ISSUE 21,22,23/ISSUE 23/build/CMakeFiles/3.20.0/CompilerIdC/CMakeCCompilerId.c", "functions": ["main"]}, {"filename": "ISSUE 21,22,23/ISSUE 23/build/CMakeFiles/3.20.0/CompilerIdCXX/CMakeCXXCompilerId.cpp", "functions": ["main"]}, {"filename": "ISSUE 21,22,23/ISSUE 23/hello.c", "functions": ["main"]}, {"filename": "ISSUE 21,22,23/ISSUE 23/test.c", "functions": ["main"]}]}
{"pr_number": 64387, "url": "https://github.com/llvm/llvm-project/pull/64387", "title": "First patch", "body": "", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Analysis/Presburger/Barvinok.cpp", "functions": ["lt"]}, {"filename": "mlir/lib/Analysis/Presburger/LinearTransform.cpp", "functions": ["determinant"]}, {"filename": "mlir/lib/Analysis/Presburger/Matrix.cpp", "functions": ["copy", "augmented", "inverse"]}, {"filename": "mlir/lib/Analysis/Presburger/MatrixF.cpp", "functions": ["sum", "copy", "matrix", "inverse", "augmented", "nRows"]}, {"filename": "mlir/lib/Analysis/FlatLinearValueConstraints.cpp", "functions": ["mat"]}, {"filename": "mlir/lib/Analysis/Presburger/IntegerRelation.cpp", "functions": ["dirs"]}, {"filename": "mlir/lib/Analysis/Presburger/Simplex.cpp", "functions": ["output"]}, {"filename": "mlir/unittests/Analysis/Presburger/LinearTransformTest.cpp", "functions": ["m3", "m5", "m1", "m6", "m4", "testColumnEchelonForm", "m2"]}, {"filename": "mlir/unittests/Analysis/Presburger/MatrixTest.cpp", "functions": ["mat"]}]}
{"pr_number": 64608, "url": "https://github.com/llvm/llvm-project/pull/64608", "title": "Solved issue #5", "body": "Code to solve issue #5 is in directory `fragile_marker`. Instructions to run the pass are in the README for the directory.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "fragile_marker/Tests/test.c", "functions": ["main", "add", "f", "ff", "fff"]}, {"filename": "fragile_marker/fragile_marker_pass.cpp", "functions": ["run", "doLocationsOverlap", "getPassPluginInfo"]}]}
{"pr_number": 64844, "url": "https://github.com/llvm/llvm-project/pull/64844", "title": "Devajith.mlir query extract", "body": "", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Query/Matcher/Diagnostics.cpp", "functions": ["maybeAddLineAndColumn", "errorTypeToFormatString", "ArgStream"]}, {"filename": "mlir/lib/Query/Matcher/Parser.cpp", "functions": ["CodeTokenizer", "set", "nextTokenKind", "sce", "skipNewlines", "nextArg", "getNextToken", "firstCharacterAndDrop", "parseIdentifierOrInvalid", "parseIdentifierPrefixImpl", "consumeWhitespace", "consumeNextToken", "parser", "currentLocation", "consumeStringLiteral", "parseMatcherExpressionImpl", "tokenizer", "code", "consumeNextTokenIgnoreNewlines"]}, {"filename": "mlir/lib/Query/Matcher/RegistryManager.cpp", "functions": ["argKinds", "asArgString", "os", "if"]}, {"filename": "mlir/lib/Query/Matcher/VariantValue.cpp", "functions": ["SinglePayload", "type", "getDynMatcher", "getTypeAsString", "VariantMatcher"]}, {"filename": "mlir/lib/Query/Query.cpp", "functions": ["builder"]}, {"filename": "mlir/lib/Query/QueryParser.cpp", "functions": ["endQuery", "doParse", "os", "queryParser", "Default", "if", "QueryParser", "word", "QueryRef", "InvalidQuery", "completeMatcherExpression", "makeInvalidQueryFromDiagnostics"]}, {"filename": "mlir/lib/Tools/mlir-query/MlirQueryMain.cpp", "functions": ["help", "le", "y", "mlirQueryCategory", "qs"]}, {"filename": "mlir/tools/mlir-query/mlir-query.cpp", "functions": ["context", "registerTestDialect", "failed", "main"]}]}
{"pr_number": 64960, "url": "https://github.com/llvm/llvm-project/pull/64960", "title": "Move CallInst::CreateMalloc to IRBuilderBase::CreateMalloc", "body": "TBD", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/IR/Instructions.cpp", "functions": ["if", "IsConstantOne"]}, {"filename": "llvm/lib/IR/IRBuilder.cpp", "functions": ["CreateMalloc"]}]}
{"pr_number": 65176, "url": "https://github.com/llvm/llvm-project/pull/65176", "title": "[tsan][go]: add atomic or/and functions", "body": "These atomic primitives are required in order to implement the race variants of the \r\nnew And and Or operators in Go's sync/atomic package, see https://github.com/golang/go/issues/61395.", "feature_layers": ["ir"], "feature_directives": ["atomic"], "files_changed": [{"filename": "compiler-rt/lib/tsan/rtl/tsan_interface_atomic.cpp", "functions": ["__tsan_go_atomic32_fetch_or", "__tsan_go_atomic64_fetch_and", "__tsan_go_atomic64_fetch_or", "__tsan_go_atomic32_fetch_and"]}]}
{"pr_number": 65171, "url": "https://github.com/llvm/llvm-project/pull/65171", "title": "[mlir] Add option to cloning with different results", "body": "Since `Operation`s cannot change the results after creation, a clone is necessary to create new results. Doing such an operation generically has not been possible so far. This PR therefore adds a new option to the `CloneOptions` struct allowing adding changing the results of the created operation.\r\n\r\nThe caller is responsible to ensure that this is a valid operation and setting the `IRMapping` accordingly afterwards if required.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/IR/Operation.cpp", "functions": ["CloneOptions", "cloneRegionsFlag"]}, {"filename": "mlir/unittests/IR/OperationSupportTest.cpp", "functions": ["builder"]}]}
{"pr_number": 65219, "url": "https://github.com/llvm/llvm-project/pull/65219", "title": "[JumpThreading] Invalidate LVI after `combineMetadataForCSE`. ", "body": "Fixes #65195.\r\n\r\nLVI information may be out of date after `combineMetadataForCSE`.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Analysis/LazyValueInfo.cpp", "functions": ["getImpl"]}]}
{"pr_number": 65210, "url": "https://github.com/llvm/llvm-project/pull/65210", "title": "[mlir] Add helper method to print and parse cyclic attributes and types", "body": "Printing cyclic attributes and types currently has no first-class support within the AsmPrinter and AsmParser. The workaround for this issue used in all mutable attributes and types upstream has been to create a `thread_local static SetVector` keeping track of currently parsed and printed attributes.\r\n\r\nThis solution is not ideal readability wise due to the use of globals and keeping track of state. Worst of all, this pattern had to be reimplemented for every mutable attribute and type.\r\n\r\nThis patch therefore adds support for this pattern in `AsmPrinter` and `AsmParser` replacing the use of this pattern. By calling `tryStartCyclingPrint/Parse`, the mutable attribute or type are registered in an internal stack. All subsequent calls to the function with the same attribute or type will lead to returning failure. This way the nesting can be detected and a short form printed or parsed instead.\r\nThrough the resetter returned by the call, the cyclic printing or parsing region automatically ends on return.", "feature_layers": ["parse", "ir", "parser"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/LLVMIR/IR/LLVMTypeSyntax.cpp", "functions": ["LLVMStructType"]}, {"filename": "mlir/lib/Dialect/SPIRV/IR/SPIRVDialect.cpp", "functions": ["removeIdentifierAndFail", "Type"]}, {"filename": "mlir/lib/IR/AsmPrinter.cpp", "functions": ["popCyclicPrinting", "success", "pushCyclicPrinting"]}, {"filename": "mlir/test/lib/Dialect/Test/TestTypes.cpp", "functions": ["parseTestType"]}]}
{"pr_number": 65187, "url": "https://github.com/llvm/llvm-project/pull/65187", "title": "[APINotes] Upstream APINotesWriter", "body": "This upstreams more of the Clang API Notes functionality that is currently implemented in the Apple fork: https://github.com/apple/llvm-project/tree/next/clang/lib/APINotes", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/APINotes/APINotesWriter.cpp", "functions": ["ContextID", "ComputeHash", "Key", "getSelector", "getIdentifier"]}]}
{"pr_number": 65238, "url": "https://github.com/llvm/llvm-project/pull/65238", "title": "[clang][Diagnostics] Fix wrong line number display", "body": "When the caret location is lower than the lowest source range, clang is printing wrong line numbers. The first line number should consider caret location line even when there are source ranges provided.\r\n\r\nCurrent wrong line example: https://godbolt.org/z/aj4qEjzs4", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "clang/test/Misc/diag-style.cpp", "functions": ["test"]}]}
{"pr_number": 65335, "url": "https://github.com/llvm/llvm-project/pull/65335", "title": "[mlir] alloc-to-alloca conversion for memref", "body": "Introduce a simple conversion of a memref.alloc/dealloc pair into an alloca in the same scope. Expose it as a transform op and a pattern.\r\n\r\nAllocas typically lower to stack allocations as opposed to alloc/dealloc that lower to significantly more expensive malloc/free calls. In addition, this can be combined with allocation hoisting from loops to further improve performance.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/MemRef/TransformOps/MemRefTransformOps.cpp", "functions": ["AllocToAllocaPattern"]}, {"filename": "mlir/lib/Dialect/MemRef/Transforms/IndependenceTransforms.cpp", "functions": ["guard"]}]}
{"pr_number": 65434, "url": "https://github.com/llvm/llvm-project/pull/65434", "title": "y", "body": "The order of stack objects decides the offset size relative to\nsp/fp, and shorter offset is more possible to make the related\ninstructions to be compressed and use less instructions to\nbuild the offset immediate. So it can improve the code size\nif we reorder the stack objects using proper cost model.\n\nThe precise cost model requires further complexity, and the\noverall gain isn't worth it. I reuse X86's cost model that\nuses the estimated density, the cost is computed by\ndensity = ObjectNumUses / ObjectSize,\nObjectNumUses is the number of instructions using the frame\nobject, and the difference between x86 and RISCV is that we\nprovide the double weight for ld/st instructions because it's\nmore possible to be compressed. ObjectSize is the size of frame\nobject.\nCodeSize may regress in some testcases if we don't add weight\nfor ld/st(the reason is that more compressible ld/st get too much\noffset to stop them being compressed), and the double weight is\nestimate(other maybe better in some cases).\nThe original allocated objects are splitted into multiple groups\nwith same alignment size first, and sort each group using the\nalgorithm that the frame object with higher density\ngets shorter offset relative to sp/fp.\n\nDifferential Revision: https://reviews.llvm.org/D158623\n", "feature_layers": ["ir"], "feature_directives": ["for", "allocate", "requires"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVFrameLowering.cpp", "functions": ["SortingObjects", "isCompressibleLdOrSt"]}]}
{"pr_number": 65343, "url": "https://github.com/llvm/llvm-project/pull/65343", "title": "[mlir][llvm] Add icmp folder", "body": "This revision adds a simple icmp folder that performs the following folds to the LLVM dialect icmp op:\r\n - cmpi(eq/ne, x, x) -> true/false\r\n - cmpi(eq/ne, alloca, null) -> false/true\r\n - cmpi(eq/ne, null, alloca) -> cmpi(eq/ne, alloca, null)", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/LLVMIR/IR/LLVMDialect.cpp", "functions": ["getBoolAttribute", "getResult"]}]}
{"pr_number": 65303, "url": "https://github.com/llvm/llvm-project/pull/65303", "title": "[MLIR][NFC] Mark barrier elimination helper static", "body": "Make local helper functions static to avoid symbol name collision.", "feature_layers": ["ir"], "feature_directives": ["barrier"], "files_changed": [{"filename": "mlir/lib/Dialect/GPU/TransformOps/GPUTransformOps.cpp", "functions": ["maybeCaptured", "mayAlias"]}]}
{"pr_number": 65449, "url": "https://github.com/llvm/llvm-project/pull/65449", "title": "[mlir][SCF] convert-scf-to-cf: Lower scf.forall to scf.parallel", "body": "scf.forall ops without shared outputs (i.e., fully bufferized ops) are lowered to scf.parallel. scf.forall ops are typically lowered by an earlier pass depending on the execution target. E.g., there are optimized lowerings for GPU execution. This new lowering is for completeness (convert-scf-to-cf can now lower all SCF loop constructs) and provides a simple CPU lowering strategy for testing purposes.\r\n\r\nscf.parallel is currently lowered to scf.for, which executes sequentially. The scf.parallel lowering could be improved in the future to run on multiple threads.", "feature_layers": ["ir"], "feature_directives": ["parallel", "for", "target"], "files_changed": [{"filename": "mlir/lib/Conversion/SCFToControlFlow/SCFToControlFlow.cpp", "functions": ["success"]}]}
{"pr_number": 65264, "url": "https://github.com/llvm/llvm-project/pull/65264", "title": "[llvm-cov] - Output better error message when the error kind is `coveragemap_error::malforme`.", "body": "The current llvm-cov error message for kind `coveragemap_error::malforme`,  just gives the issue kind without any reason for what caused the issue. This patch is aimed at improving the llvm-cov error message to help identify what caused the issue.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/ProfileData/Coverage/CoverageMapping.cpp", "functions": ["OS", "getCoverageMapErrString"]}]}
{"pr_number": 65427, "url": "https://github.com/llvm/llvm-project/pull/65427", "title": "[nfc][thinlto] Factor common state for `computeImportForModule`", "body": "Added a class to hold such common state. The goal is to both reduce the argument list of other utilities used by `computeImportForModule` (which will be brought as members in a subsequent patch), and to make it easy to extend such state later.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/IPO/FunctionImport.cpp", "functions": ["MIS"]}]}
{"pr_number": 65429, "url": "https://github.com/llvm/llvm-project/pull/65429", "title": "[clang-format][NFC] Fix broken dump_format_help.py and sync RST file", "body": "Running `dump_format_help.py` in `clang/docs/tools`:\r\n```\r\nwarning: line too long:\r\n                                      relative to the current working directory when reading stdin.\r\nwarning: line too long:\r\n     --files=<filename>             - A file containing a list of files to process, one per line.\r\nwarning: line too long:\r\n     --help-list                    - Display list of available options (--help-list-hidden for more)\r\nTraceback (most recent call last):\r\n  File \"/Users/Owen/remove-braces/clang/docs/tools/./dump_format_help.py\", line 63, in <module>\r\n    contents = substitute(contents, \"FORMAT_HELP\", help_text)\r\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/Owen/remove-braces/clang/docs/tools/./dump_format_help.py\", line 17, in substitute\r\n    return re.sub(pattern, \"%s\", text, flags=re.S) % replacement\r\n           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~\r\nTypeError: not enough arguments for format string\r\n```", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/tools/clang-format/ClangFormat.cpp", "functions": ["FileNames"]}]}
{"pr_number": 65558, "url": "https://github.com/llvm/llvm-project/pull/65558", "title": "[clang-tidy][modernize-use-using]fix function pointer typedef correctly", "body": "Fixed #65055\r\nFor normal type, typedef is from typedef to the end of original type, but for function pointer it is from typedef to the end.\r\nSo it needs to consider alias name length for normal type.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang-tools-extra/test/clang-tidy/checkers/modernize/use-using.cpp", "functions": ["void", "bool"]}]}
{"pr_number": 65581, "url": "https://github.com/llvm/llvm-project/pull/65581", "title": "[X86] Simplify the API of FixupBWInstPass::getSuperRegDestIfDead. NFC.", "body": "It is easy to check the returned register for validity so there is no\nneed to return a separate boolean flag.\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/X86/X86FixupBWInsts.cpp", "functions": ["Register", "getSuperRegDestIfDead"]}]}
{"pr_number": 65398, "url": "https://github.com/llvm/llvm-project/pull/65398", "title": "[mlir][Target][NVPTX] Add fatbin support to NVPTX compilation.", "body": "Currently, the NVPTX tool compilation path only calls `ptxas`; thus, the GPU running the binary must be an exact match of the arch of the target, or else the runtime throws an error due to the arch mismatch.\r\n\r\nThis patch adds a call to `fatbinary`, creating a fat binary with the cubin object and the PTX code, allowing the driver to JIT the PTX at runtime if there's an arch mismatch.\r\n\r\nThis patch is needed to start migrating the Integration Tests, otherwise there will be a runtime error due to architecture mismatch.", "feature_layers": ["runtime", "ir"], "feature_directives": ["target"], "files_changed": [{"filename": "mlir/lib/Target/LLVM/NVVM/Target.cpp", "functions": ["cubinFile"]}]}
{"pr_number": 65565, "url": "https://github.com/llvm/llvm-project/pull/65565", "title": "[llvm] Use llvm::any_cast instead of any_cast (NFC)", "body": "This patch replaces any_cast with llvm::any_cast.  This in turn allows us to gracefully switch to std::any in future by forwarding llvm::Any and llvm::any_cast to:\r\n\r\n  using Any = std::any;\r\n\r\n  template <class T> T *any_cast(Any *Value) {\r\n    return std::any_cast<T>(Value);\r\n  }\r\n\r\nrespectively.\r\n\r\nWithout this patch, it's ambiguous whether any_cast refers to std::any_cast or llvm::any_cast.\r\n\r\nAs an added bonus, this patch makes it easier to mechanically replace llvm::any_cast with std::any_cast without affecting other occurrences of any_cast (e.g. in libcxx).", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/IPO/SampleProfileProbe.cpp", "functions": ["if"]}]}
{"pr_number": 65617, "url": "https://github.com/llvm/llvm-project/pull/65617", "title": "[mlir][spirv] Add `CooperativeMatrixMulAdd` op", "body": "This is the last remaining op from the `SPV_KHR_cooperative_matrix` extension.", "feature_layers": ["ir", "ast"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/SPIRV/IR/CooperativeMatrixOps.cpp", "functions": ["emitOpError"]}]}
{"pr_number": 65616, "url": "https://github.com/llvm/llvm-project/pull/65616", "title": "[libc] Fix missing GPU math implementations", "body": "These functions were implemented by simply calling their `__builtin_*` equivalents.\r\nThe builtins were resolving to the libc functions back again. This patch adds explicit\r\nvendor versions for these functions to avoid the recursion.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "libc/src/math/gpu/vendor/frexp.cpp", "functions": ["__builtin_frexp"]}, {"filename": "libc/src/math/gpu/vendor/frexpf.cpp", "functions": ["__builtin_frexpf"]}, {"filename": "libc/src/math/gpu/vendor/remquo.cpp", "functions": ["__builtin_remquo"]}, {"filename": "libc/src/math/gpu/vendor/remquof.cpp", "functions": ["__builtin_remquof"]}, {"filename": "libc/src/math/gpu/vendor/scalbn.cpp", "functions": ["__builtin_scalbn"]}, {"filename": "libc/src/math/gpu/vendor/scalbnf.cpp", "functions": ["__builtin_scalbnf"]}]}
{"pr_number": 65552, "url": "https://github.com/llvm/llvm-project/pull/65552", "title": "[lldb-vscode] Show a fake child with the raw value of synthetic types", "body": "Currently, if the user wants to inspect the raw version of a synthetic variable, they have to go to the debug console and type `frame var <variable>`, which is not a great experience. Taking inspiration from CodeLLDB, this adds a `[raw]` child to every synthetic variable so that this kind of inspection can be done visually.\r\n\r\nSome examples:\r\n\r\n<img width=\"500\" alt=\"Screenshot 2023-09-06 at 7 56 25 PM\" src=\"https://github.com/llvm/llvm-project/assets/1613874/7fefb7c5-0da7-49c7-968b-78ac88348fea\">\r\n<img width=\"479\" alt=\"Screenshot 2023-09-06 at 6 58 25 PM\" src=\"https://github.com/llvm/llvm-project/assets/1613874/6e650567-16e1-462f-9bf5-4a3a605cf6fc\">\r\n\r\n\r\n", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "lldb/tools/lldb-vscode/JSONUtils.cpp", "functions": ["CreateUniqueVariableNameForDisplay"]}]}
{"pr_number": 65501, "url": "https://github.com/llvm/llvm-project/pull/65501", "title": "[OpenMP] Support 'omp_get_num_procs' on the device", "body": "Summary:\nThe `omp_get_num_procs()` function should return the amount of\nparallelism availible. On the GPU, this was not defined. We have elected\nto define this function as the maximum amount of wavefronts / warps that\ncan be simultaneously resident on the device. For AMDGPU this is the\nnumber of CUs multiplied byth CU's per wave. For NVPTX this is the\nmaximum threads per SM divided by the warp size and multiplied by the\nnumber of SMs.\n", "feature_layers": [], "feature_directives": ["parallel", "for"], "files_changed": [{"filename": "openmp/libomptarget/plugins-nextgen/amdgpu/src/rtl.cpp", "functions": ["requestedRPCPortCount", "getHardwareParallelism"]}, {"filename": "openmp/libomptarget/plugins-nextgen/cuda/src/rtl.cpp", "functions": ["getHardwareParallelism"]}, {"filename": "openmp/libomptarget/test/api/omp_get_num_procs.c", "functions": ["omp_get_num_procs", "main"]}]}
{"pr_number": 65555, "url": "https://github.com/llvm/llvm-project/pull/65555", "title": "[lldb][NFCI] Remove typedef for TypeCategoryMap::ValueSP", "body": "lldb already has a `ValueSP` type. This was confusing to me when reading TypeCategoryMap, especially when `ValueSP` is not qualified. From first glance it looks like it's referring to a `std::shared_ptr<lldb_private::Value>` when it's really referring to a `std::shared_ptr<lldb_private::TypeCategoryImpl>`.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "lldb/source/DataFormatters/TypeCategoryMap.cpp", "functions": ["sorted_categories"]}]}
{"pr_number": 65563, "url": "https://github.com/llvm/llvm-project/pull/65563", "title": "[flang][hlfir] Lower Cray pointee references.", "body": "A Cray pointee reference must be done using the characteristics\r\n(bounds, type params) of the original pointee declaration, but\r\nusing the actual address value of the associated Cray pointer.\r\nThere might be multiple Cray pointees associated with the same\r\nCray pointer.\r\n\r\nThe proposed solution is to lower each Cray pointee into a POINTER\r\nvariable with a descriptor. The descriptor is initialized at the point\r\nof declaration of the pointee, though its base_addr is set to null.\r\nBefore each reference of the Cray pointee its descriptor's base_addr\r\nis updated to the current value of the Cray pointer.\r\n\r\nThe update of the base_addr is done using PointerAssociateScalar\r\nruntime call, which just updates the base_addr of the descriptor.\r\nThis is a temporary solution just to make Cray pointers work\r\nto the same extent they work with FIR lowering.\r\n", "feature_layers": ["runtime", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Lower/ConvertVariable.cpp", "functions": ["shape"]}]}
{"pr_number": 65647, "url": "https://github.com/llvm/llvm-project/pull/65647", "title": "[clang] Make the entire `CompilerInvocation` ref-counted", "body": "This enables making the whole `CompilerInvocation` more efficient through copy-on-write.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "clang/lib/Frontend/CompilerInvocation.cpp", "functions": ["make_shared_copy", "makeIntrusiveRefCntCopy", "LangOpts", "T"]}]}
{"pr_number": 65633, "url": "https://github.com/llvm/llvm-project/pull/65633", "title": "[MLIR][Linalg] Retire `tile_to_scf_for`", "body": "Both `TileOp` and `TileToScfForOp` use the tiling interface and the `tileUsingSCFForOp` method. This duplication was introduced in https://github.com/llvm/llvm-project/commit/44cfea0279a4fb9ea8cb0c68a2b5ee7a81654071 as a way to retire `linalg::tileLinalgOp,` now there is not more need for this duplication, and it seems that `tileOp` has more recent changes, thus retire `TileToScfForOp.`", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Linalg/TransformOps/LinalgTransformOps.cpp", "functions": ["builder", "success", "failure"]}]}
{"pr_number": 65639, "url": "https://github.com/llvm/llvm-project/pull/65639", "title": "[InferAddressSpaces] Register pass.", "body": "InferAddressSpaces failed to call its initialization function. It was still called through initializeScalarOpts in llc and opt, but it was skipped entirely in clang. When the initialization function is not called, this results in confusing behavior where the pass appears to run, but not entirely as it should, e.g. the pass is excluded from -print-before-all and -print-after-all.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp", "functions": ["FunctionPass"]}]}
{"pr_number": 65412, "url": "https://github.com/llvm/llvm-project/pull/65412", "title": "[clang] Introduce copy-on-write `CompilerInvocation`", "body": "This PR introduces new copy-on-write `CompilerInvocation` class (`CowCompilerInvocation`), which will be used by the dependency scanner to reduce the number of copies performed when generating command lines for discovered modules.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Frontend/CompilerInvocation.cpp", "functions": ["ensureOwned"]}, {"filename": "clang/unittests/Frontend/CompilerInvocationTest.cpp", "functions": ["B"]}]}
{"pr_number": 65648, "url": "https://github.com/llvm/llvm-project/pull/65648", "title": "[RISCV] Lower constant build_vectors with few non-sign bits via vsext", "body": "If we have a build_vector such as [i64 0, i64 3, i64 1, i64 2], we instead lower this as vsext([i8 0, i8 3, i8 1, i8 2]).  For vectors with 4 or fewer elements, the resulting narrow vector can be generated via scalar materialization.\r\n\r\nFor shuffles which get lowered to vrgathers, constant build_vectors of small constants are idiomatic.  As such, this change covers all shuffles with an output type of 4 or less.\r\n\r\nI deliberately started narrow here.  I think it makes sense to expand this to longer vectors, but we need a more robust profit model on the recursive expansion.  It's questionable if we want to do the zsext if we're going to generate a constant pool load for the narrower type anyways.\r\n\r\nOne possibility for future exploration is to allow the narrower VT to be less than 8 bits.  We can't use vsext for that, but we could use something analogous to our widening interleave lowering with some extra shifts and ands.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVISelLowering.cpp", "functions": ["convertFromScalableVector"]}]}
{"pr_number": 65690, "url": "https://github.com/llvm/llvm-project/pull/65690", "title": "[BOLT][test] Fix patch-entries for aarch64 buildbot", "body": "", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "bolt/test/X86/Inputs/patch-entries.c", "functions": ["foo", "main"]}, {"filename": "bolt/test/X86/patch-entries.c", "functions": ["foo", "main"]}]}
{"pr_number": 65691, "url": "https://github.com/llvm/llvm-project/pull/65691", "title": "[clang][deps] Generate command lines lazily", "body": "This patch makes the generation of command lines for modular dependencies lazy/on-demand. That operation is somewhat expensive and prior to this patch used to be performed multiple times for the identical `ModuleDeps` (i.e. when they were imported from multiple different TUs).", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/tools/clang-scan-deps/ClangScanDeps.cpp", "functions": ["ul"]}]}
{"pr_number": 65606, "url": "https://github.com/llvm/llvm-project/pull/65606", "title": "Reland \"[CUDA][HIP] Fix overloading resolution in global var init\"", "body": "https://reviews.llvm.org/D158247 caused regressions for HIP on Windows and was reverted.\r\n\r\nA reduced test case is:\r\n\r\n```\r\ntypedef void (__stdcall* funcTy)();\r\nvoid invoke(funcTy f);\r\n\r\nstatic void __stdcall callee() noexcept {\r\n}\r\n\r\nvoid foo() {\r\n   invoke(callee);\r\n}\r\n```\r\n\r\nIt is due to clang missing handling host/device attributes for calling convention at a few places\r\n\r\nThis patch fixes that.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Parse/ParseDecl.cpp", "functions": ["X"]}, {"filename": "clang/lib/Sema/SemaCUDA.cpp", "functions": ["hasAttr", "S"]}, {"filename": "clang/lib/Sema/SemaType.cpp", "functions": ["handleFunctionTypeAttr", "if"]}]}
{"pr_number": 65613, "url": "https://github.com/llvm/llvm-project/pull/65613", "title": "[flang] Use BIND name, if any, when consolidating common blocks", "body": "This patch changes how common blocks are aggregated and named in lowering in order to:\r\n\r\n* fix one obvious issue where BIND(C) and non BIND(C) with the same Fortran name were \"merged\"\r\n\r\n* go further and deal with a derivative where the BIND(C) C name matches the assembly name of a Fortran common block. This is a bit unspecified IMHO, but gfortran, ifort, and nvfortran \"merge\" the common block without complaints as a linker would have done. This required getting rid of all the common block mangling early in FIR (\\_QC) instead of leaving that to the phase that emits LLVM from FIR because BIND(C) common blocks did not have mangled names. Care has to be taken to deal with the underscoring option of flang-new.\r\n\r\nSee added flang/test/Lower/HLFIR/common-block-bindc-conflicts.f90 for an illustration.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Lower/Mangler.cpp", "functions": ["mangleName"]}, {"filename": "flang/lib/Semantics/tools.cpp", "functions": ["GetCommonBlockObjectName"]}]}
{"pr_number": 65635, "url": "https://github.com/llvm/llvm-project/pull/65635", "title": "[lldb][Docs] Additions to debuging LLDB page", "body": "Adds the following:\r\n* A note that you can use attaching to debug the right lldb-server process, though there are drawbacks.\r\n* A section on debugging the remote protocol.\r\n* Reducing bugs, including reducing ptrace bugs to remove the need for LLDB.\r\n\r\nI've added a standlone ptrace program to the examples folder because:\r\n* There's no better place to put it.\r\n* Adding it to the page seems like wasting space, and would be harder to update.\r\n* I link to Eli Bendersky's classic blog on the subject, but we are safer with our own example as well.\r\n* Eli's example is for 32 bit Intel, AArch64 is more common these days.\r\n* It's easier to show the software breakpoint steps in code than explain it (though I still do that in the text).\r\n* It was living on my laptop not helping anyone so I think it's good to have it upstream for others, including future me.", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "lldb/examples/ptrace_example.c", "functions": ["main", "debugger", "if", "inferior", "volatile"]}]}
{"pr_number": 65492, "url": "https://github.com/llvm/llvm-project/pull/65492", "title": "[mlir] Make `classof` substitution in interface use an instance", "body": "The substitution supported by `extraClassOf` is currently limited to only the base instance, i.e. `Operation*`, `Type` or `Attribute`, which limits the kind of checks you can perform in the `classof` implementation.\r\n\r\nSince prior to the user code, the interface concept is fetched, we can use it to construct an instance of the interface, allowing use of its methods in the `classof` check.\r\n\r\nSince an instance of the interface allows access to the base class methods through the `->` operator, I've gone ahead and replaced the substitution of `$_op/$_type/$_attr` with an interface instance. This is also consistent with `extraSharedClassDeclaration` and other methods created in the interface class which do the same.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/unittests/IR/InterfaceTest.cpp", "functions": ["builder"]}]}
{"pr_number": 65476, "url": "https://github.com/llvm/llvm-project/pull/65476", "title": "[SLP]Do not early exit if the number of unique elements is non-power-of-2.", "body": "We still can try to vectorize the bundle of the instructions, even if the\nrepeated number of instruction is non-power-of-2. In this case need to\nadjust the cost (calculate the cost only for unique scalar instructions)\nand cost of the extracts. Also, when scheduling the bundle need to\nschedule only unique scalars to avoid compiler crash because of the\nmultiple dependencies. Can be safely applied only if all scalars's users\nare also vectorized and do not require memory accesses (this one is\na temporarily requirement, can be relaxed later).\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp", "functions": ["UniqueValues"]}]}
{"pr_number": 65261, "url": "https://github.com/llvm/llvm-project/pull/65261", "title": "[mlir][ArmSME] Use ArmSMETypeConverter for all VectorToLLVM patterns", "body": "LLVMTypeConverter::convertVectorType asserts on n-D scalable vectors to prevent generating illegal LLVM IR, since LLVM doesn't support arrays of scalable vectors. The ArmSMETypeConverter disables this conversion, but is only used for ArmSME dialect conversions that rewrite higher-level custom ArmSME ops to intrinsics.\r\n\r\nThis is problematic if we want to lower Vector ops directly to ArmSME intrinsics, as the assert fires for ops that have dialect conversion patterns (defined in ConvertVectorToLLVMPass, e.g. populateVectorToLLVMConversionPatterns) that use the LLVMTypeConverter.\r\n\r\nThere are three options to get around this:\r\n\r\n  1. Avoid the generic VectorToLLVM dialect conversion patterns (and thus the assert) altogether by first lowering Vector ops to custom ArmSME ops.\r\n  2. Disable the generic VectorToLLVM dialect conversion patterns if ArmSME is enabled.\r\n  3. Disable n-D scalable vector type conversion for all dialect conversion patterns if SME is enabled.\r\n\r\nOption 1 is already done for several Vector ops such as vector.load and vector.store as part of ConvertVectorToArmSME, but where possible we'd like to avoid bloating the ArmSME dialect by having to mirror all the Vector ops.\r\n\r\nOption 2 is undesirable as the generic conversions should only be disabled for the 2-d scalable vector types the ArmSME patterns apply to. We'd still like Vector ops with other types to get lowered via the default path when ArmSME is enabled.\r\n\r\nThis patch therefore implements option 3 to use the ArmSMETypeConverter for all VectorToLLVM conversion patterns when ArmSME is enabled.\r\n\r\nDepends on #65254", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Conversion/VectorToLLVM/ConvertVectorToLLVMPass.cpp", "functions": ["converter", "armSMEConverter"]}]}
{"pr_number": 65396, "url": "https://github.com/llvm/llvm-project/pull/65396", "title": "[RISCV] Move slide and gather costing to subtarget [NFC]", "body": "As discussed during review of D159332.  This PR doesn't actually common up that copy of the code because doing so is not NFC - due to DLEN.  Fixing that will be a future PR.", "feature_layers": [], "feature_directives": ["target"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVSubtarget.cpp", "functions": ["getLMULCost"]}, {"filename": "llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp", "functions": ["getLMULCost"]}, {"filename": "llvm/lib/Target/RISCV/RISCVISelLowering.cpp", "functions": ["getLMULCost"]}]}
{"pr_number": 65381, "url": "https://github.com/llvm/llvm-project/pull/65381", "title": "[Clang] Fix the for statement disappearing in AST when an error occurs in the conditional expression of the for statement", "body": "Consider:\r\n```\r\nconstexpr int f() {\r\n    int sum = 0;\r\n    for (int i = 0; undefined_var; ++i) {\r\n        sum += i;\r\n    }\r\n    return sum;\r\n}\r\n\r\nstatic_assert(f());\r\n```\r\n\r\nThe AST before this patch:\r\n```\r\n|-FunctionDecl <line:1:1, line:7:1> line:1:15 used constexpr f 'int ()' implicit-inline\r\n| `-CompoundStmt <col:19, line:7:1>\r\n|   |-DeclStmt <line:2:5, col:16>\r\n|   | `-VarDecl <col:5, col:15> col:9 used sum 'int' cinit\r\n|   |   `-IntegerLiteral <col:15> 'int' 0\r\n|   `-ReturnStmt <line:6:5, col:12>\r\n|     `-ImplicitCastExpr <col:12> 'int' <LValueToRValue>\r\n|       `-DeclRefExpr <col:12> 'int' lvalue Var 0xb870518 'sum' 'int'\r\n```\r\n\r\nThe AST after this patch:\r\n```\r\n|-FunctionDecl 0x11d0f63f8 <./main.cpp:1:1, line:7:1> line:1:15 used constexpr f 'int ()' implicit-inline\r\n| `-CompoundStmt 0x11d110880 <col:19, line:7:1>\r\n|   |-DeclStmt 0x11d0f65c8 <line:2:5, col:16>\r\n|   | `-VarDecl 0x11d0f6528 <col:5, col:15> col:9 used sum 'int' cinit\r\n|   |   `-IntegerLiteral 0x11d0f6590 <col:15> 'int' 0\r\n|   |-ForStmt 0x11d110800 <line:3:5, line:5:5>\r\n|   | |-DeclStmt 0x11d0f66a0 <line:3:10, col:19>\r\n|   | | `-VarDecl 0x11d0f6600 <col:10, col:18> col:14 used i 'int' cinit\r\n|   | |   `-IntegerLiteral 0x11d0f6668 <col:18> 'int' 0\r\n|   | |-<<<NULL>>>\r\n|   | |-RecoveryExpr 0x11d0f66e8 <col:21> 'bool' contains-errors\r\n|   | |-UnaryOperator 0x11d0f6728 <col:36, col:38> 'int' lvalue prefix '++'\r\n|   | | `-DeclRefExpr 0x11d0f6708 <col:38> 'int' lvalue Var 0x11d0f6600 'i' 'int'\r\n|   | `-CompoundStmt 0x11d0f67c8 <col:41, line:5:5>\r\n|   |   `-CompoundAssignOperator 0x11d0f6798 <line:4:9, col:16> 'int' lvalue '+=' ComputeLHSTy='int' ComputeResultTy='int'\r\n|   |     |-DeclRefExpr 0x11d0f6740 <col:9> 'int' lvalue Var 0x11d0f6528 'sum' 'int'\r\n|   |     `-ImplicitCastExpr 0x11d0f6780 <col:16> 'int' <LValueToRValue>\r\n|   |       `-DeclRefExpr 0x11d0f6760 <col:16> 'int' lvalue Var 0x11d0f6600 'i' 'int'\r\n|   `-ReturnStmt 0x11d110870 <line:6:5, col:12>\r\n|     `-ImplicitCastExpr 0x11d110858 <col:12> 'int' <LValueToRValue>\r\n|       `-DeclRefExpr 0x11d110838 <col:12> 'int' lvalue Var 0x11d0f6528 'sum' 'int'\r\n```", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/AST/ast-dump-recovery.cpp", "functions": ["RecoveryForStmtCond"]}]}
{"pr_number": 65712, "url": "https://github.com/llvm/llvm-project/pull/65712", "title": "[mlir][spirv] Fix coop matrix load", "body": "- Fix order of operands/attributes\r\n- Allow for stride to be any integer type\r\n- Use ODS for parsing/printing\r\n- Update examples and tests\r\n- Fix a typo in SPIR-V tblgen code", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/SPIRV/IR/CooperativeMatrixOps.cpp", "functions": ["failure", "success", "getMatrixLayout"]}]}
{"pr_number": 65736, "url": "https://github.com/llvm/llvm-project/pull/65736", "title": "[mlir][Interfaces] ValueBoundsOpInterface: Handle all destination style ops", "body": "This commit provides a default implementation for all ops that implement the `DestinationStyleOpInterface`. Result values of such ops are tied to operand, and those have the same type.\r\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Linalg/IR/ValueBoundsOpInterfaceImpl.cpp", "functions": ["registerOpInterface"]}]}
{"pr_number": 65709, "url": "https://github.com/llvm/llvm-project/pull/65709", "title": "[mlir][spirv] Fix coop matrix store", "body": "- Fix operand/attribute order\r\n- Use ODS for parsing/printing\r\n- Allow for stride to be any integer type", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/SPIRV/IR/CooperativeMatrixOps.cpp", "functions": ["failure", "success"]}]}
{"pr_number": 65197, "url": "https://github.com/llvm/llvm-project/pull/65197", "title": "[Attributor] Look through indirect calls", "body": "Through the new `Attributor::checkForAllCallees` we can look through indirect calls and visit all potential callees if they are known. Most AAs will do that implicitly now via `AACalleeToCallSite`, thus, most AAs are able to deal with missing callees for call site IR positions.\r\n\r\nDifferential Revision: https://reviews.llvm.org/D112290", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/IPO/Attributor.cpp", "functions": ["Pred"]}, {"filename": "llvm/lib/Transforms/IPO/AttributorAttributes.cpp", "functions": ["clampStateAndIndicateChange"]}]}
{"pr_number": 65660, "url": "https://github.com/llvm/llvm-project/pull/65660", "title": "[AMDGPU] Incorrect error message regarding SCC modifier", "body": "For the AMD GFX90A GPU, the SCC instruction modifier is allowed for certain classes of instructions. However, the current assembler generates an error message, \"scc is not supported on this GPU\", regardless of the instruciton. This fix modifies the message as well as the logic for generating the message. Related tests are moved from gfx90a_err.s to gfx90a_asm_features.s.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp", "functions": ["CStr"]}]}
{"pr_number": 65767, "url": "https://github.com/llvm/llvm-project/pull/65767", "title": "[OpenMPIRBuilder] Added `createTeams`", "body": "This patch adds a generator for the teams construct. The generated IR looks like the following:\n\n```\ncurrent_fn() {\n  ...\n  call @__kmpc_fork_teams(ptr @ident, i32 num_args, ptr @outlined_omp_teams, ...args)\n  ...\n}\noutlined_omp_teams(ptr %global_tid, ptr %bound_tid, ...args) {\n  ; teams body\n}\n```\n\nIt does this by first generating the body in the current function. Then we outline the\nbody in a temporary function. We then create the @outlined_omp_teams function and embed\nthe temporary outlined function in this function. We then emit the call to runtime\nfunction.\n", "feature_layers": ["runtime", "ir"], "feature_directives": ["for", "teams"], "files_changed": [{"filename": "llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp", "functions": ["AllocaIP", "CodeGenIP"]}, {"filename": "llvm/unittests/Frontend/OpenMPIRBuilderTest.cpp", "functions": ["OMPBuilder", "Builder", "Loc"]}, {"filename": "clang/test/Sema/attr-target-version.c", "functions": ["__attribute__", "cargs"]}, {"filename": "llvm/lib/Transforms/Vectorize/LoopVectorize.cpp", "functions": ["DebugLoc", "getDebugLocFromInstOrOperands"]}, {"filename": "libcxx/benchmarks/libcxxabi/dynamic_cast_old_stress.bench.cpp", "functions": ["CastTo"]}, {"filename": "libcxxabi/src/private_typeinfo.cpp", "functions": ["if", "dyn_cast_get_derived_info", "error_count"]}, {"filename": "libcxxabi/test/dynamic_cast_stress.pass.cpp", "functions": ["test", "main"]}, {"filename": "clang/lib/Sema/SemaConcept.cpp", "functions": ["FuncScope", "ThisScope"]}, {"filename": "clang/lib/Sema/SemaLambda.cpp", "functions": ["if", "FunctionScopeRAII"]}, {"filename": "clang/test/SemaCXX/lambda-capture-type-deduction.cpp", "functions": ["__declval", "operator", "fn1", "c", "__trans_tmp_1"]}, {"filename": "clang/test/SemaCXX/this-type-deduction-concept.cpp", "functions": ["begin", "empty", "operator"]}, {"filename": "libcxx/src/support/win32/locale_win32.cpp", "functions": ["newlocale"]}, {"filename": "flang/lib/Optimizer/Transforms/LoopVersioning.cpp", "functions": ["dump", "eraseUsage"]}, {"filename": "libc/src/time/linux/clock.cpp", "functions": ["clock_t"]}, {"filename": "clang/test/AST/ast-dump-recovery.cpp", "functions": ["RecoveryForStmtCond"]}]}
{"pr_number": 65245, "url": "https://github.com/llvm/llvm-project/pull/65245", "title": "[llvm-exegesis] Make SubprocessMemoryTest use PIDs", "body": "This patch makes SubprocessMemoryTest use process PIDs during creation of the SubprocessMemory objects within the tests so that there isn't interference between multiple instances of the test running at the same time which could potentially occur in multi-user environments.\r\n\r\nThis is a continuation the review in https://reviews.llvm.org/D154680.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "llvm/unittests/tools/llvm-exegesis/X86/SubprocessMemoryTest.cpp", "functions": ["getpid", "getSharedMemoryNumber"]}]}
{"pr_number": 65515, "url": "https://github.com/llvm/llvm-project/pull/65515", "title": "[llvm-objcopy] Add --gap-fill and --pad-to options", "body": "`--gap-fill <value>` fills the gaps between sections with a specified 8-bit value, instead of zero.\r\n`--pad-to <address>` pads the output binary up to the specified load address, using the 8-bit value from `--gap-fill` or zero.\r\n\r\nThese options are only supported for ELF inputs and binary outputs.", "feature_layers": [], "feature_directives": ["for", "sections"], "files_changed": [{"filename": "llvm/tools/llvm-objcopy/ObjcopyOptions.cpp", "functions": ["createStringError"]}]}
{"pr_number": 65813, "url": "https://github.com/llvm/llvm-project/pull/65813", "title": "[mlir] Make `StringRefParameter` roundtrippable", "body": "The current printer of `StringRefParameter` simply prints out the content of the string as is without escaping it any way. This leads to it generating invalid syntax, causing parser errors when read in again.\r\n\r\nThis PR fixes that by adding `printString` to `AsmPrinter`, allowing one to print a string that can be parsed with `parseString`, using the same escaping syntax as `StringAttr`.", "feature_layers": ["parse", "ir", "parser"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/IR/AsmPrinter.cpp", "functions": ["printString"]}]}
{"pr_number": 65799, "url": "https://github.com/llvm/llvm-project/pull/65799", "title": "[NVPTX] Make i16x2 a native type and add supported vec instructions", "body": "recommit https://github.com/llvm/llvm-project/pull/65432 with minor bug fix for bitcasts", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp", "functions": ["Isv2f16Orv2bf16Type", "Isf16Orbf16Type", "DL", "if", "Is16bitsType", "LowerVectorArith"]}, {"filename": "llvm/lib/Target/NVPTX/NVPTXUtilities.cpp", "functions": ["Isv2x16VT"]}]}
{"pr_number": 65787, "url": "https://github.com/llvm/llvm-project/pull/65787", "title": "[mlir][gpu][target] Use promises to verify TargetAttrs IR correctness.", "body": "This patch employs the updated promise mechanism to enforce Target Attribute IR constraints. Due to this patch, TargetAttributes implementations no longer have to be registered before executing translation to LLVM IR in cases where they are not needed, like when translating `gpu.binary` operations.", "feature_layers": ["ir"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "mlir/lib/Dialect/GPU/IR/GPUDialect.cpp", "functions": ["success", "emitError"]}]}
{"pr_number": 65764, "url": "https://github.com/llvm/llvm-project/pull/65764", "title": "Add `visitGEPOfAlloc` to restore the `visitGEPOfBitcast` part of the behavior of non-opaque pointers.", "body": "Closes #65763.", "feature_layers": ["ast"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/Transforms/InstCombine/InstructionCombining.cpp", "functions": ["replaceInstUsesWith", "Offset"]}]}
{"pr_number": 65780, "url": "https://github.com/llvm/llvm-project/pull/65780", "title": "[MLIR][Tensor] Add Destination style RewritePattern for DimOp.", "body": "This enables canonicalization to fold away unnecessary tensor.dim ops which in turn enables folding away of other operations, as can be seen in conv_tensors_dynamic where affine.min operations were folded away.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Tensor/IR/TensorOps.cpp", "functions": ["failure", "success"]}]}
{"pr_number": 65862, "url": "https://github.com/llvm/llvm-project/pull/65862", "title": "[Clang][OpenMP] Emit unroll directive w/o captured stmt", "body": "The front end doesn't create captured stmt for unroll directive. This leads to\r\na crash when `-fopenmp-simd` is used, as reported in #63570.\r\n\r\nFix #63570.\r\n", "feature_layers": ["ir"], "feature_directives": ["for", "simd"], "files_changed": [{"filename": "clang/test/OpenMP/bug63570.c", "functions": ["f"]}]}
{"pr_number": 65498, "url": "https://github.com/llvm/llvm-project/pull/65498", "title": "[clang-tidy] Exclude bitwise operators in bugprone-non-zero-enum-to-bool-conversion", "body": "Improved bugprone-non-zero-enum-to-bool-conversion check by eliminating false positives resulting from direct usage of bitwise operators.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "clang-tools-extra/test/clang-tidy/checkers/bugprone/non-zero-enum-to-bool-conversion.cpp", "functions": ["explicitBitUsage1", "testCustomOperator", "explicitBitUsage2"]}]}
{"pr_number": 65836, "url": "https://github.com/llvm/llvm-project/pull/65836", "title": "[OpenMPOpt] Allow indirect calls in AAKernelInfoCallSite", "body": "The Attributor has gained support for indirect calls but it is opt-in. This patch makes AAKernelInfoCallSite able to handle multiple potential callees.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/IPO/OpenMPOpt.cpp", "functions": ["requiresCalleeForCallBase", "indicatePessimisticFixpoint"]}]}
{"pr_number": 65896, "url": "https://github.com/llvm/llvm-project/pull/65896", "title": "[clang][Diagnostics] Add source range to uninitialized diagnostics", "body": "Before:\r\n\r\n```\r\narray.cpp:319:10: note: read of uninitialized object is not allowed in a constant expression\r\n  319 |    return aaa;\r\n      |           ^\r\n```\r\n\r\nAfter:\r\n\r\n```\r\narray.cpp:319:10: note: read of uninitialized object is not allowed in a constant expression\r\n  319 |    return aaa;\r\n      |           ^~~\r\n```", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/Misc/constexpr-source-ranges.cpp", "functions": ["uninit"]}]}
{"pr_number": 65466, "url": "https://github.com/llvm/llvm-project/pull/65466", "title": "[clang][AArch64] Add --print-supported-extensions support", "body": "This follows the RISC-V work done in 4b40ced4e5ba10b841516b3970e7699ba8ded572.\r\n\r\nThis uses AArch64's target parser instead. We just list the names, without the \"+\" on them, which matches RISC-V's format.\r\n\r\n```\r\n$ ./bin/clang -target aarch64-linux-gnu --print-supported-extensions\r\nclang version 18.0.0 (https://github.com/llvm/llvm-project.git 154da8aec20719c82235a6957aa6e461f5a5e030)\r\nTarget: aarch64-unknown-linux-gnu\r\nThread model: posix\r\nInstalledDir: <...>\r\nAll available -march extensions for AArch64\r\n\r\n        aes\r\n        b16b16\r\n        bf16\r\n        brbe\r\n        crc\r\n        crypto\r\n        cssc\r\n        <...>\r\n```\r\n\r\nSince our extensions don't have versions in the same way there's just one column with the name in.\r\n\r\nAny extension without a feature name (including the special \"none\") is not listed as those cannot be passed to -march, they're just for the backend. For example the MTE extension can be added with \"+memtag\" but MTE2 and MTE3 do not have feature names so they cannot be added to -march.\r\n\r\nThis does not attempt to tackle the fact that clang allows invalid combinations of AArch64 extensions, it simply lists the possible options. It's still up to the user to ask for something sensible.\r\n\r\nEqually, this has no context of what CPU is being selected. Neither does the RISC-V option, the user has to be aware of that.\r\n\r\nI've added a target parser test, and a high level clang test that checks RISC-V and AArch64 work and that Intel, that doesn't support this, shows the correct error.", "feature_layers": ["parse", "ir", "parser"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "clang/tools/driver/cc1_main.cpp", "functions": ["if", "PrintSupportedExtensions"]}]}
{"pr_number": 65602, "url": "https://github.com/llvm/llvm-project/pull/65602", "title": "[clang][dataflow][NFC] Delete unused function.", "body": "I'm not sure why we had this originally, but the function seems to have a pretty\nonerous contract anyway for a function that is externally available, so it seems\nbetter not to keep it around.\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Analysis/FlowSensitive/TypeErasedDataflowAnalysis.cpp", "functions": ["transferCFGBlock", "AC"]}]}
{"pr_number": 65450, "url": "https://github.com/llvm/llvm-project/pull/65450", "title": "[mlir][llvm] Return failure from type converter for n-D scalable vectors", "body": "This patch changes vector type conversion to return failure on n-D scalable vector types instead of asserting.\r\n\r\nThis is an alternative approach to #65261 that aims to enable lowering of Vector ops directly to ArmSME intrinsics where possible, and seems more consistent with other type conversions. It's trivial to hit the assert at the moment and it could be interpreted as n-D scalable vector types being a bug, when they're valid types in the Vector dialect.\r\n\r\nBy returning failure it will generally fail more gracefully, particularly for release builds or other builds where assertions are disabled.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Conversion/LLVMCommon/TypeConverter.cpp", "functions": ["failure"]}]}
{"pr_number": 65733, "url": "https://github.com/llvm/llvm-project/pull/65733", "title": "[mlir][vector] Extend mask calculation for vector.contract", "body": "Make sure that when calculating the expected mask for `vector.contract`,\r\nscalable sizes are correctly taken into account.\r\n\r\nDepends on: #65724", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Vector/IR/VectorOps.cpp", "functions": ["maskShapeScalableDims", "maskShapeScalabledims"]}]}
{"pr_number": 65818, "url": "https://github.com/llvm/llvm-project/pull/65818", "title": "[clang][VarDecl] Reset un-evaluated constant for all C++ modes", "body": "After commit 610ec954e1f8 (\"[clang] allow const structs/unions/arrays to\r\nbe constant expressions for C\"), attempts to evaluate\r\nstructs/unions/arrays as constants are also performed for C++98 and\r\nC++03.\r\n\r\nAn assertion was getting tripped up since the potentially-partially\r\nevaluated value was not being reset for those 2 language modes.  Make\r\nsure to reset it now for all C++ modes.\r\n\r\nFixes: #65784\r\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/SemaCXX/constant-expression.cpp", "functions": ["PR65784f"]}]}
{"pr_number": 65831, "url": "https://github.com/llvm/llvm-project/pull/65831", "title": "[mlir][spirv] Support `spirv.coopmatrix` type (de-)serialization", "body": "Extend SPIR-V target serialization and deserialization to handle coop matrix types. Add a roundtrip test. In addition to `FileCheck` checks, the resulting spirv binary also passes `spir-val` (external tool).\r\n\r\nAlso fix a type attribute bug surfaced by the `CooperativeMatrixLength` op.\r\n\r\nMultiple matrix operand attributes will be handled in a future patch to reduce the scope.", "feature_layers": ["ir"], "feature_directives": ["target"], "files_changed": [{"filename": "mlir/lib/Target/SPIRV/Deserialization/Deserializer.cpp", "functions": ["processCooperativeMatrixType", "processCooperativeMatrixTypeKHR", "success", "processCooperativeMatrixTypeNV"]}, {"filename": "mlir/lib/Target/SPIRV/Serialization/Serializer.cpp", "functions": ["failure", "success", "prepareConstantInt"]}, {"filename": "mlir/tools/mlir-tblgen/SPIRVUtilsGen.cpp", "functions": ["formatv"]}, {"filename": "mlir/lib/Dialect/SPIRV/IR/CooperativeMatrixOps.cpp", "functions": ["getCooperativeMatrixType", "success"]}]}
{"pr_number": 65598, "url": "https://github.com/llvm/llvm-project/pull/65598", "title": "[RISCV] Shrink vslidedown when lowering fixed extract_subvector", "body": "As noted in https://github.com/llvm/llvm-project/pull/65392#discussion_r1316259471, when lowering an extract of a fixed length vector from another vector, we don't need to perform the vslidedown on the full vector type. Instead we can extract the smallest subregister that contains the subvector to be extracted and perform the vslidedown with a smaller LMUL. E.g, with +Zvl128b:\r\n\r\nv2i64 = extract_subvector nxv4i64, 2\r\n\r\nis currently lowered as\r\n\r\nvsetivli zero, 2, e64, m4, ta, ma\r\nvslidedown.vi v8, v8, 2\r\n\r\nThis patch shrinks the vslidedown to LMUL=2:\r\n\r\nvsetivli zero, 2, e64, m2, ta, ma\r\nvslidedown.vi v8, v8, 2\r\n\r\nBecause we know that there's at least 128*2=256 bits in v8 at LMUL=2, and we only need the first 256 bits to extract a v2i64 at index 2.\r\n\r\nlowerEXTRACT_VECTOR_ELT already has this logic, so this extracts it out and reuses it.\r\n\r\nI've split this out into a separate PR rather than include it in #65392, with the hope that we'll be able to generalize it later.\r\n\r\nThis patch refactors extract_subvector lowering to lower to extract_subreg directly, and to shortcut whenever the index is 0 when extracting a scalable vector. This doesn't change any of the existing behaviour, but makes an upcoming patch that extends the scalable path slightly easier to read.", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVISelLowering.cpp", "functions": ["if"]}]}
{"pr_number": 65580, "url": "https://github.com/llvm/llvm-project/pull/65580", "title": "[llvm-readelf] Add --extra-sym-info", "body": "GNU readelf introduced --extra-sym-info/-X to display the section name\nfor --syms (https://sourceware.org/PR30684). Port the feature, which is\ncurrently llvm-readelf only.\n\nFor STO_AARCH64_VARIANT_PCS/STO_RISCV_VARIANT_PCS, the Ndx and Name\ncolumns may not be aligned.\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/tools/llvm-readobj/COFFDumper.cpp", "functions": ["printSymbols"]}, {"filename": "llvm/tools/llvm-readobj/ELFDumper.cpp", "functions": ["printSymbols", "printSymbolsHelper", "to_string"]}, {"filename": "llvm/tools/llvm-readobj/MachODumper.cpp", "functions": ["printSymbols"]}, {"filename": "llvm/tools/llvm-readobj/WasmDumper.cpp", "functions": ["printSymbols"]}, {"filename": "llvm/tools/llvm-readobj/XCOFFDumper.cpp", "functions": ["printSymbols"]}]}
{"pr_number": 65649, "url": "https://github.com/llvm/llvm-project/pull/65649", "title": "[InlineAsm] refactor InlineAsm class NFC", "body": "I would like to steal one of these bits to denote whether a kind may be\nspilled by the register allocator or not, but I'm afraid to touch of any\nthis code using bitwise operands.\n\nMake flags a first class type using bitfields, rather than launder data\naround via `unsigned`.\n", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/CodeGen/AsmPrinter/AsmPrinterInlineAsm.cpp", "functions": ["F"]}, {"filename": "llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp", "functions": ["UseFlag", "MatchedOperandFlag", "F"]}, {"filename": "llvm/lib/CodeGen/MachineInstr.cpp", "functions": ["F"]}, {"filename": "llvm/lib/CodeGen/MachineVerifier.cpp", "functions": ["F"]}, {"filename": "llvm/lib/CodeGen/SelectionDAG/InstrEmitter.cpp", "functions": ["F"]}, {"filename": "llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp", "functions": ["F"]}, {"filename": "llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp", "functions": ["F"]}, {"filename": "llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp", "functions": ["Flag"]}, {"filename": "llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp", "functions": ["Flags"]}, {"filename": "llvm/lib/CodeGen/TargetInstrInfo.cpp", "functions": ["F"]}, {"filename": "llvm/lib/Target/ARM/ARMAsmPrinter.cpp", "functions": ["F"]}, {"filename": "llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp", "functions": ["Flag"]}, {"filename": "llvm/lib/Target/AVR/AVRAsmPrinter.cpp", "functions": ["OpFlags"]}, {"filename": "llvm/lib/Target/AVR/AVRISelLowering.cpp", "functions": ["Flags"]}, {"filename": "llvm/lib/Target/CSKY/CSKYISelDAGToDAG.cpp", "functions": ["Flag"]}, {"filename": "llvm/lib/Target/Hexagon/HexagonISelLowering.cpp", "functions": ["Flags"]}, {"filename": "llvm/lib/Target/Lanai/LanaiAsmPrinter.cpp", "functions": ["Flags"]}, {"filename": "llvm/lib/Target/Mips/MipsAsmPrinter.cpp", "functions": ["Flags"]}, {"filename": "llvm/lib/Target/Mips/MipsSERegisterInfo.cpp", "functions": ["F"]}, {"filename": "llvm/lib/Target/PowerPC/PPCISelLowering.cpp", "functions": ["Flags"]}, {"filename": "llvm/lib/Target/Sparc/SparcISelDAGToDAG.cpp", "functions": ["Flag"]}, {"filename": "llvm/lib/Target/X86/X86FloatingPoint.cpp", "functions": ["F"]}]}
{"pr_number": 65674, "url": "https://github.com/llvm/llvm-project/pull/65674", "title": "[RISCV] Add a combine to form masked.load from unit strided load", "body": "Add a DAG combine to form a masked.load from a masked_strided_load intrinsic with stride equal to element size.  This covers a couple of extra test cases, and allows us to simplify and common some existing code on the concat_vector(load, ...) to strided load transform.\r\n\r\nThis is the first in a mini-patch series to try and generalize our strided load and gather matching to handle more cases, and common up different approaches to the same problems in different places.", "feature_layers": ["ir"], "feature_directives": ["for", "masked"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVISelLowering.cpp", "functions": ["SDValue", "convertFromScalableVector"]}]}
{"pr_number": 65521, "url": "https://github.com/llvm/llvm-project/pull/65521", "title": "[mlir][openacc] Model acc cache directive as data entry operands on acc.loop", "body": "The `cache` directive may appear at the top of (inside of) a loop. It specifies array elements or subarrays that should be fetched into the highest level of the cache for the body of the loop.\r\n\r\nThe `cache` directive is modeled as a data entry operands attached to the acc.loop operation. ", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/OpenACC/IR/OpenACC.cpp", "functions": ["success"]}]}
{"pr_number": 66002, "url": "https://github.com/llvm/llvm-project/pull/66002", "title": "[mlir][Linalg] Move `linalg.fill` -> `linalg.pack` pattern into `fill` canonicalization patterns.", "body": "This pattern fits better with the other canonicalization patterns that exist for `linalg.fill`.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Linalg/IR/LinalgOps.cpp", "functions": ["success", "clone", "guard", "failure", "dom"]}, {"filename": "mlir/lib/Dialect/Linalg/Transforms/DataLayoutPropagation.cpp", "functions": ["success", "clone", "guard", "failure", "dom"]}]}
{"pr_number": 65578, "url": "https://github.com/llvm/llvm-project/pull/65578", "title": "[mlir][bufferization] Move AllocationOpInterface implementations", "body": "The new Buffer Deallocation pass introduced in D158421 will not need the AllocationOpInterface anymore, thus it is better to move those default implementations to a place where they will still be used.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/Bufferization/Transforms/BufferDeallocation.cpp", "functions": ["buildClone", "getHoistingKind"]}, {"filename": "mlir/lib/Dialect/Bufferization/Transforms/Bufferize.cpp", "functions": ["buildClone", "getHoistingKind"]}]}
{"pr_number": 66031, "url": "https://github.com/llvm/llvm-project/pull/66031", "title": "[libc][libm][GPU] Added missing vendor entry points to `libm` for GPUs", "body": "There are a number of mathematical functions where no target-agnostic implementations exist, and the compiler built-ins are not correctly lowered on all GPU targets. This patch adds inlined wrappers for those functions to the GPU version of `libm` for AMDGPU and NVPTX targets.", "feature_layers": [], "feature_directives": ["for", "target"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVISelLowering.cpp", "functions": ["SDValue", "convertFromScalableVector"]}, {"filename": "mlir/lib/CAPI/IR/IR.cpp", "functions": ["failure"]}, {"filename": "mlir/test/lib/Dialect/GPU/TestConvertGPUKernelToCubin.cpp", "functions": ["getDescription", "getArgument", "registerTestGpuSerializeToCubinPass", "getDependentDialects"]}, {"filename": "mlir/test/lib/Dialect/GPU/TestConvertGPUKernelToHsaco.cpp", "functions": ["getDescription", "getArgument", "registerTestGpuSerializeToHsacoPass", "getDependentDialects"]}, {"filename": "mlir/tools/mlir-opt/mlir-opt.cpp", "functions": ["registerTestGpuSerializeToHsacoPass", "registerTestGpuSerializeToCubinPass"]}, {"filename": "mlir/lib/Dialect/OpenACC/IR/OpenACC.cpp", "functions": ["success"]}, {"filename": "mlir/lib/Dialect/Linalg/IR/LinalgOps.cpp", "functions": ["success", "clone", "guard", "failure", "dom"]}, {"filename": "mlir/lib/Dialect/Linalg/Transforms/DataLayoutPropagation.cpp", "functions": ["success", "clone", "guard", "failure", "dom"]}, {"filename": "llvm/lib/TargetParser/Triple.cpp", "functions": ["if"]}, {"filename": "llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp", "functions": ["MDB"]}, {"filename": "bolt/lib/Profile/DataAggregator.cpp", "functions": ["formatv"]}, {"filename": "bolt/lib/Profile/DataReader.cpp", "functions": ["formatv"]}, {"filename": "clang/lib/Sema/SemaExprCXX.cpp", "functions": ["EvaluateBinaryTypeTrait"]}, {"filename": "clang/test/SemaCXX/type-traits.cpp", "functions": ["reference_constructs_from_temporary_checks"]}]}
{"pr_number": 65577, "url": "https://github.com/llvm/llvm-project/pull/65577", "title": "[mlir][tensor] Check the EmptyOp's dynamicSize to be non-negative", "body": "This patch addresses a crash that occurs when negative dynamic sizes are provided in tensor.emptyOp by adding a check to ensure that dynamic sizes are non-negative.\r\n\r\nFixes #64064", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/Tensor/IR/TensorOps.cpp", "functions": ["emitOpError"]}]}
{"pr_number": 65319, "url": "https://github.com/llvm/llvm-project/pull/65319", "title": "[clang][dataflow] Merge `RecordValue`s with different locations correctly.", "body": "Now that prvalue expressions map directly to values (see\nhttps://reviews.llvm.org/D158977), it's no longer guaranteed that `RecordValue`s\nassociated with the same expression will always have the same storage location.\n\nIn other words, D158977 invalidated the assertion in `mergeDistinctValues()`.\nThe newly added test causes this assertion to fail without the other changes in\nthe patch.\n\nThis patch fixes the issue. However, the real fix will be to eliminate the\n`StorageLocation` from `RecordValue` entirely.\n", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "clang/unittests/Analysis/FlowSensitive/DataflowEnvironmentTest.cpp", "functions": ["Env2", "Env1"]}]}
{"pr_number": 65948, "url": "https://github.com/llvm/llvm-project/pull/65948", "title": "[RISCV] Support target attribute for function", "body": "The spec of RISC-V target feature is https://github.com/riscv-non-isa/riscv-c-api-doc/pull/35.\r\n\r\n---\r\n\r\nThis patch implements target attribute for RISC-V.", "feature_layers": [], "feature_directives": ["for", "target"], "files_changed": [{"filename": "clang/test/CodeGen/RISCV/riscv-func-attr-target.c", "functions": ["testDefault"]}]}
{"pr_number": 65732, "url": "https://github.com/llvm/llvm-project/pull/65732", "title": "[clang][dataflow] Don't crash when BlockToState is called from unreachable path", "body": "When we call `getEnvironment`, `BlockToState[BlockId]` for the block can return null even if CFCtx.isBlockReachable(B) returns true if it is called from a particular block that is marked unreachable to the block.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/unittests/Analysis/FlowSensitive/TransferTest.cpp", "functions": ["cast"]}]}
{"pr_number": 66071, "url": "https://github.com/llvm/llvm-project/pull/66071", "title": "[GlobalISel] Improve Handling of Immediates in Apply MIR Patterns", "body": "**NOTE**: This PR contains multiple commits as there is currently no way to do stacked pull requests on GitHub.\r\n**NOTE**: The first commit is reviewed in #65955 \r\n\r\nThis patch series aims to improve how immediates are materialized in the 'apply' patterns. It sidetracked a bit into also adding a `GITypeOf` type, which is needed to allow creating constants in `apply` that have the same type as the matched constant, but a different value.\r\n\r\nComponents:\r\n\r\n- :white_check_mark: Use  ``MachineIRBuilder`` in the MatchTable\r\n- :white_check_mark: Use `MachineIRBuilder::buildConstant` to create constants in apply patterns.\r\n- :white_check_mark: Add `GITypeOf<\"$x\">` special type to allow creating temp reg/immediates in apply pattern that have the same type as a matched pattern\r\n- :clock1: Add some basic type inference so `GITypeOf` is not needed in the common case", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "llvm/utils/TableGen/GlobalISelCombinerEmitter.cpp", "functions": ["ImmTy", "getType", "bool", "getLLTCodeGenFromRecord", "diagnoseAllSpecialTypes", "str", "isTypeOf", "setType", "getRawOpName", "isLLT", "check", "getLLTCodeGen", "checkSemantics", "Ty", "isSpecial", "getTypeOfOpName", "isValidType", "Name", "getLLTCodeGenOrTempType", "LLTCodeGen"]}]}
{"pr_number": 65467, "url": "https://github.com/llvm/llvm-project/pull/65467", "title": "[mlir][bufferization][NFC] Rename copy_tensor op to materialize_in_destination", "body": "The previous name was badly chosen. The op is used to ensure that a computation materializes in the future buffer of a certain tensor.\r\n\r\nDepends On #65766. Only review the top commit.\r\n", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/Bufferization/IR/BufferizationOps.cpp", "functions": ["failure", "success"]}]}
{"pr_number": 66020, "url": "https://github.com/llvm/llvm-project/pull/66020", "title": "[mlir][spirv] Improve coop matrix attribute handling", "body": "- Fix values of Matrix Operand bit enums.\r\n- Add verification for the aligned Memory Operand attributes. Mark the 'Aligned' enumerant as not supported.\r\n\r\nThe target test passes validation with `spirv-val`.", "feature_layers": ["ir"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "mlir/lib/Dialect/SPIRV/IR/CooperativeMatrixOps.cpp", "functions": ["verifyCoopMatrixAccess", "verifyPointerAndCoopMatrixType"]}]}
{"pr_number": 66096, "url": "https://github.com/llvm/llvm-project/pull/66096", "title": "[SPIRV] Get pointer size from datalayout", "body": "Get the pointer size from the datalayout via the TargetMachine and remove the helper function that hardcoded it. This fixes an issue caused by mismatched pointer sizes between the two for logical SPIR-V, since the computePointerSize function still defaulted to 32-bit ptr sizes.", "feature_layers": ["ir"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "llvm/lib/Target/SPIRV/SPIRVSubtarget.cpp", "functions": ["computePointerSize"]}]}
{"pr_number": 65594, "url": "https://github.com/llvm/llvm-project/pull/65594", "title": "[AArch64][SME]Update intrinsic interface for read/write", "body": "The new ACLE PR#225[1] now combines the slice parameters for some builtins. This patch is the #2 of 3 patches to update the interface.\r\n\r\nSlice specifies the ZA slice number directly and needs to be explicity implemented by the \"user\" with the base register plus the immediate offset\r\n\r\n[1]https://github.com/ARM-software/acle/pull/225/files", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CodeGen/aarch64-sme-intrinsics/acle_sme_read.c", "functions": ["SME_ACLE_FUNC"]}, {"filename": "clang/test/Sema/aarch64-sme-intrinsics/acle_sme_imm.cpp", "functions": ["test_range_0_1", "test_range_0_15", "test_range_0_3", "test_range_0_7", "test_range_0_0"]}, {"filename": "clang/lib/CodeGen/CGBuiltin.cpp", "functions": ["if"]}]}
{"pr_number": 65853, "url": "https://github.com/llvm/llvm-project/pull/65853", "title": "[MC][RISCV] Add assembly syntax highlighting for RISCV", "body": "This patch adds support for syntax highlighting RISC-V assembly.\r\nRelated patch:\r\nAArch64: https://reviews.llvm.org/D159162\r\nX86: https://reviews.llvm.org/D159241\r\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/MCTargetDesc/RISCVInstPrinter.cpp", "functions": ["getRegisterName"]}]}
{"pr_number": 66008, "url": "https://github.com/llvm/llvm-project/pull/66008", "title": "[AMDGPU] Port AMDGPURewriteUndefForPHI to new pass manager", "body": "This patch ports the AMDGPURewriteUndefForPHI pass to the new pass manager. With this, the pass is supported under both the legacy and the new pass managers.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/AMDGPURewriteUndefForPHI.cpp", "functions": ["AMDGPURewriteUndefForPHILegacy", "AMDGPURewriteUndefForPHI"]}]}
{"pr_number": 66137, "url": "https://github.com/llvm/llvm-project/pull/66137", "title": "[mlir][spirv] Fix remaining coop matrix verification corner cases", "body": "- Check `MakePointer*` load/store attribute values.\r\n- Support coop matrix types in `MatrixTimesScalar` verification.\r\n- Add test cases for all the remaining ops that accept coop matrix types.\r\n- Split NV and KHR tests.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/SPIRV/IR/SPIRVOps.cpp", "functions": ["success"]}]}
{"pr_number": 65697, "url": "https://github.com/llvm/llvm-project/pull/65697", "title": "[OpenMP] Remove optimization skipping reduction struct initialization", "body": "This commit removes an optimization that skips the initialization of the\nreduction struct if the number of threads in a team is 1. This optimization\ncaused a bug with Hidden Helper Threads. When the task group is initially\ninitialized by the master thread but a Hidden Helper Thread executes a target\nnowait region, it requires the reduction struct initialization to properly\naccumulate the data.\n\nThis commit also adds a LIT test for issue #57522 to ensure that the issue is\nproperly addressed and that the optimization removal does not introduce any\nregressions.\n\nFixes: #57522\n", "feature_layers": ["ir", "ast"], "feature_directives": ["task", "for", "master", "target", "requires"], "files_changed": [{"filename": "openmp/libomptarget/test/offloading/task_in_reduction_target.c", "functions": ["main"]}]}
{"pr_number": 65189, "url": "https://github.com/llvm/llvm-project/pull/65189", "title": "[clang-tidy] The first PR our of many PRs for the \"Initialized Class Members\" check.", "body": "The goal of this checker is to eliminate UUM (Use of Uninitialized Memory) bugs caused by uninitialized class members.\r\n\r\nThis checker is different from ProTypeMemberInitCheck in that this checker attempts to eliminate UUMs as a bug class, at the expense of false positives.\r\n\r\nThis checker is WIP. We are incrementally adding features and increasing coverage until we get to a shape that is acceptable.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang-tools-extra/clang-tidy/google/CppInitClassMembersCheck.cpp", "functions": ["isDefaultValueUninitialized", "shouldReportThisFieldType"]}, {"filename": "clang-tools-extra/test/clang-tidy/checkers/google/cpp-init-class-members.cpp", "functions": ["IsY", "SetY", "GetHelper"]}]}
{"pr_number": 65781, "url": "https://github.com/llvm/llvm-project/pull/65781", "title": "[libc++] Simplify the implementation of locale::id", "body": "Since we use C++20 to build the dylib, we can use a lambda to do the first-time initialization instead of emulating std::bind. This should not change the behavior of the code at all, it merely simplifies it.\r\n\r\nThis removes a symbol from the dylib, however that symbol was only ever used inside the dylib so it shouldn't break the ABI for anyone. I confirmed that by searching for that symbol on the ABI boundary of a large number of programs and couldn't find any references to that function.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "libcxx/src/locale.cpp", "functions": ["id_", "operator"]}]}
{"pr_number": 65483, "url": "https://github.com/llvm/llvm-project/pull/65483", "title": "[Clang][OpenMP] Clang adding the addrSpace according to DataLayout fix", "body": "Fix for an issue where clang was not adding the address space according to the data layout, instead was using the default which resulted in a crash at times. The fix includes changes to the cases of LargeCapMemAlloc and CGroupMemAlloc where we are setting the AddrSpace according to the DataLayout. ", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/OpenMP/test_target_uses_allocators_large_cap_codegen.cpp", "functions": ["test_uses_allocators_large_cap"]}]}
{"pr_number": 66083, "url": "https://github.com/llvm/llvm-project/pull/66083", "title": "[clang][ARM] Enable --print-supported-extensions for ARM", "body": "```\r\n$ ./bin/clang --target=arm-linux-gnueabihf --print-supported-extensions\r\n<...>\r\nAll available -march extensions for ARM\r\n\r\n        crc\r\n        crypto\r\n        sha2\r\n        aes\r\n        dotprod\r\n<...>\r\n```\r\n\r\nThis follows the format set by RISC-V and AArch64. As for AArch64, ARM doesn't have versioned extensions like RISC-V does. So there is only 1 column, which contains the name.\r\n\r\nAny extension without a \"feature\" is hidden as these cannot be used with -march.", "feature_layers": [], "feature_directives": ["for", "target"], "files_changed": [{"filename": "clang/tools/driver/cc1_main.cpp", "functions": ["if"]}]}
{"pr_number": 66195, "url": "https://github.com/llvm/llvm-project/pull/66195", "title": "[clang][dataflow] Rename test target function to `target()`.", "body": "Otherwise, the test doesn't actually do anything.\n", "feature_layers": [], "feature_directives": ["target"], "files_changed": [{"filename": "clang/unittests/Analysis/FlowSensitive/TransferTest.cpp", "functions": ["target", "cast"]}]}
{"pr_number": 66162, "url": "https://github.com/llvm/llvm-project/pull/66162", "title": "[Clang] Define AMDGPU ABI when referenced in CodeGen for ABI \"none\"", "body": "Summary:\r\nWe use the `llvm.amgcn.abi.version` varaible to control code generation.\r\nThis is emitted in every module now to indicate what should be used when\r\ncompiling. Previously, the logic caused us to emit an external reference\r\nto this variable when creating the code for the `none` type. This would\r\nthen cause us not to emit the actual definition. This patch refines the\r\nlogic to create the external reference, and then update it if it is\r\nfound unset by the time we emit the global. I had to remove the\r\nreference to `GetOrCreateLLVmGlobal` because it did not accept the\r\nproper address space.\r\n", "feature_layers": ["codegen"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CodeGen/amdgpu-abi-version.c", "functions": ["foo"]}]}
{"pr_number": 65582, "url": "https://github.com/llvm/llvm-project/pull/65582", "title": "[AArch64][SME]Update intrinsic interface for ld1/st1", "body": "The new ACLE PR#225[1] now combines the slice parameters for some builtins. This patch is the #1 of 3 patches to update the interface.\r\n\r\nSlice specifies the ZA slice number directly and needs to be explicity implemented by the \"user\" with the base register plus the immediate offset\r\n\r\n[1]https://github.com/ARM-software/acle/pull/225/files", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/Sema/aarch64-sme-intrinsics/acle_sme_imm.cpp", "functions": ["test_range_0_1", "test_range_0_15", "test_range_0_3", "test_range_0_7", "test_range_0_0"]}]}
{"pr_number": 66006, "url": "https://github.com/llvm/llvm-project/pull/66006", "title": "[sanitizer] Fail __sanitizer_symbolize_demangle instead of returning input", "body": "LLVMSymbolizer::DemangleName returns the same input if it can't demangle.\nWe can't tell if this is already demangled or format is unsupported.\n\nInternally DemangleName uses nonMicrosoftDemangle which can report a failure.\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "compiler-rt/test/sanitizer_common/TestCases/demangle_internal.cpp", "functions": ["main"]}]}
{"pr_number": 66269, "url": "https://github.com/llvm/llvm-project/pull/66269", "title": "[sparse] allow unpack op to return 0-ranked tensor type.", "body": "Many frontends canonicalize scalar into 0-ranked tensor, it change will hopefully make the operation easier to use for those cases.", "feature_layers": ["parse", "frontend"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/Transforms/SparseTensorCodegen.cpp", "functions": ["genCast"]}]}
{"pr_number": 66278, "url": "https://github.com/llvm/llvm-project/pull/66278", "title": "[mlir][spirv][gpu] Clean up wmma to coop matrix NV conversion. NFC.", "body": "This is a cleanup in preparation for adding a second conversion path using the KHR cooperative matrix extension.\r\n\r\nMake the existing lowering explicit about emitting ops from the NV coop matrix extension. Clean up surrounding code.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Conversion/GPUToSPIRV/GPUToSPIRVPass.cpp", "functions": ["convertMMAToSPIRVCoopMatrixNVType", "convertMMAToSPIRVType"]}]}
{"pr_number": 65857, "url": "https://github.com/llvm/llvm-project/pull/65857", "title": "[mlir][gpu] Deprecate gpu::Serialization* passes.", "body": "Deprecate the `gpu-to-cubin` & `gpu-to-hsaco` passes in favor of the `TargetAttr` workflow. This patch removes remaining upstream uses of the aforementioned passes, including the option to use them in `mlir-opt`. A future patch will remove these passes entirely.\r\n\r\n**NOTE:**\r\n  1. When testing on an NVIDIA A100 the test `Integration/Dialect/SparseTensor/GPU/CUDA/sparse-gemm-lib.mlir`  failed with:\r\n```\r\n'cuMemAlloc(&ptr, sizeBytes)' failed with 'CUDA_ERROR_INVALID_VALUE'\r\n```\r\n  However, the test failed even without the switch to the new workflow, if someone else could test and verify it would be appreciate it. All other tests succeeded including: `CUDA_SM80_LT_TESTS`.\r\n  2. The [SM_90 integration tests](https://github.com/llvm/llvm-project/tree/main/mlir/test/Integration/GPU/CUDA/sm90) still need to be ported into the new workflow, so this patch is dependent on that porting.", "feature_layers": ["parse", "ir"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "mlir/test/lib/Dialect/GPU/TestConvertGPUKernelToCubin.cpp", "functions": ["getDescription", "getArgument", "registerTestGpuSerializeToCubinPass", "getDependentDialects"]}, {"filename": "mlir/test/lib/Dialect/GPU/TestConvertGPUKernelToHsaco.cpp", "functions": ["getDescription", "getArgument", "registerTestGpuSerializeToHsacoPass", "getDependentDialects"]}, {"filename": "mlir/tools/mlir-opt/mlir-opt.cpp", "functions": ["registerTestGpuSerializeToHsacoPass", "registerTestGpuSerializeToCubinPass"]}]}
{"pr_number": 66229, "url": "https://github.com/llvm/llvm-project/pull/66229", "title": "[flang] Accept intrinsic functions in DATA statement variables", "body": "Pure intrinsic functions are acceptable in constant expressions so long as their arguments are constant expressions.  Allow them to appear in subscripts in DATA statement variables.\r\n\r\nFixes https://github.com/llvm/llvm-project/issues/65046.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "flang/lib/Semantics/check-data.cpp", "functions": ["RestrictPointer", "CheckSubscriptExpr"]}]}
{"pr_number": 65677, "url": "https://github.com/llvm/llvm-project/pull/65677", "title": "[clang][deps] Store common, partially-formed invocation", "body": "We create one `CompilerInvocation` for each modular dependency we discover. This means we create a lot of copies, even though most of the invocation is the same between modules. This patch makes use of the copy-on-write flavor of `CompilerInvocation` to share the common parts, reducing memory usage and speeding up the scan.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp", "functions": ["CI"]}]}
{"pr_number": 66234, "url": "https://github.com/llvm/llvm-project/pull/66234", "title": "[flang] Correct semantic representation & handling of RANK(*)", "body": "A RANK(*) case in a SELECT RANK construct selects the case of an assumed-rank dummy argument whose effective actual argument is an assumed-size array.  In this case, the attributes of the selector are those of a rank-1 assumed-size array, and the selector cannot be allocatable or a pointer.\r\n\r\nEnsure that the representation of a SELECT RANK construct's per-case AssocEntityDetails can distinguish RANK(n), RANK(*), and RANK DEFAULT, and clean up various code sites and tests where the distinctions matter.", "feature_layers": ["sema"], "feature_directives": [], "files_changed": [{"filename": "flang/lib/Evaluate/tools.cpp", "functions": ["ResolveAssociations"]}]}
{"pr_number": 66235, "url": "https://github.com/llvm/llvm-project/pull/66235", "title": "[flang] Don't blow up when combining mixed COMPLEX operations", "body": "Expression processing applies some straightforward rewriting of mixed complex/real and complex/integer operations to avoid having to promote the real/integer operand to complex and then perform a complex operation; for example, (a,b)+x becomes (a+x,b) rather than (a,b)+(x,0).  But this can blow up the expression representation when the complex operand cannot be duplicated cheaply.  So apply this technique only to complex operands that are appropriate to duplicate.\r\n\r\nFixes https://github.com/llvm/llvm-project/issues/65142.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Evaluate/tools.cpp", "functions": ["constexpr", "Get", "NoExpr", "Package", "AsCategoryExpr", "GetComplexPart"]}]}
{"pr_number": 66325, "url": "https://github.com/llvm/llvm-project/pull/66325", "title": "[flang][openacc] Use OpenACC terminator instead of fir.unreachable after Stop stmt", "body": "This follow an update made on OpenMP https://reviews.llvm.org/D129969 and was not possible on OpenACC until the unstructured construct was supported.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "flang/lib/Lower/Runtime.cpp", "functions": ["if"]}]}
{"pr_number": 66243, "url": "https://github.com/llvm/llvm-project/pull/66243", "title": "[clang][AST] Bail out when handling union access with virtual inheritance", "body": "An assertion issue that arose when handling union member access with virtual base class has been addressed. As pointed out by @zygoloid, there is no need for further derived-to-base analysis in this instance, so we can bail out upon encountering a virtual base class.\r\n\r\nAs per doc-comment in `HandleUnionActiveMemberChange`, it turns out we might not be handling a union, so minor refinement on the function name as well. No problem in undoing this, if any though.  \r\n\r\nFixes: https://github.com/llvm/llvm-project/issues/65982.", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/SemaCXX/cxx2a-virtual-base-used.cpp", "functions": ["member_with_virtual_inheritance"]}]}
{"pr_number": 65621, "url": "https://github.com/llvm/llvm-project/pull/65621", "title": "[mlir][ArmSME] Lower vector.outerproduct to FMOPA/BFMOPA", "body": "This patch adds support for lowering vector.outerproduct to the ArmSME\r\nMOPA intrinsic for the following types:\r\n\r\n  vector<[8]xf16>,  vector<[8]xf16>  -> vector<[8]x[8]xf16>\r\n  vector<[8]xbf16>, vector<[8]xbf16> -> vector<[8]x[8]xbf16>\r\n  vector<[4]xf32>,  vector<[4]xf32>  -> vector<[4]x[4]xf32>\r\n  vector<[2]xf64>,  vector<[2]xf64>  -> vector<[2]x[2]xf64>\r\n\r\nThe FP variants are lowered to FMOPA (non-widening) [1] and BFloat to BFMOPA\r\n(non-widening) [2].\r\n\r\nNote at the ISA level these variants are implemented by different\r\narchitecture features, these are listed below:\r\n\r\n  FMOPA (non-widening)\r\n    * half-precision   - +sme2p1,+sme-f16f16\r\n    * single-precision - +sme\r\n    * double-precision - +sme-f64f64\r\n  BFMOPA (non-widening)\r\n    * half-precision   - +sme2p1,+b16b16\r\n\r\nThere's currently no way to target different features when lowering to\r\nArmSME. Integration tests are added for F32 and F64. We use QEMU to run\r\nthe integration tests but SME2 support isn't available yet, it's\r\ntargeted for 9.0, so integration tests for these variants excluded.\r\n\r\nMasking is currently unsupported.\r\n\r\nDepends on #65450.\r\n\r\n[1] https://developer.arm.com/documentation/ddi0602/2023-06/SME-Instructions/FMOPA--non-widening---Floating-point-outer-product-and-accumulate-\r\n[2] https://developer.arm.com/documentation/ddi0602/2023-06/SME-Instructions/BFMOPA--non-widening---BFloat16-floating-point-outer-product-and-accumulate-", "feature_layers": ["ir"], "feature_directives": ["for", "single", "target"], "files_changed": [{"filename": "mlir/lib/Conversion/LLVMCommon/TypeConverter.cpp", "functions": ["failure"]}, {"filename": "mlir/lib/Dialect/ArmSME/Transforms/LegalizeForLLVMExport.cpp", "functions": ["failure", "success"]}, {"filename": "mlir/lib/Dialect/Vector/Transforms/LowerVectorContract.cpp", "functions": ["failure"]}]}
{"pr_number": 65766, "url": "https://github.com/llvm/llvm-project/pull/65766", "title": "[mlir][bufferization] Empty tensor elimination based on SubsetOpInterface", "body": "This commit generalizes empty tensor elimination to operate on subset ops. No new test cases are added because all current subset ops were already supported previously. From this perspective, this change is NFC.\r\n\r\nA new interface method (and a helper method) are added to `SubsetInsertionOpInterface` to build the subset of the destination tensor.\r\n\r\n", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/Bufferization/Transforms/EmptyTensorElimination.cpp", "functions": ["failure", "success"]}]}
{"pr_number": 66179, "url": "https://github.com/llvm/llvm-project/pull/66179", "title": "[mlir] Allow loop-like operations in `AbstractDenseForwardDataFlowAnalysis`", "body": "Remove assertion violated by loop-like operations.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/test/lib/Analysis/DataFlow/TestDenseForwardDataFlowAnalysis.cpp", "functions": ["visitOperation"]}]}
{"pr_number": 66174, "url": "https://github.com/llvm/llvm-project/pull/66174", "title": "[AArch64] Add LRINT/LLRINT/LROUND/LLROUND FP16 lowering without fullfp16", "body": "We apparently somehow had lowering for the STRICT nodes without any handling for the normal operations. This makes sure we support the LRINT and LROUND intrinsics for fp16 when +fullfp16 is not present.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AArch64/AArch64ISelLowering.cpp", "functions": ["DL"]}]}
{"pr_number": 66074, "url": "https://github.com/llvm/llvm-project/pull/66074", "title": "[analyzer] First batch of patches for the Juliet benchmark for taint improvements", "body": "See the motivation here: https://discourse.llvm.org/t/patches-inspired-by-the-juliet-benchmark/73106\r\n\r\nI've checked all these 3 commits on a large set of projects, and they - surprisingly - don't show any report differences besides noise. (EDIT: I'll recheck the measurement, to be sure.)\r\nI plan to land these 3 commits individually (aka. I don't plan to squash them).", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/Analysis/taint-generic.cpp", "functions": ["fscanf", "testReadingFromStdin"]}, {"filename": "clang/test/Analysis/taint-generic.c", "functions": ["typeof", "test_wchar_apis_propagate", "swprintf", "wcslen", "clang_analyzer_isTainted_wchar"]}]}
{"pr_number": 66112, "url": "https://github.com/llvm/llvm-project/pull/66112", "title": "[AArch64][Clang] Implement ACLE rintn intrinsics", "body": "This patch adds support for two missing ACLE intrinsics for floating point round with ties to even:\r\n\r\n- rintn\r\n- rintnf\r\n\r\nThese are specified in ACLE section 8.6: [https://arm-software.github.io/acle/main/acle.html#floating-point-data-processing-intrinsics]\r\n\r\nChange-Id: I951971ad5a3fd3822efdf8cbae22918c31eef28a", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CodeGen/arm_acle.c", "functions": ["__rintnf", "test_rintnf", "test_rintn", "__rintn"]}]}
{"pr_number": 66337, "url": "https://github.com/llvm/llvm-project/pull/66337", "title": "[mlir][bufferization] Add an ownership based buffer deallocation pass", "body": "Add a new Buffer Deallocation pass with the intend to replace the old one. For now it is added as a separate pass alongside in order to allow downstream users to migrate over gradually. This new pass has the goal of inserting fewer clone operations and supporting additional use-cases. Please refer to the Buffer Deallocation section in the updated Bufferization.md file for more information on how this new pass works.\r\n\r\nAlready reviewed in https://reviews.llvm.org/D158421", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Bufferization/Transforms/OwnershipBasedBufferDeallocation.cpp", "functions": ["begin", "success", "verifyOperationPreconditions", "getCombined", "regionOperatesOnMemrefValues", "backedges", "failure", "size", "joinOwnership", "isMemref", "handleAllInterfaces", "newTypes", "deallocate", "emitError", "liveness", "getMemrefWithGuaranteedOwnership", "end", "getUninitialized", "isUnique", "combine", "isUnknown", "clearOwnershipOf", "enter", "buildBoolValue", "runOnOperation", "exit", "retainedByLiveness", "getIndicator", "recurse", "getUnknown", "getUnique", "newOperands", "ownershipTypesToAppend", "deallocation", "isUninitialized", "handleInterface", "handleOp", "appendOpResults", "builder", "populateRemainingOwnerships", "isFunctionWithoutDynamicOwnership", "updateFunctionSignature", "ownershipResults", "verifyFunctionPreconditions"]}]}
{"pr_number": 65595, "url": "https://github.com/llvm/llvm-project/pull/65595", "title": "[OpenMP][OMPT] Fix device identifier collision during callbacks", "body": "Fixes: https://github.com/llvm/llvm-project/issues/65104\r\nWhen a user assigns devices to target regions it may happen that different identifiers will map onto the same id within different plugins. This will lead to situations where callbacks will become much harder to read, as ambiguous identifiers are reported.\r\n\r\nWe fix this by collecting the index-offset upon general RTL initialization. Which in turn, allows to calculate the unique, user-observable device id.", "feature_layers": [], "feature_directives": ["target"], "files_changed": [{"filename": "openmp/libomptarget/plugins-nextgen/common/PluginInterface/PluginInterface.cpp", "functions": ["__tgt_rtl_set_device_offset"]}]}
{"pr_number": 65692, "url": "https://github.com/llvm/llvm-project/pull/65692", "title": "[MS] Follow up fix to pass aligned args to variadic x86_32 functions", "body": "MSVC allows users to pass structures with required alignments greater than 4 to variadic functions. It does not pass them indirectly to correctly align them. Instead, it passes them directly with the usual 4 byte stack alignment.\r\n\r\nThis change implements the same logic in clang on the passing side.  The receiving side (va_arg) never implemented any of this indirect logic, so it doesn't need to be updated.\r\n\r\nThis issue pre-existed, but @aaron.ballman noticed it when we started passing structs containing aligned fields indirectly in D152752.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "clang/lib/CodeGen/Targets/X86.cpp", "functions": ["IsPreassigned"]}, {"filename": "clang/test/CodeGen/X86/x86_32-arguments-win32.c", "functions": ["receive_fixed_align_variadic", "receive_aligned_variadic", "pass_fixed_align_variadic", "__declspec", "pass_aligned_variadic"]}]}
{"pr_number": 66349, "url": "https://github.com/llvm/llvm-project/pull/66349", "title": "[mlir][bufferization][NFC] Introduce BufferDeallocationOpInterface", "body": "This new interface allows operations to implement custom handling of ownership\r\nvalues and insertion of dealloc operations which is useful when an op cannot\r\nimplement the interfaces supported by default by the buffer deallocation pass\r\n(e.g., because they are not exactly compatible or because there are some\r\nadditional semantics to it that would render the default implementations in\r\nbuffer deallocation invalid, or because no interfaces exist for this kind of\r\nbehavior and it's not worth introducing one plus a default implementation in\r\nbuffer deallocation). Additionally, it can also be used to provide more\r\nefficient handling for a specific op than the interface based default\r\nimplementations can.\r\n\r\nAlready reviewed in https://reviews.llvm.org/D158756\r\n\r\nDepends on #66337", "feature_layers": ["sema", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Bufferization/IR/BufferDeallocationOpInterface.cpp", "functions": ["buildBoolValue", "success", "retainedByLiveness", "getUnknown", "indicator", "isMemref", "emitError"]}, {"filename": "mlir/lib/Dialect/Bufferization/Transforms/OwnershipBasedBufferDeallocation.cpp", "functions": ["liveness", "success", "getCombined", "getUninitialized", "isUnique", "retainedByLiveness", "combine", "isUninitialized", "getIndicator", "getUnknown", "handleInterface", "joinOwnership", "isUnknown", "getUnique", "clearOwnershipOf", "builder", "state", "failure"]}, {"filename": "mlir/lib/Dialect/ControlFlow/Transforms/BufferDeallocationOpInterfaceImpl.cpp", "functions": ["builder", "failure", "isMemref"]}]}
{"pr_number": 66350, "url": "https://github.com/llvm/llvm-project/pull/66350", "title": "[mlir][bufferization] BufferDeallocationOpInterface: support custom ownership update logic", "body": "Add a method to the BufferDeallocationOpInterface that allows operations to\r\nimplement the interface and provide custom logic to compute the ownership\r\nindicators of values it defines. As a demonstrating example, this new method is\r\nimplemented by the `arith.select` operation.\r\n\r\nAlready reviewed in https://reviews.llvm.org/D158828\r\n\r\nDepends on #66349", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/Bufferization/Transforms/OwnershipBasedBufferDeallocation.cpp", "functions": ["getMemrefWithGuaranteedOwnership"]}]}
{"pr_number": 65999, "url": "https://github.com/llvm/llvm-project/pull/65999", "title": "[flang] Fix the incorrect insertion point for alloca", "body": "While creating a temporary alloca for a box in OpenMp region, the insertion point should be the OpenMP region block instead of the function entry block.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Optimizer/CodeGen/CodeGen.cpp", "functions": ["getBlockForAllocaInsert"]}]}
{"pr_number": 66357, "url": "https://github.com/llvm/llvm-project/pull/66357", "title": "[mlir][transform] Fix crash when op is erased during transform.foreach", "body": "Fixes a crash when an op, that is mapped to handle that a `transform.foreach` iterates over, was erased (through the `TrackingRewriter`). Erasing an op removes it from all mappings and invalidates iterators. This is already taken care of when an op is iterating over payload ops in its `apply` method, but not when another transform op is erasing a tracked payload op.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Transform/IR/TransformOps.cpp", "functions": ["doesReadPayload", "doesModifyPayload"]}]}
{"pr_number": 65432, "url": "https://github.com/llvm/llvm-project/pull/65432", "title": "[NVPTX] Make i16x2 a native type and add supported vec instructions", "body": "On sm_90 some instructions now support i16x2 which allows hardware to execute more efficiently add, min and max instructions.\r\n\r\nIn order to support that we need to make i16x2 a native type in the backend. This does the necessary changes to make i16x2 a native type and adds support for the instructions natively supporting i16x2.\r\n\r\nThis caused a negative test in nvptx slp to start passing. Changed the test to a positive one as the IR is correctly vectorized.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp", "functions": ["if"]}, {"filename": "llvm/lib/Target/NVPTX/NVPTXUtilities.cpp", "functions": ["Isv2x16VT"]}]}
{"pr_number": 66351, "url": "https://github.com/llvm/llvm-project/pull/66351", "title": "[mlir][bufferization] Implement BufferDeallocationopInterface for scf.forall.in_parallel", "body": "The scf.forall.in_parallel terminator operation has a nested graph region with\r\nthe NoTerminator trait. Such regions are not supported by the default\r\nimplementations. Therefore, this commit adds a specialized implementation for\r\nthis operation which only covers the case where the nested region is empty.\r\nThis is because after bufferization, ops like tensor.parallel_insert_slice were\r\nalready converted to memref operations residing int the scf.forall only and the\r\nnested region of scf.forall.in_parallel ends up empty.\r\n\r\nAlready reviewed in https://reviews.llvm.org/D158979\r\n\r\nDepends on #66350", "feature_layers": ["ir"], "feature_directives": ["parallel", "for"], "files_changed": [{"filename": "mlir/lib/Dialect/SCF/Transforms/BufferDeallocationOpInterfaceImpl.cpp", "functions": ["builder", "failure"]}]}
{"pr_number": 66153, "url": "https://github.com/llvm/llvm-project/pull/66153", "title": "[libc++] Reintroduce the removed std::char_traits specialization", "body": "This partially reverts commit e30a148b098, which removed the base template for std::char_traits. That base template had been marked as deprecated since LLVM 16 and we were planning to remove it in LLVM 18. However, as explained in the post-commit comments in https://reviews.llvm.org/D157058, the deprecation mechanism didn't work as expected. Basically, the deprecation warnings were never shown to users since libc++ headers are system headers and Clang doesn't show warnings in system headers.\r\n\r\nAs a result, this removal came with basically no lead time as far as users are concerned, which is a poor experience. For this reason, I am re-introducing the deprecated char_traits specialization until we have a proper way of phasing it out in a way that is not a surprise for users.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "libcxx/test/libcxx/strings/char.traits/char.traits.specializations/arbitrary_char_type.deprecated.verify.cpp", "functions": ["f"]}, {"filename": "libcxx/test/libcxx/strings/char.traits/char.traits.specializations/arbitrary_char_type.pass.cpp", "functions": ["test", "main"]}]}
{"pr_number": 66304, "url": "https://github.com/llvm/llvm-project/pull/66304", "title": "[mlir][sparse] deprecate the convert{To,From}MLIRSparseTensor methods", "body": "Rationale:\r\nThese libraries provided COO input and output at external boundaries which, since then, has been generalized to the much more powerful pack and unpack operations of the sparse tensor dialect.", "feature_layers": ["parse", "ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/ExecutionEngine/SparseTensorRuntime.cpp", "functions": ["identityPerm", "lvlCoords", "d2l"]}]}
{"pr_number": 66275, "url": "https://github.com/llvm/llvm-project/pull/66275", "title": "[Transforms][DXIL] Wire up a basic DXILUpgrade pass", "body": "This pass will upgrade DXIL-style llvm constructs (which are mostly metadata) into the representations we use in LLVM for the same concepts.\r\n\r\nFor now we just strip the valver metadata, which we don't need. Later changes will make this pass more useful, and then we should be able to wire it into clang and possibly the DirectX backend's AsmParser.", "feature_layers": ["parse", "ir", "parser"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Utils/DXILUpgrade.cpp", "functions": ["handleValVerMetadata"]}]}
{"pr_number": 66280, "url": "https://github.com/llvm/llvm-project/pull/66280", "title": "Avoid BlockFrequency overflow problems", "body": "Multiplying raw block frequency with an integer carries a high risk of overflow.\r\n\r\n- Introduce a new `BlockFrequency::mul` function returning a `bool` indicating overflow.\r\n- Mark function with `__attribute__((warn_unused_result))` to avoid users accidentally ignoring the indicator.\r\n- Fix two instances where overflow were leading to wrong results for me.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Support/BlockFrequency.cpp", "functions": ["BlockFrequency"]}]}
{"pr_number": 66011, "url": "https://github.com/llvm/llvm-project/pull/66011", "title": "[AArch64] Relax binary format switch in AArch64MCInstLower::LowerSymbolOperand to allow non-Darwin Mach-O files", "body": "Trying to use a arm64-apple-none-macho target triple today crashes with an assertion, this patch fixes that.", "feature_layers": [], "feature_directives": ["for", "target"], "files_changed": [{"filename": "llvm/lib/Target/AArch64/AArch64MCInstLower.cpp", "functions": ["lowerSymbolOperandMachO", "lowerSymbolOperandDarwin"]}]}
{"pr_number": 66364, "url": "https://github.com/llvm/llvm-project/pull/66364", "title": "[clang][dataflow] Ignore assignment where base class's operator is used", "body": "In C++ it seems it is legit to use base class's operator (e.g. `using Base::operator=`) to perform copy if the base class is the common ancestor of the source and destination object. In such a case we shouldn't try to access fields beyond that of the base class, however such a case seems to be very rare (typical code would implement a copy constructor instead), and could add complexities, so in this patch we simply bail if the method operator's parent class is different from the type of the destination object that this framework recognizes.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/unittests/Analysis/FlowSensitive/TransferTest.cpp", "functions": ["target"]}]}
{"pr_number": 66286, "url": "https://github.com/llvm/llvm-project/pull/66286", "title": "[lldb] Accept optional module in Value::ResolveValue", "body": "Value::ResolveValue calls Value::GetValueAsData as part of its implementation. The latter can receive an optional Module pointer, which is always null when called from the former. Allow threading in the Module in Value::ResolveValue.\r\n\r\nrdar://115021869", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "lldb/source/Core/Value.cpp", "functions": ["error"]}]}
{"pr_number": 66147, "url": "https://github.com/llvm/llvm-project/pull/66147", "title": "[scudo] Add -Wconversion for tests and clean-up warnings.", "body": "Fix all the places where the tests are doing implicit conversions.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "compiler-rt/lib/scudo/standalone/tests/wrappers_c_test.cpp", "functions": ["MallInfoTest"]}]}
{"pr_number": 66399, "url": "https://github.com/llvm/llvm-project/pull/66399", "title": "[mlir][spirv] Support coop matrix in `spirv.CompositeConstruct`", "body": "Also improve the documentation (code and website).", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/SPIRV/IR/SPIRVOps.cpp", "functions": ["emitOpError", "success"]}]}
{"pr_number": 66429, "url": "https://github.com/llvm/llvm-project/pull/66429", "title": "[mlir][arith] Introduce `minnumf` and `maxnumf` operations", "body": "This patch is part of a larger initiative aimed at fixing floating-point `max` and `min` operations in MLIR: https://discourse.llvm.org/t/rfc-fix-floating-point-max-and-min-operations-in-mlir/72671.\n\nHere we introduce new operations for floating-point numbers: `minnum` and `maxnum`.\nThese operations have different semantics than `minumumf` and `maximumf` ops.\nThey follow the eponymous LLVM intrinsics semantics, which differs\nin the handling positive and negative zeros and NaNs.\n\nThis patch addresses the 1.3 task from the RFC.\n", "feature_layers": ["sema", "ir"], "feature_directives": ["task", "for"], "files_changed": [{"filename": "mlir/lib/Dialect/Arith/IR/ArithOps.cpp", "functions": ["getRhs", "getLhs"]}]}
{"pr_number": 66437, "url": "https://github.com/llvm/llvm-project/pull/66437", "title": "[mlir][memref] Use dedicated ops in `AtomicRMWOpConverter`", "body": "This patch refactors the `AtomicRMWOpConverter` class to use\nthe dedicated operations from Arith dialect instead of using\n`cmpf` + `select` pattern.\nAlso, a test for `minimumf` kind of `atomic_rmw` has been added.\n", "feature_layers": ["ir"], "feature_directives": ["for", "atomic"], "files_changed": [{"filename": "mlir/lib/Dialect/MemRef/Transforms/ExpandOps.cpp", "functions": ["failure"]}]}
{"pr_number": 66312, "url": "https://github.com/llvm/llvm-project/pull/66312", "title": "[lldb] Support Unicode in the prompt", "body": "Account for Unicode when computing the prompt column width. Previously, the string length (i.e. number of bytes) rather than the width of the Glyph was used to compute the cursor position. The result was that the cursor would be offset to the right when using a prompt containing Unicode.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "lldb/source/Host/common/Editline.cpp", "functions": ["ColumnWidth", "if"]}]}
{"pr_number": 66219, "url": "https://github.com/llvm/llvm-project/pull/66219", "title": "[JITlink][AArch32] Implement ELF::R_ARM_MOVT_ABS and R_ARM_MOVW_ABS_NC", "body": "Add support for static Arm relocations of R_ARM_MOVT_ABS and R_ARM_MOVW_ABS_NC\r\nwhich are emitted by movt and movw instructions. The implementation\r\ncontains relocation fixup and its testing as well as its encode/decode\r\nfunctions for reading and writing immediate values together with its\r\nunittests.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/ExecutionEngine/JITLink/aarch32.cpp", "functions": ["makeUnexpectedOpcodeError", "decodeRegMovtA1MovwA2", "encodeImmMovtA1MovwA2", "encodeRegMovtA1MovwA2", "decodeImmMovtA1MovwA2"]}, {"filename": "llvm/unittests/ExecutionEngine/JITLink/AArch32Tests.cpp", "functions": ["decodeRegMovtA1MovwA2", "encodeImmMovtA1MovwA2", "UnaffectedBits", "encodeRegMovtA1MovwA2", "decodeImmMovtA1MovwA2"]}]}
{"pr_number": 66056, "url": "https://github.com/llvm/llvm-project/pull/66056", "title": "[Driver] Also respect SysRoot for the system library paths on DragonFly", "body": "", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Driver/ToolChains/DragonFly.cpp", "functions": ["Dir"]}]}
{"pr_number": 66311, "url": "https://github.com/llvm/llvm-project/pull/66311", "title": "[mlir][spirv][gpu] Add conversion for load/store/mad coop matrix ops", "body": "This is plugged in as an alternative lowering path in the gpu to spirv dialect conversion. Add custom op builders for coop matrix ops to make the create functions nicer to work with and less error-prone. The latter is accomplished by following the op syntax and also requiring stride to be a constant op to avoid confusion around the order of arguments.\r\n\r\nThe remaining lowering patterns will be added in a future patch.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Conversion/GPUToSPIRV/GPUToSPIRVPass.cpp", "functions": ["convertMMAToSPIRVCoopMatrixType", "convertMMAToSPIRVCoopMatrixNVType"]}, {"filename": "mlir/lib/Conversion/GPUToSPIRV/WmmaOpsToSPIRV.cpp", "functions": ["success"]}]}
{"pr_number": 66108, "url": "https://github.com/llvm/llvm-project/pull/66108", "title": "[TextAPI] Consolidate TextAPI Reader/Writer APIs.", "body": "Both Swift & LLD use TextAPI reader/writer apis to interface with TBD files. Add doc strings to document what each API does. Also, add shortcut APIs for validating input is a TBD file.\r\n\r\nThis reduces the differences between downstream and how tapi calls into these APIs.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Object/TapiFile.cpp", "functions": ["SymbolicFile"]}, {"filename": "llvm/lib/TextAPI/TextStub.cpp", "functions": ["serializeInterfaceFileToJSON", "canReadFileType"]}, {"filename": "llvm/lib/TextAPI/TextStubV5.cpp", "functions": ["getJSON"]}]}
{"pr_number": 66352, "url": "https://github.com/llvm/llvm-project/pull/66352", "title": "[mlir][bufferization] Define a pipeline for buffer deallocation", "body": "Since buffer deallocation requires a few passes to be run in a somewhat fixed\r\nsequence, it makes sense to have a pipeline for convenience (and to reduce the\r\nnumber of transform ops to represent default deallocation).\r\n\r\nAlready reviewed in https://reviews.llvm.org/D159432\r\n\r\nDepends on #66351", "feature_layers": ["ir"], "feature_directives": ["for", "requires"], "files_changed": [{"filename": "mlir/lib/Dialect/Bufferization/Transforms/OwnershipBasedBufferDeallocation.cpp", "functions": ["OwnershipBasedBufferDeallocationPass"]}]}
{"pr_number": 65630, "url": "https://github.com/llvm/llvm-project/pull/65630", "title": "[AArch64][GlobalISel] Select llvm.aarch64.neon.ld* intrinsics", "body": "Similar to llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp.\n", "feature_layers": [], "feature_directives": ["target"], "files_changed": [{"filename": "llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp", "functions": ["if", "emitScalarToVector", "DstOp"]}, {"filename": "llvm/lib/Target/AArch64/GISel/AArch64RegisterBankInfo.cpp", "functions": ["if"]}]}
{"pr_number": 66376, "url": "https://github.com/llvm/llvm-project/pull/66376", "title": "[IRSymtab] Replace linear time lookup with DenseSet", "body": "There is an inefficiency in the IRSymtab Builder where it does a lookup of PreservedSymbols when calling addSymbol. This lookup is linear in time, so it tends to be quite slow. Replacing it with DenseSet gives a 0.1% speedup:\r\nhttps://llvm-compile-time-tracker.com/compare.php?from=02d27eac0f3f470a93635fc98ae990bf2a9809ed&to=62b09786fff4d53aa0c75b64aea48de241e4a856&stat=instructions:u\r\n\r\nThis change is quite similar to https://reviews.llvm.org/D157951.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/Object/IRSymtab.cpp", "functions": ["buildPreservedSymbolsSet"]}]}
{"pr_number": 66359, "url": "https://github.com/llvm/llvm-project/pull/66359", "title": "[clang][dataflow] Add a test for context-sensitive analysis on a self-referential class.", "body": "The test demonstrates that the `this` pointer seen in the constructor has the\nsame value as the address of the variable the object is constructed into.\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/unittests/Analysis/FlowSensitive/TransferTest.cpp", "functions": ["target"]}]}
{"pr_number": 65983, "url": "https://github.com/llvm/llvm-project/pull/65983", "title": "ValueTracking: Identify implied fp classes by general fcmp", "body": "Previously we could recognize exact class tests performed by an fcmp with special values (0s, infs and smallest normal). Expand this to recognize the implied classes by a compare with a general constant. e.g. fcmp ogt x, 1 implies positive and non-0.\r\n\r\nThe API should be better merged with fcmpToClassTest but that made the diff way bigger, will try to do that in a future patch.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Analysis/ValueTracking.cpp", "functions": ["fcmpImpliesClass", "exactClass"]}]}
{"pr_number": 65326, "url": "https://github.com/llvm/llvm-project/pull/65326", "title": "[MemoryBuiltins] Cache the result of ObjectOffsetSizeVisitor::visit. #64796", "body": "visit will skip visiting instructions it already has visited\nto avoid issues with cycles in the data graph. However,\nthe result of this skipping behavior is that if we\nencounter the same instruction twice, and that instruction\nhas a well defined result and isn't part of a cycle, we\nwill introduce unknowns into the analysis even though we\nknew the size and offset of the instruction's result.\n\nInstead of skipping such instructions, keep a cache of\nthe result of visiting them. This result is initialized\nto unknown() before visiting, so if we happen to visit\nit again recursively (perhaps as the result of a cycle\nor a phi), we will get unknown as the cached result and\nexit out.\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Analysis/MemoryBuiltins.cpp", "functions": ["unknown", "visit"]}]}
{"pr_number": 66055, "url": "https://github.com/llvm/llvm-project/pull/66055", "title": "[clang-tidy]add new check `bugprone-compare-pointer-to-member-virtual-function`", "body": "This detection mechanism aims to identify instances where equality comparisons involve pointers to member virtual functions and any entity other than a null-pointer constant. It is essential to highlight this concern within your code as it addresses potential pitfalls and risks associated with such comparisons.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "clang-tools-extra/clang-tidy/bugprone/ComparePointerToMemberVirtualFunctionCheck.cpp", "functions": ["binaryOperator"]}, {"filename": "clang-tools-extra/test/clang-tidy/checkers/bugprone/compare-pointer-to-member-virtual-function.cpp", "functions": ["inheritClass"]}]}
{"pr_number": 66498, "url": "https://github.com/llvm/llvm-project/pull/66498", "title": "[analyzer] Simplify SVal for simple NonLoc->Loc casts", "body": "NonLoc symbolic SVal to Loc casts are not supported except for nonloc::ConcreteInt.\r\n\r\nThis change simplifies the source SVals so that the more casts can go through nonloc::ConcreteInt->loc::ConcreteInt path. For example:\r\n```c\r\n  void test_simplified_before_cast_add(long long t1) {\r\n    long long t2 = t1 + 3;\r\n    if (!t2) {\r\n      int *p = (int *) t2;\r\n      clang_analyzer_eval(p == 0); // expected-warning{{TRUE}}\r\n    }\r\n  }\r\n```\r\nIf simplified, 't2' is 0, resulting 'p' is nullptr, otherwise 'p' is unknown.\r\n\r\nFixes #62232", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/Analysis/symbol-simplification-nonloc-loc.cpp", "functions": ["test_simplified_before_cast_mul", "test_simplified_before_cast_add", "clang_analyzer_eval", "test_simplified_before_cast_sub"]}]}
{"pr_number": 66295, "url": "https://github.com/llvm/llvm-project/pull/66295", "title": "[NFC][CodeGen] Change CodeGenOpt::Level/CodeGenFileType into enum classes", "body": "This will make it easy for callers to see issues with and fix up calls\r\nto createTargetMachine after a future change to the params of\r\nTargetMachine.\r\n\r\nThis matches other nearby enums.\r\n\r\nFor downstream users, this should be a fairly straightforward replacement,\r\ne.g. s/CodeGenOpt::Aggressive/CodeGenOptLevel::Aggressive\r\nor s/CGFT_/CodeGenFileType::\r\n", "feature_layers": ["codegen", "ir"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "llvm/lib/CodeGen/GlobalISel/InstructionSelect.cpp", "functions": ["MachineFunctionPass"]}, {"filename": "llvm/lib/CodeGen/TargetPassConfig.cpp", "functions": ["getOptLevel", "if"]}, {"filename": "llvm/lib/LTO/LTOCodeGenerator.cpp", "functions": ["Extension"]}, {"filename": "llvm/lib/Target/ARM/ARMAsmPrinter.cpp", "functions": ["if"]}, {"filename": "clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp", "functions": ["getOptLevel", "CreateAndRunJITFunc", "OptLLVM"]}, {"filename": "llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp", "functions": ["ScheduleDAGSDNodes"]}, {"filename": "llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp", "functions": ["TM"]}, {"filename": "llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp", "functions": ["IS"]}, {"filename": "llvm/lib/Target/AMDGPU/R600ISelDAGToDAG.cpp", "functions": ["R600DAGToDAGISel"]}, {"filename": "llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp", "functions": ["ARMDAGToDAGISel"]}, {"filename": "llvm/lib/Target/CSKY/CSKYISelDAGToDAG.cpp", "functions": ["CSKYDAGToDAGISel"]}, {"filename": "llvm/lib/Target/MSP430/MSP430ISelDAGToDAG.cpp", "functions": ["MSP430DAGToDAGISel"]}, {"filename": "llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp", "functions": ["PPCDAGToDAGISel"]}, {"filename": "llvm/lib/Target/X86/X86ISelDAGToDAG.cpp", "functions": ["X86DAGToDAGISel"]}, {"filename": "llvm/lib/Target/XCore/XCoreISelDAGToDAG.cpp", "functions": ["SelectionDAGISel", "XCoreDAGToDAGISel"]}, {"filename": "llvm/tools/lli/lli.cpp", "functions": ["getOptLevel"]}, {"filename": "llvm/tools/opt/opt.cpp", "functions": ["GetCodeGenOptLevel"]}]}
{"pr_number": 66509, "url": "https://github.com/llvm/llvm-project/pull/66509", "title": "[clang] Setup whitespace detection and clang-format as Github actions", "body": "Instead of using the BuildKite jobs, use GitHub actions to detect clang-format violations and trailing whitespace in PRs.\r\n\r\nFixes #66468", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/AST/ExprClassification.cpp", "functions": ["not_well_formatted_code"]}]}
{"pr_number": 65491, "url": "https://github.com/llvm/llvm-project/pull/65491", "title": "[AArch64][GlobalISel] Select llvm.aarch64.neon.st* intrinsics", "body": "Similar to llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp\n", "feature_layers": [], "feature_directives": ["target"], "files_changed": [{"filename": "llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp", "functions": ["if", "createDTuple", "emitScalarToVector"]}]}
{"pr_number": 66425, "url": "https://github.com/llvm/llvm-project/pull/66425", "title": "[DX] Support pipeline state masks", "body": "The DXContainer pipeline state information encodes a bunch of mask vectors that are used to track things about the inputs and outputs from each shader.\r\n\r\nThis adds support for reading and writing them throught he YAML test interfaces. The writing logic in MC is extremely primitive and we'll want to revisit the API for that, but since I'm not sure how we'll want to generate the mask bits from DXIL during code generation I didn't want to spend too much time on the API.\r\n\r\nFixes #59479", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Object/DXContainer.cpp", "functions": ["maskDwordSize"]}]}
{"pr_number": 66266, "url": "https://github.com/llvm/llvm-project/pull/66266", "title": "IRBuilder: avoid crash when seeking to start of a BasicBlock with only DebugInfo", "body": "This fixes a crash in `rustc` that was triggered by\r\nhttps://reviews.llvm.org/D159485 (aka\r\nllvm/llvm-project@1ce1732f82aec29ec27d6de58153d516bca1d633).\r\n\r\nThis was more or less pair-programmed with @krasimirgg - I can't claim\r\nfull credit.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/IR/Instruction.cpp", "functions": ["getNextNonDebugInstruction"]}, {"filename": "llvm/unittests/IR/DebugInfoTest.cpp", "functions": ["BB", "Builder"]}]}
{"pr_number": 66042, "url": "https://github.com/llvm/llvm-project/pull/66042", "title": "[ELF] Align the end of PT_GNU_RELRO associated PT_LOAD to a common-page-size boundary", "body": "Close #57618: currently we align the end of PT_GNU_RELRO to a common-page-size\nboundary, but do not align the end of the associated PT_LOAD. This is benign\nwhen runtime_page_size >= common-page-size.\n\nHowever, when runtime_page_size < common-page-size, it is possible that\n`alignUp(end(PT_LOAD), page_size) < alignDown(end(PT_GNU_RELRO), page_size)`.\nIn this case, rtld's mprotect call for PT_GNU_RELRO will apply to unmapped\nregions and lead to an error, e.g.\n\n```\nerror while loading shared libraries: cannot apply additional memory protection after relocation: Cannot allocate memory\n```\n\nTo fix the issue, add a padding section .relro_padding like mold, which\nis contained in the PT_GNU_RELRO segment and the associated PT_LOAD\nsegment. The section also prevents strip from corrupting PT_LOAD program\nheaders.\n\n.relro_padding has the largest `sortRank` among RELRO sections.\nTherefore, it is naturally placed at the end of `PT_GNU_RELRO` segment\nin the absence of `PHDRS`/`SECTIONS` commands.\n\nIn the presence of `SECTIONS` commands, we place .relro_padding\nimmediately before a symbol assignment using DATA_SEGMENT_RELRO_END (see\nalso https://reviews.llvm.org/D124656), if present.\nDATA_SEGMENT_RELRO_END is changed to align to max-page-size instead of common-page-size.\n\nSome edge cases worth mentioning:\n\n* ppc64-toc-addis-nop.s: when PHDRS is present, do not append .relro_padding\n* avoid-empty-program-headers.s: when the only RELRO section is .tbss,\n  it is not part of PT_LOAD segment, therefore we do not append .relro_padding.\n\n---\n\nClose #65002: GNU ld from 2.39 onwards aligns the end of PT_GNU_RELRO to a\nmax-page-size boundary (https://sourceware.org/PR28824) so that the last page is\nprotected even if runtime_page_size > common-page-size.\n\nIn my opinion, losing protection for the last page when the runtime page size is\nlarger than common-page-size is not really an issue. Double mapping a page of up\nto max-common-page for the protection could cause undesired VM waste. Internally\nwe had users complaining about 2MiB max-page-size applying to shared objects.\n\nTherefore, the end of .relro_padding is padded to a common-page-size\nboundary. Users who are really anxious can set common-page-size to match\ntheir runtime page size.\n\n---\n\n17 tests need updating as there are lots of change detectors.", "feature_layers": ["runtime", "ir", "ast"], "feature_directives": ["for", "sections", "allocate"], "files_changed": [{"filename": "lld/ELF/SyntheticSections.cpp", "functions": ["SyntheticSection"]}, {"filename": "lld/ELF/Writer.cpp", "functions": ["getSectionRank"]}]}
{"pr_number": 66532, "url": "https://github.com/llvm/llvm-project/pull/66532", "title": "Object: account for short output names", "body": "The import library thunk name suffix uses the stem of the file. We currently would attempt to trim the suffix by dropping the trailing 4 characters (under the assumption that the output name was `.lib`). This now uses the `llvm::sys::path` API for computing the stem. This avoids an assertion failure when the name is less the 4 characters and assertions are enabled.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Object/COFFImportFile.cpp", "functions": ["Machine"]}]}
{"pr_number": 66534, "url": "https://github.com/llvm/llvm-project/pull/66534", "title": "[lldb-vscode] Show value addresses in a short format", "body": "The variables pane on VSCode is very narrow by default, and lldb-vscode has been using the default formatter for addresses, which uses 18 characters for each address. That's a bit too much because it prints too many leading zeroes.\r\nAs a way to improve readability of variables, I'm adding some logic to format addresses manually using as few chars as possible. I don't want to mess with the default LLDB formatter because, if the user uses the debug console, they should see addresses formatted in the regular way.\r\n\r\nI also added some logic to print <null> when a null pointer appears, and <invalid address> when applicable, which is a bit more readable.\r\n\r\nFor example, this is how a default variables pane looks like:\r\n<img width=\"228\" alt=\"Screenshot 2023-09-15 at 1 09 18 PM\" src=\"https://github.com/llvm/llvm-project/assets/1613874/2d317760-e4b0-4665-a6b3-15424696852b\">\r\n\r\n\r\nAnd this is how it looks with the improvement:\r\n<img width=\"232\" alt=\"Screenshot 2023-09-15 at 1 08 49 PM\" src=\"https://github.com/llvm/llvm-project/assets/1613874/4e6a36e8-5c55-4302-82a3-735b5d6d0b0f\">\r\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "lldb/source/API/SBType.cpp", "functions": ["IsPointerType"]}, {"filename": "lldb/tools/lldb-vscode/JSONUtils.cpp", "functions": ["os"]}]}
{"pr_number": 66441, "url": "https://github.com/llvm/llvm-project/pull/66441", "title": "[Coverage] Add coverage for constructor member initializers.", "body": "Before, constructor member initializers are shown as not covered. This adds coverage info for them.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CoverageMapping/ctor.cpp", "functions": ["main", "b", "A"]}]}
{"pr_number": 66550, "url": "https://github.com/llvm/llvm-project/pull/66550", "title": "[HWASan] Delete the print-memory-usage-android.c test", "body": "This test asserts that HWASan memory usage can be gathered from\n/proc/$PID/maps. This worked because the old Android-specific versions\nof the anonymous mmap patches functioned by providing a userland cstring\npointer to the kernel, and the underlying cstring was collected from\nthat pointer address dynamically when /proc/$PID/maps was being\ndecorated. This had some obvious flaws, you had to keep the string\naround for the lifetime of the program.\n\nNow, the official kernel implementation of this is to copy the string\ninto a kernel struct at prctl()-time. Thus, the name that you give at\nprctl()-time sticks around and can't be changed by userspace outside of\nanother prctl call. This breaks the feature, but this is fine, it's not\nlike anyone's really relying on it anyway. So, let's make sure we don't\ncontinue failing the test on new versions of Android where the kernel\nhas the upstream version of the named-anonymous-mappings work.\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "compiler-rt/test/hwasan/TestCases/print-memory-usage-android.c", "functions": ["main"]}]}
{"pr_number": 66530, "url": "https://github.com/llvm/llvm-project/pull/66530", "title": "[NFC][sanitizer_symbolizer]Add StackTracePrinter class", "body": "Introduce a new virtual class StackTracePrinter and an implementation\r\nFormattedStackTracePrinter in preparation of enabling symbolizer markup\r\nfor linux. \r\nThis change allows us to implement other behaviour under the same api\r\nfor StackTracePrinter, for example, MarkupStackTracePrinter.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "compiler-rt/lib/sanitizer_common/sanitizer_stacktrace_printer.cpp", "functions": ["l"]}, {"filename": "compiler-rt/lib/sanitizer_common/sanitizer_symbolizer_markup.cpp", "functions": ["RenderNeedsSymbolization"]}]}
{"pr_number": 66104, "url": "https://github.com/llvm/llvm-project/pull/66104", "title": "[MLIR][Presburger] Implement PresburgerRelation::convertVarKind and a\u2026", "body": "\u2026dd unit test for IntegerRelation::convertVarKind", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/unittests/Analysis/Presburger/IntegerRelationTest.cpp", "functions": ["parseRelationFromSet"]}, {"filename": "mlir/unittests/Analysis/Presburger/PresburgerRelationTest.cpp", "functions": ["expectedRel", "rel", "result"]}]}
{"pr_number": 65423, "url": "https://github.com/llvm/llvm-project/pull/65423", "title": "[AArch64]: Refactor target parser to use Bitset.", "body": "Use Bitset instead of BitMasking for the Architecture Extensions, because the number of extensions will exceed the bitmask max size.\r\n", "feature_layers": ["parse", "parser"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "llvm/unittests/TargetParser/AArch64TargetParserTest.cpp", "functions": ["testAArch64Extension", "operator", "CPUName", "FormatExtensionFlags", "SerializeExtensionFlags", "ExtVal"]}, {"filename": "llvm/unittests/TargetParser/ArmTargetParserTest.cpp", "functions": ["testAArch64Extension", "operator", "CPUName", "FormatExtensionFlags", "SerializeExtensionFlags", "ExtVal"]}, {"filename": "llvm/unittests/TargetParser/TargetParserTest.cpp", "functions": ["FormatExtensionFlags", "constexpr", "SerializeExtensionFlags"]}]}
{"pr_number": 66512, "url": "https://github.com/llvm/llvm-project/pull/66512", "title": "[mlir][SCF] scf.for: Consistent API around `initArgs`", "body": "* Always use the auto-generated `getInitArgs` function. Remove the hand-written `getInitOperands` duplicate.\r\n* Remove `hasIterOperands` and `getNumIterOperands`. The names were inconsistent because the \"arg\" is called `initArgs` in TableGen. Use `getInitArgs().size()` instead.\r\n* Fix verification around ops with no results.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/SCF/IR/SCF.cpp", "functions": ["success"]}, {"filename": "mlir/lib/Dialect/SCF/Transforms/LoopCanonicalization.cpp", "functions": ["Value", "isShapePreserving"]}]}
{"pr_number": 66368, "url": "https://github.com/llvm/llvm-project/pull/66368", "title": "[clang][dataflow] Model the fields that are accessed via inline accessors", "body": "So that the values that are accessed via such accessors can be analyzed as a limited version of context-sensitive analysis. We can potentially do this only when some option is set, but doing additional modeling like this won't be expensive and intrusive, so we do it by default for now.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/unittests/Analysis/FlowSensitive/TransferTest.cpp", "functions": ["getWithInc", "getIntNotAccessed", "getIntNotCalled", "getInt", "getWithOtherWork"]}]}
{"pr_number": 66491, "url": "https://github.com/llvm/llvm-project/pull/66491", "title": "add a unit test for the segfault in rust after https://reviews.llvm.org/D159485", "body": "(this is just for demonstration, let's keep the discussion on https://github.com/llvm/llvm-project/pull/66266)\r\n\r\n```sh\r\nninja unittests/IR/IRTests ; ./unittests/IR/IRTests --gtest_filter='*GetSetInsertionPointWithEmptyBasicBlock*'\r\n```\r\n\r\n```\r\n[ RUN      ] IRBuilder.GetSetInsertionPointWithEmptyBasicBlock\r\n; ModuleID = 'module'\r\nsource_filename = \"module\"\r\n\r\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\r\ndeclare void @llvm.dbg.declare(metadata %0, metadata %1, metadata %2) #0\r\n\r\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\r\n\r\nstart:                                            ; No predecessors!\r\n  call addrspace(0) void @llvm.dbg.declare(metadata <0x56430425ec90>, metadata <0x56430425ec90>, metadata <0x56430425ec90>)\r\n\r\nerror: getStableDebugLoc:getNextNonDebugInstruction is NULL\r\n```", "feature_layers": ["ir"], "feature_directives": ["for", "declare"], "files_changed": [{"filename": "llvm/lib/IR/Instruction.cpp", "functions": ["getNextNonDebugInstruction"]}, {"filename": "llvm/unittests/IR/DebugInfoTest.cpp", "functions": ["BB", "Builder"]}]}
{"pr_number": 65339, "url": "https://github.com/llvm/llvm-project/pull/65339", "title": "[Flang][Parser] Refactor parse tree enumerations into common header", "body": "This patch moves all `ENUM_CLASS` definitions from `flang/Parser/parse-tree.h` to `flang/Common/Fortran.h` so they can be used without including the much larger header defining all parse tree nodes. This is to address a suggestion to patch [D157983](https://reviews.llvm.org/D157983).\r\n\r\nThese enumerations have been renamed, since they are now placed in a more top-level namespace rather than inside of parse tree node classes, so I would be looking for reviewers to also make sure that these names make sense and to propose any changes to improve them.", "feature_layers": ["parse", "parser"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Parser/unparse.cpp", "functions": ["Unparse"]}]}
{"pr_number": 66571, "url": "https://github.com/llvm/llvm-project/pull/66571", "title": "[SDag] Fold saddo[_carry] with bitwise-not argument to ssubo[_carry]", "body": "Fold `(saddo (not a), 1)` to `(ssubo 0, a)` and\r\n`(saddo_carry (not a), b, c)` to `(ssubo_carry b, a, !c)`.\r\n\r\nProof: https://alive2.llvm.org/ce/z/Lj49YM\r\n\r\nThis is the same as https://reviews.llvm.org/D46505 and\r\nhttps://reviews.llvm.org/D59208, but for signed opcodes.\r\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp", "functions": ["SDValue"]}]}
{"pr_number": 66586, "url": "https://github.com/llvm/llvm-project/pull/66586", "title": "[clang] Enable --print-supported-extensions for all targets", "body": "This uses MCSubtargetInfo instead, to cover all the architectures. This now also list descriptions along with the names.\r\n\r\nThe advantage fetching from MCSubtargetInfo is that we rely on tablegen architecture descriptions for all architectures.\r\n\r\n---\r\n\r\n* Output from `hexagon`:\r\n```\r\n$ ./bin/clang -target hexagon-linux-gnu --print-supported-extensions\r\nclang version 18.0.0 (https://github.com/cbalint13/llvm-project 8049db0990d1695a40de57f136af20ce5340b4a6)\r\nTarget: hexagon-unknown-linux-gnu\r\nThread model: posix\r\nInstalledDir: /home/cbalint/work/GITHUB/llvm-project/build/./bin\r\nAll available -march extensions for hexagon\r\n\r\n  audio                                    Hexagon Audio extension instructions\r\n  cabac                                    Emit the CABAC instruction\r\n  compound                                 Use compound instructions\r\n  duplex                                   Enable generation of duplex instruction\r\n  hvx                                      Hexagon HVX instructions\r\n  hvx-ieee-fp                              Hexagon HVX IEEE floating point instructions\r\n  hvx-length128b                           Hexagon HVX 128B instructions\r\n  hvx-length64b                            Hexagon HVX 64B instructions\r\n  hvx-qfloat                               Hexagon HVX QFloating point instructions\r\n  hvxv60                                   Hexagon HVX instructions\r\n  hvxv62                                   Hexagon HVX instructions\r\n  hvxv65                                   Hexagon HVX instructions\r\n{...}\r\n```\r\n\r\n* Output from `x86_64`:\r\n```\r\n$ ./bin/clang -target x86_64-linux-gnu --print-supported-extensions\r\nclang version 18.0.0 (https://github.com/cbalint13/llvm-project 8049db0990d1695a40de57f136af20ce5340b4a6)\r\nTarget: x86_64-unknown-linux-gnu\r\nThread model: posix\r\nInstalledDir: /home/cbalint/work/GITHUB/llvm-project/build/./bin\r\nAll available -march extensions for x86-64\r\n\r\n  16bit-mode                               16-bit mode (i8086)\r\n  32bit-mode                               32-bit mode (80386)\r\n  3dnow                                    Enable 3DNow! instructions\r\n  3dnowa                                   Enable 3DNow! Athlon instructions\r\n  64bit                                    Support 64-bit instructions\r\n  64bit-mode                               64-bit mode (x86_64)\r\n  adx                                      Support ADX instructions\r\n  aes                                      Enable AES instructions\r\n  allow-light-256-bit                      (Enable generation of 256-bit load/stores even ....\r\n  amx-bf16                                 Support AMX-BF16 instructions\r\n  amx-complex                              Support AMX-COMPLEX instructions\r\n  amx-fp16                                 Support AMX amx-fp16 instructions\r\n  amx-int8                                 Support AMX-INT8 instructions\r\n  amx-tile                                 Support AMX-TILE instructions\r\n  avx                                      Enable AVX instructions\r\n  avx2                                     Enable AVX2 instructions\r\n  avx512bf16                               Support bfloat16 floating point\r\n  avx512bitalg                             Enable AVX-512 Bit Algorithms\r\n  avx512bw                                 Enable AVX-512 Byte and Word Instructions\r\n  avx512cd                                 Enable AVX-512 Conflict Detection Instructions\r\n{...}\r\n```\r\n\r\n---\r\n\r\nCc @DavidSpickett ,  @DanielKristofKiss , @MaskRay \r\n\r\nI also reference here #66582 for past comments on extracting information from MCSubtargetInfo .\r\n", "feature_layers": ["ir", "ast"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "clang/tools/driver/cc1_main.cpp", "functions": ["if"]}]}
{"pr_number": 66076, "url": "https://github.com/llvm/llvm-project/pull/66076", "title": "[flang] Lower PRIVATE component names safely", "body": "It is possible for a derived type extending a type with private components to define components with the same name as the private components.\r\n\r\nThis was not properly handled by lowering where several fir.record type component names could end-up being the same, leading to bad generated code (only the first component was accessed via fir.field_index, leading to bad generated code).\r\n\r\nThis patch handles the situation by adding the derived type mangled name to private component.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Lower/Mangler.cpp", "functions": ["mangleName"]}]}
{"pr_number": 66387, "url": "https://github.com/llvm/llvm-project/pull/66387", "title": "[mlir][Vector] Add a rewrite pattern for better low-precision bitcast\u2026", "body": "\u2026(trunci) expansion\r\n\r\nThis revision adds a rewrite for sequences of vector `bitcast(trunci)` to use a more efficient sequence of vector operations comprising `shuffle` and `bitwise` ops.\r\n\r\nSuch patterns appear naturally when writing quantization / dequantization functionality with the vector dialect.\r\n\r\nThe rewrite performs a simple enumeration of each of the bits in the result vector and determines its provenance in the pre-trunci vector. The enumeration is used to generate the proper sequence of `shuffle`, `andi`, `ori` followed by an optional final `trunci`/`extui`.\r\n\r\nThe rewrite currently only applies to 1-D non-scalable vectors and bails out if the final vector element type is not a multiple of 8. This is a failsafe heuristic determined empirically: if the resulting type is not an even number of bytes, further complexities arise that are not improved by this pattern: the heavy lifting still needs to be done by LLVM.", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Vector/Transforms/VectorEmulateNarrowType.cpp", "functions": ["computeLeftShiftAmount", "success", "getMaxNumberOfEntries", "sourceVectorType", "be"]}]}
{"pr_number": 65774, "url": "https://github.com/llvm/llvm-project/pull/65774", "title": "[mlir][Vector] Add a rewrite pattern for better low-precision ext(bit\u2026", "body": "\u2026cast) expansion\r\n    \r\nThis revision adds a rewrite for sequences of vector `ext(maybe_broadcast(bitcast))`\r\nto use a more efficient sequence of vector operations comprising `shuffle`, `shift` and\r\n`bitwise` ops.\r\n    \r\nThe rewrite uses an intermediate bitwidth equal to the licm of\r\nthe element types of the source and result types of `bitCastOp`. This\r\nintermediate type may be small or greater than the desired elemental type of\r\nthe `ext`, in which case appropriate `ext` or `trunc` operations are inserted.\r\n    \r\nThe rewrite fails if the intermediate type is greater than `64` and if the\r\ninvolved vector types fail to meet basic divisilibity requirements. In other\r\nwords, this rewrite does not handle partial vector boundaries and leaves\r\nthis part of the heavy-lifting to LLVM.\r\n    \r\nIn the future, it may be relevant to give control on the size of the intermediate type.\r\nFor now, it is empirically determined that taking `64` result in much better assembly\r\nbeing produced when piping through `llvm-mca`.\r\n", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Vector/Transforms/VectorEmulateNarrowType.cpp", "functions": ["success", "bcr", "enumerator", "failure", "be"]}]}
{"pr_number": 65468, "url": "https://github.com/llvm/llvm-project/pull/65468", "title": "[mlir][bufferization] Empty tensor elimination for materialize_in_destination", "body": "This revision adds support for empty tensor elimination to \"bufferization.materialize_in_destination\" by implementing the `SubsetOpInterface`.\r\n\r\nFurthermore, the One-Shot Bufferize conflict detection is improved for \"bufferization.materialize_in_destination\".\r\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Bufferization/IR/BufferizationOps.cpp", "functions": ["getOperation", "equivalenceFn", "getDest"]}]}
{"pr_number": 66619, "url": "https://github.com/llvm/llvm-project/pull/66619", "title": "[mlir][bufferization] Remove allow-return-allocs and create-deallocs pass options, remove bufferization.escape attribute", "body": "This commit removes the deallocation capabilities of one-shot-bufferization. One-shot-bufferization should never deallocate any memrefs as this should be entirely handled by the ownership-based-buffer-deallocation pass going forward. This means the `allow-return-allocs` pass option will default to true now, `create-deallocs` defaults to false and they, as well as the escape attribute indicating whether a memref escapes the current region, will be removed. A new `allow-return-allocs-from-loops` option is added as a temporary workaround for some bufferization limitations.\r\n\r\nAlready reviewed in https://reviews.llvm.org/D156662\r\n\r\nDepends on #66517\r\nThus, only review the top commit", "feature_layers": ["ir"], "feature_directives": ["for", "allocate"], "files_changed": [{"filename": "mlir/lib/Dialect/Bufferization/IR/BufferizableOpInterface.cpp", "functions": ["analysisState"]}, {"filename": "mlir/lib/Dialect/Bufferization/IR/BufferizationDialect.cpp", "functions": ["success"]}, {"filename": "mlir/lib/Dialect/Bufferization/IR/BufferizationOps.cpp", "functions": ["failure", "success"]}, {"filename": "mlir/lib/Dialect/Bufferization/Transforms/FuncBufferizableOpInterfaceImpl.cpp", "functions": ["success"]}, {"filename": "mlir/lib/Dialect/Bufferization/Transforms/OneShotAnalysis.cpp", "functions": ["domInfo"]}, {"filename": "mlir/lib/Dialect/ControlFlow/Transforms/BufferizableOpInterfaceImpl.cpp", "functions": ["success"]}, {"filename": "mlir/lib/Dialect/SCF/Transforms/BufferizableOpInterfaceImpl.cpp", "functions": ["success"]}]}
{"pr_number": 66199, "url": "https://github.com/llvm/llvm-project/pull/66199", "title": "[VP] Add missing functional_intrinsic properties and add static_assert. NFC", "body": "Some VP intrinsic definitions were missing the VP_PROPERTY_FUNCTIONAL_INTRINSIC property. This patch fills them in, and adds a static_assert that all VP intrinsics have an equivalent opcode or intrinsic defined so we don't forget them in future.\r\n\r\nSome VP intrinsics don't have an equivalent, namely merge and strided load/store. For those, a new property was added to mark that they don't have a non-VP equivalent.\r\n\r\nThis adds a helper method to get the ID of the functionally equivalent intrinsic, similar to the existing getFunctionalOpcodeForVP and getConstrainedIntrinsicIDForVP method.\r\n\r\nStacked upon #66190 ", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/IR/IntrinsicInst.cpp", "functions": ["VPHasNoFunctionalEquivalent", "allVPFunctionalDefined", "doesVPHaveNoFunctionalEquivalent"]}]}
{"pr_number": 66238, "url": "https://github.com/llvm/llvm-project/pull/66238", "title": "[flang] Accept pointer-valued function results as ASSOCIATED() arguments", "body": "The POINTER= and TARGET= arguments to the intrinsic function ASSOCIATED() can be the results of references to functions that return object pointers or procedure pointers.  NULL() was working well but not program-defined pointer-valued functions.  Correct the validation of ASSOCIATED() and extend the infrastructure used to detect and characterize procedures and pointers.", "feature_layers": ["ast"], "feature_directives": ["target"], "files_changed": [{"filename": "flang/lib/Evaluate/characteristics.cpp", "functions": ["Characterize"]}, {"filename": "flang/lib/Evaluate/tools.cpp", "functions": ["IsAllocatableOrPointerObject", "IsPointer", "IsObjectPointer", "IsProcedurePointer", "MayBePassedAsAbsentOptional", "UnwrapProcedureRef"]}, {"filename": "flang/lib/Lower/CustomIntrinsicCall.cpp", "functions": ["isMinOrMaxWithDynamicallyOptionalArg"]}]}
{"pr_number": 66279, "url": "https://github.com/llvm/llvm-project/pull/66279", "title": "[RISCV] Optimize gather/scatter to unit-stride memop + shuffle", "body": "If we have a gather or a scatter whose index describes a permutation of the lanes, we can lower this as a shuffle + a unit strided memory operation.  For RISCV, this replaces a indexed load/store with a unit strided memory operation and a vrgather (at worst).\r\n\r\nI did not both to implement the vp.scatter and vp.gather variants of these transforms because they'd only be legal when EVL was VLMAX.  Given that, they should have been transformed to the non-vp variants anyways.  I haven't checked to see if they actually are.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVISelLowering.cpp", "functions": ["ActiveLanes"]}]}
{"pr_number": 66220, "url": "https://github.com/llvm/llvm-project/pull/66220", "title": "[mlir][gpu][NVPTX] Enable NVIDIA GPU JIT compilation path", "body": "This patch adds an NVPTX compilation path that enables JIT compilation on NVIDIA targets. The following modifications were performed:\r\n1. Adding a format field to the GPU object attribute, allowing the translation attribute to use the correct runtime function to load the module. Likewise, a dictionary attribute was added to add any possible extra options.\r\n\r\n2. Adding the `createObject` method to `GPUTargetAttrInterface`; this method returns a GPU object from a binary string.\r\n\r\n3. Adding the function `mgpuModuleLoadJIT`, which is only available for NVIDIA GPUs, as there is no equivalent for AMD.\r\n\r\n4. Adding the CMake flag `MLIR_GPU_COMPILATION_TEST_FORMAT` to specify the format to use during testing.\r\n\r\nNOTE:\r\n1. Not all tests are using `MLIR_GPU_COMPILATION_TEST_FORMAT`.\r\n2.  An option needs to be added to the `SparseCompiler` to support the format option, however I didn't know if there's any preference.\r\n3. I'm basing the implementation of `mgpuModuleLoadJIT` on the assumption there's a [JIT cache](https://developer.nvidia.com/blog/cuda-pro-tip-understand-fat-binaries-jit-caching/). Another option is to implement the cache itself in MLIR.", "feature_layers": ["parse", "runtime", "ir"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "mlir/lib/Dialect/GPU/IR/GPUDialect.cpp", "functions": ["stringifyEnum", "success"]}, {"filename": "mlir/lib/Dialect/GPU/Transforms/ModuleToBinary.cpp", "functions": ["failure"]}, {"filename": "mlir/lib/Target/LLVM/NVVM/Target.cpp", "functions": ["builder", "bin"]}, {"filename": "mlir/lib/Target/LLVM/ROCDL/Target.cpp", "functions": ["builder"]}, {"filename": "mlir/lib/Target/LLVMIR/Dialect/GPU/SelectObjectAttr.cpp", "functions": ["getSelectedObject", "createKernelLaunch", "getModuleLoadJITFn", "failure"]}, {"filename": "mlir/unittests/Target/LLVM/SerializeNVVMTarget.cpp", "functions": ["options"]}, {"filename": "mlir/unittests/Target/LLVM/SerializeROCDLTarget.cpp", "functions": ["options"]}]}
{"pr_number": 66601, "url": "https://github.com/llvm/llvm-project/pull/66601", "title": "[SelectionDAG][RISCV][PowerPC][X86] Use TargetConstant for immediates for ISD::PREFETCH.", "body": "The intrinsic uses ImmArg so TargetConstant would be consistent\nwith how other intrinsics are handled.\n\nThis hides the constants from type legalization so we can remove\nthe promotion support.\n\nisel patterns are updated accordingly.\n", "feature_layers": [], "feature_directives": ["for", "target"], "files_changed": [{"filename": "llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp", "functions": ["SDValue"]}]}
{"pr_number": 66241, "url": "https://github.com/llvm/llvm-project/pull/66241", "title": "[flang] Fix SIZEOF() expression rewriting", "body": "The rewriting of the extension intrinsic function SIZEOF was producing results that would reference symbols that were not available in the current scope, leading to crashes in lowering. The symbols could be function result variables, for SIZEOF(func()), or bare derived type component names, for SIZEOF(array(n)%component). Fixing this without regressing on a current test case involved careful threading of some state through the TypeAndShape characterization code and the shape/bounds analyzer, and some clean-up was done along the way.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Evaluate/shape.cpp", "functions": ["ComputeUpperBound", "IsActuallyConstant", "GetAssociatedExtent"]}]}
{"pr_number": 66563, "url": "https://github.com/llvm/llvm-project/pull/66563", "title": "[mlir][sparse] refine sparse fusion with empty tensors materialization", "body": "This is a minor step towards deprecating bufferization.alloc_tensor(). It replaces the examples with tensor.empty() and adjusts the underlying rewriting logic to prepare for this upcoming change.", "feature_layers": ["parse", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/Transforms/SparseTensorRewriting.cpp", "functions": ["isMaterializing", "isAlloc"]}]}
{"pr_number": 66244, "url": "https://github.com/llvm/llvm-project/pull/66244", "title": "[flang][runtime] Enforce proper termination of list-directed input va\u2026", "body": "\u2026lues\r\n\r\nEmit an error at runtime when a list-directed input value is not followed by a value separator or end of record.  Previously, the runtime I/O library was consuming as many input characters that were valid for the type of the value, and leaving any remaining characters for the next input edit, if any.", "feature_layers": ["runtime", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/runtime/edit-input.cpp", "functions": ["IsCharValueSeparator", "CheckCompleteListDirectedField"]}]}
{"pr_number": 66648, "url": "https://github.com/llvm/llvm-project/pull/66648", "title": "[mlir][Vector] Add a rewrite pattern for better low-precision ext(bit\u2026", "body": "\u2026cast) expansion\r\n\r\nThis revision adds a rewrite for sequences of vector `ext(bitcast)` to use a more efficient sequence of vector operations comprising `shuffle` and `bitwise` ops.\r\n\r\nSuch patterns appear naturally when writing quantization / dequantization functionality with the vector dialect.\r\n\r\nThe rewrite performs a simple enumeration of each of the bits in the result vector and determines its provenance in the source vector. The enumeration is used to generate the proper sequence of `shuffle`, `andi`, `ori` with shifts`.\r\n\r\nThe rewrite currently only applies to 1-D non-scalable vectors and bails out if the final vector element type is not a multiple of 8. This is a failsafe heuristic determined empirically: if the resulting type is not an even number of bytes, further complexities arise that are not improved by this pattern: the heavy lifting still needs to be done by LLVM.", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Vector/Transforms/VectorEmulateNarrowType.cpp", "functions": ["success", "bcr", "enumerator", "failure", "be"]}]}
{"pr_number": 65272, "url": "https://github.com/llvm/llvm-project/pull/65272", "title": "[MLIR][Presburger] Template Matrix to allow MPInt and Fraction", "body": "Matrix has been templated to Matrix<T> (for MPInt and Fraction) with explicit instantiation for both these types.\r\nmakeMatrix has been duplicated to makeIntMatrix and makeFracMatrix.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Analysis/FlatLinearValueConstraints.cpp", "functions": ["mat"]}, {"filename": "mlir/lib/Analysis/Presburger/IntegerRelation.cpp", "functions": ["dirs"]}, {"filename": "mlir/unittests/Analysis/Presburger/LinearTransformTest.cpp", "functions": ["m3", "m5", "m1", "m6", "m4", "testColumnEchelonForm", "m2"]}, {"filename": "mlir/unittests/Analysis/Presburger/MatrixTest.cpp", "functions": ["mat"]}, {"filename": "mlir/lib/Analysis/Presburger/Simplex.cpp", "functions": ["output"]}]}
{"pr_number": 66585, "url": "https://github.com/llvm/llvm-project/pull/66585", "title": "[libc++] Fix `std::pair`'s  pair-like constructor's incorrect assumption", "body": "GitHub Issue:\nhttps://github.com/llvm/llvm-project/issues/65620\n\nThe helper function `__pair_like_explicit_wknd` is only SFINAE-ed with `tuple_size<remove_cvref_t<_PairLike>>::value == 2`, but its function body assumes `std::get` being valid\nhttps://github.com/llvm/llvm-project/blame/main/libcxx/include/__utility/pair.h#L280\n", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "libcxx/test/std/utilities/utility/pairs/pairs.pair/ctor.pair_like.pass.cpp", "functions": ["get"]}]}
{"pr_number": 66248, "url": "https://github.com/llvm/llvm-project/pull/66248", "title": "[flang] Fix characterization of result of function returning procedur\u2026", "body": "\u2026e pointer\r\n\r\nThe procedure characterization package correctly characterizes the result of a reference to a function that returns a procedure pointer. In the event of a result that is a pointer to a function that itself is a procedure pointer, the code in pointer assignment semantics checking was mistakenly using that result's procedure characteristics as the characteristics of the original function reference.  This is just wrong; delete it.", "feature_layers": ["sema"], "feature_directives": [], "files_changed": [{"filename": "flang/lib/Semantics/pointer-assignment.cpp", "functions": ["Check"]}]}
{"pr_number": 66510, "url": "https://github.com/llvm/llvm-project/pull/66510", "title": "[mlir][llvm] Use zeroinitializer for TargetExtType", "body": "Use the recently introduced llvm.mlir.zero operation for values with LLVM target extension type. Replaces the previous workaround that uses a single zero-valued integer attribute constant operation.", "feature_layers": ["ir"], "feature_directives": ["for", "single", "target"], "files_changed": [{"filename": "mlir/lib/Dialect/LLVMIR/IR/LLVMDialect.cpp", "functions": ["emitOpError", "success"]}]}
{"pr_number": 66258, "url": "https://github.com/llvm/llvm-project/pull/66258", "title": "[flang] Prioritize DATA object error messages a little better", "body": "When a DATA statement object is not valid, there's a number of possible reasons.  Emit an error message for the most egregious violation, so that an unlucky user doesn't fix something easy (due to a less-severe error message masking one that is worse) and then run into something that might be more serious.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Semantics/check-data.cpp", "functions": ["IsHostAssociated", "IsPointer", "IsUseAssociated", "IsProcedure", "IsFunctionResult", "IsDummy", "IsAutomatic", "IsAllocatable"]}]}
{"pr_number": 65887, "url": "https://github.com/llvm/llvm-project/pull/65887", "title": "[analyzer] Fix crash analyzing _BitInt() in evalIntegralCast", "body": "evalIntegralCast was using makeIntVal, and when _BitInt() types were\r\nintroduced this exposed a crash in evalIntegralCast as a result.\r\n\r\nImprove evalIntegralCast to use makeIntVal more efficiently to avoid the\r\ncrash exposed by use of _BitInt.\r\n\r\nThis was caught with our internal randomized testing.\r\n\r\n<src-root>/llvm/include/llvm/ADT/APInt.h:1510:\r\n  int64_t llvm::APInt::getSExtValue() const: Assertion\r\n  `getSignificantBits() <= 64 && \"Too many bits for int64_t\"' failed.a\r\n\r\n...\r\n #9 <address> llvm::APInt::getSExtValue() const\r\n  <src-root>/llvm/include/llvm/ADT/APInt.h:1510:5\r\n  llvm::IntrusiveRefCntPtr<clang::ento::ProgramState const>,\r\n  clang::ento::SVal, clang::QualType, clang::QualType)\r\n  <src-root>/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp:607:24\r\n  clang::Expr const*, clang::ento::ExplodedNode*, clang::ento::ExplodedNodeSet&)\r\n  <src-root>/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp:413:61\r\n...\r\n\r\n Fixes: https://github.com/llvm/llvm-project/issues/61960\r\n\r\n Reviewed By: donat.nagy", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/Analysis/bitint-no-crash.c", "functions": ["c"]}]}
{"pr_number": 66566, "url": "https://github.com/llvm/llvm-project/pull/66566", "title": "[mlir][TilingInterface] Make the tiling set tile sizes function use `OpFoldResult`.", "body": "", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/SCF/Transforms/TileUsingInterface.cpp", "functions": ["guard", "tileSizes"]}]}
{"pr_number": 66667, "url": "https://github.com/llvm/llvm-project/pull/66667", "title": "[RISCV][NFC] Simplify the sp-offset reduction by spimm of CM.PUSH/POP.", "body": "When inserting prolgue/epilogue, we use the spimm of CM.PUSH/POP to reduce the following offset for sp. Previously, we tried to use the free space of the push stack to minimize the following sp-offset. But it's useless, since free space must be less than 16 and required stack should be aligned to 16 before/after the adjustment.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVFrameLowering.cpp", "functions": ["alignTo"]}]}
{"pr_number": 66693, "url": "https://github.com/llvm/llvm-project/pull/66693", "title": "[mlir][c] Expose AsmState.", "body": "Enable usage where capturing AsmState is good. Haven't plumbed through to python yet. This also only changes one C API to verify plumbing.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/CAPI/IR/IR.cpp", "functions": ["mlirAsmStateDestroy", "wrap"]}]}
{"pr_number": 66640, "url": "https://github.com/llvm/llvm-project/pull/66640", "title": "[RISCV] Fix inline asm error for block address", "body": "After commit cedf2ea, `RISCVMergeBaseOffset` can handle `BlockAddress`\ncurrently. But we didn't handle it in `PrintAsmMemoryOperand` so we\nget `invalid operand in inline asm` error.\n\nThis patch fixes the error.\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp", "functions": ["if"]}]}
{"pr_number": 66742, "url": "https://github.com/llvm/llvm-project/pull/66742", "title": "[clang][dataflow] Fix two null pointer dereferences in `getMemberForAccessor()`.", "body": "The additions to the test trigger crashes without the fixes.\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/unittests/Analysis/FlowSensitive/TransferTest.cpp", "functions": ["returnVoid"]}]}
{"pr_number": 66622, "url": "https://github.com/llvm/llvm-project/pull/66622", "title": "[mlir][IR] Change `MutableArrayRange` to enumerate `OpOperand &`", "body": "In line with #66515, change `MutableArrayRange::begin`/`end` to enumerate `OpOperand &` instead of `Value`. Also remove `ForOp::getIterOpOperands`/`setIterArg`, which are now redundant.\r\n\r\nNote: `MutableOperandRange` cannot be made a derived class of `indexed_accessor_range_base` (like `OperandRange`), because `MutableOperandRange::assign` can change the number of operands in the range.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Bufferization/Transforms/OwnershipBasedBufferDeallocation.cpp", "functions": ["isMemrefOperand", "isMemref"]}, {"filename": "mlir/lib/Transforms/Utils/CFGToSCF.cpp", "functions": ["getMutableSuccessorOperands", "getSuccessorOperands"]}]}
{"pr_number": 66508, "url": "https://github.com/llvm/llvm-project/pull/66508", "title": "[AArch64] Remove copy instruction between uaddlv with v4i16/v8i16 and dup", "body": "If there are copy instructions between uaddlv with v4i16/v8i16 and dup for transfer from gpr to fpr, try to remove them with duplane. It is a follow-up patch of https://reviews.llvm.org/D159267", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AArch64/AArch64ISelLowering.cpp", "functions": ["DL"]}]}
{"pr_number": 66086, "url": "https://github.com/llvm/llvm-project/pull/66086", "title": "[analyzer] TaintPropagation checker strlen() should not propagate", "body": "strlen(..) call should not propagate taintedness,\r\nbecause it brings in many false positive findings. It is a common pattern to copy user provided input to another buffer. In these cases we always\r\nget warnings about tainted data used as the malloc parameter:\r\n\r\nbuf = malloc(strlen(tainted_txt) + 1); // false warning\r\n\r\nThis pattern can lead to a denial of service attack only, when the attacker can directly specify the size of the allocated area as an arbitrary large number (e.g. the value is converted from a user provided string).\r\n\r\nLater, we could reintroduce strlen() as a taint propagating function with the consideration not to emit warnings when the tainted value cannot be \"arbitrarily large\" (such as the size of an already allocated memory block).\r\n\r\nThe change has been evaluated on the following open source projects:\r\n\r\n- memcached: [1 lost false positive](https://codechecker-demo.eastus.cloudapp.azure.com/Default/reports?run=memcached_1.6.8_ednikru_taint_nostrlen_baseline&newcheck=memcached_1.6.8_ednikru_taint_nostrlen_new&is-unique=on&diff-type=Resolved)\r\n\r\n- tmux: 0 lost reports\r\n- twin [3 lost false positives](https://codechecker-demo.eastus.cloudapp.azure.com/Default/reports?run=twin_v0.8.1_ednikru_taint_nostrlen_baseline&newcheck=twin_v0.8.1_ednikru_taint_nostrlen_new&is-unique=on&diff-type=Resolved)\r\n- vim [1 lost false positive](https://codechecker-demo.eastus.cloudapp.azure.com/Default/reports?run=vim_v8.2.1920_ednikru_taint_nostrlen_baseline&newcheck=vim_v8.2.1920_ednikru_taint_nostrlen_new&is-unique=on&diff-type=Resolved)\r\n- openssl 0 lost reports\r\n- sqliste [2 lost false positives](https://codechecker-demo.eastus.cloudapp.azure.com/Default/reports?run=sqlite_version-3.33.0_ednikru_taint_nostrlen_baseline&newcheck=sqlite_version-3.33.0_ednikru_taint_nostrlen_new&is-unique=on&diff-type=Resolved)\r\n- ffmpeg 0 lost repots\r\n- postgresql [3 lost false positives](https://codechecker-demo.eastus.cloudapp.azure.com/Default/reports?run=postgres_REL_13_0_ednikru_taint_nostrlen_baseline&newcheck=postgres_REL_13_0_ednikru_taint_nostrlen_new&is-unique=on&diff-type=Resolved)\r\n- tinyxml 0 lost reports\r\n- libwebm 0 lost reports\r\n- xerces 0 lost reports\r\n\r\nIn all cases the lost reports are originating from copying untrusted environment variables into another buffer.\r\n\r\nThere are 2 types of lost false positive reports:\r\n1)  [Where the warning is emitted at the malloc call by the TaintPropagation Checker ](https://codechecker-demo.eastus.cloudapp.azure.com/Default/report-detail?run=memcached_1.6.8_ednikru_taint_nostrlen_baseline&newcheck=memcached_1.6.8_ednikru_taint_nostrlen_new&is-unique=on&diff-type=Resolved&report-id=2648506&report-hash=2079221954026f17e1ecb614f5f054db&report-filepath=%2amemcached.c)\r\n`\r\n            len = strlen(portnumber_filename)+4+1;\r\n            temp_portnumber_filename = malloc(len);\r\n`\r\n\r\n2) When pointers are set based on the length of the tainted string by the ArrayOutofBoundsv2 checker.\r\nFor example [this ](https://codechecker-demo.eastus.cloudapp.azure.com/Default/report-detail?run=vim_v8.2.1920_ednikru_taint_nostrlen_baseline&newcheck=vim_v8.2.1920_ednikru_taint_nostrlen_new&is-unique=on&diff-type=Resolved&report-id=2649310&report-hash=79dc8522d2cd34ca8e1b2dc2db64b2df&report-filepath=%2aos_unix.c)case.\r\n\r\n", "feature_layers": ["ir", "ast"], "feature_directives": ["for", "allocate"], "files_changed": [{"filename": "clang/test/Analysis/taint-diagnostic-visitor.c", "functions": ["atoi"]}, {"filename": "clang/test/Analysis/taint-generic.c", "functions": ["testStrnlen", "testStrlen_dont_propagate", "test_wchar_apis_propagate", "testStrnlen_dont_propagate", "testStrlen", "test_wchar_apis_dont_propagate"]}]}
{"pr_number": 65462, "url": "https://github.com/llvm/llvm-project/pull/65462", "title": "[clang][TSA] Consider cleanup functions for thread safety analysis", "body": "", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Analysis/CFG.cpp", "functions": ["appendCleanupFunction", "needsAutomaticDestruction", "hasTrivialDestructor"]}, {"filename": "clang/test/Analysis/scopes-cfg-output.cpp", "functions": ["cleanup_F", "__attribute__", "__attribute", "test", "test_cleanup_functions", "cleanup_int", "test_cleanup_functions2"]}, {"filename": "clang/lib/Analysis/ThreadSafetyCommon.cpp", "functions": ["translate"]}, {"filename": "clang/test/Sema/warn-thread-safety-analysis.c", "functions": ["CLEANUP", "broken_cleanup_int", "cleanup_int"]}]}
{"pr_number": 66756, "url": "https://github.com/llvm/llvm-project/pull/66756", "title": "[mlir] avoid crash in transform.sequence verifier", "body": "The verifier was unconditionally accessing the body block terminator, but it's not guaranteed that the block has one in general.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Transform/IR/TransformOps.cpp", "functions": ["emitOpError"]}]}
{"pr_number": 66765, "url": "https://github.com/llvm/llvm-project/pull/66765", "title": "[Dexter] Associate parser errors with correct file", "body": "Currently if Dexter encounters a parser error with a command, the resulting error message will refer to the most recently declared file (i.e. the source file it is testing) rather than the file containing the command itself. This patch fixes this so that parser errors point towards the correct location.", "feature_layers": ["parse", "parser"], "feature_directives": ["declare"], "files_changed": [{"filename": "cross-project-tests/debuginfo-tests/dexter/feature_tests/subtools/test/err_syntax_dexdeclarefile.cpp", "functions": ["main"]}]}
{"pr_number": 66677, "url": "https://github.com/llvm/llvm-project/pull/66677", "title": "[RISCV] Add a combine to form masked.store from unit strided store", "body": "Add a DAG combine to form a masked.store from a masked_strided_store intrinsic with stride equal to element size. This is the store analogy to PR #65674.\r\n\r\nAs seen in the tests, this does pickup a few cases that we'd previously missed due to selection ordering.  We match strided stores early without going through the recently added generic mscatter combines, and thus weren't recognizing the unit strided store.", "feature_layers": [], "feature_directives": ["for", "masked"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVISelLowering.cpp", "functions": ["SDValue"]}]}
{"pr_number": 66683, "url": "https://github.com/llvm/llvm-project/pull/66683", "title": "In ExprRequirement building, treat OverloadExpr as dependent", "body": "As reported in #66612, we aren't correctly treating the placeholder expression type correctly, so we ended up trying to get a reference version of it, and this resulted in an assertion, since the placeholder type cannot have a reference added.\r\n\r\nFixes: #66612", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "clang/test/SemaTemplate/concepts.cpp", "functions": ["end"]}]}
{"pr_number": 66766, "url": "https://github.com/llvm/llvm-project/pull/66766", "title": "[DAGCombiner] Combine vp.strided.load with unit stride to vp.load", "body": "This is the VP equivalent of #65674. We already combine MGATHER loads with unit stride to MLOAD, so this extends it for EXPERIMENTAL_VP_STRIDED_LOAD.\r\n\r\nI've added the tests in a separate commit in this PR so you can see the test diff.\r\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp", "functions": ["visitVP_STRIDED_LOAD", "SDValue", "CombineTo"]}]}
{"pr_number": 66455, "url": "https://github.com/llvm/llvm-project/pull/66455", "title": "[mlir][spirv][gpu] Convert remaining wmma ops to KHR coop matrix", "body": "These do not produce extension-specific ops and are handled via common\r\npatterns for both the KHR and the NV coop matrix extension.\r\n\r\nAlso improve match failure reporting and error handling in type conversion.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Conversion/GPUToSPIRV/WmmaOpsToSPIRV.cpp", "functions": ["failure", "allOperandsHaveSameCoopMatrixType", "success"]}]}
{"pr_number": 66724, "url": "https://github.com/llvm/llvm-project/pull/66724", "title": "[lldb][NFCI] Remove unneccessary allocation in ScriptInterpreterPythonImpl::GetSyntheticTypeName", "body": "Instead of copying memory out of the PythonString (via a std::string) and then using that to create a ConstString, it would make more sense to just create the ConstString from the original StringRef in the first place.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "lldb/source/Plugins/ScriptInterpreter/Python/ScriptInterpreterPython.cpp", "functions": ["py_string", "type_name", "return_data", "ConstString"]}]}
{"pr_number": 66713, "url": "https://github.com/llvm/llvm-project/pull/66713", "title": "[flang] Follow memory source through more operations", "body": "Add support for fir.box_addr, fir.array_corr, fir.coordinate, fir.embox, fir.rebox and fir.load.\r\n\r\n1) Through the use of boolean `followBoxAddr` determine whether the analysis should apply to the address of the box or the address wrapped by the box. \r\n2) Some asserts have been removed to allow for more SourceKinds though the flow, in a particular SourceKind::Direct\r\n3) getSource was a public method but the returned type (SourceKind) was not public making it impossible to be called publicly\r\n4) About 12 tests have been added to check for real Fortran scenarios \r\n5) More tests will be added with HLFIR\r\n6) A few TODOs have been identified and will need to be addressed in follow-up patches. I felt that more changes would increase the complexity of the patch.\r\n\r\n\r\n\r\n\r\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Optimizer/Analysis/AliasAnalysis.cpp", "functions": ["getOriginalDef"]}]}
{"pr_number": 66718, "url": "https://github.com/llvm/llvm-project/pull/66718", "title": "[flang] Correct handling of assumed-rank allocatables in ALLOCATE", "body": "Construct entities that are associations from selectors in ASSOCIATE, CHANGE TEAMS, and SELECT TYPE constructs do not have the ALLOCATABLE or POINTER attributes, even when associating with allocatables or pointers; associations from selectors in SELECT RANK constructs do have those attributes.", "feature_layers": [], "feature_directives": ["teams", "allocate"], "files_changed": [{"filename": "flang/lib/Evaluate/tools.cpp", "functions": ["IsAllocatable"]}]}
{"pr_number": 66696, "url": "https://github.com/llvm/llvm-project/pull/66696", "title": "[mlir][spirv] Add conversions for Arith's `maxnumf` and `minnumf`", "body": "This patch is part of a larger initiative aimed at fixing floating-point `max` and `min` operations in MLIR: https://discourse.llvm.org/t/rfc-fix-floating-point-max-and-min-operations-in-mlir/72671.\n\nIn this commit, we add conversion patterns for the newly introduced operations `arith.minnumf` and `arith.maxnumf`. When converting to `spirv.CL`, there is no need to insert additional guards to propagate non-NaN values when one of the arguments is NaN because `CL` ops do exactly the same. However, `GL` ops have undefined behavior when one of the arguments is NaN, so we should insert additional guards to enforce the semantics of Arith's ops.\n\nThis patch addresses the 1.5 task of the mentioned RFC.\n", "feature_layers": ["sema", "ir"], "feature_directives": ["task", "for"], "files_changed": [{"filename": "mlir/lib/Conversion/ArithToSPIRV/ArithToSPIRV.cpp", "functions": ["shouldInsertNanGuards", "success", "getTypeConversionFailure"]}]}
{"pr_number": 66720, "url": "https://github.com/llvm/llvm-project/pull/66720", "title": "[mlir][sparse] More allocate -> empty tensor migration", "body": "This also allows tensor.empty in the \"conversion\" path of the sparse compiler, further paving the way to\r\ndeprecate the bufferization.allocated_tensor() op.", "feature_layers": ["parse", "ir"], "feature_directives": ["allocate"], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/Transforms/SparseTensorConversion.cpp", "functions": ["failure", "success", "constantIndex"]}]}
{"pr_number": 66021, "url": "https://github.com/llvm/llvm-project/pull/66021", "title": "[Clang] Static member initializers are not immediate escalating context.", "body": "Per CWG2760, default members initializers should be consider part the body of constructors, which mean they are evaluated in an immediate escalating context.\r\n\r\nHowever, this does not apply to static members.\r\n\r\nThis patch produces some extraneous diagnostics, unfortunately we do not have a good way to report an error back to the initializer and this is a pre existing issue\r\n\r\nFixes #65985", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/SemaCXX/cxx2a-consteval.cpp", "functions": ["f2", "f", "constantDerp"]}, {"filename": "clang/test/SemaCXX/cxx2b-consteval-propagate.cpp", "functions": ["invalid", "escalating"]}]}
{"pr_number": 65875, "url": "https://github.com/llvm/llvm-project/pull/65875", "title": "[EarlyCSE] Compare GEP instructions based on offset", "body": "Closes #65763.\r\nThis will provide more opportunities for constant propagation for subsequent optimizations.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Scalar/EarlyCSE.cpp", "functions": ["GEPVal"]}]}
{"pr_number": 66722, "url": "https://github.com/llvm/llvm-project/pull/66722", "title": "[mlir][sparse] unifies sparse_tensor.sort_coo/sort into one operation.", "body": "The use cases of the two operations are largely overlapped, let's simplify it and only use one of them.", "feature_layers": ["parse", "ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/IR/SparseTensorDialect.cpp", "functions": ["success", "emitError"]}, {"filename": "mlir/lib/Dialect/SparseTensor/Transforms/SparseBufferRewriting.cpp", "functions": ["getMemRefType"]}, {"filename": "mlir/lib/Dialect/SparseTensor/Transforms/SparseTensorRewriting.cpp", "functions": ["xs", "es"]}]}
{"pr_number": 66122, "url": "https://github.com/llvm/llvm-project/pull/66122", "title": "[DependencyScanningFilesystem] Make sure the local/shared cache filename lookups use only absolute paths", "body": "Previously a relative path would be used as a key for cache lookup and if the same relative path was used from another compiler invocation with a different working directory then the first cache entry was erroneously returned.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp", "functions": ["insertLocalEntryForFilename", "ProxyFileSystem"]}]}
{"pr_number": 66771, "url": "https://github.com/llvm/llvm-project/pull/66771", "title": "[mlir][IR] Trigger `notifyOperationRemoved` callback for nested ops", "body": "When cloning an op, the `notifyOperationInserted` callback is triggered for all nested ops. Similarly, the `notifyOperationRemoved` callback should be triggered for all nested ops when removing an op.\r\n\r\nListeners may inspect the IR during a `notifyOperationRemoved` callback. Therefore, when multiple ops are removed in a single `RewriterBase::eraseOp` call, the notifications must be triggered in an order in which the ops could have been removed one-by-one:\r\n\r\n* Op removals must be interleaved with `notifyOperationRemoved` callbacks. A callback is triggered right before the respective op is removed.\r\n* Ops are removed post-order and in reverse order. Other traversal orders could delete an op that still has uses. (This is not avoidable in graph regions and with cyclic block graphs.)\r\n\r\nNote: Imported from https://reviews.llvm.org/D144193.\r\n", "feature_layers": ["ir"], "feature_directives": ["for", "single"], "files_changed": [{"filename": "mlir/test/lib/Dialect/Test/TestPatterns.cpp", "functions": ["notifyOperationRemoved"]}]}
{"pr_number": 66777, "url": "https://github.com/llvm/llvm-project/pull/66777", "title": "[flang] Prevent IR name clashes between BIND(C) and external procedures", "body": "Defining a procedure with a BIND(C, NAME=\"...\") where the binding label matches the assembly name of a non BIND(C) external procedure in the same file causes a failure when generating the LLVM IR because of the assembly symbol name clash.\r\n\r\nPrevent this crash with a clearer semantic error.", "feature_layers": ["sema", "ir"], "feature_directives": [], "files_changed": [{"filename": "flang/lib/Semantics/check-declarations.cpp", "functions": ["CheckProcedureAssemblyName"]}]}
{"pr_number": 66411, "url": "https://github.com/llvm/llvm-project/pull/66411", "title": "[GuardUtils] Revert llvm::isWidenableBranch change", "body": "In the d6e7c162e1df3736d8e2b3610a831b7cfa5be99b was introduced util to to extract widenable conditions from branch. That util was applied in the llvm::isWidenableBranch to check if branch is widenable. So we consider branch is widenable if it has widenable condition anywhere in the condition tree. But that will be true when we finish GuardWidening reworking from branch widening to widenable conditions widening. \r\nFor now we still need to check that widenable branch is in the form of: `br(widenable_condition & (...))`,\r\nbecause that form is assumed by LoopPredication and GuardWidening algorithms.\r\n\r\nFixes: https://github.com/llvm/llvm-project/issues/66418", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Analysis/GuardUtils.cpp", "functions": ["extractWidenableCondition"]}]}
{"pr_number": 66880, "url": "https://github.com/llvm/llvm-project/pull/66880", "title": "[mlir][gpu][bufferization] Implement BufferDeallocationOpInterface for gpu.terminator", "body": "This is necessary to support deallocation of IR with gpu.launch operations because it does not implement the RegionBranchOpInterface. Implementing the interface would require it to support regions with unstructured control flow and produced arguments/results.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Bufferization/IR/BufferDeallocationOpInterface.cpp", "functions": ["builder", "failure"]}, {"filename": "mlir/lib/Dialect/Bufferization/Transforms/OwnershipBasedBufferDeallocation.cpp", "functions": ["failure", "isMemrefOperand", "isMemref"]}, {"filename": "mlir/lib/Dialect/SCF/Transforms/BufferDeallocationOpInterfaceImpl.cpp", "functions": ["builder", "failure"]}]}
{"pr_number": 66782, "url": "https://github.com/llvm/llvm-project/pull/66782", "title": "[analyzer] Fix crash analyzing _BitInt() in evalIntegralCast", "body": "evalIntegralCast was using makeIntVal, and when _BitInt() types were introduced this exposed a crash in evalIntegralCast as a result.\r\n\r\nThis is a reapply of a previous patch that failed post merge on the arm buildbots, because arm cannot handle large\r\nBitInts. Pinning the triple for the testcase solves that problem. \r\n\r\nImprove evalIntegralCast to use makeIntVal more efficiently to avoid the crash exposed by use of _BitInt.\r\n\r\nThis was caught with our internal randomized testing.\r\n\r\n<src-root>/llvm/include/llvm/ADT/APInt.h:1510:\r\n  int64_t llvm::APInt::getSExtValue() const: Assertion\r\n  `getSignificantBits() <= 64 && \"Too many bits for int64_t\"' failed.a\r\n\r\n...\r\n #9 <address> llvm::APInt::getSExtValue() const\r\n  <src-root>/llvm/include/llvm/ADT/APInt.h:1510:5\r\n  llvm::IntrusiveRefCntPtr<clang::ento::ProgramState const>,\r\n  clang::ento::SVal, clang::QualType, clang::QualType)\r\n  <src-root>/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp:607:24\r\n  clang::Expr const*, clang::ento::ExplodedNode*, clang::ento::ExplodedNodeSet&)\r\n  <src-root>/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp:413:61\r\n...\r\n\r\n Fixes: https://github.com/llvm/llvm-project/issues/61960\r\n\r\n Reviewed By: donat.nagy", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/Analysis/bitint-no-crash.c", "functions": ["c"]}]}
{"pr_number": 66493, "url": "https://github.com/llvm/llvm-project/pull/66493", "title": "[analyzer] Fix StackAddrEscapeChecker crash on temporary object fields", "body": "Basically, the issue was that we should have unwrap the base region before we special handle temp object regions.\r\n\r\nFixes https://github.com/llvm/llvm-project/issues/66221\r\n\r\nI also decided to add some extra range information to the diagnostics to make it consistent with the other reporting path.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/Analysis/stackaddrleak.cpp", "functions": ["create_func", "new", "operator", "gh_66221", "myfunction"]}]}
{"pr_number": 66730, "url": "https://github.com/llvm/llvm-project/pull/66730", "title": "[VE] Add unittest for intrinsics", "body": "Add unittest for VE intrinsics instructions.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/unittests/Target/VE/MachineInstrTest.cpp", "functions": ["TT", "ST"]}]}
{"pr_number": 66637, "url": "https://github.com/llvm/llvm-project/pull/66637", "title": "[mlir][bufferization] Move memref specific implementation of AllocationOpInterface to memref dialect directory", "body": "Follow-up on #65578", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/Bufferization/Transforms/Bufferize.cpp", "functions": ["buildClone", "getHoistingKind"]}, {"filename": "mlir/lib/Dialect/MemRef/Transforms/AllocationOpInterfaceImpl.cpp", "functions": ["buildClone", "getHoistingKind"]}]}
{"pr_number": 66310, "url": "https://github.com/llvm/llvm-project/pull/66310", "title": "[X86] Align other variants to use void * as 512 variants.", "body": "For *_stream_* series intrinsics", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CodeGen/X86/avx-builtins.c", "functions": ["test_mm256_stream_si256_void", "test_mm256_stream_pd_void", "test_mm256_stream_ps_void"]}, {"filename": "clang/test/CodeGen/X86/avx2-builtins.c", "functions": ["test_mm256_stream_load_si256_void", "test_mm256_stream_load_si256_const"]}, {"filename": "clang/test/CodeGen/X86/sse-builtins.c", "functions": ["test_mm_stream_ps_2", "test_mm_stream_ps_void"]}, {"filename": "clang/test/CodeGen/X86/sse2-builtins.c", "functions": ["test_mm_stream_si64_void", "test_mm_stream_si128_void", "test_mm_stream_si32_void", "test_mm_stream_pd_void"]}, {"filename": "clang/test/CodeGen/X86/sse41-builtins.c", "functions": ["test_mm_stream_load_si128_void"]}, {"filename": "clang/test/CodeGen/X86/mmx-builtins.c", "functions": ["test_mm_stream_pi_void"]}, {"filename": "clang/test/CodeGen/X86/sse4a-builtins.c", "functions": ["test_mm_stream_s_void", "test_mm_stream_sd_void"]}]}
{"pr_number": 66897, "url": "https://github.com/llvm/llvm-project/pull/66897", "title": "[MLIR][Presburger] Template Matrix to allow MPInt and Fraction and separate out IntMatrix", "body": "Matrix has been templated to Matrix (for MPInt and Fraction) with explicit instantiation for both these types.\r\nIntMatrix, inheriting from Matrix<MPInt>, has been created to allow for integer-only methods.\r\nmakeMatrix has been duplicated to makeIntMatrix and makeFracMatrix.\r\n\r\nThis was already landed previously but was reverted in 98c994c8e22d7f38cc04f56ee5cdeb337734414d due to build failure. This fixes the failure.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Analysis/FlatLinearValueConstraints.cpp", "functions": ["mat"]}, {"filename": "mlir/lib/Analysis/Presburger/IntegerRelation.cpp", "functions": ["dirs"]}, {"filename": "mlir/unittests/Analysis/Presburger/LinearTransformTest.cpp", "functions": ["m3", "m5", "m1", "m6", "m4", "testColumnEchelonForm", "m2"]}, {"filename": "mlir/unittests/Analysis/Presburger/MatrixTest.cpp", "functions": ["mat"]}, {"filename": "mlir/lib/Analysis/Presburger/Simplex.cpp", "functions": ["output"]}, {"filename": "mlir/lib/Analysis/Presburger/Matrix.cpp", "functions": ["normalizeRow", "matrix", "at", "normalizeRange"]}]}
{"pr_number": 66433, "url": "https://github.com/llvm/llvm-project/pull/66433", "title": "[NFC][AsmPrinter] Refactor FrameIndexExprs as a std::set", "body": "This avoids the need for a mutable member to implement deferred sorting, and some bespoke code to maintain a SmallVector as a set.\r\n\r\nThe performance impact seems to be negligible in some small tests, and so seems acceptable to greatly simplify the code.\r\n\r\nAn old FIXME and accompanying workaround are dropped. It is ostensibly dead-code within the current codebase.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp", "functions": ["getFragmentOffsetInBits"]}]}
{"pr_number": 65699, "url": "https://github.com/llvm/llvm-project/pull/65699", "title": "[clang][CodeGen] The `eh_typeid_for` intrinsic needs special care too", "body": "This change is symmetric with the one reviewed in <https://reviews.llvm.org/D157452> and handles the exception handling specific intrinsic, which slipped through the cracks, in the same way, by inserting an address-space cast iff RTTI is in a non-default AS.", "feature_layers": ["codegen", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CodeGenCXX/try-catch-with-address-space.cpp", "functions": ["g", "h", "f"]}]}
{"pr_number": 66847, "url": "https://github.com/llvm/llvm-project/pull/66847", "title": "[mlir][sparse] remove most bufferization.alloc_tensor ops from sparse", "body": "The only ones left need actual deprecation in bufferization module.", "feature_layers": ["parse", "ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/Transforms/SparseTensorCodegen.cpp", "functions": ["failure", "success", "OpConversionPattern"]}]}
{"pr_number": 65474, "url": "https://github.com/llvm/llvm-project/pull/65474", "title": "[mlir] introduce transform.loop.forall_to_for", "body": "Add a straightforward sequentialization transform from `scf.forall` to a nest of `scf.for` in absence of results and expose it as a transform op. This is helpful in combination with other transform ops, particularly fusion, that work best on parallel-by-construction `scf.forall` but later need to target sequential `for` loops.", "feature_layers": ["ir"], "feature_directives": ["parallel", "for", "target"], "files_changed": [{"filename": "mlir/lib/Dialect/SCF/TransformOps/SCFTransformOps.cpp", "functions": ["emitSilenceableError"]}]}
{"pr_number": 66932, "url": "https://github.com/llvm/llvm-project/pull/66932", "title": "sve gather scatter offset sinking", "body": "- [flang] Add comdats to functions with linkonce linkage (#66516)\n- [clang][TSA] Thread safety cleanup functions\n- [SPIRV] Test basic float and int types (#66282)\n- [mlgo] Fix tests post PR #66334\n- [libunwind][AIX] Fix up TOC register if unw_getcontext is called from a different module (#66549)\n- [RISCV] Recognize veyron-v1 processor in clang driver. (#66703)\n- [RISCV] Add a combine to form masked.store from unit strided store\n- [SROA] Remove unnecessary IsStorePastEnd handling (NFCI)\n- In ExprRequirement building, treat OverloadExpr as dependent (#66683)\n- [mlir][SCF] `ForOp`: Remove `getIterArgNumberForOpOperand` (#66629)\n- [mlir][Interfaces] `LoopLikeOpInterface`: Support ops with multiple regions (#66754)\n- [DAGCombiner] Combine vp.strided.load with unit stride to vp.load (#66766)\n- [DAGCombiner] Combine vp.strided.store with unit stride to vp.store (#66774)\n- [TwoAddressInstruction] Use isPlainlyKilled in processTiedPairs (#65976)\n- [RISCV] Fix bad isel predicate handling for Ztso. (#66739)\n- [libc][math] Extract non-MPFR math tests into libc-math-smoke-tests.\n- [lit] Drop \"Script:\", make -v and -a imply -vv\n- [lit] Improve test output from lit's internal shell\n- [lit] Echo full RUN lines in case of external shells (#66408)\n- [RISCV] Add a pass to rewrite rd to x0 for non-computational instrs whose return values are unused\n- [mlir][spirv][gpu] Convert remaining wmma ops to KHR coop matrix (#66455)\n- [mlir][sparse] More allocate -> empty tensor migration (#66720)\n- [gn build] Port 93fde2ea1b2c\n- [RISCV] Add more instructions for the short forward branch optimization. (#66789)\n- [SSP] Accessing __stack_chk_guard when using LTO (#66535)\n- [RISCV] Expand test coverage for widening gather and strided load idioms\n- [lldb][NFCI] Remove unneeded ConstString from intel-pt plugin (#66721)\n- [lldb][NFCI] Remove unneccessary allocation in ScriptInterpreterPythonImpl::GetSyntheticTypeName (#66724)\n- [Profile] Delete coverage-debug-info-correlate.cpp test on mac as debug info correlation not working on mac for unkown reasons.\n- [lldb] Fix build after d5a62b78b8ae\n- [flang][hlfir] Fixed assignment/finalization order for user-defined assignments. (#66736)\n- [RISCV] Require alignment when forming gather with larger element type\n- Addressed review comments to use ThreadSafe instead of !ThreadSafe\n- [flang] Follow memory source through more operations (#66713)\n- [X86] Use RIP-relative addressing for data under large data threshold for medium code model\n- Fix a bug with cancelling \"attach -w\" after you have run a process previously (#65822)\n- Let the c(xx)_status pages reflect that clang 17 is released\n- Revert \"[flang][hlfir] Fixed assignment/finalization order for user-defined assignments. (#66736)\"\n- Revert \"Revert \"[flang][hlfir] Fixed assignment/finalization order for user-defined assignments. (#66736)\"\"\n- [ORC] Add writePointers to ExecutorProcessControl's MemoryAccess\n- [Coverage] Skip visiting ctor member initializers with invalid source locations.\n- [SLP]Fix PR66795: Check correct deps for vectorized inst with multiple vectorized node uses.\n- [github] Make branch workflow more robust (#66781)\n- [flang] Correct handling of assumed-rank allocatables in ALLOCATE (#66718)\n- [BOLT][runtime] Test for outline-atomics support\n- [mlir][spirv] Add conversions for Arith's `maxnumf` and `minnumf` (#66696)\n- [libc++][NFC] Clean up std::__call_once\n- [libc][cmake] Tidy compiler includes (#66783)\n- [OpenMP][Docs][NFC] Update documentation\n- [RISCV] Match strided load via DAG combine (#66800)\n- [llvm-nm] Add --line-numbers flag\n- Revert \"[libc][cmake] Tidy compiler includes (#66783)\" (#66822)\n- [-Wunsafe-bugger-usage] Clean tests: remove nondeterministic ordering\n- [mlir][sparse][gpu] free all buffers allocated for spGEMM (#66813)\n- [llvm][docs] Update active CoC Commitee members (#66814)\n- Explicitly set triple on line-numbers.test\n- [AsmPrint] Dump raw frequencies in `-mbb-profile-dump` (#66818)\n- [Clang] Static member initializers are not immediate escalating context. (#66021)\n- [mlir][spirv] Suffix NV cooperative matrix props with `_nv` (#66820)\n- [mlir][spirv] Define KHR cooperative matrix properties (#66823)\n- [lit] Fix a test fail under windows\n- [InstrProf][compiler-rt] Enable MC/DC Support in LLVM Source-based Code Coverage (1/3)\n- [AMDGPU] Use inreg for hint to preload kernel arguments\n- [EarlyCSE] Compare GEP instructions based on offset (#65875)\n- [libc++] Fix __threading_support when used with C11 threading (#66780)\n- [clang] Improve CI output when trailing whitespace is found (#66649)\n- [libc] Fix printf config not working (#66834)\n- [lit] Apply aa71680f2948's fix to an additional test\n- [AMDGPU] Add ASM and MC updates for preloading kernargs\n- [bazel] Port c649f29c24c9fc1502d8d53e0c96c3d24b31de1a (llvm-nm --line-numbers)\n- Fix test added in D150987 to account for different path separators which was causing the test to fail on Windows.\n- [SimplifyCFG] Pre-commit test for extending HoistThenElseCodeToIf.\n- [SimplifyCFG] Hoist common instructions on Switch.\n- [IR] Add \"Large Data Threshold\" module metadata (#66797)\n- A test was changing directory and then incorrectly restoring the directory to the \"testdir\" which is the build directory for that test, not the original source directory.  That caused subsequent tests to fail.\n- [mlir][sparse] unifies sparse_tensor.sort_coo/sort into one operation. (#66722)\n- [Docs] Fix table after previous document update\n- [Sparc] Remove LEA instructions (NFCI) (#65850)\n- [lldb][NFCI] Remove unused struct ConstString::StringIsEqual\n- [builtins][NFC] Avoid using CRT_LDBL_128BIT in tests (#66832)\n- [RISCV] Prefer Zcmp push/pop instead of save-restore calls. (#66046)\n- [DependencyScanningFilesystem] Make sure the local/shared cache filename lookups use only absolute paths (#66122)\n- [NFC][hwasan] Make ShowHeapOrGlobalCandidate a method (#66682)\n- [NFC][hwasan] Find overflow candidate early (#66682)\n- [NFC][hwasan] Clang-format c557621176f5f38b5757a325cc72be0a11a91c78\n- [NFC][hwasan] Extract a few BaseReport::Copy methods (#66682)\n- [NFC][hwasan] Extract announce_by_id (#66682)\n- [NFC][hwasan] Collect heap allocations early (#66682)\n- [libc++] Warn if an unsupported compiler is used\n- [ELF][test] Improve tests about non-SHF_ALLOC sections relocated by non-ABS relocations\n- [ELF] Remove a R_ARM_PCA special case from relocateNonAlloc\n- [clang][dataflow] Reorder checks to protect against a null pointer dereference. (#66764)\n- [MC,X86] Property report error for modifiers with incorrect size\n- [RISCV] Install sifive_vector.h to riscv-resource-headers (#66330)\n- [InferAlignment] Create tests for InferAlignment pass\n- [InferAlignment] Implement InferAlignmentPass\n- [InstCombine] Use a cl::opt to control calls to getOrEnforceKnownAlignment in LoadInst and StoreInst\n- [InferAlignment] Enable InferAlignment pass by default\n- [ELF][test] Improve -r tests for local symbols\n- [mlir][IR] Trigger `notifyOperationRemoved` callback for nested ops (#66771)\n- [Workflow] Add new code format helper. (#66684)\n- [gn build] Port 0f152a55d3e4\n- [RISCV] Fix bugs about register list of Zcmp push/pop. (#66073)\n- [AMDGPU] Run twoaddr tests with -early-live-intervals (#66775)\n- [TableGen][GlobalISel] Use `GIM_SwitchOpcode` in Combiners (#66864)\n- [NFC][InferAlignment] Swap extern declaration and definition of EnableInferAlignmentPass\n- [flang] Prevent IR name clashes between BIND(C) and external procedures (#66777)\n- Revert \"[Workflow] Add new code format helper. (#66684)\"\n- [lldb][Docs] Fix typo in style docs\n- [clang-format][NFC] Clean up signatures of some parser functions (#66569)\n- Revert \"Fix a bug with cancelling \"attach -w\" after you have run a process previously (#65822)\"\n- [OpenMP][VE] Limit the number of threads to create (#66729)\n- [SimpleLoopUnswitch] Fix reversed branch during condition injection\n- [mlir][vector] Make ReorderElementwiseOpsOnBroadcast support vector.splat (#66596)\n- [lldb][AArch64] Add SME's streaming vector control register\n- [reland][libc][cmake] Tidy compiler includes (#66783) (#66878)\n- [GuardUtils] Revert llvm::isWidenableBranch change (#66411)\n- [LLVM] convergence verifier should visit all instructions (#66200)\n- [lldb][API] Remove debug print in TestRunLocker.py\n- [clang] [C23] Fix crash with _BitInt running clang-tidy (#65889)\n- [Flang][OpenMP] Move FIR lowering tests to a separate directory (#66779)\n- [RISCV] Add missing V extensions for zvk-invalid-features.c (#66875)\n- [mlir][gpu][bufferization] Implement BufferDeallocationOpInterface for gpu.terminator (#66880)\n- [analyzer] Fix crash analyzing _BitInt() in evalIntegralCast (#66782)\n- [IR] Fix a memory leak if Function::dropAllReferences() is followed by setHungoffOperand\n- [X86] vector-interleaved tests - add AVX512-SLOW/AVX512-FAST common prefixes to reduce duplication\n- [X86] combineINSERT_SUBVECTOR - attempt to combine concatenated shuffles\n- [X86] Add test cases for gnux32 large constants Issue #55061\n- [NFC][Clang] Address reviews about overrideFunctionFeaturesWithTargetFeatures (#65938)\n- [analyzer] Fix StackAddrEscapeChecker crash on temporary object fields (#66493)\n- [VE] Add unittest for intrinsics (#66730)\n- [NFC][AMDGPU] Perform a single lookup in map in SIInsertWaitcnts::isPreheaderToFlush\n- [NFC][AMDGPU] Remove redundant hasSideEffects=1\n- [SROA] Don't shrink volatile load past end\n- [mlir][bufferization][scf] Implement BufferDeallocationOpInterface for scf.reduce.return (#66886)\n- [RISCV] Add tests where bin ops of splats could be scalarized. NFC (#65747)\n- [clang][Interp][NFC] Small code refactoring\n- [Docs] Update ExceptionHandling example (NFC)\n- [mlir][bufferization][NFC] Move memref specific implementation of AllocationOpInterface to memref dialect directory (#66637)\n- [X86] Align other variants to use void * as 512 variants. (#66310)\n- [X86] Fix an assembler bug of CMPCCXADD. (#66748)\n- [clang][dataflow] Identify post-visit state changes in the HTML logger. (#66746)\n- [MLIR][Presburger] Template Matrix to allow MPInt and Fraction; use IntMatrix for integer matrices (#66897)\n- [SPIR-V] Fix 64-bit integer literal printing (#66686)\n- [libc++] Simplify how the global stream tests are written (#66842)\n- [AArch64][SME] Enable TPIDR2 lazy-save for za_preserved\n- [X86] X86DAGToDAGISel::matchIndexRecursively - replace hard coded recursion limit with SelectionDAG::MaxRecursionDepth. NFCI.\n- [libc++] Sort available features before printing them\n- [mlir][VectorOps] Extend vector.constant_mask to support 'all true' scalable dims (#66638)\n- Warn on align directive with non-zero fill value in virtual sections (#66792)\n- [VE] Add TargetParser to CMakeLists.txt for VE unittest\n- [lldb-vscode] Use auto summaries whenever variables don't have a summary (#66551)\n- Revert \"[clang] Don't inherit dllimport/dllexport to exclude_from_explicit_instantiation members during explicit instantiation (#65961)\"\n- [AMDGPU] Convert tests rotr.ll and rotl.ll to be auto-generated (#66828)\n- [NFC] Fix spelling 'constanst' -> 'constants'\n- [mlir][Vector] Add fastmath flags to vector.reduction (#66905)\n- [lldb][AArch64] Invalidate cached VG value before reconfiguring SVE registers\n- [gn] Add dummy build file for VETests\n- [SPIRV] Fix OpConstant float and double printing\n- [flang][hlfir] Fixed cleanup code placement indeterminism in OrderedAssignments. (#66811)\n- [AMDGPU] Regenerate always-uniform.ll\n- [X86] Regenerate pr39098.ll\n- [ELF][test] Add a test to demonstrate #66836\n- [NFC][AsmPrinter] Refactor FrameIndexExprs as a std::set (#66433)\n- [ELF] Postpone \"unable to move location counter backward\" error (#66854)\n- [clang][CodeGen] The `eh_typeid_for` intrinsic needs special care too (#65699)\n- [AArch64][GlobalISel] Adopt dup(load) -> LD1R patterns from SelectionDAG\n- Cleanup fallback NOT checks\n- [AArch64] Add some tests for setcc known bits fold. NFC\n- [SelectionDAG] [NFC] Add pre-commit test for PR66701. (#66796)\n- [Driver] Some improvements for path handling on NetBSD (#66863)\n- [mlir][sparse] remove most bufferization.alloc_tensor ops from sparse (#66847)\n- [mlir] Bazel fixes for 1b8b55644313216e6b0fa233bbd8b01fee23f99f (#66929)\n- [mlir] introduce transform.loop.forall_to_for (#65474)\n- [mlir] regenerate linalg named ops yaml (#65475)\n- [SLP]Fix a crash when trying to find operand with re-vectorized main instruction.\n- [libc][Obvious] Fix incorrect RPC opcode for `clearerr`\n- [SVE][CodeGenPrepare] Sink address calculations that match SVE gather/scatter addressing modes.\n", "feature_layers": ["parse", "codegen", "runtime", "ir", "ast", "parser"], "feature_directives": ["for", "sections", "single", "atomic", "flush", "ordered", "target", "allocate", "masked"], "files_changed": [{"filename": "llvm/lib/Target/AArch64/AArch64ISelLowering.cpp", "functions": ["shouldSinkVectorOfPtrs"]}]}
{"pr_number": 66835, "url": "https://github.com/llvm/llvm-project/pull/66835", "title": "[clang-tidy] Fix support for typedefs in readability-identifier-naming", "body": "Typedef rename were not properly handled when typedef were used behind pointer, or as a part of function type. Additionally because entire function were passed as an source-range, when function started with macro, such change were not marked for a fix.\r\n\r\nRemoved workaround and used proper TypedefTypeLoc instead.\r\n\r\nFixes #55156, #54699", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang-tools-extra/clang-tidy/utils/RenamerClangTidyCheck.cpp", "functions": ["VisitTypedefTypeLoc"]}, {"filename": "clang-tools-extra/test/clang-tidy/checkers/readability/identifier-naming.cpp", "functions": ["someFunc", "ValueType"]}]}
{"pr_number": 65998, "url": "https://github.com/llvm/llvm-project/pull/65998", "title": "[libc++] Make sure LWG2070 is implemented as a DR", "body": "When we implemented C++20's P0674R1, we didn't enable the part of P0674R1 that was resolving LWG2070 as a DR. This patch fixes that and makes sure that we consistently go through the allocator when constructing and destroying the underlying object in std::allocate_shared.\r\n\r\nFixes #54365.", "feature_layers": [], "feature_directives": ["allocate"], "files_changed": [{"filename": "libcxx/test/std/utilities/memory/util.smartptr/util.smartptr.shared/util.smartptr.shared.create/allocate_shared.pass.cpp", "functions": ["construct"]}]}
{"pr_number": 66804, "url": "https://github.com/llvm/llvm-project/pull/66804", "title": "[ELF] -r --compress-debug-sections: update implicit addends for .rel.debug_* referencing STT_SECTION symbols", "body": "https://reviews.llvm.org/D48929 updated addends for non-SHF_ALLOC sections\nrelocated by REL for -r links, but the patch did not update the addends when\n--compress-debug-sections={zlib,zstd} is used (#66738).\n\nhttps://reviews.llvm.org/D116946 handled tombstone values in debug\nsections in relocatable links. As a side effect, both\nrelocateNonAllocForRelocatable (using `sec->relocations`) and\nrelocatenonNonAlloc (using raw REL/RELA) may run.\n\nActually, we can adjust the condition in relocatenonAlloc to completely replace\nrelocateNonAllocForRelocatable. This patch implements this idea and fixes #66738.\n\nAs relocateNonAlloc processes the raw relocations like copyRelocations() does,\nthe condition `if (config->relocatable && type != target.noneRel)` in `copyRelocations`\n(commit 08d6a3f1337238a480225d4caf71b8fec10dc8c6, modified by https://reviews.llvm.org/D62052)\ncan be made specific to SHF_ALLOC sections.\n\nAs a side effect, we can now report diagnostics for PC-relative relocations for\n-r. This is a less useful diagnostic that is not worth too much code. As\nhttps://github.com/ClangBuiltLinux/linux/issues/1937 has violations, just\nsuppress the warning for -r. Tested by commit 561b98f9e025363b416f4e89af750d01d1e8c4cc.", "feature_layers": [], "feature_directives": ["for", "sections", "target"], "files_changed": [{"filename": "lld/ELF/InputSection.cpp", "functions": ["if", "relocateNonAllocForRelocatable"]}]}
{"pr_number": 65706, "url": "https://github.com/llvm/llvm-project/pull/65706", "title": "[VectorCombine][RISCV] Convert VPIntrinsics with splat operands to splats", "body": "of the scalar operation\r\n\r\nVP Intrinsics whose vector operands are both splat values may be simplified into the scalar version of the operation and the result is splatted. If this simplification occurs, then it can lead to scalarization during CodeGen.\r\n\r\nThis issue is the intrinsic dual of #65072. This issue scalarizes non-legal types when the operations are VP Intrinsics.", "feature_layers": ["codegen"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp", "functions": ["replaceInstUsesWith"]}, {"filename": "llvm/lib/Transforms/Vectorize/VectorCombine.cpp", "functions": ["Attrs"]}]}
{"pr_number": 66853, "url": "https://github.com/llvm/llvm-project/pull/66853", "title": "[Sema] Fix fixit cast printing inside macros", "body": "`Lexer::getLocForEndOfToken` is documented as returning an invalid\r\nsource location when the end of the token is inside a macro expansion.\r\nWe don't want that for this particular application, so just calculate\r\nthe end location directly instead.\r\n\r\nBefore this, format fix-its would omit the closing parenthesis (thus\r\nproducing invalid code) for macros, e.g.:\r\n\r\n```\r\n$ cat format.cpp\r\nextern \"C\" int printf(const char *, ...);\r\nenum class Foo { Bar };\r\n#define LOG(...) printf(__VA_ARGS__)\r\nvoid f(Foo foo) { LOG(\"%d\\n\", foo); }\r\n\r\n$ clang -fsyntax-only format.cpp\r\nformat.cpp:4:29: warning: format specifies type 'int' but the argument has type 'Foo' [-Wformat]\r\n    4 | void f(Foo f) { LOG(\"%d\\n\", f); }\r\n      |                      ~~     ^\r\n      |                             static_cast<int>(\r\nformat.cpp:3:25: note: expanded from macro 'LOG'\r\n    3 | #define LOG(...) printf(__VA_ARGS__)\r\n      |                         ^~~~~~~~~~~\r\n1 warning generated.\r\n```\r\n\r\nWe now emit a valid fix-it:\r\n\r\n```\r\n$ clang -fsyntax-only format.cpp\r\nformat.cpp:4:31: warning: format specifies type 'int' but the argument has type 'Foo' [-Wformat]\r\n    4 | void f(Foo foo) { LOG(\"%d\\n\", foo); }\r\n      |                        ~~     ^~~\r\n      |                               static_cast<int>( )\r\nformat.cpp:3:25: note: expanded from macro 'LOG'\r\n    3 | #define LOG(...) printf(__VA_ARGS__)\r\n      |                         ^~~~~~~~~~~\r\n1 warning generated.\r\n```\r\n\r\nFixes https://github.com/llvm/llvm-project/issues/63462\r\n", "feature_layers": ["sema", "ir", "ast", "lexer"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/FixIt/format.cpp", "functions": ["a"]}]}
{"pr_number": 66110, "url": "https://github.com/llvm/llvm-project/pull/66110", "title": "[clang][AST][ASTImporter] improve AST comparasion on VarDecl & GotoStmt", "body": "improve AST comparasion on VarDecl & GotoStmt:\r\n\r\n1. VarDecl should not be ignored,\r\n2. GotoStmt has no children, it should be handle explicitly.", "feature_layers": ["ast"], "feature_directives": [], "files_changed": [{"filename": "clang/lib/AST/ASTStructuralEquivalence.cpp", "functions": ["IsStructurallyEquivalent", "IsStmtEquivalent"]}, {"filename": "clang/unittests/AST/StructuralEquivalenceTest.cpp", "functions": ["foo", "x"]}]}
{"pr_number": 66976, "url": "https://github.com/llvm/llvm-project/pull/66976", "title": "[clang][AST][ASTImporter] improve AST comparasion on VarDecl & GotoStmt", "body": "improve AST comparasion on VarDecl & GotoStmt:\r\n  1. VarDecl should not be ignored,\r\n  2. GotoStmt has no children, it should be handle explicitly.\r\n\r\nReviewed By: donat.nagy\r\n\r\nDifferential Revision: https://reviews.llvm.org/D159519", "feature_layers": ["ast"], "feature_directives": [], "files_changed": [{"filename": "clang/lib/AST/ASTStructuralEquivalence.cpp", "functions": ["IsStructurallyEquivalent", "IsStmtEquivalent"]}, {"filename": "clang/unittests/AST/StructuralEquivalenceTest.cpp", "functions": ["foo", "x"]}]}
{"pr_number": 65962, "url": "https://github.com/llvm/llvm-project/pull/65962", "title": "[AMDGPU] [SIFrameLowering] Use LiveRegUnits instead of LivePhysRegs", "body": "Enhanced liveness checks in LiveRegUnits and then used the modified LiveRegUnits to track liveness in SIFrameLowering.\r\nThe first commit is the enhancement to LiveRegUnits and the second commit changes the liveness tracking utility to LiveRegUnits in SIFrameLowering.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/SIFrameLowering.cpp", "functions": ["findUnusedRegister"]}]}
{"pr_number": 66041, "url": "https://github.com/llvm/llvm-project/pull/66041", "title": "[clang][AST] fix lack comparison of declRefExpr in ASTStructuralEquivalence", "body": "Fixes #66047\r\nBefore fix,the following testcase expected true. While I think only comparison of declName is not sufficient.Thanks for giving suggestions.\r\n```cpp\r\nTEST_F(StructuralEquivalenceStmtTest, DeclRefENoEq) {\r\n  std::string Prefix = \"enum Test { AAA, BBB };\";\r\n  auto t = makeStmts(\r\n      Prefix + \"void foo(int i) {if (i > 0) {i = AAA;} else {i = BBB;}}\",\r\n      Prefix + \"void foo(int i) {if (i > 0) {i = BBB;} else {i = AAA;}}\",\r\n      Lang_CXX03, ifStmt());\r\n  EXPECT_FALSE(testStructuralMatch(t)); // EXPECT_TRUE\r\n}\r\n```\r\n\r\n\r\n", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/AST/ASTStructuralEquivalence.cpp", "functions": ["IsStructurallyEquivalent", "IsStmtEquivalent"]}]}
{"pr_number": 66638, "url": "https://github.com/llvm/llvm-project/pull/66638", "title": "[mlir][VectorOps] Extend vector.constant_mask to support 'all true' scalable dims", "body": "This extends `vector.constant_mask` so that mask dim sizes that correspond to a scalable dimension are treated as if they're implicitly multiplied by vscale. Currently this is limited to mask dim sizes of 0 or the size of the dim/vscale. This allows constant masks to represent all true and all false scalable masks (and some variations):\r\n\r\n```\r\n// All true scalable mask\r\n%mask = vector.constant_mask [8] : vector<[8]xi1>\r\n\r\n// All false scalable mask\r\n%mask = vector.constant_mask [0] : vector<[8]xi1>\r\n\r\n// First two scalable rows\r\n%mask = vector.constant_mask [2,4] : vector<4x[4]xi1>\r\n```", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/Vector/IR/VectorOps.cpp", "functions": ["emitOpError"]}, {"filename": "mlir/lib/Dialect/Vector/Transforms/LowerVectorMask.cpp", "functions": ["values"]}]}
{"pr_number": 66925, "url": "https://github.com/llvm/llvm-project/pull/66925", "title": "[mlir][Interfaces] `LoopLikeOpInterface`:  Add helpers to get region iter_args and inits", "body": "`AffineForOp::getInitOperands` is renamed to `getInits` to be consistent with MLIR operand getter naming conventions. (\"get\" + operand name)", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Affine/IR/AffineOps.cpp", "functions": ["getIterOperands", "getInits"]}, {"filename": "mlir/lib/Dialect/SCF/IR/SCF.cpp", "functions": ["getBeforeArguments"]}]}
{"pr_number": 66692, "url": "https://github.com/llvm/llvm-project/pull/66692", "title": " [libc++] Add test coverage for unordered containers comparison", "body": "This patch is a melting pot of changes picked up from https://llvm.org/D61878. It adds a few tests checking corner cases of unordered containers comparison and adds benchmarks for a few unordered_set operations.", "feature_layers": [], "feature_directives": ["for", "ordered"], "files_changed": [{"filename": "libcxx/test/std/containers/unord/unord.multiset/eq.pass.cpp", "functions": ["c1", "c2", "operator"]}]}
{"pr_number": 66994, "url": "https://github.com/llvm/llvm-project/pull/66994", "title": "sve gather scatter offset sinking", "body": "- [flang] Add comdats to functions with linkonce linkage (#66516)\n- [clang][TSA] Thread safety cleanup functions\n- [SPIRV] Test basic float and int types (#66282)\n- [mlgo] Fix tests post PR #66334\n- [libunwind][AIX] Fix up TOC register if unw_getcontext is called from a different module (#66549)\n- [RISCV] Recognize veyron-v1 processor in clang driver. (#66703)\n- [RISCV] Add a combine to form masked.store from unit strided store\n- [SROA] Remove unnecessary IsStorePastEnd handling (NFCI)\n- In ExprRequirement building, treat OverloadExpr as dependent (#66683)\n- [mlir][SCF] `ForOp`: Remove `getIterArgNumberForOpOperand` (#66629)\n- [mlir][Interfaces] `LoopLikeOpInterface`: Support ops with multiple regions (#66754)\n- [DAGCombiner] Combine vp.strided.load with unit stride to vp.load (#66766)\n- [DAGCombiner] Combine vp.strided.store with unit stride to vp.store (#66774)\n- [TwoAddressInstruction] Use isPlainlyKilled in processTiedPairs (#65976)\n- [RISCV] Fix bad isel predicate handling for Ztso. (#66739)\n- [libc][math] Extract non-MPFR math tests into libc-math-smoke-tests.\n- [lit] Drop \"Script:\", make -v and -a imply -vv\n- [lit] Improve test output from lit's internal shell\n- [lit] Echo full RUN lines in case of external shells (#66408)\n- [RISCV] Add a pass to rewrite rd to x0 for non-computational instrs whose return values are unused\n- [mlir][spirv][gpu] Convert remaining wmma ops to KHR coop matrix (#66455)\n- [mlir][sparse] More allocate -> empty tensor migration (#66720)\n- [gn build] Port 93fde2ea1b2c\n- [RISCV] Add more instructions for the short forward branch optimization. (#66789)\n- [SSP] Accessing __stack_chk_guard when using LTO (#66535)\n- [RISCV] Expand test coverage for widening gather and strided load idioms\n- [lldb][NFCI] Remove unneeded ConstString from intel-pt plugin (#66721)\n- [lldb][NFCI] Remove unneccessary allocation in ScriptInterpreterPythonImpl::GetSyntheticTypeName (#66724)\n- [Profile] Delete coverage-debug-info-correlate.cpp test on mac as debug info correlation not working on mac for unkown reasons.\n- [lldb] Fix build after d5a62b78b8ae\n- [flang][hlfir] Fixed assignment/finalization order for user-defined assignments. (#66736)\n- [RISCV] Require alignment when forming gather with larger element type\n- Addressed review comments to use ThreadSafe instead of !ThreadSafe\n- [flang] Follow memory source through more operations (#66713)\n- [X86] Use RIP-relative addressing for data under large data threshold for medium code model\n- Fix a bug with cancelling \"attach -w\" after you have run a process previously (#65822)\n- Let the c(xx)_status pages reflect that clang 17 is released\n- Revert \"[flang][hlfir] Fixed assignment/finalization order for user-defined assignments. (#66736)\"\n- Revert \"Revert \"[flang][hlfir] Fixed assignment/finalization order for user-defined assignments. (#66736)\"\"\n- [ORC] Add writePointers to ExecutorProcessControl's MemoryAccess\n- [Coverage] Skip visiting ctor member initializers with invalid source locations.\n- [SLP]Fix PR66795: Check correct deps for vectorized inst with multiple vectorized node uses.\n- [github] Make branch workflow more robust (#66781)\n- [flang] Correct handling of assumed-rank allocatables in ALLOCATE (#66718)\n- [BOLT][runtime] Test for outline-atomics support\n- [mlir][spirv] Add conversions for Arith's `maxnumf` and `minnumf` (#66696)\n- [libc++][NFC] Clean up std::__call_once\n- [libc][cmake] Tidy compiler includes (#66783)\n- [OpenMP][Docs][NFC] Update documentation\n- [RISCV] Match strided load via DAG combine (#66800)\n- [llvm-nm] Add --line-numbers flag\n- Revert \"[libc][cmake] Tidy compiler includes (#66783)\" (#66822)\n- [-Wunsafe-bugger-usage] Clean tests: remove nondeterministic ordering\n- [mlir][sparse][gpu] free all buffers allocated for spGEMM (#66813)\n- [llvm][docs] Update active CoC Commitee members (#66814)\n- Explicitly set triple on line-numbers.test\n- [AsmPrint] Dump raw frequencies in `-mbb-profile-dump` (#66818)\n- [Clang] Static member initializers are not immediate escalating context. (#66021)\n- [mlir][spirv] Suffix NV cooperative matrix props with `_nv` (#66820)\n- [mlir][spirv] Define KHR cooperative matrix properties (#66823)\n- [lit] Fix a test fail under windows\n- [InstrProf][compiler-rt] Enable MC/DC Support in LLVM Source-based Code Coverage (1/3)\n- [AMDGPU] Use inreg for hint to preload kernel arguments\n- [EarlyCSE] Compare GEP instructions based on offset (#65875)\n- [libc++] Fix __threading_support when used with C11 threading (#66780)\n- [clang] Improve CI output when trailing whitespace is found (#66649)\n- [libc] Fix printf config not working (#66834)\n- [lit] Apply aa71680f2948's fix to an additional test\n- [AMDGPU] Add ASM and MC updates for preloading kernargs\n- [bazel] Port c649f29c24c9fc1502d8d53e0c96c3d24b31de1a (llvm-nm --line-numbers)\n- Fix test added in D150987 to account for different path separators which was causing the test to fail on Windows.\n- [SimplifyCFG] Pre-commit test for extending HoistThenElseCodeToIf.\n- [SimplifyCFG] Hoist common instructions on Switch.\n- [IR] Add \"Large Data Threshold\" module metadata (#66797)\n- A test was changing directory and then incorrectly restoring the directory to the \"testdir\" which is the build directory for that test, not the original source directory.  That caused subsequent tests to fail.\n- [mlir][sparse] unifies sparse_tensor.sort_coo/sort into one operation. (#66722)\n- [Docs] Fix table after previous document update\n- [Sparc] Remove LEA instructions (NFCI) (#65850)\n- [lldb][NFCI] Remove unused struct ConstString::StringIsEqual\n- [builtins][NFC] Avoid using CRT_LDBL_128BIT in tests (#66832)\n- [RISCV] Prefer Zcmp push/pop instead of save-restore calls. (#66046)\n- [DependencyScanningFilesystem] Make sure the local/shared cache filename lookups use only absolute paths (#66122)\n- [NFC][hwasan] Make ShowHeapOrGlobalCandidate a method (#66682)\n- [NFC][hwasan] Find overflow candidate early (#66682)\n- [NFC][hwasan] Clang-format c557621176f5f38b5757a325cc72be0a11a91c78\n- [NFC][hwasan] Extract a few BaseReport::Copy methods (#66682)\n- [NFC][hwasan] Extract announce_by_id (#66682)\n- [NFC][hwasan] Collect heap allocations early (#66682)\n- [libc++] Warn if an unsupported compiler is used\n- [ELF][test] Improve tests about non-SHF_ALLOC sections relocated by non-ABS relocations\n- [ELF] Remove a R_ARM_PCA special case from relocateNonAlloc\n- [clang][dataflow] Reorder checks to protect against a null pointer dereference. (#66764)\n- [MC,X86] Property report error for modifiers with incorrect size\n- [RISCV] Install sifive_vector.h to riscv-resource-headers (#66330)\n- [InferAlignment] Create tests for InferAlignment pass\n- [InferAlignment] Implement InferAlignmentPass\n- [InstCombine] Use a cl::opt to control calls to getOrEnforceKnownAlignment in LoadInst and StoreInst\n- [InferAlignment] Enable InferAlignment pass by default\n- [ELF][test] Improve -r tests for local symbols\n- [mlir][IR] Trigger `notifyOperationRemoved` callback for nested ops (#66771)\n- [Workflow] Add new code format helper. (#66684)\n- [gn build] Port 0f152a55d3e4\n- [RISCV] Fix bugs about register list of Zcmp push/pop. (#66073)\n- [AMDGPU] Run twoaddr tests with -early-live-intervals (#66775)\n- [TableGen][GlobalISel] Use `GIM_SwitchOpcode` in Combiners (#66864)\n- [NFC][InferAlignment] Swap extern declaration and definition of EnableInferAlignmentPass\n- [flang] Prevent IR name clashes between BIND(C) and external procedures (#66777)\n- Revert \"[Workflow] Add new code format helper. (#66684)\"\n- [lldb][Docs] Fix typo in style docs\n- [clang-format][NFC] Clean up signatures of some parser functions (#66569)\n- Revert \"Fix a bug with cancelling \"attach -w\" after you have run a process previously (#65822)\"\n- [OpenMP][VE] Limit the number of threads to create (#66729)\n- [SimpleLoopUnswitch] Fix reversed branch during condition injection\n- [mlir][vector] Make ReorderElementwiseOpsOnBroadcast support vector.splat (#66596)\n- [lldb][AArch64] Add SME's streaming vector control register\n- [reland][libc][cmake] Tidy compiler includes (#66783) (#66878)\n- [GuardUtils] Revert llvm::isWidenableBranch change (#66411)\n- [LLVM] convergence verifier should visit all instructions (#66200)\n- [lldb][API] Remove debug print in TestRunLocker.py\n- [clang] [C23] Fix crash with _BitInt running clang-tidy (#65889)\n- [Flang][OpenMP] Move FIR lowering tests to a separate directory (#66779)\n- [RISCV] Add missing V extensions for zvk-invalid-features.c (#66875)\n- [mlir][gpu][bufferization] Implement BufferDeallocationOpInterface for gpu.terminator (#66880)\n- [analyzer] Fix crash analyzing _BitInt() in evalIntegralCast (#66782)\n- [IR] Fix a memory leak if Function::dropAllReferences() is followed by setHungoffOperand\n- [X86] vector-interleaved tests - add AVX512-SLOW/AVX512-FAST common prefixes to reduce duplication\n- [X86] combineINSERT_SUBVECTOR - attempt to combine concatenated shuffles\n- [X86] Add test cases for gnux32 large constants Issue #55061\n- [NFC][Clang] Address reviews about overrideFunctionFeaturesWithTargetFeatures (#65938)\n- [analyzer] Fix StackAddrEscapeChecker crash on temporary object fields (#66493)\n- [VE] Add unittest for intrinsics (#66730)\n- [NFC][AMDGPU] Perform a single lookup in map in SIInsertWaitcnts::isPreheaderToFlush\n- [NFC][AMDGPU] Remove redundant hasSideEffects=1\n- [SROA] Don't shrink volatile load past end\n- [mlir][bufferization][scf] Implement BufferDeallocationOpInterface for scf.reduce.return (#66886)\n- [RISCV] Add tests where bin ops of splats could be scalarized. NFC (#65747)\n- [clang][Interp][NFC] Small code refactoring\n- [Docs] Update ExceptionHandling example (NFC)\n- [mlir][bufferization][NFC] Move memref specific implementation of AllocationOpInterface to memref dialect directory (#66637)\n- [X86] Align other variants to use void * as 512 variants. (#66310)\n- [X86] Fix an assembler bug of CMPCCXADD. (#66748)\n- [clang][dataflow] Identify post-visit state changes in the HTML logger. (#66746)\n- [MLIR][Presburger] Template Matrix to allow MPInt and Fraction; use IntMatrix for integer matrices (#66897)\n- [SPIR-V] Fix 64-bit integer literal printing (#66686)\n- [libc++] Simplify how the global stream tests are written (#66842)\n- [AArch64][SME] Enable TPIDR2 lazy-save for za_preserved\n- [X86] X86DAGToDAGISel::matchIndexRecursively - replace hard coded recursion limit with SelectionDAG::MaxRecursionDepth. NFCI.\n- [libc++] Sort available features before printing them\n- [mlir][VectorOps] Extend vector.constant_mask to support 'all true' scalable dims (#66638)\n- Warn on align directive with non-zero fill value in virtual sections (#66792)\n- [VE] Add TargetParser to CMakeLists.txt for VE unittest\n- [lldb-vscode] Use auto summaries whenever variables don't have a summary (#66551)\n- Revert \"[clang] Don't inherit dllimport/dllexport to exclude_from_explicit_instantiation members during explicit instantiation (#65961)\"\n- [AMDGPU] Convert tests rotr.ll and rotl.ll to be auto-generated (#66828)\n- [NFC] Fix spelling 'constanst' -> 'constants'\n- [mlir][Vector] Add fastmath flags to vector.reduction (#66905)\n- [lldb][AArch64] Invalidate cached VG value before reconfiguring SVE registers\n- [gn] Add dummy build file for VETests\n- [SPIRV] Fix OpConstant float and double printing\n- [flang][hlfir] Fixed cleanup code placement indeterminism in OrderedAssignments. (#66811)\n- [AMDGPU] Regenerate always-uniform.ll\n- [X86] Regenerate pr39098.ll\n- [ELF][test] Add a test to demonstrate #66836\n- [NFC][AsmPrinter] Refactor FrameIndexExprs as a std::set (#66433)\n- [ELF] Postpone \"unable to move location counter backward\" error (#66854)\n- [clang][CodeGen] The `eh_typeid_for` intrinsic needs special care too (#65699)\n- [AArch64][GlobalISel] Adopt dup(load) -> LD1R patterns from SelectionDAG\n- Cleanup fallback NOT checks\n- [AArch64] Add some tests for setcc known bits fold. NFC\n- [SelectionDAG] [NFC] Add pre-commit test for PR66701. (#66796)\n- [Driver] Some improvements for path handling on NetBSD (#66863)\n- [mlir][sparse] remove most bufferization.alloc_tensor ops from sparse (#66847)\n- [mlir] Bazel fixes for 1b8b55644313216e6b0fa233bbd8b01fee23f99f (#66929)\n- [mlir] introduce transform.loop.forall_to_for (#65474)\n- [mlir] regenerate linalg named ops yaml (#65475)\n- [SLP]Fix a crash when trying to find operand with re-vectorized main instruction.\n- [libc][Obvious] Fix incorrect RPC opcode for `clearerr`\n- [SVE][CodeGenPrepare] Sink address calculations that match SVE gather/scatter addressing modes.\n", "feature_layers": ["parse", "codegen", "runtime", "ir", "ast", "parser"], "feature_directives": ["for", "sections", "single", "atomic", "flush", "ordered", "target", "allocate", "masked"], "files_changed": [{"filename": "llvm/lib/Target/AArch64/AArch64ISelLowering.cpp", "functions": ["shouldSinkVectorOfPtrs"]}]}
{"pr_number": 65715, "url": "https://github.com/llvm/llvm-project/pull/65715", "title": "[AMDGPU] Remove Code Object V2", "body": "Code Object V2 has been deprecated for more than a year now. We can safely remove it from LLVM.\r\n\r\n- [clang] Remove support for the `-mcode-object-version=2` option.\r\n- [lld] Remove/refactor tests that were still using COV2\r\n- [llvm] Update AMDGPUUsage.rst\r\n   - Code Object V2 docs are left for informational purposes because those code objects may still be supported by the runtime/loaders for a while.\r\n- [AMDGPU] Remove COV2 emission capabilities.\r\n- [AMDGPU] Remove `MetadataStreamerYamlV2` which was only used by COV2\r\n- [AMDGPU] Update all tests that were still using COV2 - They are either deleted or ported directly to code object v4 (as v3 is also planned to be removed soon).", "feature_layers": ["runtime", "ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/AMDGPUHSAMetadataStreamer.cpp", "functions": ["if"]}, {"filename": "llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp", "functions": ["Error", "ParseDirectiveHSAMetadata"]}, {"filename": "llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.cpp", "functions": ["isHsaAbi", "isHsaAbiVersion3AndAbove", "isHsaAbiVersion2", "isHsaAbiVersion3"]}]}
{"pr_number": 66435, "url": "https://github.com/llvm/llvm-project/pull/66435", "title": "[NFC][AsmPrinter] Refactor constructVariableDIE", "body": "Fold constructVariableDIEImpl into constructVariableDIE, simplify it and group related functions.\r\n\r\nPull out the previously inline lambdas for visiting the active variant of the DbgVariable to add location and related attributes as an overload set for a private method\r\napplyConcreteDbgVariableAttributes.\r\n\r\nRename applyVariableAttribute to reflect what kinds of attributes it applies, and to contrast it with the new\r\napplyConcreteDbgVariableAttributes.\r\n\r\nMove constructLabelDIE down in the implementation file, so all of the constructVariableDIE-related function impls are adjacent.", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp", "functions": ["AddEntry", "Cursor", "DwarfExpr"]}]}
{"pr_number": 67015, "url": "https://github.com/llvm/llvm-project/pull/67015", "title": "[mlir][Interfaces] Clean up `DestinationStyleOpInterface`", "body": "* \"init\" operands are specified with `MutableOperandRange` (which gives access to the underlying `OpOperand *`). No more magic numbers.\r\n* Remove most interface methods and make them helper functions. Only `getInitsMutable` should be implemented.\r\n* Provide separate helper functions for accessing mutable/immutable operands (`OpOperand`/`Value`, in line with #66515): `getInitsMutable` and `getInits` (same naming convention as auto-generated op accessors). `getInputOperands` was not renamed because this function cannot return a `MutableOperandRange` (because the operands are not necessarily consecutive). `OpOperandVector` is no longer needed.\r\n* The new `getDpsInits`/`getDpsInitsMutable` is more efficient than the old `getDpsInitOperands` because no `SmallVector` is created. The new functions return a range of operands.\r\n* Fix a bug in `getDpsInputOperands`: out-of-bounds operands were potentially returned.\r\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Linalg/IR/LinalgOps.cpp", "functions": ["outputOperands"]}, {"filename": "mlir/lib/Dialect/Linalg/Transforms/SplitReduction.cpp", "functions": ["newInputs"]}, {"filename": "mlir/tools/mlir-linalg-ods-gen/mlir-linalg-ods-yaml-gen.cpp", "functions": ["getOutputsMutable", "getDpsInitsMutable"]}]}
{"pr_number": 66700, "url": "https://github.com/llvm/llvm-project/pull/66700", "title": "[libc] Remove the 'rpc_reset' routine from the RPC implementation", "body": "Summary:\nThis patch removes the `rpc_reset` function. This was previously used to\ninitialize the RPC client on the device by setting up the pointers to\ncommunicate with the server. The purpose of this was to make it easier\nto initialize the device for testing. However, this prevented us from\nenforcing an invariant that the buffers are all read-only from the\nclient side.\n\nThe expected way to initialize the server is now to copy it from the\nhost runtime. This will allow us to maintain that the RPC client is in\nthe constant address space on the GPU, potentially through inference,\nand improving caching behaviour.\n", "feature_layers": ["runtime"], "feature_directives": ["for"], "files_changed": [{"filename": "libc/test/src/__support/RPC/rpc_smoke_test.cpp", "functions": ["ProcB", "ProcA"]}, {"filename": "libc/utils/gpu/server/rpc_server.cpp", "functions": ["buffer", "reset"]}]}
{"pr_number": 66511, "url": "https://github.com/llvm/llvm-project/pull/66511", "title": "[mlir][memref][transform] Add new alloca_to_global op.", "body": "This PR adds a new transform op that replaces `memref.alloca`s with `memref.get_global`s to newly inserted `memref.global`s. This is useful, for example, for allocations that should reside in the shared memory of a GPU, which have to be declared as globals.", "feature_layers": ["ir"], "feature_directives": ["for", "declare"], "files_changed": [{"filename": "mlir/lib/Dialect/MemRef/TransformOps/MemRefTransformOps.cpp", "functions": ["symbolTable", "Twine", "emitDefiniteFailure"]}]}
{"pr_number": 66920, "url": "https://github.com/llvm/llvm-project/pull/66920", "title": "[mlir][Interfaces][NFC] Better documentation for `RegionBranchOpInterface`", "body": "Update outdated documentation and add an example.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/SCF/IR/SCF.cpp", "functions": ["getInits"]}, {"filename": "mlir/lib/Interfaces/ControlFlowInterfaces.cpp", "functions": ["printRegionEdgeName"]}]}
{"pr_number": 66689, "url": "https://github.com/llvm/llvm-project/pull/66689", "title": "Reland: [sanitizer_symbolizer] Add StackTracePrinter virtual class", "body": "Introduce a new virtual class StackTracePrinter and an implementation\r\nFormattedStackTracePrinter in preparation of enabling symbolizer markup\r\nfor linux.\r\nThis change allows us to implement other behaviour under the same api\r\nfor StackTracePrinter, for example, MarkupStackTracePrinter.\r\n\r\nReason for revert: A missing header file for the sanitizer_symbolizer_markup.cpp files. \r\nThis was not caught in local builds or pre-merge checks given that to trigger the error, the code\r\nhas to be compiled for Fuchsia.\r\nFor this reland I've build for the fuchsia targets as well as linux.", "feature_layers": ["ir"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "compiler-rt/lib/sanitizer_common/sanitizer_stacktrace_printer.cpp", "functions": ["l", "RenderNeedsSymbolization"]}, {"filename": "compiler-rt/lib/sanitizer_common/sanitizer_symbolizer_markup.cpp", "functions": ["RenderNeedsSymbolization"]}]}
{"pr_number": 65306, "url": "https://github.com/llvm/llvm-project/pull/65306", "title": "[AArch64] Separate PNR into its own Register Class", "body": "This patch separates PNR registers into their own register class instead of sharing a register class with PPR registers. This primarily allows us to return more accurate register classes when applying assembly constraints, but also more protection from supplying an incorrect predicate type to an invalid register operand.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp", "functions": ["addPNRasPPRRegOperands"]}, {"filename": "llvm/lib/Target/AArch64/Disassembler/AArch64Disassembler.cpp", "functions": ["DecodePPRRegisterClass", "DecodePNRRegisterClass"]}]}
{"pr_number": 66960, "url": "https://github.com/llvm/llvm-project/pull/66960", "title": "[mlir][index] Implement folders for CastSOp and CastUOp", "body": "Fixes https://github.com/llvm/llvm-project/issues/66402", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/unittests/Dialect/Index/IndexOpsFoldersTest.cpp", "functions": ["foldOp", "state"]}]}
{"pr_number": 66945, "url": "https://github.com/llvm/llvm-project/pull/66945", "title": "[NVPTX] improve lowering for common byte-extraction operations.", "body": "Some critical code paths we have depend on efficient byte extraction from data loaded as integers.\r\nBy default LLVM tries to extract by storing/loading from stack, which is very inefficient on GPU.\r\n", "feature_layers": [], "feature_directives": ["for", "critical"], "files_changed": [{"filename": "llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp", "functions": ["SDValue", "DL", "PerformEXTRACTCombine"]}]}
{"pr_number": 66277, "url": "https://github.com/llvm/llvm-project/pull/66277", "title": "[libc] Template the printf / scanf parser class", "body": "Summary:\r\nThe parser class for stdio currently accepts different argument\r\nproviders. In-tree this is only used for a fuzzer test, however, the\r\nproposed implementation of the GPU handling of printf / scanf will\r\nrequire custom argument handlers. This makes the current approach of\r\nusing a preprocessor macro messier. This path proposed folding this\r\nlogic into a template instantiation. The downside to this is that\r\nbecause the implementation of the parser class is placed into an\r\nimplementation file we need to manually instantiate the needed templates\r\nwhich will slightly bloat binary size. Alternatively we could remove the\r\nimplementation file, or key off of the `libc` external packaging macro\r\nso it is not present in the installed version.\r\n", "feature_layers": ["parse", "ir", "parser"], "feature_directives": ["for"], "files_changed": [{"filename": "libc/src/stdio/printf_core/parser.cpp", "functions": ["if"]}, {"filename": "libc/src/stdio/printf_core/printf_main.cpp", "functions": ["parser"]}, {"filename": "libc/src/stdio/scanf_core/scanf_main.cpp", "functions": ["parser"]}, {"filename": "libc/test/src/stdio/printf_core/parser_test.cpp", "functions": ["parser", "v"]}, {"filename": "libc/test/src/stdio/scanf_core/parser_test.cpp", "functions": ["parser", "v"]}]}
{"pr_number": 66308, "url": "https://github.com/llvm/llvm-project/pull/66308", "title": "[lldb] Add 'modify' type watchpoints, make it default", "body": "Watchpoints in lldb can be either 'read', 'write', or 'read/write'.  This is exposing the actual behavior of hardware watchpoints.  gdb has a different behavior: a \"write\" type watchpoint only stops when the watched memory region *changes*.\r\n\r\nA user is using a watchpoint for one of three reasons:\r\n\r\n1. Want to find what is changing/corrupting this memory.\r\n3. Want to find what is reading from this memory.\r\n2. Want to find what is writing to this memory.\r\n\r\nI believe (1) is the most common use case for watchpoints, and it currently can't be done in lldb -- the user needs to continue every time the same value is written to the watched-memory manually.  I think gdb's behavior is the correct one.  There are some use cases where a developer wants to find every function that writes/reads to/from a memory region, regardless of value, I want to still allow that functionality.\r\n\r\nThis is also a bit of groundwork for my large watchpoint support proposal\r\nhttps://discourse.llvm.org/t/rfc-large-watchpoint-support-in-lldb/72116 where I will be adding support for AArch64 MASK watchpoints which watch power-of-2 memory regions.  A user might ask to watch 24 bytes, and a MASK watchpoint stub can do this with a 32-byte MASK watchpoint if it is properly aligned. And we need to ignore writes to the final 8 bytes of that watched region, and not show those hits to the user.\r\n\r\nThis patch adds a new 'modify' watchpoint type and it is the default.\r\n\r\nThe part of this patch I think is the most questionable is the\r\nSBTarget::CreateWatchpoint(addr, size, bool read, bool write, error) which I currently change the meaning of write==True to be Modify.  This is part of making 'modify' the default watchpoint type - a driver is likely setting write==True for its watchpoints.\r\n\r\nI chatted with Alex and Jim about this a little and I'm not sure how I should solve this for real.  Add a new SBTarget::CreateWatchpoint API with a third `bool modify` argument in addition to the old one? Add a new SBWatchpointOptions class in case we want to add more types of watchpoints?  I'm not sure what other types of watchpoints we'd want to hardcode in our support.  We have conditional expressions or python callbacks that can do more unique operations.\r\n\r\nThere's more work here - the SB API needs to give the driver a way to specify all three possible types of watchpoint ('write' and 'modify' being exclusive of the other) - but I'd love to hear what other people think we should do for this API especially.", "feature_layers": ["ir"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "lldb/source/Breakpoint/Watchpoint.cpp", "functions": ["g_watch_name", "watch_name"]}, {"filename": "lldb/test/API/functionalities/watchpoint/modify-watchpoints/main.c", "functions": ["main"]}, {"filename": "lldb/source/API/SBTarget.cpp", "functions": ["WatchpointCreateByAddress"]}, {"filename": "lldb/source/API/SBWatchpointOptions.cpp", "functions": ["m_opaque_up"]}]}
{"pr_number": 66682, "url": "https://github.com/llvm/llvm-project/pull/66682", "title": "[hwasan] Store some report data early", "body": "Please review them one by one in order, and let me know which are OK.\r\nIt's mostly code shuffling.\r\n\r\nThe goal is to make HWASA collect all needed info the first, and printout later.\r\nThis way we avoid the printing changes HWASAN metadata.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "compiler-rt/lib/hwasan/hwasan_report.cpp", "functions": ["FindMismatchOffset"]}]}
{"pr_number": 66861, "url": "https://github.com/llvm/llvm-project/pull/66861", "title": "[HWASAN] Prevent SEGV in report near inaccessible memory", "body": "We can't use IsAccessibleMemoryRange on short granule check because of\nperformance impact. However we can prevent crashing if report prints out\n\"Tags for short granules around the buggy address\".\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "compiler-rt/test/hwasan/TestCases/report-unmapped.cpp", "functions": ["main"]}]}
{"pr_number": 66178, "url": "https://github.com/llvm/llvm-project/pull/66178", "title": "[PGO]add bitcode-use-sample-profile", "body": "When use bitcode file as input and use \"-fprofile-sample-use\" first. Function don't has \"use-sample-profile\" attribute and then \"buildFunctionOrder\" return empty vector.\r\nWhen \"bitcode-use-sample-profile\" enable, add \"use-sample-profile\" to function and make it can do optimation about pgo.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/Transforms/IPO/SampleProfile.cpp", "functions": ["hasSampleProfile"]}]}
{"pr_number": 66358, "url": "https://github.com/llvm/llvm-project/pull/66358", "title": "[analyzer] Fix taint sink rules for exec-like functions", "body": "Variadic arguments were not considered as taint sink arguments. I also decided to extend the list of exec-like functions.\r\n\r\n(Juliet CWE78_OS_Command_Injection__char_connect_socket_execl)\r\n\r\n---\r\n\r\nThis commit was split off from PR https://github.com/llvm/llvm-project/pull/66074 as requested.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/Analysis/taint-generic.c", "functions": ["execv", "fexecve", "execlp", "execvpe", "pclose", "execvp", "execve", "test_exec_like_functions", "system", "coin", "execl", "execle"]}]}
{"pr_number": 65778, "url": "https://github.com/llvm/llvm-project/pull/65778", "title": "[Clang][RISCV] Use Decl for checkRVVTypeSupport", "body": "Using ValueDecl will cause error for OpenMP. Decl should do the work.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/SemaOpenMP/riscv-vector-with-openmp.c", "functions": ["foo"]}]}
{"pr_number": 67036, "url": "https://github.com/llvm/llvm-project/pull/67036", "title": "[flang] Deallocate local allocatable at end of their scopes", "body": "Implement automatic deallocation of unsaved local alloctables when reaching the end of their scope of block as described in Fortran 2018 9.7.3.2 point 2. and 3.\r\n\r\nUses genDeallocateIfAllocated used for intent(out) deallocation and the \"function context\" already used for finalization at end of scope.", "feature_layers": ["ir"], "feature_directives": ["for", "allocate"], "files_changed": [{"filename": "flang/lib/Lower/ConvertVariable.cpp", "functions": ["hasFinalization", "needEndFinalization"]}]}
{"pr_number": 66715, "url": "https://github.com/llvm/llvm-project/pull/66715", "title": "[clang] Enable descriptions for --print-supported-extensions", "body": "Enables summary descriptions along with the names of the feature.\r\nDescriptions here are simply looked up via the available llvm tablegen data.\r\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Support/RISCVISAInfo.cpp", "functions": ["format"]}, {"filename": "llvm/lib/TargetParser/AArch64TargetParser.cpp", "functions": ["format"]}, {"filename": "llvm/lib/TargetParser/ARMTargetParser.cpp", "functions": ["format"]}]}
{"pr_number": 66757, "url": "https://github.com/llvm/llvm-project/pull/66757", "title": "[clangd] Allow --query-driver to match a dot-normalized form of the path", "body": "(In addition to the un-normalized form, so this is back-compatible)\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang-tools-extra/clangd/SystemIncludeExtractor.cpp", "functions": ["NoDots"]}]}
{"pr_number": 66424, "url": "https://github.com/llvm/llvm-project/pull/66424", "title": "[dataflow] Parse formulas from text", "body": "My immediate use for this is not in checked-in code, but rather the\nability to plug printed flow conditions (from analysis logs) back into\nsat solver unittests to reproduce slowness.\n\nIt does allow simplifying some of the existing solver tests, though.\n", "feature_layers": ["parse"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Analysis/FlowSensitive/Arena.cpp", "functions": ["Offset", "Formula"]}, {"filename": "clang/unittests/Analysis/FlowSensitive/SolverTest.cpp", "functions": ["parseAll", "solver"]}]}
{"pr_number": 66672, "url": "https://github.com/llvm/llvm-project/pull/66672", "title": "[AArch64][SVE2] Do not emit RSHRNB for large shifts", "body": "rshrnb's shift amount operand must be between 1-EltSizeInBits. This patch stops RSHRNB ISD nodes being emitted in this case", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AArch64/AArch64ISelLowering.cpp", "functions": ["SDValue"]}]}
{"pr_number": 65440, "url": "https://github.com/llvm/llvm-project/pull/65440", "title": "[MLIR][NVGPU] Adding `nvgpu.warpgroup.mma` Op for Hopper GPUs", "body": "This work introduces a new operation called `warpgroup.mma` to the NVGPU dialect of MLIR. The purpose of this operation is to facilitate warpgroup-level matrix multiply and accumulate (WGMMA) operations on Hopper GPUs with sm_90a architecture.\r\n\r\nPreviously, the `nvvm.wgmma.mma_async` operation was introduced to support warpgroup-level matrix operations in NVVM dialect. This op is used multiple instances of `nvvm.wgmma.mma_async` to achieve the desired shape. The new `nvgpu.warpgroup.mma` operation abstracts this complexity and provides a higher-level interface for performing warpgroup-level matrix operations.\r\n\r\nThe `nvgpu.warpgroup.mma` does followings:\r\n1) Corresponds multiple `wgmma` instructions.\r\n2) Iterates input matrix descriptors to achieve the desired computation shape. 3) Groups and runs `wgmma` instructions asynchronously, and eventually waits them. This are done by `wgmma.fence.aligned`, `wgmma.commit.group.sync.aligned`, and `wgmma.wait.group.sync.aligned` 4) Results fragmented matrices\r\n\r\nHere's an example usage of the `nvgpu.warpgroup.mma` operation:\r\n```\r\n%wgmmaResult, %wgmmaResult2 = nvgpu.warpgroup.mma %descA, %descB, %acc1, %acc2 {transposeB}: \r\n      !nvgpu.wgmma.descriptor<tensor = memref<128x64xf16, 3>>, \r\n      !nvgpu.wgmma.descriptor<tensor = memref<64x128xf16, 3>>, \r\n      !nvgpu.warpgroup.accumulator< fragmented = vector<64x128xf32>>,\r\n      !nvgpu.warpgroup.accumulator< fragmented = vector<64x128xf32>> \r\n      -> \r\n      !nvgpu.warpgroup.accumulator< fragmented = vector<64x128xf32>>, \r\n      !nvgpu.warpgroup.accumulator< fragmented = vector<64x128xf32>>  \r\n```\r\n\r\nThe op will result following PTX:\r\n```\r\nwgmma.fence.sync.aligned;\r\nwgmma.mma_async.sync.aligned.m64n128k16.f32.f16.f16 {%f1, %f2,    62 more registers}, %descA,     %descB,     p, 1, 1, 0, 1;\r\nwgmma.mma_async.sync.aligned.m64n128k16.f32.f16.f16 {%f1, %f2,    62 more registers}, %descA+2,   %descB+128, p, 1, 1, 0, 1;\r\nwgmma.mma_async.sync.aligned.m64n128k16.f32.f16.f16 {%f1, %f2,    62 more registers}, %descA+4,   %descB+256, p, 1, 1, 0, 1;\r\nwgmma.mma_async.sync.aligned.m64n128k16.f32.f16.f16 {%f1, %f2,    62 more registers}, %descA+8,   %descB+348, p, 1, 1, 0, 1;\r\nwgmma.mma_async.sync.aligned.m64n128k16.f32.f16.f16 {%f500,%f501, 62 more registers}, %descA+512, %descB,     p, 1, 1, 0, 1;\r\nwgmma.mma_async.sync.aligned.m64n128k16.f32.f16.f16 {%f500,%f501, 62 more registers}, %descA+514, %descB+128, p, 1, 1, 0, 1;\r\nwgmma.mma_async.sync.aligned.m64n128k16.f32.f16.f16 {%f500,%f501, 62 more registers}, %descA+516, %descB+256, p, 1, 1, 0, 1;\r\nwgmma.mma_async.sync.aligned.m64n128k16.f32.f16.f16 {%f500,%f501, 62 more registers}, %descA+518, %descB+348, p, 1, 1, 0, 1;\r\nwgmma.commit_group.sync.aligned;\r\nwgmma.wait_group.sync.aligned 1;\r\n```\r\n\r\nThe Op keeps \r\n  - first 64 registers (`{%f1, %f2,    62 more registers}`) -> `%acc1` \r\n  - second 64 registers (`{%f500,%f501, 62 more registers}`)  -> `%acc2`. \r\n\r\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Conversion/NVGPUToNVVM/NVGPUToNVVM.cpp", "functions": ["failure", "makeAdd"]}, {"filename": "mlir/lib/Dialect/NVGPU/IR/NVGPUDialect.cpp", "functions": ["emitOpError"]}]}
{"pr_number": 67115, "url": "https://github.com/llvm/llvm-project/pull/67115", "title": "[MLIR][UB] Add inliner interface for UB dialect", "body": "This revision adds an inliner interface to the UB dialect that allows inlining of `ub.poison` operations.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/UB/IR/UBOps.cpp", "functions": ["isLegalToInline"]}]}
{"pr_number": 66485, "url": "https://github.com/llvm/llvm-project/pull/66485", "title": "[include-cleaner] Respect the UsingShadowDecl when find headers for ambiguous std symbols.", "body": "In libcpp, the `std::remove(const char*)` is a using decl in std namespace `using ::remove`, which was not handled correctly in `headerForAmbiguousStdSymbol`", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang-tools-extra/include-cleaner/unittests/FindHeadersTest.cpp", "functions": ["remove", "VisitDeclRefExpr", "k"]}]}
{"pr_number": 67128, "url": "https://github.com/llvm/llvm-project/pull/67128", "title": "[mlir][bufferization] Remove `deallocationFn` from `BufferizationOptions`", "body": "One-Shot Bufferize no longer deallocates buffers, so `deallocationFn` can be removed.\r\n\r\nNote: There is a `bufferization.dealloc_tensor` op that now always bufferizes to `memref.dealloc`. This op will be phased out soon.", "feature_layers": ["ir"], "feature_directives": ["allocate"], "files_changed": [{"filename": "mlir/lib/Dialect/Bufferization/IR/BufferizableOpInterface.cpp", "functions": ["success"]}, {"filename": "mlir/lib/Dialect/Bufferization/IR/BufferizationOps.cpp", "functions": ["failure"]}]}
{"pr_number": 65951, "url": "https://github.com/llvm/llvm-project/pull/65951", "title": "[MLIR][NVGPU] Introduce `nvgpu.mbarrier.group` for multiple mbarrier use ", "body": "A common practice involves the creation of multiple `mbarrier` objects, see an example below. This is particularly valuable in scenarios like software pipelining for GEMM, where we need to generate multiple barriers dynamically use and wait them in a loop.\r\n\r\nPR improves `nvgpu.mbarrier.barrier` type into the `nvgpu.mbarrier.group`. All `mbarrier` related Ops now uses this type. Consequently, these Ops are now capable of managing multiple barriers seamlessly.\r\n\r\nHaving `num_barriers = 4` helps us to locate mbarrier object(s) into static shared memory. We could make the value dynamic that requires dynamic shared memory it would complicate the codegen.\r\n\r\n```\r\n%barriers = nvgpu.mbarrier.create -> !nvgpu.mbarrier.group<3, num_barriers = 4>\r\nnvgpu.mbarrier.init %barriers[%c0], %num_threads : !nvgpu.mbarrier.group<3, num_barriers = 4>\r\nnvgpu.mbarrier.init %barriers[%c1], %num_threads : !nvgpu.mbarrier.group<3, num_barriers = 4>\r\nnvgpu.mbarrier.init %barriers[%c2], %num_threads : !nvgpu.mbarrier.group<3, num_barriers = 4>\r\nnvgpu.mbarrier.init %barriers[%c3], %num_threads : !nvgpu.mbarrier.group<3, num_barriers = 4>\r\n...\r\nscf.for %i = %c0 to %n step %c1 {\r\n  nvgpu.mbarrier.try_wait %barriers[ (i % 4) ] ... \r\n\r\n  // ... Do work once mbarrier is ready \r\n\r\n  nvgpu.mbarrier.arrive.expect_tx %barriers[ (i + 3 % 4) ] ... \r\n}\r\n```\r\nWe will have mbarrier usages like below: \r\n```\r\nexpect_tx[0]\r\nexpect_tx[1]\r\nexpect_tx[2]\r\nLoop:\r\n try_wait mbarrier[0], expect_tx[3]\r\n try_wait mbarrier[1], expect_tx[0]\r\n try_wait mbarrier[2], expect_tx[1]\r\n try_wait mbarrier[3], expect_tx[2]\r\n...\r\n```\r\n", "feature_layers": ["codegen", "ir"], "feature_directives": ["for", "barrier", "requires"], "files_changed": [{"filename": "mlir/lib/Conversion/NVGPUToNVVM/NVGPUToNVVM.cpp", "functions": ["isMbarrierShared", "memRefDescriptor"]}, {"filename": "mlir/lib/Dialect/NVGPU/TransformOps/NVGPUTransformOps.cpp", "functions": ["buildTryWaitParity"]}]}
{"pr_number": 67034, "url": "https://github.com/llvm/llvm-project/pull/67034", "title": "[mlir][sparse] Add more error messages and avoid crashing in new parser", "body": "Updates:\r\n1. Added more invalid encodings to test the robustness of the new syntax\r\n2. Changed the asserts that caused crashing into returning booleans\r\n3. Modified some error messages to make them clearer and handled failures in parsing quotes as keyword for level properties.", "feature_layers": ["parse", "ir", "parser"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/IR/Detail/Var.cpp", "functions": ["isInternalConsistent"]}]}
{"pr_number": 67055, "url": "https://github.com/llvm/llvm-project/pull/67055", "title": "[lldb][NFCI] Change parameter type in UserExpression::GetObjectPointer", "body": "GetObjectPointer (and other related methods) do not need `ConstString` parameters. The string parameter in these methods boil down to getting a StringRef and calling `StackFrame::GetValueForVariableExpressionPath` which takes a `StringRef` parameter. All the users of `GetObjectPointer` (and related methods) end up creating ConstString objects to pass to these methods, but they could just as easily be StringRefs (potentially saving us some allocations in the StringPool).", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "lldb/source/Plugins/ExpressionParser/Clang/ClangUserExpression.cpp", "functions": ["g_objc_object_name", "cmd_name", "g_cplusplus_object_name"]}]}
{"pr_number": 67047, "url": "https://github.com/llvm/llvm-project/pull/67047", "title": "[flang][hlfir] Fixed some finalization/deallocation issues.", "body": "This set of commits resolves some of the issues with elemental calls producing\r\nresults that may require finalization, and also some memory leak issues due to\r\nthe missing deallocation of allocatable components of the temporary buffers\r\ncreated by the bufferization pass.\r\n\r\nI split it into 7 commits to make the review a little bit more convenient, though,\r\nI am planning to merge it as a single squashed commit.\r\n\r\n- [flang][runtime] Expose Finalize API for derived types.\r\n\r\n- [flang][hlfir] Add 'finalize' attribute for DestroyOp.\r\n\r\n- [flang][hlfir] Postpone result finalization for elemental calls.\r\n\r\n    The results of elemental calls generated inside hlfir.elemental must not\r\n    be finalized/destructed before they are copied into the resulting\r\n    array. The finalization must be done on the array as a whole\r\n    (e.g. there might be different scalar and array finalization routines).\r\n    The finalization work is left to the hlfir.destroy corresponding\r\n    to this hlfir.elemental.\r\n\r\n- [flang][hlfir] Tighten requirements on hlfir.end_associate operand.\r\n\r\n    If component deallocation might be required for the operand of\r\n    hlfir.end_associate, we have to be able to get the variable\r\n    shape/params to create a descriptor for calling the runtime.\r\n    This commit adds verification that we can do so.\r\n\r\n- [flang][hlfir] Lower argument clean-ups using valid hlfir.end_associate.\r\n\r\n    The operand must be a Fortran entity, when allocatable component\r\n    deallocation may be required.\r\n\r\n- [flang][hlfir] Properly clean-up temporary buffers in bufferization pass.\r\n\r\n    This commit combines changes for proper finalization and component\r\n    deallocation of the temporary buffers. The finalization part\r\n    relates to hlfir.destroy operations with 'finalize' attribute.\r\n    The component deallocation might be invoked for both hlfir.destroy\r\n    and hlfir.end_associate, if the operand is of a derived type\r\n    with allocatable component(s).\r\n\r\n    The changes are mostly in one function, so I decided not to split them.\r\n\r\n- [flang][hlfir] Disable optimizations for hlfir.elemental requiring finalization.\r\n\r\n    If hlfir.elemental is coupled with hlfir.destroy with 'finalize' attribute,\r\n    the temporary array result of hlfir.elemental needs to be created\r\n    for the purpose of finalization. We cannot do certain optimizations\r\n    on such hlfir.elemental operations.\r\n\r\n    I was not able to come up with a test for the OptimizedBufferization pass,\r\n    but I put the check there as well.\r\n", "feature_layers": ["runtime", "ir"], "feature_directives": ["for", "single"], "files_changed": [{"filename": "flang/runtime/derived-api.cpp", "functions": ["RTNAME"]}, {"filename": "flang/lib/Lower/ConvertCall.cpp", "functions": ["pushExprAssociateCleanUp"]}, {"filename": "flang/lib/Optimizer/HLFIR/IR/HLFIROps.cpp", "functions": ["build"]}]}
{"pr_number": 67041, "url": "https://github.com/llvm/llvm-project/pull/67041", "title": "[dsymutil] Remove paper trail warnings", "body": "Remove the paper trail warning from dsymutil and the DWARF linker. The original purpose of this functionality was to leave a paper trail in the output artifact about missing object files. The current implementation however has diverged and is the source of a pretty serious bug:\r\n\r\n  - In the debug map parser, missing object files are not the only warnings we emit. When paper trail warnings are enabled, all of them end up in the dSYM which wasn't the goal.\r\n  - When warnings are associated with a object file in the debug map, it is skipped by the DWARF linker. This only makes sense if the object file is missing and is obviously incorrect for any other type of warning (such as a missing symbol).\r\n\r\nThe combination of the two means that we can generate broken DWARF when the feature is enabled. AFAIK it was only used by Apple and nobody I spoke to has relied on it, so rather than fixing the broken behavior I propose we remove it.", "feature_layers": ["parse", "parser"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/DWARFLinkerParallel/DWARFLinkerImpl.cpp", "functions": ["ChildGenerator", "ParentGenerator"]}, {"filename": "llvm/tools/dsymutil/MachODebugMapParser.cpp", "functions": ["Parser"]}]}
{"pr_number": 65506, "url": "https://github.com/llvm/llvm-project/pull/65506", "title": "[BasicBlockSections] Introduce the basic block sections profile version 1.", "body": "This patch introduces a new version for the basic block sections profile as was requested in D158442, while keeping backward compatibility for the old version.\n\nThe new encoding is as follows:\n```\nm <module_name>\nf <function_name_1> <function_name_2>...\nc <bb_id_1> <bb_id_2> <bb_id_3>\nc <bb_id_4> <bb_id_5>\n...\n```\nModule name specifier (starting with 'm') is optional and allows distinguishing profiles for internal-linkage functions with the same name. If not specified, profile will be applied to any function with the same name.\nFunction name specifier (starting with 'f') can specify multiple function name aliases.\nFinally, basic block clusters are specified by 'c' and specify the cluster of basic blocks, and the internal order in which they must be placed in the same section.\n", "feature_layers": [], "feature_directives": ["for", "sections"], "files_changed": [{"filename": "llvm/lib/CodeGen/BasicBlockSectionsProfileReader.cpp", "functions": ["ReadV1Profile", "S", "invalidProfileError", "ReadV0Profile", "FirstLine", "createProfileParseError", "LineIt"]}]}
{"pr_number": 66970, "url": "https://github.com/llvm/llvm-project/pull/66970", "title": "[RISCV][GISel] Implement instruction selection for G_PHI and G_BRCOND.", "body": "This uses a naive lowering for G_BRCOND to a BNE instruction comparing the register to X0.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp", "functions": ["constrainSelectedInstRegOperands"]}]}
{"pr_number": 67169, "url": "https://github.com/llvm/llvm-project/pull/67169", "title": "[hwasan] Fixing false invalid-free with disabled tagging", "body": "This problem was accidentally discovered by the internal symbolizer, but\nit's relevant for external one as well, see the test.\n\nIf we just disable tagging, there may still be tagged allocations that\nhave already been freed. After disabling tagging, these tagged\nallocations can be released to the user as-is, which would later break\nthe \"invalid-free\" check.\n\nWe cannot just disable the \"invalid-free\" check with disabled tagging,\nbecause if we re-enable tagging, the issue still applies to allocations\ncreated when it was disabled.\n\nThe fix is to continue tagging with zero even if tagging is disabled.\n\nThis makes the \"disabled\" mode less efficient, but this is not the\nprimary use case.\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "compiler-rt/test/hwasan/TestCases/enable-disable.c", "functions": ["main"]}]}
{"pr_number": 67198, "url": "https://github.com/llvm/llvm-project/pull/67198", "title": "Revert \"Implement [[msvc::no_unique_address]] (#65675)\"", "body": "This reverts commit 4a55d426967b9c70f5dea7b3a389e11393a4f4c4.\n\nReverting because this breaks sphinx documentation, and even with it\nfixed the format of the attribute makes the no_unique_address\ndocumentation show up twice.\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/AST/RecordLayoutBuilder.cpp", "functions": ["if", "Context", "Builder", "EmptySubobjects"]}, {"filename": "clang/lib/Sema/SemaDeclAttr.cpp", "functions": ["handleNoUniqueAddressAttr"]}, {"filename": "clang/test/Layout/ms-no-unique-address.cpp", "functions": ["alignas"]}, {"filename": "clang/test/SemaCXX/cxx2a-ms-no-unique-address.cpp", "functions": ["sf", "f"]}]}
{"pr_number": 67194, "url": "https://github.com/llvm/llvm-project/pull/67194", "title": "[mlir][sparse] add lvlToDim field to sparse tensor encoding", "body": "Note the new surface syntax allows for defining a dimToLvl and lvlToDim map at once (where usually the latter can be inferred from the former, but not always). This revision adds storage for the latter, together with some intial boilerplate. The actual support (inference, validation, printing, etc.) is still TBD of course.", "feature_layers": ["parse", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/CAPI/Dialect/SparseTensor.cpp", "functions": ["mlirSparseTensorEncodingAttrGetLvlToDim", "wrap"]}]}
{"pr_number": 67202, "url": "https://github.com/llvm/llvm-project/pull/67202", "title": "[RISCV][GISel] Emit G_CONSTANT 0 as a copy from X0.", "body": "We need to use a COPY so the register coalescer can replace reads of the register we copy to with X0. This is needed so that we use X0 on instructions that don't have an immediate form.\r\n\r\nI've added a roundtrip test for negate to show this. I had to disable the late copy propagation pass that could see through the ADDI.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp", "functions": ["selectConstant"]}]}
{"pr_number": 67130, "url": "https://github.com/llvm/llvm-project/pull/67130", "title": "[Clang][CodeGen] Add __builtin_bcopy", "body": "Add __builtin_bcopy to the list of GNU builtins. This was causing a series of test failures in glibc.\r\n\r\nAdjust the tests to reflect the changes in codegen.\r\n\r\nFixes #51409.\r\nFixes #63065.", "feature_layers": ["codegen"], "feature_directives": [], "files_changed": [{"filename": "clang/test/Analysis/bstring.c", "functions": ["bcopy"]}]}
{"pr_number": 66961, "url": "https://github.com/llvm/llvm-project/pull/66961", "title": "[NFC]Do not use recursion for CounterMappingContext::evaluate", "body": "This causes stack overflows for real-world coverage reports.\r\n\r\nRan $ build/bin/llvm-lit -a llvm/test/tools/llvm-cov locally and passed.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/ProfileData/Coverage/CoverageMapping.cpp", "functions": ["errorCodeToError"]}]}
{"pr_number": 66807, "url": "https://github.com/llvm/llvm-project/pull/66807", "title": "[OMPIRBuilder] Added `createTeams`", "body": "This patch adds basic support for `omp teams` to the OpenMPIRBuilder.\r\n\r\nThe outlined function after code extraction is called from a wrapper function with appropriate arguments. This wrapper function is passed to the runtime calls.\r\n\r\nThis approach is different from the Clang approach - clang directly emits the runtime call to the outlined function. The outlining utility (OutlineInfo) simply outlines the code and generates a function call to the outlined function. After the function has been generated by the outlining utility, there is no easy way to alter the function arguments without meddling with the outlining itself. Hence the wrapper function approach is taken.", "feature_layers": ["runtime", "ir", "ompirbuilder"], "feature_directives": ["for", "teams"], "files_changed": [{"filename": "llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp", "functions": ["InsertPointTy", "AllocaIP", "CodeGenIP"]}, {"filename": "llvm/unittests/Frontend/OpenMPIRBuilderTest.cpp", "functions": ["OMPBuilder", "Builder", "Loc"]}]}
{"pr_number": 67223, "url": "https://github.com/llvm/llvm-project/pull/67223", "title": "[LAA] Keep track of sink ptr forked by a phi", "body": "Given a function like the following: https://godbolt.org/z/nqW3637Mf\r\n```\r\nvoid s1161_ptr (int *Preds, double *a, double *b, double *c) {\r\n  for (int i = 0; i < 1000; ++i) {\r\n    if (Preds[i] != 0)\r\n      b[i] = a[i] + 1;\r\n    else\r\n      a[i] = i * i;\r\n  }\r\n}\r\n```\r\nLLVM will optimize the IR to a single store by a phi instruction:\r\n```\r\nfor.body:                               ; preds = %entry, %for.inc\r\n  %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.inc ]\r\n  ...\r\nif.then:                                ; preds = %for.body\r\n  %arrayidx3 = getelementptr inbounds double, ptr %a, i64 %indvars.iv\r\n  ...\r\n  br label %for.inc\r\nif.else:\r\n  ...\r\n  br label %for.inc\r\nfor.inc:                                ; preds = %if.then, %if.else\r\n  %b.sink = phi ptr [ %b, %if.then ], [ %a, %if.else ]\r\n  %add.sink = phi double [ %add, %if.then ], [ %conv, %if.else ]\r\n  %arrayidx5 = getelementptr inbounds double, ptr %b.sink, i64\r\n%indvars.iv\r\n  store double %add.sink, ptr %arrayidx5, align 8\r\n```\r\n\r\nBecause array A has read and write operations at the same time in the loop body, we need extra runtime checks for this alias set compare to the previous scenario in commit be9211279.\r\n\r\nTo track the forked pointer, we transform it back to 2 PointerInfo entries with separate value just like the IR generated with option -simplifycfg-sink-common=false.", "feature_layers": ["runtime", "ir"], "feature_directives": ["for", "single"], "files_changed": [{"filename": "llvm/lib/Analysis/LoopAccessAnalysis.cpp", "functions": ["BuilderB", "BuilderA"]}]}
{"pr_number": 67218, "url": "https://github.com/llvm/llvm-project/pull/67218", "title": "[clang-format][NFC] Clean up alignTrailingComments()", "body": "", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Format/WhitespaceManager.cpp", "functions": ["if"]}]}
{"pr_number": 67255, "url": "https://github.com/llvm/llvm-project/pull/67255", "title": "[EarlyCSE] Support CSE for commutative intrinsics with over 2 args", "body": "Extends EarlyCSE to support commutative intrinsics with over 2 args.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Scalar/EarlyCSE.cpp", "functions": ["hash_combine"]}]}
{"pr_number": 65969, "url": "https://github.com/llvm/llvm-project/pull/65969", "title": "[clang][Sema] Make format size estimator aware of %p's existence in format string", "body": "GCC stops counting format string's size when it sees %p format in order to avoid `Wformat-truncation` false positive against Linux kernel's format extension (%pOF, for example).\r\nThis change makes clang's behavior align with GCC's.\r\nAs requested in https://github.com/llvm/llvm-project/issues/64871\r\n", "feature_layers": ["sema"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Sema/SemaChecking.cpp", "functions": ["isKernelCompatible"]}, {"filename": "clang/test/Sema/warn-format-overflow-truncation.c", "functions": ["call_snprintf"]}]}
{"pr_number": 66217, "url": "https://github.com/llvm/llvm-project/pull/66217", "title": "[SPIRV] Implement support for SPV_KHR_expect_assume", "body": "Adds new extension SPV_KHR_expect_assume, new capability\nExpectAssumeKHR as well as the new instructions:\n  * OpExpectKHR\n  * OpAssumeTrueKHR\n\nThese are lowered from respectively llvm.expect.<ty> and llvm.assume\nintrinsics.\n\nPreviously https://reviews.llvm.org/D157696", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/SPIRV/SPIRVPrepareFunctions.cpp", "functions": ["lowerExpectAssume"]}]}
{"pr_number": 66760, "url": "https://github.com/llvm/llvm-project/pull/66760", "title": "[mlir][ArmSME] Add support for vector.transpose", "body": "This patch adds support for lowering vector.transpose to ArmSME. It's\r\nimplemented by storing the input tile of the tranpose to memory and\r\nreloading vertically, building on top of the tile slice layout support.\r\n\r\nTranposing via memory is obviously expensive, the current intention is\r\nto avoid the transpose if possible, this is therefore intended as a\r\nfallback and to provide base support for Vector ops. If it turns out\r\ntransposes can't be avoided then this should be replaced with a more\r\noptimal implementation, perhaps with tile <-> vector (MOVA) ops.\r\n\r\nDepends on https://github.com/llvm/llvm-project/pull/66758.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Conversion/VectorToArmSME/VectorToArmSME.cpp", "functions": ["failure", "success", "g"]}]}
{"pr_number": 66867, "url": "https://github.com/llvm/llvm-project/pull/66867", "title": "[TableGen] Fix wrong bits output in GenericTable", "body": "We used to return `int` in `getAsInt`, while `IntInit::getValue`\nreturns `int64_t` and `utohexstr` needs `uint64_t`. The casting\ncauses the wrong hex value when printing bits value.\n\nI split this PR into two commits to show the difference.\n\n", "feature_layers": ["ast"], "feature_directives": [], "files_changed": [{"filename": "llvm/utils/TableGen/SearchableTableEmitter.cpp", "functions": ["getAsInt", "getInt"]}]}
{"pr_number": 67145, "url": "https://github.com/llvm/llvm-project/pull/67145", "title": "[mlir][vector] proper masking support for contract lowering", "body": "Support all known permutations when lowering masked vector.contract to vector.outerproduct, and not just the canonical permutation.", "feature_layers": ["ir"], "feature_directives": ["for", "masked"], "files_changed": [{"filename": "mlir/lib/Dialect/Vector/Transforms/LowerVectorContract.cpp", "functions": ["outerProd"]}]}
{"pr_number": 67012, "url": "https://github.com/llvm/llvm-project/pull/67012", "title": "Add support for MLIR to llvm vscale attribute", "body": "The vscale_range is used for scalabale vector functionality in Arm Scalable Vector Extension to select the size of vector operation (and I thnk RISCV has something similar).\r\n\r\nThis patch adds the base support for the vscale_range attribute to the LLVM::FuncOp, and the marshalling for translation to LLVM-IR and import from LLVM-IR to LLVM dialect.\r\n\r\nThis attribute is intended to be used at higher level MLIR, specified either by command-line options to the compiler or using compiler directives (e.g. pragmas or function attributes in the source code) to indicate the desired range.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/LLVMIR/IR/LLVMDialect.cpp", "functions": ["failure"]}]}
{"pr_number": 67315, "url": "https://github.com/llvm/llvm-project/pull/67315", "title": "[mlir] emit better errors in transform.structured.interchange", "body": "The implementation doesn't emit any diagnostics as it is shared with the pattern-based implementation. Check preconditions early and emit diagnostics from the transform op instead. Without this change, the op would produce a definite failure and no error message.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Linalg/TransformOps/LinalgTransformOps.cpp", "functions": ["emitSilenceableError", "emitDefiniteFailure", "getIteratorInterchangeAttrName"]}]}
{"pr_number": 67064, "url": "https://github.com/llvm/llvm-project/pull/67064", "title": "[libc++] Make sure we forward stdin through executors", "body": "This allows running tests like the ones for std::cin even on SSH executors. This was originally reported as https://github.com/llvm/llvm-project/pull/66842#issuecomment-1728701639.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "libcxx/test/libcxx/selftest/stdin-is-piped.sh.cpp", "functions": ["main"]}]}
{"pr_number": 66645, "url": "https://github.com/llvm/llvm-project/pull/66645", "title": "[libc++] Refactor tests for std::pointer_traits", "body": "After landing the implementation of LWG3545, I realized that the tests for std::pointer_traits had become a bit disorganized. This patch is a NFC that refactors the tests:\r\n- Move compile-only tests to `.compile.pass.cpp` tests\r\n- Re-create the clear distinction between tests for the std::pointer_traits base tempate and for the T* specialization.\r\n- De-duplicate test coverage -- we had a bunch of things that were tested in duplication.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "libcxx/test/std/utilities/memory/pointer.traits/pointer.traits.functions/pointer_to.pass.cpp", "functions": ["test", "pointer_to", "main", "A"]}, {"filename": "libcxx/test/std/utilities/memory/pointer.traits/pointer.traits.types/difference_type.compile.pass.cpp", "functions": ["main"]}, {"filename": "libcxx/test/std/utilities/memory/pointer.traits/pointer.traits.types/element_type.compile.pass.cpp", "functions": ["main"]}, {"filename": "libcxx/test/std/utilities/memory/pointer.traits/pointer.traits.types/rebind.compile.pass.cpp", "functions": ["main"]}, {"filename": "libcxx/test/std/utilities/memory/pointer.traits/ptr.types.compile.pass.cpp", "functions": ["f"]}, {"filename": "libcxx/test/std/utilities/memory/pointer.traits/types.compile.pass.cpp", "functions": ["pointer_to", "main"]}]}
{"pr_number": 66987, "url": "https://github.com/llvm/llvm-project/pull/66987", "title": "[mlir][transform] Improve error message of tracking listener.", "body": "This PR extends the error message of the tracking listener when replacement ops cannot be found. That may happen if the applied patterns replace an op by an op of a different kind or by block arguments. However, this only matters if there are alive handles to the replaced op. The new error message mentions that explicitly and reports the alive handles.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Transform/IR/TransformInterfaces.cpp", "functions": ["failure"]}, {"filename": "mlir/test/lib/Dialect/Tensor/TestTensorTransforms.cpp", "functions": ["builder", "listener"]}]}
{"pr_number": 67215, "url": "https://github.com/llvm/llvm-project/pull/67215", "title": "[flang] Do not write implicit SAVE attribute into the mod file.", "body": "If it happens that a symbol has an implicit SAVE attribute,\r\nwe have to omit it in the mod file writer. Otherwise it may\r\nviolate F202X C862:\r\nThe SAVE attribute shall not be specified for... an object that is\r\nin a common block.\r\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Semantics/mod-file.cpp", "functions": ["getSymbolAttrsToWrite"]}]}
{"pr_number": 67326, "url": "https://github.com/llvm/llvm-project/pull/67326", "title": "[flang] Finalize polymorphic alloctable component if needed", "body": "The runtime skips finalization if the runtime type info \"nofinalizationneeded\" is set, so it should not be set if the derived type has polymorphic allocatable components since they may be allocated to some type extension with a final methods.\r\nIsFinalizable cannot be updated since polymorphic allocatable components do not imply a final routine will actually be called (it depends of the dynamic type, which semantics cannot know about), and this would not match the \"Finalizable\" definition of the standard in 7.5.6.1. Hence, this patch adds a MayRequireFinalization helper.\r\n\r\nThe component visitor change is to avoid crashing in FindPolymorphicAllocatableUltimateComponent in the test test/Driver/dump-all-bad.f90 that tries generating runtime type info even after some semantic error is raised under debug-dump options.", "feature_layers": ["sema", "runtime", "ir"], "feature_directives": ["allocate"], "files_changed": [{"filename": "flang/lib/Semantics/tools.cpp", "functions": ["IsFinalizable", "MayRequireFinalization"]}]}
{"pr_number": 66270, "url": "https://github.com/llvm/llvm-project/pull/66270", "title": "[Clang] Fix CXXRewrittenBinaryOperator::getDecomposedForm to handle case when spaceship operator returns comparison category by reference", "body": "Currently CXXRewrittenBinaryOperator::getDecomposedForm(...) may crash if the\nspaceship operator returns a comparison category by reference. This because\nIgnoreImplicitAsWritten() does not look through CXXConstructExpr. The fix is to\nuse IgnoreUnlessSpelledInSource() which will look though CXXConstructExpr.\n\nThis fixes: https://github.com/llvm/llvm-project/issues/64162\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/SemaCXX/compare-cxx2a.cpp", "functions": ["f", "test", "A"]}]}
{"pr_number": 67190, "url": "https://github.com/llvm/llvm-project/pull/67190", "title": "[lldb] Modify the DWARFDebugAbbrev interface to be closer to LLVM's", "body": "I want to work towards unifying the implementations. It would be a lot easier to do if LLDB's DWARFDebugAbbrev looked more similar to LLVM's implementation, so this change moves in that direction.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "lldb/source/Plugins/SymbolFile/DWARF/DWARFDebugAbbrev.cpp", "functions": ["m_abbrevCollMap"]}]}
{"pr_number": 67350, "url": "https://github.com/llvm/llvm-project/pull/67350", "title": "[MLIR][SCF] Add a pattern to remove dead cycles in scf.for ops", "body": "Dead code elimination cannot remove dead cycles in loop operations. This pattern allows removing dead cycles in scf.for loops. The algorithm first assumes all the arguments associated to unused results to be dead then recursively propagates liveness to identify dead arguments.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/SCF/Transforms/ForOpDeadCycleElimination.cpp", "functions": ["failure", "success"]}, {"filename": "mlir/test/lib/Dialect/SCF/TestSCFUtils.cpp", "functions": ["getDescription", "getArgument", "runOnOperation", "patterns"]}]}
{"pr_number": 67307, "url": "https://github.com/llvm/llvm-project/pull/67307", "title": "[ASTMatchers] Fix classIsDerivedFrom for recusrive cases", "body": "By ensuring the base is only visited once. This avoids infinite recursion and expontential running times in some corner cases.\r\n\r\nSee the added tests for examples.\r\n\r\nApart from the cases that caused infinite recursion and used to crash, this change is an NFC and results of the matchers are the same.", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/ASTMatchers/ASTMatchFinder.cpp", "functions": ["classIsDerivedFromImpl"]}]}
{"pr_number": 67359, "url": "https://github.com/llvm/llvm-project/pull/67359", "title": "[RISCV][GISel] Add instruction selection for G_SEXT, G_ZEXT, and G_SEXT_INREG", "body": "G_SEXT and G_ZEXT are supported via patterns imported from SDISel; G_SEXT_INREG is selected using hand-written code as there is no (functional) rule at this moment to import G_SEXT_INREG from ISD::SEXT_INREG.\r\n\r\nCredit helps from @topperc on G_SEXT and G_ZEXT.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp", "functions": ["selectSExtInreg"]}]}
{"pr_number": 67389, "url": "https://github.com/llvm/llvm-project/pull/67389", "title": "[Demangler] support demangling for AIX function entry names", "body": "AIX has two symbols for a function, one is function descriptor and another one is function entry(there is a leading dot). See details in https://www.ibm.com/docs/en/aix/7.1?topic=formats-xcoff-object-file-format\r\n\r\n```\r\na function descriptor, which contains the following three values:\r\n\r\n    The address of the executable code for a function.\r\n    The address of the TOC anchor (TOC base address) of the module that contains the function.\r\n    The environment pointer (used by languages such as Pascal and PL/I).\r\n```\r\n\r\nA symbol table example:\r\n```\r\n[9]\tm   0x00000060     .text     1    weak                    ._ZN1A3fooEi\r\n[10]\ta4  0x00000005       0    0     LD       PR    0    0\r\n[13]\tm   0x000000cc     .data     1    weak                    _ZN1A3fooEi\r\n[14]\ta4  0x0000000c       0    0     SD       DS    0    0\r\n```\r\n\r\nFor now, llvm-cxxfilt is able to demangle `_ZN1A3fooEi`, but it can not demangle function entry name `._ZN1A3fooEi`.  Support demangling the function entry names as well. Sanitizers will check the function entries' demangle names in the LIT tests.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Demangle/Demangle.cpp", "functions": ["if"]}]}
{"pr_number": 67151, "url": "https://github.com/llvm/llvm-project/pull/67151", "title": "[AMDGPU] New image intrinsic optimizer pass", "body": "Implement a new pass to combine multiple image_load_2dmsaa and\n2darraymsaa intrinsic calls into a single image_msaa_load if:\n\n- they refer to the same vaddr except for sample_id,\n- they use a constant sample_id and they fall into the same group,\n- they have the same dmask and the number of instructions and the\n  number of vaddr/vdata dword transfers is reduced by the combine\n\nThis should be valid on all GFX11 but a hardware bug renders it\nunworkable on GFX11.0.* so it is only enabled for GFX11.5.\n\nBased on a patch by Rodrigo Dominguez!\n", "feature_layers": [], "feature_directives": ["for", "single"], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/AMDGPUImageIntrinsicOptimizer.cpp", "functions": ["optimizeSection"]}]}
{"pr_number": 66332, "url": "https://github.com/llvm/llvm-project/pull/66332", "title": "[MLIR] Introduce new C bindings to differentiate between discardable and inherent attributes", "body": "This is part of the transition toward properly splitting the two groups. This only introduces new C APIs, the Python bindings are unaffected. No API is removed.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/CAPI/IR/IR.cpp", "functions": ["mlirOperationGetNumDiscardableAttributes", "wrap"]}]}
{"pr_number": 67400, "url": "https://github.com/llvm/llvm-project/pull/67400", "title": "[X86][FP16] Add missing handling for FP16 constrained cmp intrinsics", "body": "", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CodeGen/X86/avx512fp16-builtins-constrained-cmp.c", "functions": ["test_mm512_mask_cmp_ph_mask_nge_us", "test_mm512_cmp_round_ph_mask", "test_mm_cmp_ph_mask_false_oq", "test_mm_cmp_ph_mask_eq_os", "test_mm256_cmp_ph_mask_le_oq", "test_mm512_mask_cmp_ph_mask_true_uq", "test_mm_cmp_ph_mask_nle_us", "test_mm256_mask_cmp_ph_mask_unord_q", "test_mm512_mask_cmp_ph_mask_nle_uq", "test_mm_cmp_ph_mask_le_os", "test_mm_cmp_ph_mask_neq_uq", "test_mm_cmp_ph_mask_gt_os", "test_mm512_mask_cmp_ph_mask_ge_os", "test_mm512_mask_cmp_ph_mask_gt_os", "test_mm_cmp_ph_mask_unord_q", "test_mm256_cmp_ph_mask_neq_us", "test_mm256_cmp_ph_mask_gt_oq", "_mm512_mask_cmp_ph_mask", "test_mm512_mask_cmp_ph_mask_false_oq", "test_mm512_mask_cmp_ph_mask_ngt_uq", "test_mm256_cmp_ph_mask_ngt_uq", "test_mm256_cmp_ph_mask_lt_oq", "test_mm256_cmp_ph_mask_nlt_uq", "test_mm512_mask_cmp_ph_mask_nlt_us", "_mm512_mask_cmp_round_ph_mask", "test_mm512_mask_cmp_ph_mask_neq_us", "test_mm512_mask_cmp_ph_mask_eq_os", "test_mm256_cmp_ph_mask_ge_oq", "test_mm512_mask_cmp_ph_mask_neq_os", "_mm_cmp_ph_mask", "test_mm256_cmp_ph_mask_unord_s", "_mm512_cmp_round_ph_mask", "test_mm512_mask_cmp_round_ph_mask", "test_mm256_cmp_ph_mask_true_us", "test_mm_cmp_ph_mask_nlt_us", "test_mm256_cmp_ph_mask_nge_uq", "test_mm256_cmp_ph_mask_false_os", "test_mm512_mask_cmp_ph_mask_unord_s", "test_mm_cmp_ph_mask_ord_q", "test_mm512_mask_cmp_ph_mask_ord_s", "test_mm256_mask_cmp_ph_mask_lt_os", "test_mm512_mask_cmp_ph_mask_nge_uq", "test_mm512_mask_cmp_ph_mask_true_us", "test_mm_cmp_ph_mask_true_uq", "_mm256_mask_cmp_ph_mask", "test_mm_cmp_ph_mask_eq_uq", "test_mm512_mask_cmp_ph_mask_neq_uq", "test_mm256_cmp_ph_mask_nle_uq", "test_mm_cmp_ph_mask_lt_os", "test_mm256_mask_cmp_ph_mask_eq_oq", "test_mm512_mask_cmp_ph_mask_gt_oq", "test_mm256_cmp_ph_mask_eq_us", "test_mm512_mask_cmp_ph_mask_false_os", "test_mm_cmp_ph_mask_ngt_us", "test_mm512_mask_cmp_ph_mask_nlt_uq", "test_mm512_mask_cmp_ph_mask_eq_us", "test_mm512_mask_cmp_ph_mask_neq_oq", "test_mm256_mask_cmp_ph_mask_le_os", "test_mm512_mask_cmp_ph_mask_le_oq", "test_mm_cmp_ph_mask_nge_us", "test_mm_cmp_ph_mask_eq_oq", "test_mm_cmp_ph_mask_neq_oq", "test_mm256_cmp_ph_mask_ord_s", "test_mm512_mask_cmp_ph_mask_eq_uq", "test_mm512_mask_cmp_ph_mask_ngt_us", "test_mm256_cmp_ph_mask_neq_os", "test_mm_cmp_ph_mask_ge_os", "test_mm512_mask_cmp_ph_mask_nle_us", "test_mm512_mask_cmp_ph_mask_ord_q", "test_mm512_mask_cmp_ph_mask_lt_oq", "test_mm512_mask_cmp_ph_mask_ge_oq", "_mm256_cmp_ph_mask"]}]}
{"pr_number": 67421, "url": "https://github.com/llvm/llvm-project/pull/67421", "title": "[mlir][python] Expose transform param types", "body": "This exposes the Transform dialect types `AnyParamType` and `ParamType` via the Python bindings.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Bindings/Python/DialectTransform.cpp", "functions": ["cls"]}, {"filename": "mlir/lib/CAPI/Dialect/Transform.cpp", "functions": ["mlirTypeIsATransformAnyParamType", "mlirTransformAnyParamTypeGet", "mlirTransformParamTypeGetType", "mlirTransformParamTypeGet", "wrap", "mlirTypeIsATransformParamType"]}]}
{"pr_number": 67358, "url": "https://github.com/llvm/llvm-project/pull/67358", "title": "[RISCV] Transform build_vector((binop X_i, C_i)..) to binop (build_ve\u2026", "body": "\u2026ctor, build_vector)\r\n\r\nIf we have a build_vector of identical binops, we'd prefer to have a single vector binop in most cases.  We do need to make sure that the two build_vectors aren't more difficult to materialize than the original build_vector.  To start with, let's restrict ourselves to the case where one build_vector is a fully constant vector.\r\n\r\nNote that we don't need to worry about speculation safety here.  We are not speculating any of the lanes, and thus none of the typical e.g. div-by-zero concerns apply.\r\n\r\nI'll highlight that the constant build_vector heuristic is just one we could chose here.  We just need some way to be reasonable sure the cost of the two build_vectors isn't going to completely outweigh the savings from the binop formation.  I'm open to alternate heuristics here - both more restrictive and more permissive.\r\n\r\nAs noted in comments, we can extend this in a number of ways.  I decided to start small as a) that helps keep things understandable in review and b) it covers my actual motivating case.", "feature_layers": [], "feature_directives": ["for", "single"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVISelLowering.cpp", "functions": ["SDValue", "DL"]}]}
{"pr_number": 66691, "url": "https://github.com/llvm/llvm-project/pull/66691", "title": "[mlir][ArmSME] Add custom vector.print lowering for SME tiles", "body": "This adds a custom lowering for SME that loops over each row of the tile, extracting it via an SME MOVA, then printing with a normal 1D vector.print.\r\n\r\nThis makes writing SME integration tests easier and less verbose.\r\n\r\nDepends on: #66910, #66911\r\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Conversion/ArmSMEToSCF/ArmSMEToSCF.cpp", "functions": ["failure", "success"]}]}
{"pr_number": 66839, "url": "https://github.com/llvm/llvm-project/pull/66839", "title": "[clang] Add -mlarge-data-threshold for x86_64 medium code model", "body": "Error if not used with x86_64.\nWarn if not used with the medium code model (can update if other code models end up using this).\n\nSet TargetMachine option and add module flag.\n", "feature_layers": [], "feature_directives": ["for", "target"], "files_changed": [{"filename": "clang/test/CodeGen/large-data-threshold.c", "functions": ["f"]}]}
{"pr_number": 67446, "url": "https://github.com/llvm/llvm-project/pull/67446", "title": "[flang][lowering] propagate location info of macro expansions", "body": "Currently flang-new -g is failing when compiling code containing a call in a macro to a function defined in the same file.\r\n\r\nThe verification added in https://reviews.llvm.org/D157447 is valid, flang lowering was failing to propagate location information in code from macro expansion because GetSourcePositionRange does not work with them (it fails to come with an end location), but we do not need a range for the MLIR location, only the start.\r\n\r\nUse GetSourcePosition instead that works with code from macro expansion.\r\n\r\nNote that the source location is the one of the statement where the macro appeared, if needed some FusedLocation could be later built to keep a link to the macro location in the debug info.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Lower/Bridge.cpp", "functions": ["filePath"]}]}
{"pr_number": 67409, "url": "https://github.com/llvm/llvm-project/pull/67409", "title": "Simplify diagnostic error management for MLIR properties API (NFC)", "body": "This is a follow-up to 8c2bff1ab929 which lazy-initialized the diagnostic and removed the need to dynamically abandon() an InFlightDiagnostic. This further simplifies the code to not needed to return a reference to an InFlightDiagnostic and instead eagerly emit errors.\r\n\r\nAlso use `emitError` as name instead of `getDiag` which seems more explicit and in-line with the common usage.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/TableGen/CodeGenHelpers.cpp", "functions": ["getDiag", "emitError"]}]}
{"pr_number": 67374, "url": "https://github.com/llvm/llvm-project/pull/67374", "title": "[mlir][tosa] Add scaffolding for bytecode version.", "body": "This does not decide on any specific bytecode version or structure, but adds the scaffolding to make it easy to add.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Tosa/IR/TosaOps.cpp", "functions": ["success", "readType", "BytecodeDialectInterface", "writeVersion", "readAttribute"]}]}
{"pr_number": 66981, "url": "https://github.com/llvm/llvm-project/pull/66981", "title": "[mlir] Implement DestinationStyleOpInterface for scf::ForallOp", "body": "`scf::ForallOp` has `shared_outs` tensor operands which are used to insert partial results into in the parallel terminator. The `scf::ForallOp` returns one tensor for each `shared_out` which then contains the combined result from all threads. Since the parallel terminator cannot change the shape of the `shared_out`, ForallOp is a `DestinationStyleOp` and this patch implements the interface by declaring the `outputs` operands as `inits` in the language of the DPS interface.\r\n\r\nFor this change to work, we need to add an exception to the Pattern that folds `tensor.cast` Ops into DPS Ops because `scf::Forall` needs special handling of it's `BlockArgument` Type during this folding.", "feature_layers": ["ir", "ast"], "feature_directives": ["parallel", "for"], "files_changed": [{"filename": "mlir/lib/Dialect/Tensor/IR/TensorOps.cpp", "functions": ["failure"]}]}
{"pr_number": 67081, "url": "https://github.com/llvm/llvm-project/pull/67081", "title": "[mlir][TilingInterface] NFC code changes separated out from introduction of `scf::tileUsingSCFForallop`.", "body": "This patch contains NFC changes that are precursor to the introduction of `scf::tileUsingSCFForallOp` method introduced in https://github.com/llvm/llvm-project/pull/67083.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/SCF/Transforms/TileUsingInterface.cpp", "functions": ["castToTypedOperations", "getAsOpFoldResult", "getAsOperations"]}, {"filename": "mlir/test/lib/Interfaces/TilingInterface/TestTilingInterface.cpp", "functions": ["filter"]}]}
{"pr_number": 67191, "url": "https://github.com/llvm/llvm-project/pull/67191", "title": "[DebugInfo] Change return type of DWARFDebugAbbrev::parse", "body": "To make DWARFDebugAbbrev more amenable to error-handling, I would like to change the return type of DWARFDebugAbbrev::parse from `void` to `Error`. Users of DWARFDebugAbbrev can consume the error if they want to use all the valid DWARF that was parsed (without worrying about the malformed DWARF) or stop when the parse fails if the use case needs to be strict.\r\n\r\nThis also will bring the LLVM DWARFDebugAbbrev interface closer to LLDB's which opens up the opportunity for LLDB adopt the LLVM implementation with minimal changes.", "feature_layers": ["parse"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/tools/obj2yaml/dwarf2yaml.cpp", "functions": ["dumpDebugAbbrev"]}, {"filename": "llvm/tools/obj2yaml/macho2yaml.cpp", "functions": ["dumpDebugAbbrev"]}, {"filename": "llvm/unittests/DebugInfo/DWARF/DWARFDebugAbbrevTest.cpp", "functions": ["Data", "OS", "DebugAbbrev"]}]}
{"pr_number": 66817, "url": "https://github.com/llvm/llvm-project/pull/66817", "title": "[Libomptarget] Fix Nvidia offloading hanging on dataRetrieve using RPC", "body": "Summary:\nThe RPC server is responsible for providing host services from the GPU.\nGenerally, the client running on the GPU will spin in place until the\nhost checks the server. Inside the runtime, we elected to have the user\nthread do this checking while it would be otherwise waiting for the\nkernel to finish. However, for Nvidia this caused problems when\noffloading to a target region that requires a copy back.\n\nThis is caused by the implementation of `dataRetrieve` on Nvidia. We\ninitialize an asynchronous copy-back on the same stream that the kernel\nis running on. This creates an implicit sync on the kernel to finish\nbefore we issue the D2H copy, which we then wait on. This implicit sync\nhappens inside of the CUDA runtime. This is problematic when running the\nRPC server because we need someone to check the RPC server. If no one\nchecks the RPC server then the kernel will never finish, meaning that\nthe memcpy will never be issued and the program hangs. This patch adds\nan explicit check for unfinished work on the stream and waits for it to\ncomplete.\n", "feature_layers": ["runtime", "ir"], "feature_directives": ["for", "target", "requires"], "files_changed": [{"filename": "openmp/libomptarget/test/libc/fwrite.c", "functions": ["main"]}]}
{"pr_number": 67485, "url": "https://github.com/llvm/llvm-project/pull/67485", "title": "[mlir][spirv][gpu] Default to KHR coop matrix. Clean up type conversion.", "body": "- Now that the KHR coop matrix implementation is robust, switch the gpu conversion pass to default to it.\r\n- Use a populate function for MMA to coop matrix type conversions. This makes the API surface area smaller.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Conversion/GPUToSPIRV/GPUToSPIRVPass.cpp", "functions": ["convertMMAToSPIRVCoopMatrixType", "convertMMAToSPIRVCoopMatrixNVType"]}]}
{"pr_number": 65514, "url": "https://github.com/llvm/llvm-project/pull/65514", "title": "[lldb-vscode] Display a more descriptive summary for containers and pointers", "body": "We've been displaying types and addresses for containers, but that's not very useful information. A better approach is to compose the summary of containers with the summary of a few of its children.\r\n\r\nNot only that, we can dereference simple pointers and references to get the summary of the pointer variable, which is also better than just showing an anddress.\r\n\r\nAnd in the rare case where the user wants to inspect the raw address, they can always use the debug console for that.\r\n\r\nFor the record, this is very similar to what the CodeLLDB extension does, and it seems to give a better experience.\r\n\r\nAn example of the new output:\r\n<img width=\"494\" alt=\"Screenshot 2023-09-06 at 2 24 27 PM\" src=\"https://github.com/llvm/llvm-project/assets/1613874/588659b8-421a-4865-8d67-ce4b6182c4f9\">\r\n\r\nAnd this is the \r\n<img width=\"476\" alt=\"Screenshot 2023-09-06 at 2 46 30 PM\" src=\"https://github.com/llvm/llvm-project/assets/1613874/5768a52e-a773-449d-9aab-1b2fb2a98035\">\r\nold output:\r\n\r\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "lldb/tools/lldb-vscode/JSONUtils.cpp", "functions": ["os", "ShouldBeDereferencedForSummary"]}]}
{"pr_number": 67371, "url": "https://github.com/llvm/llvm-project/pull/67371", "title": "[LLParser] Merge xor constantexpr parsing with add/mul/shl/lshr/ashr.", "body": "Not sure if xor is sticking around or not. I see and/or was already removed.\r\n\r\nThis changes the error messages and makes one error message more accurate.", "feature_layers": ["parse", "parser"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/AsmParser/LLParser.cpp", "functions": ["error"]}]}
{"pr_number": 67057, "url": "https://github.com/llvm/llvm-project/pull/67057", "title": "[TargetLowering] Deduplicate choosing InlineAsm constraint between ISels", "body": "Given a list of constraints for InlineAsm (ex. \"imr\") I'm looking to\r\nmodify the order in which they are chosen.  Before doing so, I noticed a fair\r\namount of logic is duplicated between SelectionDAGISel and GlobalISel\r\nfor this.\r\n\r\nThat is because SelectionDAGISel is also trying to lower immediates\r\nduring selection. If we detangle these concerns into:\r\n1. choose the preferred constraint\r\n2. attempt to lower that constraint\r\n\r\nThen we can slide down the list of constraints until we find one that\r\ncan be lowered. That allows the implementation to be shared between\r\ninstruction selection frameworks.\r\n\r\nThis makes it so that later I might only need to adjust the priority of\r\nconstraints in one place, and have both selectors behave the same.\r\n", "feature_layers": ["ir"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp", "functions": ["getConstraintGenerality"]}, {"filename": "llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp", "functions": ["getConstraintPiority", "getConstraintGenerality"]}]}
{"pr_number": 67121, "url": "https://github.com/llvm/llvm-project/pull/67121", "title": "[mlir][Interfaces] `LoopLikeOpInterface`: Add `replaceWithAdditionalYields`", "body": "`affine::replaceForOpWithNewYields` and `replaceLoopWithNewYields` (for \"scf.for\") are now interface methods and additional loop-carried variables can now be added to \"scf.for\"/\"affine.for\" uniformly. (No more `TypeSwitch` needed.)\r\n\r\nNote: `scf.while` and other loops with loop-carried variables can implement `replaceWithAdditionalYields`, but to keep this commit small, that is not done in this commit.\r\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Affine/IR/AffineOps.cpp", "functions": ["g"]}, {"filename": "mlir/lib/Dialect/Affine/Utils/LoopFusionUtils.cpp", "functions": ["b", "rewriter"]}, {"filename": "mlir/lib/Dialect/Affine/Utils/LoopUtils.cpp", "functions": ["builder", "rewriter"]}, {"filename": "mlir/lib/Dialect/Linalg/Transforms/Hoisting.cpp", "functions": ["b", "rewriter"]}, {"filename": "mlir/lib/Dialect/SCF/IR/SCF.cpp", "functions": ["g"]}, {"filename": "mlir/lib/Dialect/SCF/Utils/Utils.cpp", "functions": ["g"]}, {"filename": "mlir/test/lib/Dialect/SCF/TestSCFUtils.cpp", "functions": ["b", "rewriter", "oldYieldValues"]}]}
{"pr_number": 67523, "url": "https://github.com/llvm/llvm-project/pull/67523", "title": "Revert \"[clang analysis][NFCI] Preparatory work for D153131. (#67420)\"", "body": "There was a misunderstanding as to whether we wanted those base NFC changes or not.\r\n\r\nThis reverts commit 166074eff2e9a5f79b791f1cc9b641a4e2968616.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Analysis/ThreadSafety.cpp", "functions": ["checkPtAccess", "checkAccess"]}]}
{"pr_number": 67524, "url": "https://github.com/llvm/llvm-project/pull/67524", "title": "[mlir][linalg] Add `SubsetInsertionOpInterface` to `linalg.copy`", "body": "This commit enables empty tensor elimination on `linalg.copy` ops.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/Linalg/Transforms/SubsetInsertionOpInterfaceImpl.cpp", "functions": ["equivalenceFn"]}]}
{"pr_number": 67491, "url": "https://github.com/llvm/llvm-project/pull/67491", "title": "[sanitizer] Implement __sanitizer_symbolize_frame", "body": "__sanitizer_symbolize_frame is used by HWASAN\nfor use after scope reports.\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "compiler-rt/lib/sanitizer_common/sanitizer_symbolizer_posix_libcdep.cpp", "functions": ["SymbolizeFrame"]}, {"filename": "compiler-rt/lib/sanitizer_common/symbolizer/sanitizer_symbolize.cpp", "functions": ["OS"]}]}
{"pr_number": 67558, "url": "https://github.com/llvm/llvm-project/pull/67558", "title": "[BOLT][RISCV] Implement R_RISCV_64", "body": "Relocation for 64-bit absolute values.\r\n\r\nNote that this patch also implements two `Relocation` methods (`encodeValue` and `getAbs64`) that will become necessary to support instrumentation of non-PIE binaries (see #67348). However, I didn't find a way to test those independent of instrumentation.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "bolt/lib/Core/Relocation.cpp", "functions": ["encodeValueRISCV"]}]}
{"pr_number": 67489, "url": "https://github.com/llvm/llvm-project/pull/67489", "title": "[flang][runtime] Enable more code for offload device builds.", "body": "I extended the \"closure\" of the device code containing the initial\r\ntransformational.cpp. The device side of the library should not be\r\ncomplete at least for some APIs. For example, I tested with C OpenMP\r\ncode calling BesselJnX0 with a nullptr descriptor that failed with\r\na runtime error when executing on a GPU.\r\n\r\nI added `--expt-relaxed-constexpr` for NVCC compiler to avoid multiple\r\nwarnings about missing `__attribute__((device))` on constexpr methods\r\ncoming from C++ header files.\r\n", "feature_layers": ["runtime", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/runtime/descriptor.cpp", "functions": ["operator"]}, {"filename": "flang/runtime/terminator.cpp", "functions": ["void"]}]}
{"pr_number": 67470, "url": "https://github.com/llvm/llvm-project/pull/67470", "title": "[lldb] Implement thread local storage for linux", "body": "This patch implements the thread local storage support for linux (https://github.com/llvm/llvm-project/issues/28766). \r\n\r\nTLS feature is originally only implemented for Mac. With my previous patch to enable `fs_base` register for Linux (https://reviews.llvm.org/D155256), now it is feasible to implement this feature for Linux.  \r\n\r\nThe major changes are:\r\n* Track the main module's link address during launch\r\n* Fetch thread pointer from `fs_base` register\r\n* Create register alias for thread pointer\r\n* Read pthread metadata from target memory instead of process so that it works for coredump\r\n\r\nWith the patch the failing test is passing now. Note: I am only enabling this test for Mac and Linux because I do not have machine to test for FreeBSD/NetBSD. \r\n\r\n\r\n ", "feature_layers": [], "feature_directives": ["for", "target"], "files_changed": [{"filename": "lldb/source/Target/RegisterContext.cpp", "functions": ["ReadRegisterAsUnsigned"]}]}
{"pr_number": 67509, "url": "https://github.com/llvm/llvm-project/pull/67509", "title": "[mlir][sparse][gpu] add CSC and BSR format to cuSparse GPU ops", "body": "This adds two cuSparse formats to the GPU dialect support. Together with proper lowering and runtime cuda support. Also fixes a few minor omissions.", "feature_layers": ["parse", "runtime", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Conversion/GPUCommon/GPUToLLVMConversion.cpp", "functions": ["failure", "success"]}]}
{"pr_number": 67481, "url": "https://github.com/llvm/llvm-project/pull/67481", "title": "[NFC] refactor demangle of llvm-nm", "body": "since we landed the patch `https://reviews.llvm.org/D139864 [llvm-cxxfilt] Do not consider the prefix dot as part of the demangled symbol name`. we can simply the code on the llvm-nm demanlge by using the llvm::demangle directly.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "llvm/tools/llvm-nm/llvm-nm.cpp", "functions": ["demangle", "demangleXCOFF", "demangleMachO"]}]}
{"pr_number": 67479, "url": "https://github.com/llvm/llvm-project/pull/67479", "title": "[ObjectSizeOffsetVisitor] Bail after visiting 100 instructions", "body": "We're running into stack overflows for huge functions with lots of phis. Even without the stack overflows, this is recursing >7000 in some auto-generated code.\n\nThis fixes the stack overflow and brings down the compile time to something reasonable.\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Analysis/MemoryBuiltins.cpp", "functions": ["Known", "computeImpl", "combineSizeOffset", "unknown", "compute"]}]}
{"pr_number": 67360, "url": "https://github.com/llvm/llvm-project/pull/67360", "title": "Diagnose problematic uses of constructor/destructor attribute", "body": "Functions with these attributes will be automatically called before main() or after main() exits gracefully, which means the functions should not accept arguments or have a returned value (nothing can provide an argument to the call in these cases, and nothing can use the returned value), nor should they be allowed on a non-static member function in C++.\r\n\r\nAdditionally, these reuse the same priority logic as the init_priority attribute which explicitly reserved priorty values <= 100 or > 65535. So we now diagnose use of reserved priorities the same as we do for the init_priority attribute.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Sema/SemaDeclAttr.cpp", "functions": ["handleConstructorAttr", "handleDestructorAttr", "handleCtorDtorAttr"]}, {"filename": "clang/test/CodeGen/2008-03-03-CtorAttrType.c", "functions": ["__attribute__"]}, {"filename": "clang/test/CodeGen/PowerPC/aix-constructor-attribute.c", "functions": ["foo2", "foo", "foo3"]}, {"filename": "clang/test/CodeGen/PowerPC/aix-destructor-attribute.c", "functions": ["bar2", "bar3", "bar"]}, {"filename": "clang/test/CodeGenCXX/aix-constructor-attribute.cpp", "functions": ["foo2", "foo", "foo3"]}, {"filename": "clang/test/CodeGenCXX/aix-destructor-attribute.cpp", "functions": ["bar2", "bar3", "bar"]}, {"filename": "clang/test/Sema/constructor-attribute.c", "functions": ["g", "_BitInt", "h2", "g2", "j", "nonmem5", "i", "h1", "nonmem6", "g1", "g0", "h", "nonmem1", "h0", "nonmem2", "nonmem3", "nonmem4"]}]}
{"pr_number": 67490, "url": "https://github.com/llvm/llvm-project/pull/67490", "title": "[llvm] Implement S_INLINEES debug symbol", "body": "The `S_INLINEES` debug symbol is used to record all the functions that are directly inlined within the current function (nested inlining is ignored).\r\n\r\nThis change implements support for emitting the `S_INLINEES` debug symbol in LLVM, and cleans up how the `S_INLINEES` and `S_CALLEES` debug symbols are dumped.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/DebugInfo/CodeView/SymbolDumper.cpp", "functions": ["S"]}]}
{"pr_number": 67557, "url": "https://github.com/llvm/llvm-project/pull/67557", "title": "[OpenMP] Implicitly include the 'cgpu' and 'mgpu' libraries for OpenMP", "body": "Summary:\n[The LLVM C library for GPUs](https://libc.llvm.org/gpu/) supports\nstandard function calls on the GPU that users are familiar with.\nCurrently, this requires that users include these manually. The support\nfor this library is dependent upon whether or not associated LLVM build\nwas built with the GPU C library support. This patch implicitly adds\nthese for an OpenMP offloading compilation if we find that the toolchain\ncontains the GPU declarations that allow us to use this.\n\nI do not know how to test this, given that it requires information from\nthe resource directory in the install. That means it won't be present\nfor any internal tests. It works when I test it and the idea is simple\nenough so it should be simple enough.\n", "feature_layers": ["ir"], "feature_directives": ["for", "requires"], "files_changed": [{"filename": "clang/lib/Driver/ToolChains/CommonArgs.cpp", "functions": ["LibCDecls"]}]}
{"pr_number": 67207, "url": "https://github.com/llvm/llvm-project/pull/67207", "title": "[RISCV][GISel] Remove source constraint from selectCopy and use it fo\u2026", "body": "\u2026r G_ANYEXT/G_TRUNC.\r\n\r\nAArch64, Mips, and ARM do not have source constraints in their version of selectCopy. I'm assuming we don't need it either.\r\n\r\nWe weren't constraining the destination register of G_ANYEXT/G_TRUNC previously, but we got away with it in our tests because all their users constrained them as a use. When I removed the source constraint from selectCopy this stopped working.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp", "functions": ["selectCopy"]}]}
{"pr_number": 67612, "url": "https://github.com/llvm/llvm-project/pull/67612", "title": "[ORC] Unify symbol mapping logic to IRLayer", "body": "Remove the old `IRSymbolMapper` and unify symbol mapping logic to IRLayer. Allows clients to provide their own version of a `IRSymbolMapper` function for custom mappings.\r\n\r\nThis is my first contribution, so I'm sorry in advance for any problems that may arise.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/ExecutionEngine/Orc/CompileOnDemandLayer.cpp", "functions": ["HC", "formatv", "extractSubModule", "Mangle"]}, {"filename": "llvm/lib/ExecutionEngine/Orc/CompileUtils.cpp", "functions": ["irManglingOptionsFromTargetOptions"]}, {"filename": "llvm/lib/ExecutionEngine/Orc/Layer.cpp", "functions": ["IRMaterializationUnit", "getSymbolInfo"]}, {"filename": "llvm/lib/ExecutionEngine/Orc/Mangling.cpp", "functions": ["Mangle"]}]}
{"pr_number": 67362, "url": "https://github.com/llvm/llvm-project/pull/67362", "title": "[LLParser] Remove unnecessary switch from the handling of the remaini\u2026", "body": "\u2026ng binary constantexprs.\r\n\r\nFP binary operators aren't supported anymore, so we don't need a switch to pick whether we expect an integer or FP type.", "feature_layers": ["parse", "parser"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/AsmParser/LLParser.cpp", "functions": ["error", "llvm_unreachable"]}]}
{"pr_number": 66805, "url": "https://github.com/llvm/llvm-project/pull/66805", "title": "[XCOFF] Do not generate the special .ref for zero-length sections", "body": "", "feature_layers": [], "feature_directives": ["for", "sections"], "files_changed": [{"filename": "llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp", "functions": ["emitPGORefs"]}]}
{"pr_number": 67274, "url": "https://github.com/llvm/llvm-project/pull/67274", "title": "[MLIR][LLVM] Add vararg support in LLVM::CallOp", "body": "Adds an attribute that specifies the callee type of a LLVMCallOp. This is needed to distinguish between vararg and non-vararg calls as currently the LLVM Dialect always translates CallOp's to non-vararg calls.\r\n\r\nThe new syntax I opted for is this:\r\n\r\n```\r\n%2 = llvm.call @printf vararg !llvm.func<i32 (ptr<4>, ...)> (%1, %arg0) : (!llvm.ptr<4>, i32) -> i32\r\n```\r\n\r\nfor vararg calls, and for non-vararg calls, the function type is omitted and the type will be inferred from the operation operand and result types, for example:\r\n\r\n```\r\n%2 = llvm.call @foo(%1, %arg0) : (!llvm.ptr<4>, i32) -> i32\r\n```\r\n\r\nI think it makes sense to keep the type at the end after the `:` which describes the type as a MLIR operation and the function type separate.\r\n\r\nIf this syntax looks good I will update the tests to reflect this change.\r\n\r\n\r\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/LLVMIR/IR/LLVMDialect.cpp", "functions": ["getLLVMFuncType"]}, {"filename": "mlir/lib/Target/LLVMIR/ModuleImport.cpp", "functions": ["failure"]}, {"filename": "mlir/examples/toy/Ch6/mlir/LowerToLLVM.cpp", "functions": ["getPrintfType"]}, {"filename": "mlir/examples/toy/Ch7/mlir/LowerToLLVM.cpp", "functions": ["getPrintfType"]}]}
{"pr_number": 67561, "url": "https://github.com/llvm/llvm-project/pull/67561", "title": "[flang] Fix issues with STORAGE_SIZE and characters", "body": "Semantics was replacing storage_size(func()) by the length specification expression of func result (if any), which brought meaningless symbols. Update FunctionRef::GetType to not copy its length parameter from the procedure designator symbol if it is not a constant expression. Note that the deferred aspect can and must be preserved because it matters for POINTER function results (semantics test added to ensure this).\r\n\r\nUpdate lowering code to deal with characters in storage_size: simply always call createBox to ensure the BoxEleSizeOp is legal. This will take care of dereferencing pointers/allocatables if needed (what the load was intended for in the previous code).", "feature_layers": ["sema"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Evaluate/type.cpp", "functions": ["DynamicType"]}]}
{"pr_number": 67539, "url": "https://github.com/llvm/llvm-project/pull/67539", "title": "[MemCpyOpt] Merge alias metadatas when replacing arguments", "body": "Fix mis-compilation encountered in https://rust-lang.zulipchat.com/#narrow/stream/131828-t-compiler/topic/Failing.20tests.20when.20rustc.20is.20compiled.20with.201.20CGU.\r\n\r\n~~I marked it as a draft PR because I haven't got an appropriate test case yet.~~\r\nWe may want to merge pr without additional test cases first.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp", "functions": ["combineAAMetadata"]}]}
{"pr_number": 67527, "url": "https://github.com/llvm/llvm-project/pull/67527", "title": "[mlir][ArmSME] Add support for vector.transfer_read with transpose", "body": "This patch adds support for lowering a vector.transfer_read with a transpose permutation map to a vertical tile load, for example:\r\n```\r\nvector.transfer_read ...  permutation_map: (d0, d1) -> (d1, d0)\r\n```\r\nis converted to:\r\n```\r\narm_sme.tile_load ... <vertical>\r\n```\r\nOn SME the transpose can be done in-flight, rather than as a separate operation as in the generic `TransferReadPermutationLowering`, which would do the following:\r\n```\r\n%0 = vector.transfer_read ...\r\nvector.transpose %0, [1, 0] ...\r\n```\r\nThe lowering doesn't support masking yet and the transfer_read must be in-bounds. It also intentionally doesn't handle simple loads as transfer_write currently does, as the generic\r\n`TransferReadToVectorLoadLowering` can lower these to simple vector.load ops, which can already be lowered to ArmSME.\r\n\r\nA subsequent patch will update the existing transfer_write lowering, this is a separate patch as there is currently no lowering for vector.transfer_read.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Conversion/VectorToArmSME/VectorToArmSME.cpp", "functions": ["success"]}]}
{"pr_number": 66496, "url": "https://github.com/llvm/llvm-project/pull/66496", "title": "[NVPTX] Add support for maxclusterrank in launch_bounds", "body": "Since SM_90 CUDA supports specifying additional argument to the launch_bounds attribute: maxBlocksPerCluster, to express the maximum number of CTAs that can be part of the cluster. See: https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#cluster-dimension-directives-maxclusterrank and\r\nhttps://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#launch-bounds for details.", "feature_layers": ["ir"], "feature_directives": ["parallel", "for"], "files_changed": [{"filename": "clang/lib/CodeGen/Targets/NVPTX.cpp", "functions": ["MaxBlocks"]}, {"filename": "clang/lib/Sema/SemaDeclAttr.cpp", "functions": ["CudaArchToString", "TmpAttr", "getCudaArch"]}, {"filename": "llvm/lib/Target/NVPTX/NVPTXUtilities.cpp", "functions": ["findOneNVVMAnnotation", "getMaxClusterRank"]}]}
{"pr_number": 67113, "url": "https://github.com/llvm/llvm-project/pull/67113", "title": "[ADT] Fix llvm::join on containers of char*s", "body": "Currently it tries to call S.size() when preallocating the target string,\nwhich doesn't compile.\nvector<const char*> is used a bunch in e.g. clang driver.\n", "feature_layers": [], "feature_directives": ["target"], "files_changed": [{"filename": "llvm/unittests/ADT/StringExtrasTest.cpp", "functions": ["testJoin"]}]}
{"pr_number": 67496, "url": "https://github.com/llvm/llvm-project/pull/67496", "title": "[libc++] Refactor the tests for [iterator.range]", "body": "The tests were a bit of a mess -- the testing coverage wasn't bad but it was extremely difficult to see what was being tested and where. I split up the tests to make them easier to audit for completeness and did such an audit, adding a few missing tests (e.g. the conditional noexcept-ness of std::cbegin and std::cend). I also audited the synopsis and adjusted it where it needed to be adjusted.\r\n\r\nThis patch is in preparation of fixing #67471.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "libcxx/test/std/iterators/iterator.range/begin-end.adl.pass.cpp", "functions": ["begin", "crend", "end", "main", "crbegin", "rend", "test", "cend", "cbegin", "rbegin"]}, {"filename": "libcxx/test/std/iterators/iterator.range/begin-end.array.pass.cpp", "functions": ["test", "main", "test_r"]}, {"filename": "libcxx/test/std/iterators/iterator.range/begin-end.container.pass.cpp", "functions": ["test", "main"]}, {"filename": "libcxx/test/std/iterators/iterator.range/begin-end.initializer_list.pass.cpp", "functions": ["test", "main"]}, {"filename": "libcxx/test/std/iterators/iterator.range/begin-end.pass.cpp", "functions": ["begin", "crend", "end", "main", "crbegin", "test_adl_proofing", "test_arrays_and_initializer_lists_forward", "rend", "cend", "test_arrays_and_initializer_lists_backward", "test_container", "cbegin", "rbegin"]}, {"filename": "libcxx/test/std/language.support/support.initlist/support.initlist.range/begin_end.pass.cpp", "functions": ["B", "test", "main"]}]}
{"pr_number": 67559, "url": "https://github.com/llvm/llvm-project/pull/67559", "title": "[libc++][NFC] Simplify checks for static assertions in .verify.cpp tests", "body": "We don't neeed to handle both spellings anymore since we don't support Clang 15 anymore.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "libcxx/test/std/utilities/optional/optional.object/optional.object.ctor/deduct.verify.cpp", "functions": ["opt"]}]}
{"pr_number": 67433, "url": "https://github.com/llvm/llvm-project/pull/67433", "title": "[AArch64][GlobalISel] More type support for G_VECREDUCE_ADD", "body": "G_VECREDUCE_ADD is now able to have v4i16 and v8i8 vector types as source registers", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp", "functions": ["if"]}]}
{"pr_number": 67538, "url": "https://github.com/llvm/llvm-project/pull/67538", "title": "[Clang] Handle sema of noexcept condition in their evaluation context.", "body": "The conditions of a noexcept and explicit specifier are full expressions. Before this patch, we would call ActOnFinishFullExpr on these in the context of the enclosing expression, which would cause the collect of odr-used variables (and subsequently capture attempts) in the wrong (enclosing) context.\r\n\r\nThis was observable when parsing the noexcept specifier condition of a lambda appearing in a wider full expression odr-using variables.\r\n\r\nFixes #67492", "feature_layers": ["sema", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/SemaCXX/lambda-expressions.cpp", "functions": ["GH67492"]}]}
{"pr_number": 67610, "url": "https://github.com/llvm/llvm-project/pull/67610", "title": "[flang][openacc] Support assumed shape arrays in reduction", "body": "Assumed shape array are using descriptor and must be handled differently than known shape arrays. This patch adds support to generate the `init` and `combiner` region for the reduction recipe operation with assumed shape array by using the descriptor and the HLFIR lowering path. \r\n\r\n`createTempFromMold` function is moved from `flang/lib/Optimizer/HLFIR/Transforms/BufferizeHLFIR.cpp` to `flang/include/flang/Optimizer/Builder/HLFIRTools.h` to be reused to create the private copy.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Lower/OpenACC.cpp", "functions": ["getReductionInitValue"]}]}
{"pr_number": 66935, "url": "https://github.com/llvm/llvm-project/pull/66935", "title": "[hwasan] Update (Post-)DominatorTreeAnalysis and LoopAnalysis incrementally", "body": "HWAddressSanitizerPass::run sanitizes functions one by one. The sanitization of each function - which may split blocks via insertShadowTagCheck - may result in some cached analyses are invalid. This matters because sanitizeFunction(F', FAM) may indirectly call the global stack safety analysis, hence we need to make sure the analyses of F are up to date.\n\nBug report: https://github.com/llvm/llvm-project/issues/66934\n", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp", "functions": ["DTU", "instrumentMemAccess"]}]}
{"pr_number": 67679, "url": "https://github.com/llvm/llvm-project/pull/67679", "title": "[LinkerWrapper] Correctly handle multiple image wrappers", "body": "Summary:\nWe use these image wrappers to do runtime specifica registration of\nvariables and to load the device image that was compiled. This was\nintended to support multiple of these running at the same time, e.g. you\ncan have a CUDA instance running with OpenMP and they should both\nfunction so long as you do not share state between the two. However,\nbecause we did not use a unique name for this file it would cause\nconflicts when included. This patch names the image based off of the\nlanguage runtime it's using so that they remain separate.\n\nFixes: https://github.com/llvm/llvm-project/issues/67583\n", "feature_layers": ["runtime"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp", "functions": ["compileModule"]}]}
{"pr_number": 67383, "url": "https://github.com/llvm/llvm-project/pull/67383", "title": "[clang][modules] Adopt `FileEntryRef` in the `HeaderFileInfo` block in PCM files", "body": "This patch adopts `FileEntryRef` in the `HeaderFileInfo`-writing part of `ASTWriter`.\r\n\r\nFirst, this patch removes the loop over `FileManager::VirtualFileEntries`. It's redundant, since all virtual file entries are also present in `SeenFileEntries` and thus already in `UIDToFiles`.\r\n\r\nSecond, since we now no longer rely on `FileEntry::getLastRef()`/`FileEntry::getName()`, this patch takes care to establish which path gets used for each UID by picking the `FileEntryRef` with the most \"`<`\" name (instead of just relying on the `StringMap` iteration order).\r\n\r\nNote that which `FileEntry`/`FileEntryRef` objects we pick for each UID for serialization into the `llvm::OnDiskChainedHashTable` doesn't really matter. The hash function only includes the file size and modification time. The file name only plays role during resolution of hash collisions, in which case it goes through `FileManager` and resolves to a `FileEntry` that gets pointer-compared with the queried `FileEntry`.\r\n\r\n(Reincarnation of [D143414](https://reviews.llvm.org/D143414) and [D142780](https://reviews.llvm.org/D142780).)\r\n", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Basic/FileManager.cpp", "functions": ["FE"]}]}
{"pr_number": 67290, "url": "https://github.com/llvm/llvm-project/pull/67290", "title": "[Flang] [OpenMP] [Semantics] Add semantic support for IS_DEVICE_PTR nd HAS_DEVICE_ADDR clauses on  OMP TARGET directive and add more semantic checks for OMP TARGET.", "body": "Summary of this patch\r\n\r\n- Add semantic support for HAS_DEVICE_ADDR and IS_DEVICE_PTR clauses.\r\n- A list item that appears in an IS_DEVICE_PTR clause must be a valid device pointer for the device data environment.\r\n- A list item may not be specified in both an IS_DEVICE_PTR clause and a HAS_DEVICE_ADDR clauses on the directive.\r\n- A list item that appears in an IS_DEVICE_PTR or a HAS_DEVICE_ADDR clauses must not be specified in any data-sharing attribute clause on the same target construct.", "feature_layers": ["sema", "ir"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "flang/lib/Semantics/resolve-directives.cpp", "functions": ["Pre"]}]}
{"pr_number": 67666, "url": "https://github.com/llvm/llvm-project/pull/67666", "title": "[mlir][SCF] Bufferize scf.index_switch", "body": "Add the `BufferizableOpInterface` implementation of `scf.index_switch`.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/SCF/Transforms/BufferizableOpInterfaceImpl.cpp", "functions": ["g", "success", "failure"]}]}
{"pr_number": 67713, "url": "https://github.com/llvm/llvm-project/pull/67713", "title": "[mlir][sparse][gpu] add CSC to libgen GPU sparsification using cuSparse", "body": "Add CSC, but also adds BSR as a future format. Coming soon!", "feature_layers": ["parse", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/Transforms/SparseGPUCodegen.cpp", "functions": ["failure", "isAdmissibleCSC", "isAdmissibleCSR", "isAdmissibleMetaData"]}]}
{"pr_number": 66793, "url": "https://github.com/llvm/llvm-project/pull/66793", "title": "[DAGCombiner] Inverse transform `(select c, (and X, 1), 0)` -> `(and (zext c), X)`", "body": "- [X86][AArch64][RISCV] Add tests for combining `(select c, (and X, 1), 0)` -> `(and (zext c), X)`; NFC\n- [DAGCombiner] Combine `(select c, (and X, 1), 0)` -> `(and (zext c), X)`\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp", "functions": ["SDValue"]}]}
{"pr_number": 67579, "url": "https://github.com/llvm/llvm-project/pull/67579", "title": "[lldb][NFCI] Move functionality for getting unsupported DW_FORM values", "body": "The LLVM implementation of DWARFDebugAbbrev does not have a way of listing all the DW_FORM values that have been parsed but are unsupported or otherwise unknown. AFAICT this functionality does not exist in LLVM at all. Since my primary goal is to unify the implementations and not judge the usefulness or completeness of this functionality, I decided to move it out of LLDB's implementation of DWARFDebugAbbrev for the time being.", "feature_layers": ["parse"], "feature_directives": ["for"], "files_changed": [{"filename": "lldb/source/Plugins/SymbolFile/DWARF/SymbolFileDWARF.cpp", "functions": ["GetUnsupportedForms"]}]}
{"pr_number": 66955, "url": "https://github.com/llvm/llvm-project/pull/66955", "title": "[scudo] Update header without read-modify-write operation", "body": "We used to update the deallocated block with\r\natomic_compare_exchange_strong to ensure the concurrent double-free will be detected. However, this operation incurs huge performance overhead which takes over 50% execution time in deallocate(). Given that we already have the checksum to guard the most double-free cases and other block verifications in the primary allocator, use atomic-store instead.", "feature_layers": [], "feature_directives": ["for", "atomic", "allocate"], "files_changed": [{"filename": "compiler-rt/lib/scudo/standalone/report.cpp", "functions": ["reportHeaderRace"]}]}
{"pr_number": 66389, "url": "https://github.com/llvm/llvm-project/pull/66389", "title": "[clang][deps] Load module map file from PCM", "body": "Loading the module map path directly from the PCM is faster. Calling `ModuleMap::getModuleMapFileForUniquing()` causes deserialization of multiple `SLocEntries` and calling `ModuleMap::canonicalizeModuleMapPath()` issues an uncached call to `vfs::FileSystem::getRealPath()`.", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Serialization/ASTWriter.cpp", "functions": ["StringRef"]}]}
{"pr_number": 66036, "url": "https://github.com/llvm/llvm-project/pull/66036", "title": "[Inliner] Fix bug when propagating poison generating return attributes", "body": "[Inliner] Fix bug when propagating poison generating return attributes\r\nPoison generating return attributes can't be propagated the same as\r\nothers, as they can change the behavior of other uses and/or create UB\r\nwhere it otherwise wouldn't have occurred.\r\n\r\nFor example:\r\n```\r\ndefine nonnull ptr @foo() {\r\n    %p = call ptr @bar()\r\n    call void @use(ptr %p)\r\n    ret ptr %p\r\n}\r\n```\r\n\r\nIf we inline `@foo` and propagate `nonnull` to `@bar`, it could change\r\nthe behavior of `@use` as instead of taking `null`, `@use` will\r\nnow be passed `poison`.\r\n\r\nThis can be even worth in a case like:\r\n```\r\ndefine nonnull ptr @foo() {\r\n    %p = call noundef ptr @bar()\r\n    ret ptr %p\r\n}\r\n```\r\n\r\nWhere propagating `nonnull` to `@bar` will cause UB on `null` return\r\nof `@bar` (`noundef` + `poison`) where it previously wouldn't\r\nhave occurred.\r\n\r\nTo fix this, we only propagate poison generating return attributes if\r\neither 1) The only use of the callsite to propagate too is return and\r\nthe callsite to propagate too doesn't have `noundef`. Or 2) the\r\ncallsite to be be inlined has `noundef`.\r\n\r\nThe former case ensures no new UB or `poison` values will be\r\nadded. The latter is UB anyways if the value is `poison` so we can go\r\nahead without worrying about behavior changes.\r\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Utils/InlineFunction.cpp", "functions": ["IdentifyValidAttributes", "IdentifyValidPoisonGeneratingAttributes", "Valid", "IdentifyValidUBGeneratingAttributes"]}]}
{"pr_number": 67199, "url": "https://github.com/llvm/llvm-project/pull/67199", "title": "Recommit \"Implement [[msvc::no_unique_address]] (#65675)\"", "body": "This implements the [[msvc::no_unique_address]] attribute.\r\n\r\nThere is not ABI compatibility in this patch because the attribute is relatively new and there's still some uncertainty in the MSVC version.\r\n\r\nThe recommit changes the attribute definitions so that instead of making two separate attributes for no_unique_address\r\nand msvc::no_unique_address, it modifies the attributes tablegen emitter to allow spellings to be target-specific. \r\n\r\nThis reverts commit 71f9e7695b87298f9855d8890f0e6a3b89381eb5.\r\n", "feature_layers": [], "feature_directives": ["for", "target"], "files_changed": [{"filename": "clang/lib/AST/RecordLayoutBuilder.cpp", "functions": ["if", "Context", "Builder", "EmptySubobjects"]}, {"filename": "clang/lib/Sema/SemaDeclAttr.cpp", "functions": ["handleNoUniqueAddressAttr"]}, {"filename": "clang/test/Layout/ms-no-unique-address.cpp", "functions": ["alignas"]}, {"filename": "clang/test/SemaCXX/cxx2a-ms-no-unique-address.cpp", "functions": ["sf", "f"]}, {"filename": "clang/lib/Sema/ParsedAttr.cpp", "functions": ["getInfo"]}]}
{"pr_number": 67598, "url": "https://github.com/llvm/llvm-project/pull/67598", "title": "[NFC][LLD] Refactor some copy-paste into the Common library", "body": "", "feature_layers": ["ast"], "feature_directives": [], "files_changed": [{"filename": "lld/COFF/LTO.cpp", "functions": ["openFile"]}, {"filename": "lld/Common/Filesystem.cpp", "functions": ["openFile"]}, {"filename": "lld/ELF/LTO.cpp", "functions": ["openFile", "openLTOOutputFile"]}, {"filename": "lld/MachO/LTO.cpp", "functions": ["openFile"]}]}
{"pr_number": 67667, "url": "https://github.com/llvm/llvm-project/pull/67667", "title": "Reland [NVPTX] Add support for maxclusterrank in launch_bounds (#66496)", "body": "This reverts commit 0afbcb20fd908f8bf9073697423da097be7db592.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/CodeGen/Targets/NVPTX.cpp", "functions": ["MaxBlocks"]}, {"filename": "clang/lib/Sema/SemaDeclAttr.cpp", "functions": ["StringToCudaArch", "CudaArchToString", "TmpAttr", "getCudaArch"]}, {"filename": "llvm/lib/Target/NVPTX/NVPTXUtilities.cpp", "functions": ["findOneNVVMAnnotation", "getMaxClusterRank"]}]}
{"pr_number": 67775, "url": "https://github.com/llvm/llvm-project/pull/67775", "title": "Reland \"[clang analysis][NFCI] Preparatory work for D153131. (#67420)\u2026", "body": "\u2026\" (#67523)\r\n\r\nDiscussion in https://reviews.llvm.org/D153132.\r\n\r\nThis reverts commit f70377471c990aa567584ae429e77adc9a55491b.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Analysis/ThreadSafety.cpp", "functions": ["checkPtAccess", "checkAccess"]}]}
{"pr_number": 67553, "url": "https://github.com/llvm/llvm-project/pull/67553", "title": "[Support] Add KnownBits::computeForSubBorrow #65893", "body": "- [Support] Add KnownBits::computeForSubBorrow\n- [CodeGen] Implement USUBC, USUBO_CARRY, and SSUBO_CARRY with KnownBits::computeForSubBorrow\n- [CodeGen] Compute unknown bits for Carry/Borrow for ADD/SUB\n", "feature_layers": ["codegen"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/unittests/Support/KnownBitsTest.cpp", "functions": ["Known"]}, {"filename": "llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp", "functions": ["if"]}]}
{"pr_number": 67420, "url": "https://github.com/llvm/llvm-project/pull/67420", "title": "[clang analysis][NFCI] Preparatory work for D153131.", "body": "This was ported over from phabricator.\r\n\r\nReview https://reviews.llvm.org/D153131.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Analysis/ThreadSafety.cpp", "functions": ["checkPtAccess", "checkAccess"]}]}
{"pr_number": 67694, "url": "https://github.com/llvm/llvm-project/pull/67694", "title": "[mlir][Affine][NFC] Define AffineForOp operands in ODS", "body": "Modernize affine dialect ops: Define LB, UB, step and inits as operands in TableGen.\r\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Affine/IR/AffineOps.cpp", "functions": ["OpFoldResult", "getStepAsInt", "getStep", "failure", "AffineBound"]}]}
{"pr_number": 67659, "url": "https://github.com/llvm/llvm-project/pull/67659", "title": "[mlir][SME] Add vector.splat -> SME conversion", "body": "This conversion is identical to vector.broadcast when broadcasting a\nscalar.\n", "feature_layers": ["ir", "ast"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Conversion/VectorToArmSME/VectorToArmSME.cpp", "functions": ["g"]}]}
{"pr_number": 67652, "url": "https://github.com/llvm/llvm-project/pull/67652", "title": "[mlir][ArmSME] Add arm_sme.move_tile_slice_to_vector op", "body": "This adds a simple higher-level op for the tile slice to vector intrinsics (and updates the existing vector.print lowering to use it). This op will be used a few more times to implement vector.insert/extract lowerings in later patches.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/ArmSME/Transforms/LegalizeForLLVMExport.cpp", "functions": ["success"]}]}
{"pr_number": 67273, "url": "https://github.com/llvm/llvm-project/pull/67273", "title": "[InstCombine] Canonicalize `icmp eq/ne (A ^ C), B` to `icmp eq/ne (A ^ B), C`", "body": "This patch canonicalizes `icmp eq/ne (A ^ Cst), B` to `icmp eq/ne (A ^ B), Cst` since the latter form exposes more optimizations.\r\nProof: https://alive2.llvm.org/ce/z/9DbhGc\r\nFixes #65968.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp", "functions": ["ICmpInst"]}]}
{"pr_number": 67776, "url": "https://github.com/llvm/llvm-project/pull/67776", "title": "[clang analysis][thread-safety] Handle return-by-reference...", "body": "...of guarded variables, when the function is not marked as requiring locks:\r\n\r\n```\r\nclass Return {\r\n  Mutex mu;\r\n  Foo foo GUARDED_BY(mu);\r\n\r\n  Foo &returns_ref_locked() {\r\n    MutexLock lock(&mu);\r\n    return foo;  // BAD\r\n  }\r\n\r\n  Foo &returns_ref_locks_required() SHARED_LOCKS_REQUIRED(mu) {\r\n    return foo;  // OK\r\n  }\r\n};\r\n```\r\n\r\nReview on Phabricator: https://reviews.llvm.org/D153131", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "clang/lib/Analysis/ThreadSafety.cpp", "functions": ["LocksetBuilder", "VisitReturnStmt"]}, {"filename": "clang/test/SemaCXX/warn-thread-safety-analysis.cpp", "functions": ["lock", "returns_ref_releases_lock_before_return", "GUARDED_BY", "returns_value_releases_lock_after_return", "returns_value_releases_lock_before_return", "PT_GUARDED_BY", "returns_value_aquires_lock", "returns_value_locked", "returns_value_locks_required", "returns_value_not_locked"]}]}
{"pr_number": 67795, "url": "https://github.com/llvm/llvm-project/pull/67795", "title": "Revert \"[clang analysis][thread-safety] Handle return-by-reference...\u2026", "body": "\u2026 (#67776)\"\r\n\r\nThis detects issues in `scudo`. Reverting until these are fixed.\r\n\r\n```\r\n/b/sanitizer-x86_64-linux-autoconf/build/llvm-project/compiler-rt/lib/scudo/standalone/tsd.h:74:12: error: returning variable 'QuarantineCache' by reference requires holding mutex 'Mutex' exclusively [-Werror,-Wthread-safety-reference]\r\n   74 |     return QuarantineCache;\r\n      |            ^\r\n/b/sanitizer-x86_64-linux-autoconf/build/llvm-project/compiler-rt/lib/scudo/standalone/combined.h:248:28: note: in instantiation of member function 'scudo::TSD<scudo::Allocator<scudo::DefaultConfig, &malloc_postinit>>::getQuarantineCache' requested here\r\n  248 |     Quarantine.drain(&TSD->getQuarantineCache(),\r\n      |                            ^\r\n/b/sanitizer-x86_64-linux-autoconf/build/llvm-project/compiler-rt/lib/scudo/standalone/tsd.h:57:15: note: in instantiation of member function 'scudo::Allocator<scudo::DefaultConfig, &malloc_postinit>::commitBack' requested here\r\n   57 |     Instance->commitBack(this);\r\n      |               ^\r\n/b/sanitizer-x86_64-linux-autoconf/build/llvm-project/compiler-rt/lib/scudo/standalone/tsd_exclusive.h:172:27: note: in instantiation of member function 'scudo::TSD<scudo::Allocator<scudo::DefaultConfig, &malloc_postinit>>::commitBack' requested here\r\n  172 |   TSDRegistryT::ThreadTSD.commitBack(Instance);\r\n      |                           ^\r\n/b/sanitizer-x86_64-linux-autoconf/build/llvm-project/compiler-rt/lib/scudo/standalone/tsd_exclusive.h:33:46: note: in instantiation of function template specialization 'scudo::teardownThread<scudo::Allocator<scudo::DefaultConfig, &malloc_postinit>>' requested here\r\n   33 |     CHECK_EQ(pthread_key_create(&PThreadKey, teardownThread<Allocator>), 0);\r\n      |                                              ^\r\n/b/sanitizer-x86_64-linux-autoconf/build/llvm-project/compiler-rt/lib/scudo/standalone/tsd_exclusive.h:42:5: note: in instantiation of member function 'scudo::TSDRegistryExT<scudo::Allocator<scudo::DefaultConfig, &malloc_postinit>>::init' requested here\r\n   42 |     init(Instance); // Sets Initialized.\r\n      |     ^\r\n/b/sanitizer-x86_64-linux-autoconf/build/llvm-project/compiler-rt/lib/scudo/standalone/tsd_exclusive.h:130:5: note: in instantiation of member function 'scudo::TSDRegistryExT<scudo::Allocator<scudo::DefaultConfig, &malloc_postinit>>::initOnceMaybe' requested here\r\n  130 |     initOnceMaybe(Instance);\r\n      |     ^\r\n/b/sanitizer-x86_64-linux-autoconf/build/llvm-project/compiler-rt/lib/scudo/standalone/tsd_exclusive.h:74:5: note: in instantiation of member function 'scudo::TSDRegistryExT<scudo::Allocator<scudo::DefaultConfig, &malloc_postinit>>::initThread' requested here\r\n   74 |     initThread(Instance, MinimalInit);\r\n      |     ^\r\n/b/sanitizer-x86_64-linux-autoconf/build/llvm-project/compiler-rt/lib/scudo/standalone/combined.h:221:17: note: in instantiation of member function 'scudo::TSDRegistryExT<scudo::Allocator<scudo::DefaultConfig, &malloc_postinit>>::initThreadMaybe' requested here\r\n  221 |     TSDRegistry.initThreadMaybe(this, MinimalInit);\r\n      |                 ^\r\n/b/sanitizer-x86_64-linux-autoconf/build/llvm-project/compiler-rt/lib/scudo/standalone/combined.h:790:5: note: in instantiation of member function 'scudo::Allocator<scudo::DefaultConfig, &malloc_postinit>::initThreadMaybe' requested here\r\n  790 |     initThreadMaybe();\r\n      |     ^\r\n/b/sanitizer-x86_64-linux-autoconf/build/llvm-project/compiler-rt/lib/scudo/standalone/wrappers_c.inc:36:25: note: in instantiation of member function 'scudo::Allocator<scudo::DefaultConfig, &malloc_postinit>::canReturnNull' requested here\r\n   36 |     if (SCUDO_ALLOCATOR.canReturnNull()) {\r\n```\r\n\r\nThis reverts commit 6dd96d6e80e9b3679a6161c590c60e0e99549b89.", "feature_layers": ["ir"], "feature_directives": ["requires"], "files_changed": [{"filename": "clang/lib/Analysis/ThreadSafety.cpp", "functions": ["LocksetBuilder", "VisitReturnStmt"]}, {"filename": "clang/test/SemaCXX/warn-thread-safety-analysis.cpp", "functions": ["lock", "returns_ref_releases_lock_before_return", "GUARDED_BY", "returns_value_releases_lock_after_return", "returns_value_releases_lock_before_return", "PT_GUARDED_BY", "returns_value_aquires_lock", "returns_value_locked", "returns_value_locks_required", "returns_value_not_locked"]}]}
{"pr_number": 67683, "url": "https://github.com/llvm/llvm-project/pull/67683", "title": "[AIX][PowerPC] Teach the Threading Library About the Number of Physical Cores on AIX", "body": "The threading library does not recognize AIX and always returns `-1` for number of physical cores on AIX. This PR teaches the library to recognize AIX and obtain the correct value for the number of physical cores. ", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Support/Unix/Threading.inc", "functions": ["computeHostNumPhysicalCores"]}]}
{"pr_number": 67790, "url": "https://github.com/llvm/llvm-project/pull/67790", "title": "[Linalg] Fix SoftmaxOp's reify result shape calculation", "body": "-- SoftmaxOp's `reifyResultShapes` function was wrongly casting it as a `LinalgOp`.\r\n-- This commit thus adds a fix to SoftmaxOp's reify result shape calculation.\r\n\r\nSigned-off-by: Abhishek Varma <abhishek@nod-labs.com>", "feature_layers": ["ast"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/Linalg/IR/LinalgOps.cpp", "functions": ["success", "rewriter"]}]}
{"pr_number": 66844, "url": "https://github.com/llvm/llvm-project/pull/66844", "title": "[OpenMP] Introduce the initial support for OpenMP kernel language", "body": "This patch starts the support for OpenMP kernel language, basically to write\r\nOpenMP target region in SIMT style, similar to kernel languages such as CUDA.\r\nWhat included in this first patch is the `ompx_bare` clause for `target teams`\r\ndirective. When `ompx_bare` exists, globalization is disabled such that local\r\nvariables will not be globalized. The runtime init/deinit function calls will\r\nnot be emitted. That being said, almost all OpenMP executable directives are\r\nnot supported in the region, such as parallel, task. This patch doesn't include\r\nthe Sema checks for that, so the use of them is UB. Simple directives, such as\r\natomic, can be used. We provide a set of APIs (for C, they are prefix with\r\n`ompx_`; for C++, they are in `ompx` namespace) to get thread id, block id, etc.\r\nFor more details, you can refer to\r\nhttps://tianshilei.me/wp-content/uploads/llvm-hpc-2023.pdf.\r\n", "feature_layers": ["sema", "runtime", "ir"], "feature_directives": ["task", "parallel", "for", "atomic", "target", "teams"], "files_changed": [{"filename": "clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp", "functions": ["RT"]}, {"filename": "clang/lib/Parse/ParseOpenMP.cpp", "functions": ["getOpenMPClauseName"]}, {"filename": "clang/lib/Sema/SemaOpenMP.cpp", "functions": ["new"]}, {"filename": "clang/test/OpenMP/nvptx_target_teams_ompx_bare_codegen.cpp", "functions": ["ftemplate", "bar"]}, {"filename": "clang/test/OpenMP/ompx_bare_messages.c", "functions": ["bar", "foo"]}]}
{"pr_number": 65407, "url": "https://github.com/llvm/llvm-project/pull/65407", "title": "[SystemZ][z/OS] This change adds support for the PPA2 section in zOS", "body": "This PR adds support for the PPA2 fields.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Support/Chrono.cpp", "functions": ["getStructTMUtc"]}, {"filename": "llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp", "functions": ["O", "ostr", "getProductRelease", "formatv", "getProductPatch", "getProductVersion"]}]}
{"pr_number": 67722, "url": "https://github.com/llvm/llvm-project/pull/67722", "title": "[clang] Fix a crash from nested ArrayInitLoopExpr", "body": "For the following snippets clang performs the same steps:\r\n```\r\n  S s[2][2];\r\n\r\n  auto [a1,a2] = s;\r\n```\r\n\r\n```\r\nvoid crash() {\r\n  S s[2][2];\r\n\r\n  int arr[4];\r\n\r\n  arr[0] = [s] { return s[0][0].i; }();\r\n}\r\n```\r\n\r\nFrom the two however the latter crashes. The source of the crash is that we create a temporary variable for the source array expression, the `ArrayInitLoop` is performed on.\r\n\r\n```\r\n-ArrayInitLoopExpr ... 'S[2][2]'\r\n |-OpaqueValueExpr ...\r\n | `-DeclRefExpr ... 'S[2][2]' lvalue Var ... 's' 'S[2][2]'\r\n `-ArrayInitLoopExpr ... 'S[2]' \r\n   |-OpaqueValueExpr ... <-- a temporary is created for this during every iteration\r\n   | `<SourceArray> \r\n   `-...\r\n```\r\nThe problem is that we are unable to differentiate between the temporaries that are created in the different iterations, as we only use the pointer to the node as the key, which stays the same.\r\n\r\nAs for why only the second snippet crashes, the reason is that after evaluating the first iteration, we note a failure and would return, however during analyzing the second snippet, the `CheckingForUndefinedBehavior` flag is set, probably because we assign to an array member and clang wants us to keep going.\r\n\r\n~~This patch changes the described behaviour, as if we keep going the exact same expression would be evaluated again and it would fail again, so there's no point of doing that.~~ A different solution would be to wrap the temporary in a `FullExpressionRAII` so that the temporary is cleaned up before it is created once again.\r\n\r\nFixes #57135\r\n\r\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/AST/nested-array-init-loop-in-lambda-capture.cpp", "functions": ["used_to_crash"]}, {"filename": "clang/lib/AST/ExprConstant.cpp", "functions": ["Scope"]}, {"filename": "clang/test/AST/Interp/cxx20.cpp", "functions": ["set", "main", "f", "X", "Highlander"]}]}
{"pr_number": 67871, "url": "https://github.com/llvm/llvm-project/pull/67871", "title": "[mlir][spirv] Implement missing validation rules for ptr variables", "body": "Variables that point to physical storage buffer require aliasing decorations. This is specified by the `SPV_KHR_physical_storage_buffer` extension.\r\n\r\nAlso add an example of a variable with a decoration attribute.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/SPIRV/IR/MemoryOps.cpp", "functions": ["emitOpError"]}]}
{"pr_number": 65228, "url": "https://github.com/llvm/llvm-project/pull/65228", "title": "[C API] Fix LLVMGetOrdering/LLVMIsAtomicSingleThread for fence/memory instrs", "body": "Fixes https://github.com/llvm/llvm-project/issues/65227\r\n\r\nLLVMGetOrdering previously did not support Fence instructions, and calling it on a fence would lead to a bad cast as it\r\nassumed a load/store, or an AtomicRMWInst. This would either read a garbage memory order, or assertion\r\n\r\nLLVMIsAtomicSingleThread did not support either Fence instructions, loads, or stores, and would similarly lead to a bad cast.\r\nIt happened to work out since the relevant types all have their synch scope ID at the same offset, but it still should be fixed\r\n\r\nThese cases are now fixed for the C API, and tests for these instructions are added. The echo test utility now also supports cloning Fence instructions, which it did not previously\r\n\r\n-----\r\n\r\nFrom what I can tell, there's no unified API to pull `getOrdering`/`getSyncScopeID` from, and instead requires casting to individual types: if there is a better way of handling this I can switch to that", "feature_layers": ["ir", "ast"], "feature_directives": ["for", "single", "atomic", "requires"], "files_changed": [{"filename": "llvm/lib/IR/Core.cpp", "functions": ["if"]}]}
{"pr_number": 65823, "url": "https://github.com/llvm/llvm-project/pull/65823", "title": "Update GoogleTest to v1.14.0", "body": "This PR updates GoogleTest to v1.14.0\r\nThe LLVM specific modification over the GoogleTest can be seen from: https://gist.github.com/zeroomega/fb24b1d1c4252b852200e15fda29384d\r\nList of removed GoogleTest files can be found: \r\nhttps://gist.github.com/zeroomega/54d1da74aa5df9a22bf60474adc53cab\r\n\r\n2 additional commits are required for the GoogleTest roll. Due to a change in how GoogleTest treats uninstantiated tests, any test added by `TEST_P` needs an corresponding `INSTANTIATE_TEST_SUITE_P`, otherwise an error will be reported. However, in LLVM, sometimes `INSTANTIATE_TEST_SUITE_P` calls were commented out to temporarily disable tests. In this case in v1.14.0, a `GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST` is needed to suppress the error. This macro did not exist in v1.10.0 so the change needs to land together with v1.14.0 roll to avoid build breakages.\r\n\r\nThe roll was tested under Linux x64 and Windows x64 and pass all tests under testing. It would be great if we can tests it under more build variants and hosts in LLVM bots before landing it.\r\n\r\nI admit I cannot create a shellscript to do the auto roll. At least it was not possible without some non-trival refactoring to LLVM's patch and move these LLVM's additional functions into `gtest_port.h/cc` and `gmock_port.h/cc`. A better approach would be upstream LLVM's changes to GoogleTest so we can just keep a vanilla GoogleTest in LLVM (using git submodule). \r\n\r\nThe GoogleTest code also uses a different code style (Google C++ style instead of LLVM style). Shall I reformat the entire GoogleTest code base?", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "third-party/unittest/googlemock/src/gmock-cardinalities.cc", "functions": ["min_"]}, {"filename": "third-party/unittest/googlemock/src/gmock-internal-utils.cc", "functions": ["JoinAsTuple", "UnBase64Impl", "Base64Unescape", "UndoWebSafeEncoding"]}, {"filename": "third-party/unittest/googlemock/src/gmock-spec-builders.cc", "functions": ["intToCallReaction", "IsSaturated", "source_text", "UninterestingCallReactionMap", "IsSatisfied"]}, {"filename": "third-party/unittest/googlemock/src/gmock.cc", "functions": ["ParseInt32"]}, {"filename": "third-party/unittest/googlemock/src/gmock_main.cc", "functions": ["setup", "loop", "main", "RUN_ALL_TESTS", "_tmain"]}, {"filename": "third-party/unittest/googletest/src/gtest-assertion-result.cc", "functions": ["AssertionSuccess", "AssertionFailure", "success_", "negation"]}, {"filename": "third-party/unittest/googletest/src/gtest-death-test.cc", "functions": ["GetEnviron", "DeathTestAbort", "size", "AddArgument", "FormatDeathTestOutput", "GetCapturedStderr", "Argv", "AddArguments"]}, {"filename": "third-party/unittest/googletest/src/gtest-filepath.cc", "functions": ["path", "IsPathSeparator", "RemoveTrailingPathSeparator", "IsDirectory"]}, {"filename": "third-party/unittest/googletest/src/gtest-port.cc", "functions": ["info", "MatchRegexAtHead", "FormatFileLocation", "IsAsciiWordChar", "Int32FromGTestEnv", "OutputFlagAlsoCheckEnvVar", "handle_", "IsAsciiDigit", "runnable_", "IsAsciiWhiteSpace", "SleepMilliseconds", "ParseInt32"]}, {"filename": "third-party/unittest/googletest/src/gtest-printers.cc", "functions": ["PrintTo", "PrintAsCharLiteralTo", "GetCharWidthPrefix", "PrintAsStringLiteralTo", "UniversalPrintArray", "PrintU16StringTo", "PrintCStringTo", "ToChar32", "IsPrintableAscii", "PrintU32StringTo", "IsUTF8TrailByte", "PrintU8StringTo"]}, {"filename": "third-party/unittest/googletest/src/gtest.cc", "functions": ["TestPartResultTypeToString", "OnTestCaseStart", "operator", "Elapsed", "OnEnvironmentsSetUpStart", "data_", "ParseBoolFlag", "success_", "CodePointToUtf8", "name_", "Int32FromEnvOrDie", "Append", "PositiveAndNegativeUnitTestFilter", "ParseInt32", "IsGlobPattern", "IsSubstringPred", "loc_", "FormatIntWidthN", "OnTestCaseEnd", "GetDefaultFailFast", "disable_test_filter", "ChopLowBits", "strcmp", "UnitTestFilter", "HandleExceptionsInMethodIfSupported", "OnEnvironmentsTearDownStart", "Indent", "sizeof", "AssertionResult", "impl", "GTestIsInitialized", "unit_test_", "lock", "OnTestSuiteStart", "OnTestProgramEnd", "OnTestProgramStart", "StreamingListener", "ParseInt32Flag", "PrintFailedTestSuites", "TestBody", "MatchesName", "HandleSehExceptionsInMethodIfSupported", "GetDirFromEnv", "FormatHexUInt32", "TestPropertiesAsJson", "ParseStringFlag", "StringStreamToString", "EscapeXmlAttribute", "OnTestDisabled", "PrintToString", "TestNameIs", "if", "PrintTestName", "arg_str", "OnTestPartResult", "intercept_mode_", "OnTestStart", "GTEST_CUSTOM_SRCDIR_FUNCTION_", "GetCurrentExecutableDirectory", "GetTimeInMillis", "OnTestSuiteEnd", "death_test_suite_filter", "EqFailure", "AssertionFailure", "negation", "IsNormalizableWhitespace", "OnEnvironmentsTearDownEnd", "SrcDir", "OnTestIterationEnd", "GetTestTypeId", "OnEnvironmentsSetUpEnd", "ColoredPrintf", "localtime_s", "IsValidXmlCharacter", "RegisterTypeParameterizedTestSuiteInstantiation", "ClassUniqueToAlwaysTrue", "ParseFlag", "argv_0", "AssertionSuccess", "gtest_flag_saver_", "GetIgnoredParameterizedTestSuites", "OnTestEnd"]}, {"filename": "third-party/unittest/googletest/src/gtest_main.cc", "functions": ["setup", "loop", "main", "RUN_ALL_TESTS"]}]}
{"pr_number": 67555, "url": "https://github.com/llvm/llvm-project/pull/67555", "title": "[RISCV][MC] Recognise that fcvt.d.s with frm != 0b000 is valid", "body": "This seems to be an issue common to both GCC and LLVM. There are various RISC-V FCVT instructions where the frm field makes no difference to the output as the result is always exact (e.g. fcvt.d.s, fcvt.s.h, fcvt.d.h). As with GCC, we always generate a form of these fcvt instructions where frm=0b000. However, the ISA manual _doesn't_ state that frm values are invalid, and we should ensure we can accept them. This patch does so by adding the frm field to fcvt.d.s and adding an InstAlias so that if no frm is specified, it defaults to rne (0b000).\r\n\r\nThis patch just corrects fcvt.d.s in order to allow the approach to be reviewed, before applying it to the other affected instructions.\r\n\r\nI haven't added tests to llvm/test/MC/Disassembler/RISCV, because it doesn't seem necessary to test there in addition to our usual round-trip tests in llvm/test/MC/RISCV. But feedback is welcome.\r\n\r\nRecently added tests ensure that the default `rne` rounding mode is printed as desired.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp", "functions": ["isFRMArgLegacy", "defaultFRMArgLegacyOp"]}]}
{"pr_number": 67234, "url": "https://github.com/llvm/llvm-project/pull/67234", "title": "Add a structured if operation", "body": "Add an emitc.if op to the EmitC dialect. A new convert-scf-to-emitc\npass replaces the existing direct translation of scf.if to C; The\ntranslator now handles emitc.if instead.\n\nThe emitc.if op doesn't return any value and its then/else regions are\nterminated with a new scf.yield op. Values returned by scf.if are\nlowered using emitc.variable ops, assigned to in the then/else regions\nusing a new emitc.assign op.\n", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Conversion/SCFToEmitC/SCFToEmitC.cpp", "functions": ["target", "runOnOperation", "success", "patterns"]}, {"filename": "mlir/lib/Dialect/EmitC/IR/EmitC.cpp", "functions": ["emitOpError", "success", "guard", "failure", "adaptor"]}, {"filename": "mlir/lib/Target/Cpp/TranslateToCpp.cpp", "functions": ["failure", "printOperation", "success"]}]}
{"pr_number": 67904, "url": "https://github.com/llvm/llvm-project/pull/67904", "title": "[GSYM] Fix the initialization of DataExtractor", "body": "Without this patch, we pass Endian as one of the parameters to the\nconstructor of DataExtractor.  The problem is that Endian is of:\n\n  enum endianness {big, little, native};\n\nwhereas the constructor is expecting \"bool IsLittleEndian\".  That is,\nwe are relying on an implicit conversion to convert big and little to\nfalse and true, respectively.\n\nWhen we migrate llvm::support::endianness to std::endian in future, we\ncan no longer rely on an implicit conversion because std::endian is\ndeclared with \"enum class\".  Even if we could, the conversion would\nnot be guaranteed to work because, for example, libcxx defines:\n\n  enum class endian {\n    little = 0xDEAD,\n    big = 0xFACE,\n    :\n\nwhere big and little are not boolean values.\n\nThis patch fixes the problem by properly converting Endian to a\nboolean value.\n", "feature_layers": [], "feature_directives": ["for", "declare"], "files_changed": [{"filename": "llvm/lib/DebugInfo/GSYM/GsymReader.cpp", "functions": ["Data"]}]}
{"pr_number": 67821, "url": "https://github.com/llvm/llvm-project/pull/67821", "title": "[RISCV] Form vredsum from explode_vector + scalar (left) reduce", "body": "This change adds two related DAG combines which together will take a left-reduce scalar add tree of an explode_vector, and will incrementally form a vector reduction of the vector prefix.  If the entire vector is reduced, the result will be a reduction over the entire vector.\r\n\r\nProfitability wise, this relies on vredsum being cheaper than a pair of extracts and scalar add.  Given vredsum is linear in LMUL, and the vslidedown required for the extract is *also* linear in LMUL, this is clearly true at higher index values.  At N=2, it's a bit questionable, but I think the vredsum form is probably a better canonical form anyways.\r\n\r\nNote that this only matches left reduces.  This happens to be the motivating example I have (from spec2017 x264).  This approach could be generalized to handle right reduces without much effort, and could be generalized to handle any reduce whose tree starts with adjacent elements if desired.  The approach fails for a reduce such as (A+C)+(B+D) because we can't find a root to start the reduce with without scanning the entire associative add expression.  We could maybe explore using masked reduces for the root node, but that seems of questionable profitability.  (As in, worth questioning - I haven't explored in any detail.)\r\n\r\nThis is covering up a deficiency in SLP.  If SLP encounters the scalar form of reduce_or(A) + reduce_sum(a) where a is some common vectorizeable tree, SLP will sometimes fail to revisit one of the reductions after vectorizing the other.  Fixing this in SLP is hard, and there's no good reason not to handle the easy cases in the backend.\r\n\r\nAnother option here would be to do this in VectorCombine or generic DAG.  I chose not to as the profitability of the non-legal typed prefix cases is very target dependent.  I think this makes sense as a starting point, even if we move it elsewhere later.\r\n\r\nThis is currently restructed only to add reduces, but obviously makes sense for any associative reduction operator.  Once this is approved, I plan to extend it in this manner.  I'm simply staging work in case we decide to go in another direction.", "feature_layers": ["ir"], "feature_directives": ["for", "target", "masked"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVISelLowering.cpp", "functions": ["SDValue", "DL"]}]}
{"pr_number": 65293, "url": "https://github.com/llvm/llvm-project/pull/65293", "title": "[mlir][affine] Check the input vector sizes to be greater than 0", "body": "In the process of vectorization of the affine loop, the 0 vector size causes the crash with building the invalid AffineForOp. We can catch the case beforehand propagating to the assertion.\r\n\r\nSee: https://github.com/llvm/llvm-project/issues/64262", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Affine/Transforms/SuperVectorize.cpp", "functions": ["signalPassFailure"]}]}
{"pr_number": 67923, "url": "https://github.com/llvm/llvm-project/pull/67923", "title": "[mlir][bufferization] Better analysis around allocs and block arguments", "body": "Values that are the result of buffer allocation ops are guaranteed to *not* be the same allocation as block arguments of containing blocks. This fact can be used to allow for more aggressive simplification of `bufferization.dealloc` ops.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Bufferization/Transforms/BufferDeallocationSimplification.cpp", "functions": ["getViewBase", "distinctAllocAndBlockArgument", "areDistinct"]}]}
{"pr_number": 67880, "url": "https://github.com/llvm/llvm-project/pull/67880", "title": "[mlir][memref] Use array notation instead of permutation map for memref.transpose", "body": "Until now, the dimensional permutation for memref.transpose was given in the form of an affine map. However, just from looking at such a representation, e.g. `(i, j) -> (j, i)`, it's not obvious whether it represents a mapping from the result dimensions to the source dimensions or the other way around. This has led to a bug (#65145).\r\n\r\nThis patch introduces to `memref.transpose` the integer array based notation that is also used in Ops like `linalg.transpose`, `memref.collapse_shape` and others which is harder to misinterpret and easier to work with.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/MemRef/IR/MemRefOps.cpp", "functions": ["emitOpError"]}]}
{"pr_number": 66647, "url": "https://github.com/llvm/llvm-project/pull/66647", "title": "[analyzer] Remove inaccurate legacy handling of bad bitwise shifts", "body": "Previously, bitwise shifts with constant operands were validated by the checker `core.UndefinedBinaryOperatorResult`. However, this logic was unreliable, and commit 25b9696b61e53a958e217bb3d0eab66350dc187f added the dedicated checker `core.BitwiseShift` which validated the preconditions of all bitwise shifts with a more accurate logic (that uses the real types from the AST instead of the unreliable type information encoded in `APSInt` objects).\r\n\r\nThis commit disables the inaccurate logic that could mark bitwise shifts as 'undefined' and removes the redundant shift-related warning messages from core.UndefinedBinaryOperatorResult. The tests that were validating this logic are also deleted by this commit; but I verified that those testcases trigger the expected bug reports from `core.BitwiseShift`. (I didn't convert them to tests of `core.BitwiseShift`, because that checker already has its own extensive test suite with many analogous testcases.)\r\n\r\nI hope that there will be a time when the constant folding will be reliable, but until then we need hacky solutions like this improve the quality of results.", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/StaticAnalyzer/Checkers/UndefResultChecker.cpp", "functions": ["if"]}, {"filename": "clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp", "functions": ["UnknownVal"]}, {"filename": "clang/test/Analysis/bitwise-ops-nocrash.c", "functions": ["offsetof", "left_shift_overflow_no_crash"]}, {"filename": "clang/test/Analysis/bitwise-ops.c", "functions": ["testPersistentConstraints", "testOverflowShift", "testNegativeLeftShift", "testConstantShifts_PR18073", "clang_analyzer_eval", "testNegativeShift", "testUnrepresentableLeftShift"]}, {"filename": "clang/test/Analysis/bitwise-shift-sanity-checks.c", "functions": ["strange_cast"]}, {"filename": "clang/test/Analysis/left-shift-cxx2a.cpp", "functions": ["testNegativeLeftShift", "testNegativeShift", "testUnrepresentableLeftShift"]}]}
{"pr_number": 65844, "url": "https://github.com/llvm/llvm-project/pull/65844", "title": "[clang][Interp] Add IntegralAP for arbitrary-precision integers", "body": "This adds `IntegralAP` backing the two new primtypes `IntAP` (unsinged arbitrary-precision int) and `IntAPS` (same but signed).\r\n\r\nWe use this for `int128` support (which isn't available on all host systems we support AFAIK) and I think we can also use this for `_BitInt` later.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/AST/Interp/literals.cpp", "functions": ["CastFrom", "CastTo"]}]}
{"pr_number": 67927, "url": "https://github.com/llvm/llvm-project/pull/67927", "title": "[mlir][bufferization] Remove `resolveUsesInRepetitiveRegions`", "body": "The bufferization analysis has been improved over the last months and this workaround is no longer needed.", "feature_layers": ["ir", "ast"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/Bufferization/Transforms/TensorCopyInsertion.cpp", "functions": ["state", "rewriter"]}]}
{"pr_number": 67769, "url": "https://github.com/llvm/llvm-project/pull/67769", "title": "[flang][hlfir] Return function call result as AsExpr.", "body": "This should help inlining elemental into another elemental, and also will help to get rid of unnecessary deep copies in bufferization.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "flang/lib/Lower/ConvertCall.cpp", "functions": ["extendedValueToHlfirEntity"]}]}
{"pr_number": 67212, "url": "https://github.com/llvm/llvm-project/pull/67212", "title": "[analyzer] Fix crash in BasicValueFactory.cpp with __int128_t integers", "body": "This change avoids a crash in BasicValueFactory by checking the bit width of an APSInt to avoid calling getZExtValue if greater than 64-bits. This was caught by our internal, randomized test generator.\r\n\r\nClang invocation\r\nclang -cc1 -analyzer-checker=optin.portability.UnixAPI case.c\r\n\r\n<src-root>/llvm/include/llvm/ADT/APInt.h:1488:\r\nuint64_t llvm::APInt::getZExtValue() const: Assertion `getActiveBits() <= 64\r\n  && \"Too many bits for uint64_t\"' failed.\r\n...\r\n\r\n #9 <address> llvm::APInt::getZExtValue() const\r\n     <src-root>/llvm/include/llvm/ADT/APInt.h:1488:5\r\n     clang::BinaryOperatorKind, llvm::APSInt const&, llvm::APSInt const&)\r\n     <src-root>/clang/lib/StaticAnalyzer/Core/BasicValueFactory.cpp:307:37\r\n     llvm::IntrusiveRefCntPtr<clang::ento::ProgramState const>,\r\n     clang::BinaryOperatorKind, clang::ento::NonLoc, clang::ento::NonLoc,\r\n     clang::QualType)\r\n     <src-root>/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:531:31\r\n     llvm::IntrusiveRefCntPtr<clang::ento::ProgramState const>,\r\n     clang::BinaryOperatorKind, clang::ento::SVal, clang::ento::SVal,\r\n     clang::QualType)\r\n     <src-root>/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp:532:26\r\n...", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/Analysis/int128-nocrash.c", "functions": ["_BitInt", "int128", "withbitint"]}]}
{"pr_number": 67373, "url": "https://github.com/llvm/llvm-project/pull/67373", "title": "[Clang] Fix crash when ill-formed code is treated as a deduction guide", "body": "In some cases where ill-formed code could be interpreted as a deduction guide we can crash because we reach an unreachable path. This fixes this issue by introducing a diagnostic instead.\r\n\r\nFixes: https://github.com/llvm/llvm-project/issues/65522", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/SemaCXX/gh65522.cpp", "functions": ["B3"]}]}
{"pr_number": 66120, "url": "https://github.com/llvm/llvm-project/pull/66120", "title": "[clang-cl] Fix value of __FUNCTION__ and __FUNC__ in MSVC mode for c++.", "body": "Predefined macro __FUNCTION__  in clang is not returning the same string than MS for templated functions.\r\n\r\nSee https://godbolt.org/z/q3EKn5zq4\r\n\r\nFor the same test case MSVC is returning:\r\n\r\nfunction: TestClass<class UnitTestNative>::TestClass\r\nfunction: TestStruct<struct C>::TestStruct\r\nfunction: TestEnum<enum E>::TestEnum", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/AST/Expr.cpp", "functions": ["Policy", "PrettyCB", "Out", "POut"]}, {"filename": "clang/test/CodeGenCXX/predefined-expr.cpp", "functions": ["strcmp"]}]}
{"pr_number": 67931, "url": "https://github.com/llvm/llvm-project/pull/67931", "title": "[clang] Add test for CWG2267", "body": "https://cplusplus.github.io/CWG/issues/2267.html\r\nRelated: #63416", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CXX/drs/dr22xx.cpp", "functions": ["d1", "b1"]}]}
{"pr_number": 67378, "url": "https://github.com/llvm/llvm-project/pull/67378", "title": "[Sema] Use underlying type of scoped enum for -Wformat diagnostics", "body": "Right now, `-Wformat` for a scoped enum will suggest a cast based on the\nformat specifier being used. This can lead to incorrect results, e.g.\nattempting to format a scoped enum with `%s` would suggest casting to\n`char *` instead of fixing the specifier. Change the logic to treat the\nscoped enum's underlying type as the intended type to be printed, and\nsuggest format specifier changes and casts based on that.\n", "feature_layers": ["sema", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/FixIt/format-darwin-enum-class.cpp", "functions": ["f"]}]}
{"pr_number": 66401, "url": "https://github.com/llvm/llvm-project/pull/66401", "title": "[MLIR] Pass hostShared flag in gpu.alloc op to runtime wrappers", "body": "This PR is a breakdown of the big PR https://github.com/llvm/llvm-project/pull/65539 which enables intel gpu integration. In this PR we pass hostShared flag to runtime wrappers (required by SyclRuntimeWrappers which will come in subsequent PR) to indicate if the allocation is done on host shared gpu memory or device only memory.", "feature_layers": ["runtime", "ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Conversion/GPUCommon/GPUToLLVMConversion.cpp", "functions": ["failure", "if"]}]}
{"pr_number": 67922, "url": "https://github.com/llvm/llvm-project/pull/67922", "title": "[mlir][CAPI, python bindings] Expose `Operation::setSuccessor`", "body": "This is useful for emitting (using the python bindings) `cf.br` to blocks that are declared lexically post block creation.", "feature_layers": ["ir"], "feature_directives": ["for", "declare"], "files_changed": [{"filename": "mlir/lib/Bindings/Python/IRCore.cpp", "functions": ["bindDerived", "slice", "dunderSetItem", "getRawNumElements", "getRawElement", "PyOpSuccessors", "PyBlock", "mlirOperationGetNumSuccessors"]}]}
{"pr_number": 68036, "url": "https://github.com/llvm/llvm-project/pull/68036", "title": "[BOLT] Support input binaries that use R_X86_GOTPC64", "body": "In large code model, the address of GOT is calculated by the static linker via R_X86_GOTPC64 reloc applied against a MOVABSQ instruction. In the final binary, it can be disassembled as a regular immediate, but because such immediate is the result of PC-relative pointer arithmetic, we need to parse this relocation and update this calculation whenever we move code, otherwise we break the code trying to read GOT.\r\n\r\nA test case showing how GOT is accessed was provided.\r\n\r\nDifferential Revision: https://reviews.llvm.org/D158911", "feature_layers": ["parse"], "feature_directives": [], "files_changed": [{"filename": "bolt/lib/Rewrite/RewriteInstance.cpp", "functions": ["if"]}]}
{"pr_number": 68049, "url": "https://github.com/llvm/llvm-project/pull/68049", "title": "[mlir][sparse] unify lib/codegen rewriting rules for sparse tensor re\u2026", "body": "\u2026shaping operations.", "feature_layers": ["parse", "codegen", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/Transforms/SparseTensorConversion.cpp", "functions": ["failure", "params", "success", "genSparse2SparseReshape"]}]}
{"pr_number": 67827, "url": "https://github.com/llvm/llvm-project/pull/67827", "title": "[flang][openacc] Keep constant bounds in reduction recipe when it is all constants", "body": "Following #67719, propagate the constant bounds in the combiner region when all bounds are constant. Otherwise, bounds information are propagated as block arguments as defined in #67719.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Lower/OpenACC.cpp", "functions": ["hasDynamicShape", "getBoundsString", "areAllBoundConstant"]}]}
{"pr_number": 67505, "url": "https://github.com/llvm/llvm-project/pull/67505", "title": "[Object] Remove restriction universal archives having both IR and native", "body": "Mach-O archives seems to be able to contain both IR objects and native objects mixed together. Apple tooling seems to deal with them correctly.\r\n\r\nThe current implementation was adding an additional restriction of all the objects in the archive being either IR objects or native objects.\r\n\r\nThe changes in this commit remove that restriction and allow mixing both IR and native objects, while still checking that the CPU restrictions still apply (all objects in a slice need to be the same CPU type/subtype).\r\n\r\nA test that was testing for the previous behaviour had been modified to test that mixed archives are allowed and that they create the expected results.\r\n\r\nAdditionally, locally I checked the results of Apple's `libtool` against `llvm-libtool-darwin` with this code, and the resulting libraries are almost identical with expected differences in the GUID and code signatures load commands, and some minor differences in the rest of the binary.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Object/MachOUniversalWriter.cpp", "functions": ["getMachoCPUFromObjectFile"]}]}
{"pr_number": 67993, "url": "https://github.com/llvm/llvm-project/pull/67993", "title": "[mlir][nvgpu] Use ImplicitLocOpBuilder in nvgpu-to-nvvm pass (NFC)", "body": "For the sake of better readability, this PR uses  `ImplicitLocOpBuilder` instead of rewriter+loc", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Conversion/NVGPUToNVVM/NVGPUToNVVM.cpp", "functions": ["makeAdd", "truncToI32", "elementTypeAsLLVMConstant", "makeI64Const", "b"]}]}
{"pr_number": 65966, "url": "https://github.com/llvm/llvm-project/pull/65966", "title": "[ELF] Handle relocations in synthetic .eh_frame with a non-zero offset within the output section", "body": "When the .eh_frame section is placed at a non-zero\r\noffset within its output section, the relocation\r\nvalue within .eh_frame are computed incorrectly.\r\n\r\nWe had similar issue in .ARM.exidx section and it has been\r\nfixed already in https://reviews.llvm.org/D148033.\r\n\r\nWhile applying the relocation using S+A-P,  the value\r\n of P (the location of the relocation) is getting wrong. \r\nP is:\r\n  P = SecAddr + rel.offset, But SecAddr points to the\r\nstarting address of the outputsection rather than the\r\nstarting address of the eh frame section within that\r\noutput section.\r\n\r\nThis issue affects all targets which generates .eh_frame \r\nsection. Hence fixing in all the corresponding targets it affecting.", "feature_layers": [], "feature_directives": ["target"], "files_changed": [{"filename": "lld/ELF/Arch/AArch64.cpp", "functions": ["if"]}, {"filename": "lld/ELF/Arch/PPC64.cpp", "functions": ["if"]}, {"filename": "lld/ELF/Arch/X86_64.cpp", "functions": ["if"]}, {"filename": "lld/ELF/Target.cpp", "functions": ["if"]}]}
{"pr_number": 67925, "url": "https://github.com/llvm/llvm-project/pull/67925", "title": "[Target] Change `no-trap-after-noreturn` to `trap-after-noreturn`", "body": "This was suggested in https://github.com/llvm/llvm-project/commit/5b7a7ec5a2106772de90a59c52e9fac7481f7e8a to avoid too many negates (e.g. `!NoTrapAfterNoreturn`).", "feature_layers": [], "feature_directives": ["target"], "files_changed": [{"filename": "llvm/lib/Target/NVPTX/NVPTXLowerUnreachable.cpp", "functions": ["NVPTXLowerUnreachable"]}]}
{"pr_number": 67033, "url": "https://github.com/llvm/llvm-project/pull/67033", "title": "Late temporal divergence lowering for SDAG", "body": "D155343 introduced performance regressions by not allowing machine instruction sinking in some cases - SWEDEV-414443.\r\nIt originally fixed SWDEV-407790\r\n\r\nRevert D155343 to fix performance regression SWEDEV-414443\r\nand introduce temporal divergence lowering pass that also fixes SWDEV-407790", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/AMDGPUTemporalDivergenceLowering.cpp", "functions": ["AMDGPUTemporalDivergenceLowering", "getAnalysisUsage", "getPassName", "runOnMachineFunction"]}]}
{"pr_number": 66656, "url": "https://github.com/llvm/llvm-project/pull/66656", "title": "Fix mechanism propagating mangled names for TLI function mappings", "body": "Currently the mappings from TLI are used to generate the list of available \"scalar to vector\" mappings attached to scalar calls as \"vector-function-abi-variant\" LLVM IR attribute. Function names from TLI are wrapped in mangled name following the pattern:\r\n_ZGV<isa><mask><vlen><parameters>_<scalar_name>[(<vector_redirection>)] The problem is the mangled name uses _LLVM_ as the ISA name which prevents the compiler to compute vectorization factor for scalable vectors as it cannot make any decision based on the _LLVM_ ISA. If we use \"s\" as the ISA name, the compiler can make decisions based on VFABI specification where SVE spacific rules are described.\r\n\r\nThis patch is only a refactoring stage where there is no change to the compiler's behaviour.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Analysis/TargetLibraryInfo.cpp", "functions": ["Out"]}, {"filename": "llvm/lib/Analysis/VectorUtils.cpp", "functions": ["Out"]}]}
{"pr_number": 66993, "url": "https://github.com/llvm/llvm-project/pull/66993", "title": "[LIBCLC] Teach prepare-builtins how to handle text based IR", "body": "", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "libclc/utils/prepare-builtins.cpp", "functions": ["TextualOut"]}]}
{"pr_number": 65257, "url": "https://github.com/llvm/llvm-project/pull/65257", "title": "[clang-repl] Emit const variables only once", "body": "Disable internal linkage for const variables if IncrementalExtensions are enabled. Otherwise the variables are emitted multiple times, with multiple constructions at unique memory locations, during every PTU.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/Interpreter/const.cpp", "functions": ["a"]}]}
{"pr_number": 67792, "url": "https://github.com/llvm/llvm-project/pull/67792", "title": "[flang][NFCI]Use config structure for MLIR to LLVM pass creation", "body": "The CreateMLIRToLLVMPassPipeline function has quite a few arguments, all of which has default values. Create a struct, with a constructor for the default values, and pass that struct instead.\r\n\r\nRe-arrange a few include files to make everything available.\r\n\r\nNo functional change intended.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Frontend/FrontendActions.cpp", "functions": ["triple", "config"]}, {"filename": "flang/tools/tco/tco.cpp", "functions": ["config"]}]}
{"pr_number": 67844, "url": "https://github.com/llvm/llvm-project/pull/67844", "title": "[Clang][OpenMP][OMPIRBuilder] Move Clang's OpenMP Member/MemberOf flag helpers into the OMPIRBuilder", "body": "This patch seeks to move the following functions to the OMPIRBuilder:\r\n - getFlagMemberOffset\r\n - getMemberOfFlag\r\n - setCorrectMemberOfFlag\r\n\r\nThese small helper functions help set the end bits of the OpenMPOffloadMappingFlags flag that correspond to the reserved segment for OMP_MAP_MEMBER_OF.\r\n\r\nThey will be of use in the future for lowering MLIR types/values that can contian members and can be lowered similarly to a structure or class type within the OpenMPToLLVMIRTranslation step of the OpenMP dialects lowering to LLVM-IR. In particular for Flang which currently uses this flow. Types with descriptors like pointers/allocatables, and likely derived types in certain cases can be lowered as if they were structures with explicitly mapped members.", "feature_layers": ["ir", "ompirbuilder"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/CodeGen/CGOpenMPRuntime.cpp", "functions": ["getFlagMemberOffset", "getMemberOfFlag", "generateAllInfoForMapper"]}, {"filename": "llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp", "functions": ["getFlagMemberOffset"]}]}
{"pr_number": 68080, "url": "https://github.com/llvm/llvm-project/pull/68080", "title": "[mlir][tensor][bufferize] `tensor.empty` bufferizes to an allocation", "body": "Make `tensor.empty` bufferizable, so that the `-empty-tensor-to-alloc-tensor` pass becomes optional. This makes the bufferization easier to use. `tensor.empty` used to be non-bufferizable, so that there two separate ops, one that can be optimized away (`tensor.empty`) and one that is guaranteed to bufferize to an allocation (`bufferization.alloc_tensor`). With the recent improvements of \"empty tensor elimination\" this is no longer needed and `bufferization.alloc_tensor` can be phased out.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/Tensor/Transforms/BufferizableOpInterfaceImpl.cpp", "functions": ["failure", "success"]}]}
{"pr_number": 68057, "url": "https://github.com/llvm/llvm-project/pull/68057", "title": "[mlir][sparse] unify lib/codegen rewriting rules for sparse tensor concatenation.", "body": "", "feature_layers": ["parse", "codegen", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/Transforms/SparseTensorConversion.cpp", "functions": ["lcvs", "params", "success"]}]}
{"pr_number": 67251, "url": "https://github.com/llvm/llvm-project/pull/67251", "title": "[mlir] Add an Observer for profiling actions to a stream.", "body": "The profile is stored in the Chrome trace event format.\r\n\r\nAdded the --profile-action-to=<file> option to mlir-opt.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Debug/Observers/ActionProfiler.cpp", "functions": ["event", "guard"]}]}
{"pr_number": 67987, "url": "https://github.com/llvm/llvm-project/pull/67987", "title": "[CodeExtractor] Consider Value arguments of dbg.assign", "body": "Currently, the code extractor functionality deletes a debug intrinsic if its \"Location\" argument is not part of the extracted function. The location is the first argument (or the first few arguments in case of a DIArgList) of all debug intrinsics.\r\n\r\nHowever, according to the docs, the signature of dbg.assign is:\r\n\r\n```\r\nvoid @llvm.dbg.assign(Value *Value,\r\n                      DIExpression *ValueExpression,\r\n                      DILocalVariable *Variable,\r\n                      DIAssignID *ID,\r\n                      Value *Address,\r\n                      DIExpression *AddressExpression)\r\n```\r\n\r\nThat is, there are two `Value` arguments to it: the usual location argument and an \"Address\" argument. This Address argument should also receive the same treatment.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/Transforms/Utils/CodeExtractor.cpp", "functions": ["IsInvalidLocation"]}]}
{"pr_number": 68078, "url": "https://github.com/llvm/llvm-project/pull/68078", "title": "[Clang] Correctly handle callees whose type is a Record type when classifying expressions", "body": "when the callee is an object.\r\n\r\nWhen implementing deducing this, we changed\r\n`DeduceTemplateArgumentsFromCallArgument` to take an argument classification because we need to deduce the type of argument for which we might not have an expression yet.\r\n\r\nHowever classifying a dependent call expression whose type is just some sort of record or elaborated type was not supported.\r\n\r\nFixes #68024", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/SemaTemplate/temp_arg_nontype_cxx1z.cpp", "functions": ["operator"]}]}
{"pr_number": 68012, "url": "https://github.com/llvm/llvm-project/pull/68012", "title": "Implement data formatters for LibStdC++ std::variant", "body": "This patch implements the data formatters for LibStdC++ `std::variant`.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "lldb/test/API/functionalities/data-formatter/data-formatter-stl/libstdcpp/variant/main.cpp", "functions": ["int", "main"]}]}
{"pr_number": 67751, "url": "https://github.com/llvm/llvm-project/pull/67751", "title": "[NFC][clang] change remaining context-dependent type nodes to ContextualFoldingSet", "body": "With this change, we are avoiding storing one pointer per Type Node instance, for the cost of one extra pointer per ASTContext, which is negligible.\r\n\r\nAfter we introduced `ContextualFoldingSet` a long time ago, we never went back and updated these existing users.\r\nThis patch corrects that.", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/AST/Type.cpp", "functions": ["ArrayType", "DecltypeType"]}]}
{"pr_number": 67066, "url": "https://github.com/llvm/llvm-project/pull/67066", "title": "[NFC][Clang][CodeGen] Improve performance for vtable metadata generation", "body": "", "feature_layers": ["codegen"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/CodeGen/CGVTables.cpp", "functions": ["O2", "O1", "Stream"]}]}
{"pr_number": 67838, "url": "https://github.com/llvm/llvm-project/pull/67838", "title": "[clang] NFCI: Use `FileEntryRef` for `FileID` creation", "body": "This patch removes the `SourceManager` APIs that create `FileID` from a `const FileEntry *` in favor of APIs that take `FileEntryRef`. This also removes a misleading documentation that claims `nullptr` file entry represents stdin. I don't think that's right, since we just try to dereference that pointer anyways.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Basic/SourceManager.cpp", "functions": ["createFileID"]}]}
{"pr_number": 68047, "url": "https://github.com/llvm/llvm-project/pull/68047", "title": "[flang] TBAA for memory accesses of derived type values.", "body": "Since HLFIR bufferization can introduce shallow copies of derived\r\ntype values we have to be careful not to treat these load/store\r\noperations as data-only-accesses. If a derived type has descriptor\r\nmembers, we attach any-access tag now.\r\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Optimizer/CodeGen/TBAABuilder.cpp", "functions": ["getAccessTag"]}, {"filename": "flang/lib/Optimizer/Dialect/FIRType.cpp", "functions": ["isRecordWithDescriptorMember"]}]}
{"pr_number": 68064, "url": "https://github.com/llvm/llvm-project/pull/68064", "title": "[flang] Deallocate components of local variables at the end of the scope.", "body": "Call Destroy runtime for local variables of derived types with\r\nallocatable components.\r\n", "feature_layers": ["runtime"], "feature_directives": ["for", "allocate"], "files_changed": [{"filename": "flang/lib/Semantics/tools.cpp", "functions": ["HasAllocatableDirectComponent"]}]}
{"pr_number": 68147, "url": "https://github.com/llvm/llvm-project/pull/68147", "title": "[flang][openacc] Use the array section for assumed shape array reduction", "body": "Use the bounds information in the reduction recipe for assumed shape arrays. ", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Optimizer/Dialect/FIRType.cpp", "functions": ["isAssumedShape"]}]}
{"pr_number": 68042, "url": "https://github.com/llvm/llvm-project/pull/68042", "title": "[mlir][OpenMP] Added translation for `omp.teams` to LLVM IR", "body": "This patch adds translation from `omp.teams` operation to LLVM IR using OpenMPIRBuilder. The clauses are not handled in this patch.", "feature_layers": ["ir"], "feature_directives": ["for", "teams"], "files_changed": [{"filename": "mlir/lib/Target/LLVMIR/Dialect/OpenMP/OpenMPToLLVMIRTranslation.cpp", "functions": ["convertOmpTeams", "frame"]}]}
{"pr_number": 66519, "url": "https://github.com/llvm/llvm-project/pull/66519", "title": "[mlir][ODS] Change `get...Mutable` to return `OpOperand &` for single operands", "body": "The TableGen code generator now generates C++ code that returns a single `OpOperand &` for `get...Mutable` of operands that are not variadic and not optional. `OpOperand::set`/`assign`  can be used to set a value (same as `MutableOperandRange::assign`). This is safer than `MutableOperandRange` because only single values (and no longer `ValueRange`) can be assigned.\r\n\r\nE.g.:\r\n```\r\n// Assignment of multiple values to non-variadic operand.\r\n// Before: Compiles, but produces invalid op.\r\n// After: Compilation error.\r\nextractSliceOp.getSourceMutable().assign({v1, v2});\r\n```\r\n\r\n", "feature_layers": ["ir"], "feature_directives": ["for", "single"], "files_changed": [{"filename": "mlir/lib/IR/OperationSupport.cpp", "functions": ["MutableOperandRange"]}, {"filename": "mlir/test/lib/Dialect/Test/TestDialect.cpp", "functions": ["MutableOperandRange", "getInitMutable"]}]}
{"pr_number": 66641, "url": "https://github.com/llvm/llvm-project/pull/66641", "title": "[clang] Preserve UDL nodes in RemoveNestedImmediateInvocation", "body": "D63960 performs a tree transformation on AST to prevent evaluating constant expressions eagerly by removing recorded immediate consteval invocations from subexpressions. (See https://reviews.llvm.org/D63960#inline-600736 for its motivation.)\r\n\r\nHowever, the UDL node has been replaced with a CallExpr in the default TreeTransform since ca844ab0 (inadvertently?). This confuses clangd as it relies on the exact AST node type to decide whether or not to present inlay hints for an expression.\r\n\r\nWith regard to the fix, I think it's enough to return the UDL expression as-is during the transformation: We've bound it to temporary in its construction, and there's no ConstantExpr to visit under a UDL.\r\n\r\nFixes https://github.com/llvm/llvm-project/issues/63898.", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Sema/SemaExpr.cpp", "functions": ["TransformUserDefinedLiteral"]}, {"filename": "clang/test/AST/ast-dump-udl-consteval.cpp", "functions": ["udl"]}]}
{"pr_number": 68104, "url": "https://github.com/llvm/llvm-project/pull/68104", "title": "[AArch64][FMV] Add rcpc3 support, introduce bits for features extensi\u2026", "body": "\u2026on and initialization.\r\n\r\nThe patch implements FEAT_LRCPC3 support (Load-Acquire RCpc instructions version 3) in Function Multi Versioning. To maintain compatibility while features list grows extension bit FEAT_EXT and initialization bit FEAT_INIT are reserved.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CodeGen/attr-target-version.c", "functions": ["__attribute__"]}, {"filename": "clang/test/Sema/attr-target-clones-aarch64.c", "functions": ["__attribute__"]}, {"filename": "clang/test/SemaCXX/attr-target-version.cpp", "functions": ["__attribute__"]}]}
{"pr_number": 68204, "url": "https://github.com/llvm/llvm-project/pull/68204", "title": "[clang][dataflow] HTML logger: Mark iterations that have converged.", "body": "I've eliminated the `logText(\"Block converged\")` call entirely because\r\n\r\na) These logs are associated with an individual `CFGElement`, while convergence\r\n   should be associated with a block, and\r\n\r\nb) The log message was being associated with the wrong block: `recordState()`\r\n   dumps all of the pending log messages, but `blockConverged()` is called after\r\n   the last `recordState()` call for a given block, so that the \"Block\r\n   converged\" log message was being associated with the first element of the\r\n   _next_ block to be processed.\r\n\r\nExample:\r\n\r\n![image](https://github.com/llvm/llvm-project/assets/29098113/6a19095c-2dbb-4771-9485-e8e45c9d26fb)\r\n\r\n", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Analysis/FlowSensitive/HTMLLogger.cpp", "functions": ["writeBlock", "blockConverged"]}]}
{"pr_number": 67106, "url": "https://github.com/llvm/llvm-project/pull/67106", "title": "[lldb][FreeBSD] Add dynamic loader handle class for FreeBSD Kernel", "body": "This commit is moved from [llvm-phabricator](https://reviews.llvm.org/D159076).\r\nThe implemtation support parsing kernel module for FreeBSD Kernel and has been test on x86-64 and arm64.\r\nIn summary, this class parse the linked list resides in the kernel memory that record all kernel module and load the debug symbol file to facilitate debug process", "feature_layers": ["parse"], "feature_directives": ["for"], "files_changed": [{"filename": "lldb/source/Plugins/DynamicLoader/FreeBSD-Kernel/DynamicLoaderFreeBSDKernel.cpp", "functions": ["is_kernel", "kld_off_address_symbol_name", "modlist_symbol_name", "file_spec", "kld_off_next_symbol_name", "DynamicLoader", "is_reloc", "kld_off_pathname_symbol_name", "kld_off_filename_symbol_name", "is_kmod", "UUID", "DynamicLoaderFreeBSDKernel", "module_spec", "IsLoaded", "kld_load_addr", "kernel_arch", "error", "kernel_name"]}, {"filename": "lldb/source/Plugins/ObjectFile/ELF/ObjectFileELF.cpp", "functions": ["loader_section_name", "Address", "freebsd_kernel_loader_name", "loader_name"]}]}
{"pr_number": 67451, "url": "https://github.com/llvm/llvm-project/pull/67451", "title": "[AArch64] Don't expand RSHRN intrinsics to add+srl+trunc.", "body": "We expand aarch64_neon_rshrn intrinsics to trunc(srl(add)), having tablegen patterns to combine the results back into rshrn. See D140297.  Unfortunately, but perhaps not surprisingly, other combines can happen that prevent us converting back.  For example sext(rshrn) becomes sext(trunc(srl(add))) which will turn into sext_inreg(srl(add))).\r\n\r\nThis patch just prevents the expansion of rshrn intrinsics, reinstating the old tablegen patterns for selecting them. This should allow us to still regognize the rshrn instructions from trunc+shift+add, without performing any negative optimizations for the intrinsics.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AArch64/AArch64ISelLowering.cpp", "functions": ["DL"]}]}
{"pr_number": 68171, "url": "https://github.com/llvm/llvm-project/pull/68171", "title": "[flang][runtime] Added Assign runtime to CUDA build closure.", "body": "", "feature_layers": ["runtime"], "feature_directives": [], "files_changed": [{"filename": "flang/runtime/ISO_Fortran_binding.cpp", "functions": ["CFI_is_contiguous", "CFI_deallocate"]}, {"filename": "flang/runtime/assign.cpp", "functions": ["RTDEF", "RTNAME", "MayAlias"]}, {"filename": "flang/runtime/derived.cpp", "functions": ["HasDynamicComponent"]}, {"filename": "flang/runtime/stat.cpp", "functions": ["ToErrmsg"]}, {"filename": "flang/runtime/tools.cpp", "functions": ["TrimTrailingSpaces", "ShallowCopy", "CheckIntegerKind"]}]}
{"pr_number": 68155, "url": "https://github.com/llvm/llvm-project/pull/68155", "title": "[libc++] Remove dead code in legacy_debug_handler.cpp", "body": "We removed all traces of the legacy debug mode a while back, but we forgot to remove the actual `.cpp` file that implemented the legacy debug handler. The file is not referenced from anywhere so this is effectively a NFC.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "libcxx/src/legacy_debug_handler.cpp", "functions": ["__libcpp_set_debug_function", "void", "__libcpp_abort_debug_function", "what"]}]}
{"pr_number": 67241, "url": "https://github.com/llvm/llvm-project/pull/67241", "title": "[mlir][transform] Fix handling of transitive includes in interpreter.", "body": "Until now, the interpreter would only load those symbols from the provided library files that were declared in the main transform module. However, sequences in the library may include other sequences on their own. Until now, if such sequences were not *also* declared in the main transform module, the interpreter would fail to resolve them. Forward declaring all of them is undesirable as it defeats the purpose of encapsulation into library modules.\r\n\r\nThis PR extends the loading missing as follows: in `defineDeclaredSymbols`, not only are the definitions inserted that are forward-declared in the main module, but any such inserted definition is scanned for further dependencies, and those are processed in the same way as the forward-declarations from the main module.", "feature_layers": ["ir"], "feature_directives": ["for", "declare"], "files_changed": [{"filename": "mlir/lib/Dialect/Transform/Transforms/TransformInterpreterPassBase.cpp", "functions": ["builder", "symbolTable", "definitionsSymbolTable", "targetSymbolTable"]}]}
{"pr_number": 68050, "url": "https://github.com/llvm/llvm-project/pull/68050", "title": "[lldb] Expose Platform::Attach through the SB API", "body": "Expose Platform::Attach through the SB API.\r\n\r\nrdar://116188959", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "lldb/source/API/SBPlatform.cpp", "functions": ["SBProcess"]}]}
{"pr_number": 67890, "url": "https://github.com/llvm/llvm-project/pull/67890", "title": "[DAG] Extend the computeOverflowForSignedSub/computeOverflowForUnsignedSub implementations with ConstantRange", "body": "- Add tests for computeOverflowFor*Sub functions\n- extend the computeOverflowForSignedSub/computeOverflowForUnsignedSub implementations with ConstantRange\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp", "functions": ["mapOverflowResult"]}]}
{"pr_number": 68014, "url": "https://github.com/llvm/llvm-project/pull/68014", "title": "[RISCV] Generaize reduction tree matching to all integer reductions", "body": "This builds on the transform introduced in https://github.com/llvm/llvm-project/pull/67821, and generalizes it for all integer reduction types.\r\n\r\nA couple of notes:\r\n* This will only form smax/smin/umax/umin reductions when zbb is enabled.  Otherwise, we lower the min/max expressions early.  I don't care about this case, and don't plan to address this further.\r\n* This excludes floating point.  Floating point introduces concerns about associativity.  I may or may not do a follow up patch for that case.\r\n* The explodevector test change is mildly undesirable from a clarity perspective.  If anyone sees a good way to rewrite that to stablize the test, please suggest.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVISelLowering.cpp", "functions": ["combineBinOpToReduce", "SDValue", "getVecReduceOpcode"]}]}
{"pr_number": 68215, "url": "https://github.com/llvm/llvm-project/pull/68215", "title": "[LinkerWrapper] Fix resolution of weak symbols during LTO", "body": "Summary:\nWeak symbols are supposed to have the semantics that they can be\noverriden by a strong (i.e. global) definition. This wasn't being\nrespected by the LTO pass because we simply used the first definition\nthat was available. This patch fixes that logic by doing a first pass\nover the symbols to check for strong resolutions that could override a\nweak one.\n\nA lot of fake linker logic is ending up in the linker wrapper. If there\nwere an option to handle this in `lld` it would be a lot cleaner, but\nunfortunately supporting NVPTX is a big restriction as their binaries\nrequire the `nvlink` tool.\n", "feature_layers": ["sema", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "openmp/libomptarget/test/offloading/weak.c", "functions": ["main"]}]}
{"pr_number": 67786, "url": "https://github.com/llvm/llvm-project/pull/67786", "title": "[mlir][ArmSME] Lower vector.extract/insert on SME tiles to MOVA intrinsics", "body": "This patch adds support for lowering vector.insert/extract of tile slices or elements to ArmSME MOVA intrinsics.\r\n\r\nThis enables the following operations for ArmSME:\r\n```\r\n// Extract slice from tile:\r\n%slice = vector.extract %tile[%row] \r\n                 : vector<[4]xi32> from vector<[4]x[4]xi32>\r\n```\r\n```\r\n// Extract element from tile:\r\n%el = vector.extract %tile[%row, %col]\r\n                 : i32 from vector<[4]x[4]xi32>\r\n```\r\n```\r\n// Insert slice into tile:\r\n%new_tile = vector.insert %slice, %tile[%row]\r\n                    : vector<[4]xi32> into vector<[4]x[4]xi32>\r\n```\r\n```\r\n// Insert element into tile;\r\n%new_tile = vector.insert %el, %tile[%row, %col]\r\n                    : i32 into vector<[4]x[4]xi32>\r\n```", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/ArmSME/Transforms/LegalizeForLLVMExport.cpp", "functions": ["failure", "success"]}]}
{"pr_number": 68130, "url": "https://github.com/llvm/llvm-project/pull/68130", "title": "[mlir][sparse] Print new syntax", "body": "Printing changes from `#sparse_tensor.encoding<{ lvlTypes = [ \"compressed\" ] }>` to `map = (d0) -> (d0 : compressed)`. Level properties, ELL and slice are also supported.\r\n\r\nSome check tests are modified to support this change. For instance, `%[[S:.*]]:` is changed to `%[[S:[a-zA-Z0-9_]*]]:`, because the new syntax contains \":\" and `.*` will greedily match sparse encoding instead of just the variable name.", "feature_layers": ["parse", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/Transforms/SparseTensorCodegen.cpp", "functions": ["replaceWithUnderscore"]}]}
{"pr_number": 68169, "url": "https://github.com/llvm/llvm-project/pull/68169", "title": "[Clang][CodeGen] Fix use of CXXThisValue with StrictVTablePointers", "body": "When emitting non-virtual base initializers for the constructor prologue,\r\nwe would potentially use a re-laundered this pointer value from a\r\nprevious block, which subsequently would not dominate this use.\r\n\r\nWith this fix, we always launder the original CXXThisValue.\r\n\r\nThis fixes https://github.com/llvm/llvm-project/issues/67937", "feature_layers": ["codegen", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/CodeGen/CGClass.cpp", "functions": ["ThisRAII"]}]}
{"pr_number": 68257, "url": "https://github.com/llvm/llvm-project/pull/68257", "title": "[mlir][Vector] Add Broadcast -> CastOp reordering to SinkVectorBroadcasting patterns.", "body": "", "feature_layers": ["ir", "ast"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/Vector/Transforms/VectorTransforms.cpp", "functions": ["failure"]}]}
{"pr_number": 67325, "url": "https://github.com/llvm/llvm-project/pull/67325", "title": "[mlir][nvgpu] Improve nvgpu->nvvm transformation of `warpgroup.mma` Op (NFC)", "body": "This PR introduces substantial improvements to the readability and maintainability of the `nvgpu.warpgroup.mma` Op transformation from nvgpu->nvvm. This transformation plays a crucial role in GEMM and manages complex operations such as generating multiple wgmma ops and iterating their descriptors. The prior code lacked clarity, but this PR addresses that issue effectively.\r\n\r\n**PR does followings:**\r\n**Introduces a helper class:** `WarpgroupGemm` class encapsulates the necessary functionality, making the code cleaner and more understandable. \r\n\r\n**Detailed Documentation:** Each function within the helper class is thoroughly documented to provide clear insights into its purpose and functionality.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Conversion/NVGPUToNVVM/NVGPUToNVVM.cpp", "functions": ["warpgroupGemm", "b", "op", "makeAdd"]}]}
{"pr_number": 65441, "url": "https://github.com/llvm/llvm-project/pull/65441", "title": "[MLIR][NVGPU] Introduce `nvgpu.wargroup.mma.store` Op for Hopper GPUs", "body": "This PR introduces a new Op called `warpgroup.mma.store` to the NVGPU dialect of MLIR. The purpose of this operation is to facilitate storing fragmanted result(s) `nvgpu.warpgroup.accumulator` produced by `warpgroup.mma` to the given memref.\r\n\r\nAn example of fragmentated matrix is given here :\r\nhttps://docs.nvidia.com/cuda/parallel-thread-execution/index.html#wgmma-64n16-d\r\n\r\nThe `warpgroup.mma.store` does followings:\r\n1) Takes one or more `nvgpu.warpgroup.accumulator` type (fragmented results matrix)\r\n2) Calculates indexes per thread in warp-group and stores the data into give memref.\r\n\r\nHere's an example usage:\r\n```\r\n// A warpgroup performs GEMM, results in fragmented matrix\r\n%result1, %result2 = nvgpu.warpgroup.mma ...\r\n\r\n// Stores the fragmented result to memref\r\nnvgpu.warpgroup.mma.store [%result1, %result2], %matrixD : \r\n    !nvgpu.warpgroup.accumulator< fragmented = vector<64x128xf32>>,\r\n    !nvgpu.warpgroup.accumulator< fragmented = vector<64x128xf32>> \r\n    to memref<128x128xf32,3>\r\n```\r\n\r\n", "feature_layers": ["ir"], "feature_directives": ["parallel", "for"], "files_changed": [{"filename": "mlir/lib/Conversion/NVGPUToNVVM/NVGPUToNVVM.cpp", "functions": ["getWarpSizeValue"]}, {"filename": "mlir/lib/Dialect/NVGPU/IR/NVGPUDialect.cpp", "functions": ["emitOpError"]}]}
{"pr_number": 66222, "url": "https://github.com/llvm/llvm-project/pull/66222", "title": "[Clang] Handle consteval expression in array bounds expressions", "body": "The bounds of a c++ array is a _constant-expression_. And in C++ it is also a constant expression.\r\n\r\nBut we also support VLAs, ie arrays with non-constant bounds.\r\n\r\nWe need to take care to handle the case of a consteval function (which are specified to be only immediately called in non-constant contexts) that appear in arrays bounds.\r\n\r\nThis introduces `Sema::isAlwayConstantEvaluatedContext`, and a flag in ExpressionEvaluationContextRecord, such that immediate functions in array bounds are always immediately invoked.\r\n\r\nSema had both `isConstantEvaluatedContext` and\r\n`isConstantEvaluated`, so I took the opportunity to cleanup that.\r\n\r\nThe change in `TimeProfilerTest.cpp` is an unfortunate manifestation of the problem that #66203 seeks to address.\r\n\r\nFixes #65520", "feature_layers": ["sema"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Parse/ParseExpr.cpp", "functions": ["ParseConstantExpressionInExprEvalContext"]}, {"filename": "clang/test/SemaCXX/cxx2a-consteval.cpp", "functions": ["undefined", "immediate"]}]}
{"pr_number": 68231, "url": "https://github.com/llvm/llvm-project/pull/68231", "title": "[lldb][DWARFASTParserClang][NFCI] Extract DW_AT_data_member_location calculation logic", "body": "Currently this non-trivial calculation is repeated multiple times, making it hard to reason about when the `byte_offset`/`member_byte_offset` is being set or not.\r\n\r\nThis patch simply moves all those instances of the same calculation into a helper function.\r\n\r\nWe return an optional to remain an NFC patch. Default initializing the offset would make sense but requires further analysis and can be done in a follow-up patch.", "feature_layers": ["parse", "ir", "ast", "parser"], "feature_directives": ["requires"], "files_changed": [{"filename": "lldb/source/Plugins/SymbolFile/DWARF/DWARFASTParserClang.cpp", "functions": ["memberOffset", "initialValue"]}]}
{"pr_number": 67133, "url": "https://github.com/llvm/llvm-project/pull/67133", "title": "[IRTranslator] Set NUW flag for inbounds gep and load/store offsets", "body": "In an inbounds translateGetElementPtr, when an index produces a constant non-negative offset to add to the base, the add can be assumed to not have unsigned overflow", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/CodeGen/GlobalISel/MachineIRBuilder.cpp", "functions": ["buildInstr"]}]}
{"pr_number": 68289, "url": "https://github.com/llvm/llvm-project/pull/68289", "title": "[mlir][bufferization] Add `dump_alias_sets` option to transform op", "body": "Add `dump_alias_sets` to `transform.bufferization.one_shot_bufferize`. This option is useful for debugging. Also improve the verifier to ensure that `test_analysis_only` is set when other debugging flags are enabled.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Bufferization/TransformOps/BufferizationTransformOps.cpp", "functions": ["emitOpError"]}]}
{"pr_number": 68201, "url": "https://github.com/llvm/llvm-project/pull/68201", "title": "[mlir][tensor][bufferize] `tensor.empty` bufferizes to allocation", "body": "`BufferizableOpInterface::bufferizesToAllocation` is queried when forming equivalence sets during bufferization. It is not really needed for ops like `tensor.empty` which do not have tensor operands, but it should be added for consistency.\r\n\r\nThis change should have been part of #68080. No test is added because the return value of this function is irrelevant for ops without tensor operands. (However, this function acts as a form documentation, describing the bufferization semantics of the op.)", "feature_layers": ["sema", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Tensor/Transforms/BufferizableOpInterfaceImpl.cpp", "functions": ["bufferizesToAllocation"]}]}
{"pr_number": 68195, "url": "https://github.com/llvm/llvm-project/pull/68195", "title": "[mlir][tensor][bufferize] Reshapes: Fix memory side effects and memory space", "body": "* `tensor.collapse_shape` may bufferize to a memory read because the op may have to reallocate the source buffer.\r\n* `tensor.reshape` should not use `bufferization.clone` for reallocation. This op has requirements wrt. the order of buffer writes/reads. Use `memref.alloc` and `memref.copy` instead. Also fix a bug where the memory space of the source buffer was not propagated to the reallocated buffer.", "feature_layers": ["ir"], "feature_directives": ["for", "allocate"], "files_changed": [{"filename": "mlir/lib/Dialect/Tensor/Transforms/BufferizableOpInterfaceImpl.cpp", "functions": ["failure"]}]}
{"pr_number": 68291, "url": "https://github.com/llvm/llvm-project/pull/68291", "title": "[mlir][MemRef] Add a pattern to simplify `extract_strided_metadata(ca\u2026", "body": "\u2026st)`\r\n\r\n`expand-strided-metadata` was missing a pattern to get rid of `memref.cast`.\r\nThe pattern is straight foward:\r\nProduce a new `extract_strided_metadata` with the source of the cast and fold the static information (sizes, strides, offset) along the way.", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/MemRef/Transforms/ExpandStridedMetadata.cpp", "functions": ["failure", "success"]}]}
{"pr_number": 68103, "url": "https://github.com/llvm/llvm-project/pull/68103", "title": "[flang]Pass to add vscale range attribute", "body": "Add vscale range attirbute for the Scalable Vector Extension (SVE) if provided on the command-line (options in a previous commit)\r\n\r\nIf no command-line option is provided, if the target-feature of SVE is specified and the architecture is AArch64, it defualts to 128-2048. in other words a vscale-min of 1, vscale-max of 16.\r\n\r\nA pass is used to add the atribute to all functions. The vectorizer will use this attribute to generate the SVE instruction to match the range specified. The attribute is harmless if there is no vectorizable operations in the function.", "feature_layers": ["ir"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "flang/lib/Frontend/FrontendActions.cpp", "functions": ["triple"]}, {"filename": "flang/lib/Optimizer/Transforms/VScaleAttr.cpp", "functions": ["runOnOperation"]}]}
{"pr_number": 67162, "url": "https://github.com/llvm/llvm-project/pull/67162", "title": "[HIP] Support compressing device binary", "body": "Add option -f[no-]offload-compress to clang to enable/disable compression of device binary for HIP. By default it is disabled.\r\n\r\nAdd option -compress to clang-offload-bundler to enable compression of offload bundle. By default it is disabled.\r\n\r\nWhen enabled, zstd or zlib is used for compression when available.\r\n\r\nWhen disabled, it is NFC compared to previous behavior. The same offload bundle format is used as before.\r\n\r\nClang-offload-bundler automatically detects whether the input file to be unbundled is compressed and the compression method and decompress if necessary.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Driver/OffloadBundler.cpp", "functions": ["WriteBundleStart", "createStringError", "BufferStream", "WriteBundle", "finalizeOutputFile", "WriteBundleEnd", "createFileError", "if", "OS", "Write8byteIntegerToBuffer", "OutputFile", "Magic"]}, {"filename": "clang/test/Driver/clang-offload-bundler-zlib.c", "functions": ["test_func"]}, {"filename": "clang/test/Driver/clang-offload-bundler-zstd.c", "functions": ["test_func"]}, {"filename": "clang/tools/clang-offload-bundler/ClangOffloadBundler.cpp", "functions": ["Verbose"]}]}
{"pr_number": 67346, "url": "https://github.com/llvm/llvm-project/pull/67346", "title": "[DX] Add support for program signatures", "body": "For DirectX, program signatures are encoded into three different binary sections depending on if the signature is for inputs, outputs, or patches. All three signature types use the same data structure encoding so they can share a lot of logic.\r\n\r\nThis patch adds support for reading and writing program signature data as both yaml and binary data.\r\n\r\nFixes #57743 and #57744", "feature_layers": ["ir"], "feature_directives": ["for", "sections"], "files_changed": [{"filename": "llvm/lib/BinaryFormat/DXContainer.cpp", "functions": ["ArrayRef"]}, {"filename": "llvm/lib/MC/DXContainerPSVInfo.cpp", "functions": ["StrTabBuilder"]}, {"filename": "llvm/lib/Object/DXContainer.cpp", "functions": ["parseFailed"]}, {"filename": "llvm/tools/obj2yaml/dxcontainer2yaml.cpp", "functions": ["dumpSignature"]}]}
{"pr_number": 68256, "url": "https://github.com/llvm/llvm-project/pull/68256", "title": "[ValueTracking] Try to infer range of select from true and false values.", "body": "When computing range of `select` instruction, first compute the union of ranges of \"True\" and \"False\" operands of the `select` instruction.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/Analysis/ValueTracking.cpp", "functions": ["if"]}]}
{"pr_number": 68266, "url": "https://github.com/llvm/llvm-project/pull/68266", "title": "Use BlockFrequency type in more places (NFC)", "body": "The `BlockFrequency` class abstracts `uint64_t` frequency values. Use it more consistently in various APIs and disable implicit conversion to make usage more consistent and explicit.\r\n\r\n- Use `BlockFrequency Freq` parameter for `setBlockFreq`, `getProfileCountFromFreq` and `setBlockFreqAndScale` functions.\r\n- Return `BlockFrequency` in `getEntryFreq()` functions.\r\n- While on it change some `const BlockFrequency& Freq` parameters to plain `BlockFreqency Freq`.\r\n- Mark `BlockFrequency(uint64_t)` constructor as explicit.\r\n- Add missing `BlockFrequency::operator!=`.\r\n- Remove `uint64_t BlockFreqency::getMaxFrequency()`.\r\n- Add `BlockFrequency BlockFrequency::max()` function.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Analysis/BlockFrequencyInfo.cpp", "functions": ["NewFreq"]}, {"filename": "llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp", "functions": ["BlockFrequency"]}, {"filename": "llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp", "functions": ["BlockFrequency", "Cost"]}, {"filename": "llvm/lib/CodeGen/MachineBlockPlacement.cpp", "functions": ["BlockFrequency"]}, {"filename": "llvm/lib/CodeGen/SpillPlacement.cpp", "functions": ["clear", "update"]}, {"filename": "llvm/lib/Transforms/IPO/SyntheticCountsPropagation.cpp", "functions": ["EntryFreq"]}, {"filename": "llvm/lib/Transforms/Scalar/LoopSink.cpp", "functions": ["T"]}]}
{"pr_number": 68181, "url": "https://github.com/llvm/llvm-project/pull/68181", "title": "[mlir][memref] Fix emulate narrow types for strided memref offset", "body": "This patch fixes strided memref offset calculation for emulating narrow types.\r\n\r\nAs a side effect, this patch also adds support for a 1-D subviews with static sizes, static offsets and strides of 1 for testing. Emulate narrow types pass was not tested for strided memrefs before this patch.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/MemRef/Transforms/EmulateNarrowType.cpp", "functions": ["success"]}]}
{"pr_number": 67512, "url": "https://github.com/llvm/llvm-project/pull/67512", "title": "BlockFrequencyInfo: Add PrintBlockFreq helper", "body": "- Refactor the (Machine)BlockFrequencyInfo::printBlockFreq functions into a `PrintBlockFreq()` function returning a `Printable` object. This simplifies usage as it can be directly piped to a `raw_ostream` like `dbgs() << PrintBlockFreq(MBFI, Freq) << '\\n';`.\r\n- Previously there was an interesting behavior where `BlockFrequencyInfoImpl` stores frequencies both as a `Scaled64` number and as an `uint64_t`. Most algorithms use the `BlockFrequency` abstraction with the integers, the print function for basic blocks printed the `Scaled64` number potentially showing higher accuracy than was used by the algorithm. This changes things to only print `BlockFrequency` values.\r\n- Replace some instances of `dbgs() << Freq.getFrequency()` with the new function.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Analysis/BlockFrequencyInfo.cpp", "functions": ["printBlockFreq", "PrintBFI", "Printable"]}, {"filename": "llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp", "functions": ["getFloatingBlockFreq", "Entry"]}, {"filename": "llvm/lib/CodeGen/MachineBlockFrequencyInfo.cpp", "functions": ["printBlockFreq", "Printable"]}, {"filename": "llvm/lib/CodeGen/MachineBlockPlacement.cpp", "functions": ["printBlockFreq", "getBlockName"]}, {"filename": "llvm/lib/CodeGen/RegAllocGreedy.cpp", "functions": ["printBlockFreq"]}, {"filename": "llvm/lib/CodeGen/ShrinkWrap.cpp", "functions": ["printBlockFreq"]}]}
{"pr_number": 68236, "url": "https://github.com/llvm/llvm-project/pull/68236", "title": "[LLD][COFF] Add support for `--time-trace`", "body": "This adds support for generating Chrome-tracing .json profile traces in the LLD COFF driver.\r\n\r\nAlso add the necessary time scopes, so that the profile trace shows in great detail which tasks are executed.\r\n\r\nAs an example, this is what we see when linking a Unreal Engine executable:\r\n\r\n![image](https://github.com/llvm/llvm-project/assets/37383324/b2e26eb4-9d37-4cf9-b002-48b604e7dcb7)\r\n", "feature_layers": [], "feature_directives": ["task", "for"], "files_changed": [{"filename": "lld/COFF/DebugTypes.cpp", "functions": ["timeScope"]}, {"filename": "lld/COFF/Driver.cpp", "functions": ["timeScope2"]}, {"filename": "lld/COFF/DriverUtils.cpp", "functions": ["timeScope"]}, {"filename": "lld/COFF/ICF.cpp", "functions": ["timeScope"]}, {"filename": "lld/COFF/LLDMapFile.cpp", "functions": ["timeScope"]}, {"filename": "lld/COFF/MapFile.cpp", "functions": ["timeScope"]}, {"filename": "lld/COFF/MarkLive.cpp", "functions": ["timeScope"]}, {"filename": "lld/COFF/MinGW.cpp", "functions": ["timeScope"]}, {"filename": "lld/COFF/PDB.cpp", "functions": ["timeScope", "t2", "pdb"]}, {"filename": "lld/COFF/SymbolTable.cpp", "functions": ["timeScope"]}, {"filename": "lld/COFF/Writer.cpp", "functions": ["t1", "timeScope3", "timeScope2", "timeScope"]}, {"filename": "lld/Common/Filesystem.cpp", "functions": ["timeScope"]}, {"filename": "llvm/lib/DebugInfo/MSF/MSFBuilder.cpp", "functions": ["timeScope"]}, {"filename": "llvm/lib/DebugInfo/PDB/Native/DbiStreamBuilder.cpp", "functions": ["timeScope"]}, {"filename": "llvm/lib/DebugInfo/PDB/Native/GSIStreamBuilder.cpp", "functions": ["timeScope"]}, {"filename": "llvm/lib/DebugInfo/PDB/Native/InfoStreamBuilder.cpp", "functions": ["timeScope"]}, {"filename": "llvm/lib/DebugInfo/PDB/Native/PDBFileBuilder.cpp", "functions": ["NSW", "timeScope"]}, {"filename": "llvm/lib/DebugInfo/PDB/Native/PDBStringTableBuilder.cpp", "functions": ["timeScope"]}, {"filename": "llvm/lib/DebugInfo/PDB/Native/TpiStreamBuilder.cpp", "functions": ["timeScope"]}, {"filename": "llvm/lib/Support/FileOutputBuffer.cpp", "functions": ["timeScope"]}]}
{"pr_number": 68223, "url": "https://github.com/llvm/llvm-project/pull/68223", "title": "[BOLT][NFC] Add MCSubtargetInfo to MCPlusBuilder", "body": "On RISC-V, it's helpful to have access to `MCSubtargetInfo` while generating instructions in `MCPlusBuilder`. For example, a return instruction might be generated differently based on if the target supports compressed instructions (`c.jr ra`) or not (`jalr ra`).", "feature_layers": [], "feature_directives": ["for", "target"], "files_changed": [{"filename": "bolt/lib/Rewrite/MachORewriteInstance.cpp", "functions": ["createAArch64MCPlusBuilder", "createX86MCPlusBuilder"]}, {"filename": "bolt/lib/Rewrite/RewriteInstance.cpp", "functions": ["createRISCVMCPlusBuilder", "createAArch64MCPlusBuilder", "createX86MCPlusBuilder"]}, {"filename": "bolt/lib/Target/AArch64/AArch64MCPlusBuilder.cpp", "functions": ["AArch64MCPlusBuilder", "MCPlusBuilder"]}, {"filename": "bolt/lib/Target/RISCV/RISCVMCPlusBuilder.cpp", "functions": ["RISCVMCPlusBuilder"]}, {"filename": "bolt/lib/Target/X86/X86MCPlusBuilder.cpp", "functions": ["X86MCPlusBuilder", "MCPlusBuilder"]}]}
{"pr_number": 68312, "url": "https://github.com/llvm/llvm-project/pull/68312", "title": "[clang][Diagnostics] Add bitfield source range to zero width diags", "body": "Before:\r\n```\r\narray.cpp:157:8: error: named bit-field 'a' has zero width\r\n  157 |   char a : 12 - 12;\r\n      |        ^\r\n1 error generated.\r\n```\r\n\r\nAfter:\r\n\r\n```\r\narray.cpp:157:8: error: named bit-field 'a' has zero width\r\n  157 |   char a : 12 - 12;\r\n      |        ^   ~~~~~~~\r\n1 error generated.\r\n```", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Sema/SemaDecl.cpp", "functions": ["Diag"]}]}
{"pr_number": 68319, "url": "https://github.com/llvm/llvm-project/pull/68319", "title": "[mlir][Transform] Add a transform.match.operation_empty op to allow s\u2026", "body": "\u2026pecifying negative conditions\r\n\r\nIn the process, get_parent_op gains an attribute to allow it to return empty handles explicitly and still succeed.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Transform/IR/TransformOps.cpp", "functions": ["emitSilenceableError"]}]}
{"pr_number": 68309, "url": "https://github.com/llvm/llvm-project/pull/68309", "title": "[flang][nfc] replace fir.dispatch_table with more generic fir.type_info", "body": "The goal is to progressively propagate all the derived type info that is currently in the runtime type info globals into a FIR operation that can be easily queried and used by FIR/HLFIR passes.\r\n\r\nWhen this will be complete, the last step will be to stop generating the runtime info global in lowering, but to do that later in or just before codegen to keep the FIR files readable (on the added type-info.f90 tests, the lowered runtime info globals takes a wooping 2.6 millions characters of 1600 lines the FIR textual output. The fir.type_info that contains all the info required to generate those globals for such \"trivial\" types takes 1721 characters on 9 lines).\r\n\r\nSo far this patch simply starts by replacing the fir.dispatch_table operation by the fir.type_info operation and to add the noinit/ nofinal/nodestroy flags to it. These flags will soon be used in HLFIR to better rewrite hlfir.assign with derived types.", "feature_layers": ["codegen", "runtime", "ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Lower/Bridge.cpp", "functions": ["createDispatchTableOps", "createTypeInfoGlobals", "createTypeInfo"]}, {"filename": "flang/lib/Optimizer/Dialect/FIROps.cpp", "functions": ["emitOpError"]}]}
{"pr_number": 67120, "url": "https://github.com/llvm/llvm-project/pull/67120", "title": "[mlir][transform] Allow passing various library files to interpreter.", "body": "The transfrom interpreter accepts an argument to a \"library\" file with named sequences. This patch exteneds this functionality such that (1) several such individual files are accepted and (2) folders can be passed in, in which all `*.mlir` files are loaded.\r\n\r\nThis PR depends on and therefor currently includes ~~#67241~~ #67560.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Transform/Transforms/TransformInterpreterPassBase.cpp", "functions": ["failure", "success", "emitError"]}]}
{"pr_number": 68300, "url": "https://github.com/llvm/llvm-project/pull/68300", "title": "[lldb][DWARFASTParserClang] Check DW_AT_declaration to determine static data members", "body": "**Background**\r\n\r\nPrior to DWARFv4, there was no clear normative text on how to handle static data members. Non-normative text suggested that compilers should use `DW_AT_external` to mark static data members of structrues/unions. Clang does this consistently. However, GCC doesn't, e.g., when the structure/union is in an anonymous namespace (which is C++ standard conformant). Additionally, GCC never emits `DW_AT_data_member_location`s for union members (regardless of storage linkage and storage duration).\r\n\r\nSince DWARFv5 (issue 161118.1), static data members get emitted as `DW_TAG_variable`.\r\n\r\nLLDB used to differentiate between static and non-static members by checking the `DW_AT_external` flag and the absence of `DW_AT_data_member_location`. With [D18008](https://reviews.llvm.org/D18008) LLDB started to pretend that union members always have a `0` `DW_AT_data_member_location` by default (because GCC never emits these locations).\r\n\r\nIn [D124409](https://reviews.llvm.org/D124409) LLDB stopped checking the `DW_AT_external` flag to account for the case where GCC doesn't emit the flag for types in anonymous namespaces; instead we only check for presence of `DW_AT_data_member_location`s.\r\n\r\nThe combination of these changes then meant that LLDB would never correctly detect that a union has static data members.\r\n\r\n**Solution**\r\n\r\nInstead of unconditionally initializing the `member_byte_offset` to `0` specifically for union members, this patch proposes to check for both the absence of `DW_AT_data_member_location` and `DW_AT_declaration`, which consistently gets emitted for static data members on GCC and Clang.\r\n\r\nWe initialize the `member_byte_offset` to `0` anyway if we determine it wasn't a static. So removing the special case for unions makes this code simpler to reason about.\r\n\r\nLong-term, we should just use DWARFv5's new representation for static data members.\r\n\r\nFixes #68135", "feature_layers": ["parse", "ast", "parser"], "feature_directives": ["for"], "files_changed": [{"filename": "lldb/test/API/lang/cpp/union-static-data-members/main.cpp", "functions": ["main"]}]}
{"pr_number": 68330, "url": "https://github.com/llvm/llvm-project/pull/68330", "title": "[mlir][Transform] Provide a minimal set of utils that allow implementing a simple transform dialect interpreter pass", "body": "", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Transform/IR/TransformInterfaces.cpp", "functions": ["failure"]}, {"filename": "mlir/lib/Dialect/Transform/Transforms/TransformInterpreterPassBase.cpp", "functions": ["success", "otherSymbolTable", "targetSymbolTable", "failure", "if", "canMergeInto"]}, {"filename": "mlir/lib/Dialect/Transform/Transforms/TransformInterpreterUtils.cpp", "functions": ["ModuleOp", "success", "otherSymbolTable", "targetSymbolTable", "applyTransforms", "failure", "if", "canMergeInto", "clonedTransformModule"]}, {"filename": "mlir/unittests/Dialect/Transform/Preload.cpp", "functions": ["registerTestTransformDialectExtension", "parserConfig", "createTestTransformDialectInterpreterPass"]}]}
{"pr_number": 65852, "url": "https://github.com/llvm/llvm-project/pull/65852", "title": "[InstCombine] Simplify the pattern `a ne/eq (zext/sext (a ne/eq c))`", "body": "This patch folds the pattern `a ne/eq (zext/sext (a ne/eq c))` into a boolean constant or a compare.\r\nClang vs GCC: https://godbolt.org/z/4ro817WE8\r\nProof for `zext`: https://alive2.llvm.org/ce/z/6z9NRF\r\nProof for `sext`: https://alive2.llvm.org/ce/z/tv5wuE\r\nFixes #65073.\r\n\r\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp", "functions": ["CreateRangeCheck"]}]}
{"pr_number": 68333, "url": "https://github.com/llvm/llvm-project/pull/68333", "title": "[mlir][VectorOps] Don't fold extract chains that include dynamic indices", "body": "This is not yet supported and previously led to a confusing crash where an extract op with a kDynamic marker, but no dynamic positions was created. The verifier has also been updated to check for this, and hint at where the problem is likely to be.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Vector/IR/VectorOps.cpp", "functions": ["failure"]}]}
{"pr_number": 66921, "url": "https://github.com/llvm/llvm-project/pull/66921", "title": "[SPIRV] Implement log10 for logical SPIR-V", "body": "There is no log10 instruction in the GLSL Extended Instruction Set so to implement the HLSL log10 intrinsic when targeting Vulkan this change adds the logic to derive the result using the following formula:\r\n```\r\nlog10(x) = log2(x) * (1 / log2(10))\r\n         = log2(x) * 0.30103\r\n```", "feature_layers": ["ir"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp", "functions": ["MIRBuilder", "selectLog10", "selectExtInst"]}]}
{"pr_number": 68348, "url": "https://github.com/llvm/llvm-project/pull/68348", "title": "[flang][openacc] Do not generate duplicate routine op", "body": "This patch updates the lowering of OpenACC routine directive to avoid creating duplicate acc.routine operations when all the clauses are identical. If clauses differ an error is raised. ", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "flang/lib/Lower/OpenACC.cpp", "functions": ["modBuilder"]}]}
{"pr_number": 65703, "url": "https://github.com/llvm/llvm-project/pull/65703", "title": "[flang] Fixed LoopVersioning for array slices.", "body": "The first test case added in the LIT test demonstrates the problem.\r\nEven though we did not consider the inner loop as a candidate for\r\nthe transformation due to the array_coor with a slice, we decided to\r\nversion the outer loop for the same function argument.\r\nDuring the cloning of the outer loop we dropped the slicing completely\r\nproducing invalid code.\r\n\r\nI restructured the code so that we record all arg uses that cannot be\r\ntransformed (regardless of the reason), and then fixup the usage\r\ninformation across the loop nests. I also noticed that we may generate\r\nredundant contiguity checks for the inner loops, so I fixed it\r\nsince it was easy with the new way of keeping the usage data.\r\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Optimizer/Transforms/LoopVersioning.cpp", "functions": ["dump", "eraseUsage"]}]}
{"pr_number": 68298, "url": "https://github.com/llvm/llvm-project/pull/68298", "title": "[MLIR][Presburger] Fix reduce bug in Fraction class and add tests", "body": "Modified `Fraction.reduce()` to work with negative fractions as well.\r\nAdded tests to verify the implementation of arithmetic and relational operators on Fractions.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/unittests/Analysis/Presburger/FractionTest.cpp", "functions": ["f"]}]}
{"pr_number": 67289, "url": "https://github.com/llvm/llvm-project/pull/67289", "title": "[RISCV] Support VLS for VCIX", "body": "", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVISelLowering.cpp", "functions": ["convertFromScalableVector", "DL"]}]}
{"pr_number": 68378, "url": "https://github.com/llvm/llvm-project/pull/68378", "title": "[lldb] Expose SBPlatform::GetAllProcesses to the SB API", "body": "Add the ability to list all processes through the SB API.\r\n\r\nrdar://116188959", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "lldb/source/API/SBPlatform.cpp", "functions": ["SBProcessInfoList"]}, {"filename": "lldb/source/API/SBProcessInfoList.cpp", "functions": ["m_opaque_up"]}]}
{"pr_number": 67614, "url": "https://github.com/llvm/llvm-project/pull/67614", "title": "[RISCV][GISel] Select G_SELECT", "body": "This patch adds minimal support for selecting G_SELECT. In the future we may want to fix this patch to select the other opcodes or handle that in the combiner.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp", "functions": ["selectSelect", "constrainSelectedInstRegOperands"]}]}
{"pr_number": 68127, "url": "https://github.com/llvm/llvm-project/pull/68127", "title": "Fixes and closes #53952. Setting the ASTHasCompilerErrors member variable correctly based on the PP diagnostics.", "body": "The issue #53952 is reported indicating clang is giving a crashing pch file, when hasErrors is been passed incorrectly to WriteAST method.\r\n\r\nTo fix the issue, I have a added an assertion to make sure the given value of ASTHasCompilerErrors is matching with Preprocessor diagnostics. And this assertion will get triggered inside Debug builds.\r\n\r\nFor release builds, based on the conditional check, forcefully set the ASTHasCompilerErrors member variable to a valid value from Preprocessor.", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Frontend/ASTUnit.cpp", "functions": ["serializeUnit"]}]}
{"pr_number": 66962, "url": "https://github.com/llvm/llvm-project/pull/66962", "title": "[clang][modules] Remove preloaded SLocEntries from PCM files", "body": "This commit removes the list of SLocEntry offsets to preload eagerly from PCM files. Commit introducing this functionality (258ae54a) doesn't clarify why this would be more performant than the lazy approach used regularly.\n\nCurrently, the only SLocEntry the reader is supposed to preload is the predefines buffer, but in my experience, it's not actually referenced in most modules, so the time spent deserializing its SLocEntry is wasted. This is especially noticeable in the dependency scanner, where this change brings 4.56% speedup on my benchmark.\n", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/unittests/Basic/SourceManagerTest.cpp", "functions": ["makeFileID", "ReadSLocEntry"]}]}
{"pr_number": 67185, "url": "https://github.com/llvm/llvm-project/pull/67185", "title": "[TableGen][RISCV][GlobalISel] Select G_ICMP, G_SELECT, G_PTR_ADD, G_STORE, G_LOAD, G_ZEXTLOAD", "body": "This series of patches works towards implementing instruction selection for RISCV. ", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp", "functions": ["selectAddrRegImm"]}]}
{"pr_number": 68360, "url": "https://github.com/llvm/llvm-project/pull/68360", "title": "[mlir][sparse] introduce MapRef, unify conversion/codegen for reader", "body": "This revision introduces a MapRef, which will support a future generalization beyond permutations (e.g. block sparsity). This revision also unifies the conversion/codegen paths for the sparse_tensor.new operation from file (eg. the readers). Note that more unification is planned as well as general affine dim2lvl and lvl2dim (all marked with TODOs).", "feature_layers": ["parse", "codegen", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/Transforms/CodegenUtils.cpp", "functions": ["allocaBuffer", "lvl2dimValues", "dim2lvlValues", "lvlSizesValues"]}, {"filename": "mlir/lib/Dialect/SparseTensor/Transforms/SparseTensorCodegen.cpp", "functions": ["dimToLvlValues"]}, {"filename": "mlir/lib/Dialect/SparseTensor/Transforms/SparseTensorConversion.cpp", "functions": ["lvlSizeValues", "lvlToDimValues", "dimToLvlValues"]}, {"filename": "mlir/lib/ExecutionEngine/SparseTensor/MapRef.cpp", "functions": ["dimRank"]}]}
{"pr_number": 68436, "url": "https://github.com/llvm/llvm-project/pull/68436", "title": "[mlir][sparse] introduce a pass to stage complex sparse operations in\u2026", "body": "\u2026to simple steps", "feature_layers": ["parse", "ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/Transforms/SparseTensorPasses.cpp", "functions": ["runOnOperation", "patterns"]}]}
{"pr_number": 66966, "url": "https://github.com/llvm/llvm-project/pull/66966", "title": "[clang][modules] Move `SLocEntry` search into `ASTReader`", "body": "In `SourceManager::getFileID()`, Clang performs binary search over its buffer of `SLocEntries`. For modules, this binary search fully deserializes the entire `SLocEntry` block for each visited entry. For some entries, that includes decompressing the associated buffer (e.g. the predefines buffer, macro expansion buffers, contents of volatile files), which shows up in profiles of the dependency scanner.\r\n\r\nThis patch moves the binary search over loaded entries into `ASTReader`, which can perform cheaper partial deserialization during the binary search, reducing the wall time of dependency scans by ~3%. This also reduces the number of retired instructions by ~1.4% on regular (implicit) modules compilation.\r\n\r\nNote that this patch drops the optimizations based on the last lookup ID (pruning the search space and performing linear search before resorting to the full binary search). Instead, it reduces the search space by asking `ASTReader::GlobalSLocOffsetMap` for the containing `ModuleFile` and only does binary search over entries of single module file.", "feature_layers": ["ir", "ast"], "feature_directives": ["for", "single"], "files_changed": [{"filename": "clang/lib/Basic/SourceManager.cpp", "functions": ["FileID"]}, {"filename": "clang/lib/Serialization/ASTReader.cpp", "functions": ["Indices"]}]}
{"pr_number": 66865, "url": "https://github.com/llvm/llvm-project/pull/66865", "title": "[mlir][tools] Introduce tblgen-to-irdl tool", "body": "RFC: https://discourse.llvm.org/t/rfc-tblgen-to-irdl-tool/73578", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/tools/tblgen-to-irdl/OpDefinitionsGen.cpp", "functions": ["if"]}, {"filename": "mlir/tools/tblgen-to-irdl/tblgen-to-irdl.cpp", "functions": ["main"]}]}
{"pr_number": 66636, "url": "https://github.com/llvm/llvm-project/pull/66636", "title": "[clang] remove ClassScopeFunctionSpecializationDecl", "body": "This removes the `ClassScopeFunctionSpecializationDecl` `Decl` node, and instead uses `DependentFunctionTemplateSpecializationInfo` to handle such declarations. `DependentFunctionTemplateSpecializationInfo` is also changed to store a `const ASTTemplateArgumentListInfo*` to be more in line with `FunctionTemplateSpecializationInfo`. \r\n\r\nThis also changes `FunctionDecl::isFunctionTemplateSpecialization` to return `true` for dependent specializations, and `FunctionDecl::getTemplateSpecializationKind`/`FunctionDecl::getTemplateSpecializationKindForInstantiation` to return `TSK_ExplicitSpecialization` for non-friend dependent specializations (the same behavior as dependent class scope `ClassTemplateSepcializationDecl` & `VarTemplateSepcializationDecl`).", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/AST/Decl.cpp", "functions": ["new", "TemplateArgumentsAsWritten", "AngleLocs"]}, {"filename": "clang/lib/AST/DeclTemplate.cpp", "functions": ["new"]}, {"filename": "clang/lib/Sema/SemaDecl.cpp", "functions": ["if"]}, {"filename": "clang/lib/Sema/SemaTemplateInstantiateDecl.cpp", "functions": ["ExplicitArgs"]}, {"filename": "clang/lib/Serialization/ASTReader.cpp", "functions": ["TemplArgsInfo"]}, {"filename": "clang/lib/Serialization/ASTReaderDecl.cpp", "functions": ["TemplArgsInfo"]}, {"filename": "clang/test/SemaTemplate/instantiate-method.cpp", "functions": ["f0_impl1", "f0", "bazqux"]}]}
{"pr_number": 68074, "url": "https://github.com/llvm/llvm-project/pull/68074", "title": "[mlir][bufferization] `MaterializeInDestinationOp`: Support memref destinations", "body": "Extend `bufferization.materialize_in_destination` to support memref destinations. This op can now be used to indicate that a tensor computation should materialize in a given buffer (that may have been allocated by another component/runtime). The op still participates in \"empty tensor elimination\".\r\n\r\nExample:\r\n```mlir\r\nfunc.func @test(%out: memref<10xf32>) {\r\n  %t = tensor.empty() : tensor<10xf32>\r\n  %c = linalg.generic ... outs(%t: tensor<10xf32>) -> tensor<10xf32>\r\n  bufferization.materialize_in_destination %c in restrict writable %out : (tensor<10xf32>, memref<10xf32>) -> ()\r\n  return\r\n}\r\n```\r\nAfter \"empty tensor elimination\", the above IR can bufferize without an allocation:\r\n```mlir\r\nfunc.func @test(%out: memref<10xf32>) {\r\n  linalg.generic ... outs(%out: memref<10xf32>)\r\n  return\r\n}\r\n```\r\n\r\nThis change also clarifies the meaning of the `restrict` unit attribute on `bufferization.to_tensor` ops.\r\n", "feature_layers": ["runtime", "ir"], "feature_directives": ["allocate"], "files_changed": [{"filename": "mlir/lib/Dialect/Bufferization/IR/BufferizationOps.cpp", "functions": ["emitOpError", "success", "failure", "getDestMutable", "getDest"]}]}
{"pr_number": 67602, "url": "https://github.com/llvm/llvm-project/pull/67602", "title": "[RISCV] Add sink-and-fold support for RISC-V.", "body": "This uses the recently introduced sink-and-fold support in MachineSink. https://reviews.llvm.org/D152828\r\n    \r\nThis enables folding ADDI into load/store addresses.\r\n    \r\n Enabling by default will be a separate PR.\r\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVInstrInfo.cpp", "functions": ["BuildMI"]}, {"filename": "llvm/lib/Target/RISCV/RISCVTargetMachine.cpp", "functions": ["TargetPassConfig"]}]}
{"pr_number": 67464, "url": "https://github.com/llvm/llvm-project/pull/67464", "title": "[llvm-rc] add support for MENUEX", "body": "Fixes #39455.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/tools/llvm-rc/ResourceFileWriter.cpp", "functions": ["writeResource", "writeMenuExDefinitionList"]}, {"filename": "llvm/tools/llvm-rc/ResourceScriptParser.cpp", "functions": ["Control"]}]}
{"pr_number": 68497, "url": "https://github.com/llvm/llvm-project/pull/68497", "title": "[mlir][bufferization] Update empty_tensor_elimination transform op", "body": "The empty tensor elimination pass semantics have changed recently: when applied to a module, the One-Shot Module Analysis is run. Otherwise, the regular One-Shot Analysis is run. The latter one is slightly different because it ignores function boundaries and treats function block arguments as \"read-only\".\r\n\r\nThis commit updates the transform dialect op to behave in the same way.", "feature_layers": ["sema", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Bufferization/TransformOps/BufferizationTransformOps.cpp", "functions": ["state"]}, {"filename": "mlir/lib/Dialect/Bufferization/Transforms/EmptyTensorElimination.cpp", "functions": ["failure", "rewriter"]}]}
{"pr_number": 67275, "url": "https://github.com/llvm/llvm-project/pull/67275", "title": "[SimplifyCFG][Migrated] Transform for redirecting phis between unmergeable BB and SuccBB", "body": "This patch extends function TryToSimplifyUncondBranchFromEmptyBlock to handle the similar cases below.\r\n\r\n```llvm\r\ndefine i8 @src(i8 noundef %arg) {\r\nstart:\r\n  switch i8 %arg, label %unreachable [\r\n    i8 0, label %case012\r\n    i8 1, label %case1\r\n    i8 2, label %case2\r\n    i8 3, label %end\r\n  ]\r\n\r\nunreachable:\r\n  unreachable\r\n\r\ncase1:\r\n  br label %case012\r\n\r\ncase2:\r\n  br label %case012\r\n\r\ncase012:\r\n  %phi1 = phi i8 [ 3, %case2 ], [ 2, %case1 ], [ 1, %start ]\r\n  br label %end\r\n\r\nend:\r\n  %phi2 = phi i8 [ %phi1, %case012 ], [ 4, %start ]\r\n  ret i8 %phi2\r\n}\r\n```\r\nThe phis here should be merged into one phi, so that we can better optimize it:\r\n\r\n```llvm\r\ndefine i8 @tgt(i8 noundef %arg) {\r\nstart:\r\n  switch i8 %arg, label %unreachable [\r\n    i8 0, label %end\r\n    i8 1, label %case1\r\n    i8 2, label %case2\r\n    i8 3, label %case3\r\n  ]\r\n\r\nunreachable:\r\n  unreachable\r\n\r\ncase1:\r\n  br label %end\r\n\r\ncase2:\r\n  br label %end\r\n\r\ncase3:\r\n  br label %end\r\n\r\nend:\r\n  %phi = phi i8 [ 4, %case3 ], [ 3, %case2 ], [ 2, %case1 ], [ 1, %start ]\r\n  ret i8 %phi\r\n}\r\n```\r\nProof:\r\n[normal](https://alive2.llvm.org/ce/z/vAWi88)\r\n[multiple stages](https://alive2.llvm.org/ce/z/DDBQqp)\r\n[multiple stages 2](https://alive2.llvm.org/ce/z/nGkeqN)\r\n[multiple phi combinations](https://alive2.llvm.org/ce/z/VQeEdp)\r\n\r\nAnd lookup table optimization should convert it into add %arg 1.\r\nThis patch just match similar CFG structure and merge the phis in different cases.\r\n\r\nMaybe such transform can be applied to other situations besides switch,\r\nbut I'm not sure whether it's better than not merging. Therefore, I only try it in switch,\r\n\r\nRelated issue:\r\n#63876\r\n\r\n[Migrated](https://reviews.llvm.org/D155940)", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Utils/Local.cpp", "functions": ["CanPropagatePredecessorsForPHIs", "UnreachableInst", "if"]}]}
{"pr_number": 68420, "url": "https://github.com/llvm/llvm-project/pull/68420", "title": "[flang] Set func.func arg attributes for procedure designators", "body": "Currently, if the first usage of a procedure not defined in the file was inside a procedure designator reference (not a call to it), the lowered func.func lacked the argument attributes if any.\r\n\r\nFix this by using `CallInterface<T>::declare` too in SignatureBuilder to create a new func.func instead of using custom code.\r\n\r\nNote: this problem was made worse by the fact that module variables fir.global are currently lowered before the module procedures func.func are created. I will try to fix that in a later patch (the debug location may still be wrong in certain cases) because there is quite some test fallout when changing the order of globals/funcop in the output.", "feature_layers": ["ir"], "feature_directives": ["for", "declare"], "files_changed": [{"filename": "flang/lib/Lower/CallInterface.cpp", "functions": ["getProcedureDesignatorLoc", "getProcMangledName", "getOrCreateFuncOp", "getFuncOp", "getFunctionType", "genFunctionType", "setFuncAttrs"]}]}
{"pr_number": 67793, "url": "https://github.com/llvm/llvm-project/pull/67793", "title": "[SPIRV] Fix SPV_KHR_expect_assume support", "body": "Since efe0e10718 changes in tests are required. Need to add extension to Extensions list\nand command line to enable use of the extension for test runs.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/SPIRV/SPIRVPrepareFunctions.cpp", "functions": ["SPIRVPrepareFunctions"]}, {"filename": "llvm/lib/Target/SPIRV/SPIRVTargetMachine.cpp", "functions": ["TargetPassConfig"]}]}
{"pr_number": 66521, "url": "https://github.com/llvm/llvm-project/pull/66521", "title": "[LV] Cache call vectorization decisions", "body": "LoopVectorize currently queries VFDatabase repeatedly for each CI,\r\nand each query to VFDatabase rescans all vector variants.\r\n\r\nThis patch instead makes a decision for each call once per VF based\r\non the cost of scalarization vs. function call to a vector variant\r\nof the function vs. a vector intrinsic, then caches the decision\r\nalong with relevant info for use in planning and plan execution.\r\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Vectorize/LoopVectorize.cpp", "functions": ["getVectorCallCost", "setVectorizedCallDecision"]}]}
{"pr_number": 68400, "url": "https://github.com/llvm/llvm-project/pull/68400", "title": "[mlir][vector] Constrain patterns: vector.contract -> vector.outerproduct", "body": "This patch constrains the patterns for converting `vector.contract` to\n`vector.outerproduct` so that\n\n  * the reduction dimension is _not unrolled_ if the corresponding\n    dimension is scalable.\n\nThis is necessary as the current lowering is incorrect for scalable\ndims. Indeed, instead of the following unrolling that is currently being\ngenerated for `vector.contract` (K is the size  f the reduction\ndimension):\n\n```\n  // K times\n  %lhs = vector.extract %LHS[0]\n  %rhs = vector.extract %RHS[0]\n  vector.outerproduct %lhs, %rhs\n\n  %lhs = vector.extract %LHS[1]\n  %rhs = vector.extract %RHS[1]\n  vector.outerproduct %lhs, %rhs\n\n  ...\n```\n\nwe should be generating a `for` loop like the following:\n```\nscf.for %k = 0 to K step 1\n  %lhs = vector.extract LHS[%k]\n  %rhs = vector.extract RHS[%k]\n  vector.outerproduct %lhs, %rhs\n```\n\nHowever, the lowering of `vector.extract` of vector slices with dynamic\nindices is incomplete and hence the implementation above wouldn't work\njust yet. Instead, this patch effectively disables unrolling in case\nwhere the generated code would be functionally incorrect (i.e. when the\nreduction dimension is scalable).\n\nIn order to document unsupported cases, a dedicated test file is added:\n\n* \"vector-contract-to-outerproduct-transforms-unsupported.mlir\"\n\nThis is the first patch in a series of patches that strives to update\nthese patterns (and to test them) for scalable vectors.\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Vector/Transforms/LowerVectorContract.cpp", "functions": ["failure"]}]}
{"pr_number": 66939, "url": "https://github.com/llvm/llvm-project/pull/66939", "title": "[libc++] LWG 3821 uses_allocator_construction_args should have overload for pair-like", "body": "This change addresses LWG 3821 and LWG 3677.\r\n\r\n- make `std::pair`'s constructor no longer takes `subrange`\r\n- `uses_allocator_construction_args` constraint changes w.r.t to `pair-like` types\r\n- `uses_allocator_construction_args` constraints checks `is-pair-like<remove_cv_t<T>>`", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "libcxx/test/std/utilities/memory/allocator.uses/allocator.uses.construction/uses_allocator_construction_args.pass.cpp", "functions": ["test", "testOne"]}, {"filename": "libcxx/test/std/ranges/range.utility/range.subrange/operator.pair_like.pass.cpp", "functions": ["a", "test", "main"]}, {"filename": "libcxx/test/std/utilities/utility/pairs/pairs.pair/ctor.pair_like.pass.cpp", "functions": ["a"]}]}
{"pr_number": 68359, "url": "https://github.com/llvm/llvm-project/pull/68359", "title": "[clang-tidy] Improve `ExceptionSpecAnalyzer`s handling of conditional noexcept expressions", "body": "The previous code was pretty messy and treated value dependant expressions which could not be evaluated the same as if they evaluted to `false`. Which was obviously not correct.\r\n\r\nWe now check if we can evaluate the dependant expressions and if not we truthfully return that we don't know if the function is declared as `noexcept` or not.\r\n\r\nThis fixes #68101", "feature_layers": [], "feature_directives": ["declare"], "files_changed": [{"filename": "clang-tools-extra/test/clang-tidy/checkers/performance/noexcept-swap.cpp", "functions": ["swap"]}]}
{"pr_number": 67697, "url": "https://github.com/llvm/llvm-project/pull/67697", "title": "[AArch64][LoopVectorize] Use upper bound trip count instead of the constant TC when choosing max VF", "body": "This patch is based off of https://github.com/llvm/llvm-project/pull/67543. It should not be merged before the previous PR.\r\n\r\nWe are currently using the exact trip count to make decisions regarding the maximum VF. We can instead use the upper bound TC, which will be the same as the constant trip count when that is known. ", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Vectorize/LoopVectorize.cpp", "functions": ["computeFeasibleMaxVF"]}]}
{"pr_number": 68410, "url": "https://github.com/llvm/llvm-project/pull/68410", "title": "[mlir][tosa] Add verifier for `ArgMax` operator", "body": "Verifier ensures that operator is valid by checking:\r\n\r\n* Output type is I32\r\n* Axis is within the rank of the tensor", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Tosa/IR/TosaOps.cpp", "functions": ["emitOpError", "success"]}]}
{"pr_number": 68461, "url": "https://github.com/llvm/llvm-project/pull/68461", "title": "[mlir][sparse] replace specialized buffer setup with util code", "body": "This completely centralizes all set up related to dim2lvl and lvl2dim for the runtime library (and even parts of direct IR codegen) into one place! And all comptatible with the MapRef data structure that should be used in all remaining clients of dim2lvl and lvl2dim.\r\n\r\nNOTE: the convert_x2y.mlir tests were becoming too overloaded\r\n      so I decided to bring them back to the basics; if e.g.\r\n      more coverage of the foreach is required, they should\r\n      go into isolated smalle tests", "feature_layers": ["parse", "codegen", "runtime", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/Transforms/SparseTensorConversion.cpp", "functions": ["lvlSizes", "dimToLvl", "allocaBuffer", "lvlToDim"]}]}
{"pr_number": 68422, "url": "https://github.com/llvm/llvm-project/pull/68422", "title": "[flang][openacc] Support allocatable and pointer array in private recipe", "body": "Add support for pointer and allocatable arrays in private clause. ", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Lower/OpenACC.cpp", "functions": ["extractSequenceType"]}]}
{"pr_number": 68603, "url": "https://github.com/llvm/llvm-project/pull/68603", "title": "Revert \"[Clang] Implement the 'counted_by' attribute\"", "body": "This reverts commit 9a954c693573281407f6ee3f4eb1b16cc545033d, which causes clang\ncrashes when compiling with `-fsanitize=bounds`. See\nhttps://github.com/llvm/llvm-project/commit/9a954c693573281407f6ee3f4eb1b16cc545033d#commitcomment-129529574\nfor details.\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/AST/Expr.cpp", "functions": ["if"]}, {"filename": "clang/lib/CodeGen/CGExpr.cpp", "functions": ["if", "SanScope"]}, {"filename": "clang/lib/Sema/SemaDeclAttr.cpp", "functions": ["ValidateCandidate", "handleCountedByAttr", "clone", "Result", "CCC", "FieldDeclValidatorCCC"]}, {"filename": "clang/test/CodeGen/attr-counted-by.c", "functions": ["test4", "test3", "__counted_by", "test1", "test2"]}, {"filename": "clang/test/Sema/attr-counted-by.c", "functions": ["__counted_by"]}]}
{"pr_number": 68308, "url": "https://github.com/llvm/llvm-project/pull/68308", "title": "[mlir][python] generate value builders", "body": "This PR adds the additional generation of what I'm calling \"value builders\" (a term I'm not married to) that look like this:\r\n\r\n```python\r\ndef empty(sizes, element_type, *, loc=None, ip=None):\r\n    return get_result_or_results(tensor.EmptyOp(sizes=sizes, element_type=element_type, loc=loc, ip=ip))\r\n```\r\n\r\nwhich instantiates a `tensor.EmptyOp` and then immediately grabs the result (`OpResult`) and then returns that *instead of a handle to the op*.\r\n\r\nWhat's the point of adding these when `EmptyOp.result` already exists? My claim/feeling/intuition is that eDSL users are more comfortable with a value centric programming model (i.e., passing values as operands) as opposed to an operator instantiation programming model. Thus this change enables (or at least goes towards) the bindings supporting such a user and use case. For example,\r\n\r\n```python\r\ni32 = IntegerType.get_signless(32)\r\n...\r\nten1 = tensor.empty((10, 10), i32)\r\nten2 = tensor.empty((10, 10), i32)\r\nten3 = arith.addi(ten1, ten2)\r\n```\r\n\r\nNote, in order to present a \"pythonic\" API and enable \"pythonic\" eDSLs, the generated identifiers (op names and operand names) are snake case instead of camel case and thus `llvm::convertToSnakeFromCamelCase` needed a small fix. Thus this PR is stacked on top of https://github.com/llvm/llvm-project/pull/68375.\r\n\r\nIn addition, as a kind of victory lap, this PR adds a \"rangefor\" that looks and acts exactly like python's `range` but emits `scf.for`.", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/tools/mlir-tblgen/OpPythonBindingGen.cpp", "functions": ["_get_op_result_or_op_results", "emitDefaultOpBuilder"]}]}
{"pr_number": 68450, "url": "https://github.com/llvm/llvm-project/pull/68450", "title": "Remove LLDB introspection entrypoints from the shim", "body": "Rather than forwarding the LLDB entrypoints into asan_abi stable ABI, leave them unimplemented for now. Doing so allows the shim and asan_abi to be solely constrained to the entrypoints expected by the instrumentation. We will take up a model for other stable ABIs (tsan, ubsan, common, etc.) at a later date after choosing an inter-sanitizer stable abi pattern after discussion and RFC. This commit modifies https://reviews.llvm.org/D159545 by simply eliminating them from the shim entirely.\r\n\r\nrdar://115974403", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "compiler-rt/lib/asan_abi/asan_abi.cpp", "functions": ["__asan_abi_set_error_report_callback", "__asan_abi_get_report_access_type", "__asan_abi_report_present", "__asan_abi_describe_address", "__asan_abi_get_report_access_size"]}, {"filename": "compiler-rt/lib/asan_abi/asan_abi_shim.cpp", "functions": ["__asan_describe_address", "__asan_get_report_bp", "__asan_set_error_report_callback", "__asan_abi_get_report_access_type", "__asan_report_present", "__asan_get_report_access_type", "__asan_get_report_pc", "__asan_get_report_access_size", "__asan_get_alloc_stack", "__asan_get_report_address", "__asan_abi_get_report_description", "__asan_get_report_sp"]}]}
{"pr_number": 68457, "url": "https://github.com/llvm/llvm-project/pull/68457", "title": "[llvm][objdump] Remove support for printing the embedded Bitcode section in MachO files.", "body": "It's no longer possible to submit bitcode apps to the Apple App Store. The tools\nused to create xar archived bitcode sections inside MachO files have been\ndiscontinued. Additionally, the xar APIs have been deprecated since macOS 12,\nso this change removes unnecessary code from objdump and all dependencies on\nlibxar.\n\nThis fixes rdar://116600767\n", "feature_layers": [], "feature_directives": ["for", "sections"], "files_changed": [{"filename": "llvm/tools/llvm-objdump/MachODump.cpp", "functions": ["PrintXarFilesSummary", "format_hex", "xar", "xar_t", "xar_iter_t", "PrintModeVerbose", "if", "XarFile", "swapStruct", "XarContents"]}]}
{"pr_number": 68347, "url": "https://github.com/llvm/llvm-project/pull/68347", "title": "[lldb][NFCI] Remove use of ConstString from FilterRule in StructuredDataDarwinLog", "body": "There are only ever 2 FilterRules and their operations are either \"regex\" or \"match\". This does not benefit from deduplication since the strings have static lifetime and we can just compare StringRefs pointing to them. This is also not on a fast path, so it doesn't really benefit from the pointer comparisons of ConstStrings.", "feature_layers": ["ir", "ast"], "feature_directives": [], "files_changed": [{"filename": "lldb/source/Plugins/StructuredData/DarwinLog/StructuredDataDarwinLog.cpp", "functions": ["GetOperationType", "StaticGetOperation", "s_operation"]}]}
{"pr_number": 65918, "url": "https://github.com/llvm/llvm-project/pull/65918", "title": "[Sema] add cast from IncompleteArrayType to ConstantArrayType in TryReferenceListInitialization", "body": "Fixed: https://github.com/llvm/llvm-project/issues/62945\r\nc++20 supports \"Permit conversions to arrays of unknown bound\". This need additional cast from IncompleteArrayType to ConstantArrayType in TryReferenceListInitialization", "feature_layers": ["sema", "ast"], "feature_directives": [], "files_changed": [{"filename": "clang/lib/Sema/SemaInit.cpp", "functions": ["if"]}, {"filename": "clang/test/CodeGenCXX/cxx20-p0388-unbound-ary.cpp", "functions": ["foo"]}]}
{"pr_number": 68624, "url": "https://github.com/llvm/llvm-project/pull/68624", "title": "[flang][openacc] Support array with dynamic extent in private recipe", "body": "Add lowering support for array with dynamic extents for private recipe. The extents are passed as block arguments and used in the alloca operation. The shape also used this information for the hlfir.declare operation. ", "feature_layers": ["ir"], "feature_directives": ["for", "declare"], "files_changed": [{"filename": "flang/lib/Lower/OpenACC.cpp", "functions": ["isConstantBound", "areAllBoundConstant"]}]}
{"pr_number": 68320, "url": "https://github.com/llvm/llvm-project/pull/68320", "title": "[mlir] Make overloads of SymbolTable::replaceAllSymbolUses consistent.", "body": "This function has several overloads that allow to specify the symbol that should be renamed and the scope for that renaming in different ways. The overloads were inconsistent in the following way (quoted strings are `StringAttr`s, other variables are `Operation *`):\r\n\r\n* `replaceAllSymbolUses(symbolOp, \"new_symbol\", scopeOp)` would traverse into the nested regions of `scopeOp` and hence rename the symbol inside of `scopeOp`.\r\n* `replaceAllSymbolUses(\"symbol\", \"new_symbol\", scopeOp)` would *not* traverse into the nested regions of `scopeOp` and hence *not* rename the symbol.\r\n\r\nThe underlying behavior was spread over different places and is somewhat hard to understand. The two overloads above mainly differed by what `collectSymbolScopes` computed, which is itself overloaded. If `scopeOp` is a top-level module, then the overload on `(Operation *, Operation *)`, which is used in the first of the above cases, computes a scope where the body region of the module is the `limit`; however, the overload on `(StringAttr, Operation *)` computed the module op itself as the `limit`. Later, `walkSymbolTable` would walk the body of the module if it was given as a region but it would *not* enter the regions of the module op because that op has a symbol table (which was assumed to be a *different* scope).\r\n\r\nThe fix in this commit is change the behavior of `collectSymbolScopes` such that the `(StringAttr, Operation *)` overload returns a scope for each region in the `limit` argument.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/unittests/IR/SymbolTableTest.cpp", "functions": ["context", "testReplaceAllSymbolUses", "SetUp"]}]}
{"pr_number": 65246, "url": "https://github.com/llvm/llvm-project/pull/65246", "title": "[Clang] Fix missing diagnostic for non-standard layout type in `offsetof`", "body": "Fixes #64619\r\n\r\nClang warns diagnostic for non-standard layout types in `offsetof` only if they are in evaluated context. With this patch, you'll also get diagnostic if you use `offsetof` on non-standard layout types in any other contexts", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Sema/SemaExpr.cpp", "functions": ["SourceRange"]}]}
{"pr_number": 67791, "url": "https://github.com/llvm/llvm-project/pull/67791", "title": "[AMDGPU] Use absolute relocations when compiling for AMDPAL and Mesa3D", "body": "The primary ISA-independent justification for using PC-relative addressing is that it makes code position-independent and therefore allows sharing of .text pages between processes.\r\n\r\nWhen not sharing .text pages, we can use absolute relocations instead, which will possibly prevent a bubble introduced by s_getpc_b64.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/SIISelLowering.cpp", "functions": ["if"]}]}
{"pr_number": 68598, "url": "https://github.com/llvm/llvm-project/pull/68598", "title": "[flang][hlfir] Cast actual cst len character to stmt func dummy type", "body": "When calling a statement function with a character actual argument with a constant length mismatching the dummy length, HLFIR lowering created an hlfir.declare with the actual argument length for the dummy, causing bugs when lowering the statement function expression.\r\n\r\nEnsure character dummies are always cast to the dummy type when lowering dummy declarations.", "feature_layers": ["ir", "ast"], "feature_directives": ["for", "declare"], "files_changed": [{"filename": "flang/lib/Lower/ConvertVariable.cpp", "functions": ["if"]}]}
{"pr_number": 65165, "url": "https://github.com/llvm/llvm-project/pull/65165", "title": "[BOLT][RISCV] Implement R_RISCV_PCREL_LO12_S", "body": "Relocation used for store instructions.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "bolt/lib/Core/Relocation.cpp", "functions": ["extractSImmRISCV"]}]}
{"pr_number": 65204, "url": "https://github.com/llvm/llvm-project/pull/65204", "title": "[BOLT][RISCV] Implement R_RISCV_PCREL_LO12_S", "body": "Relocation used for store instructions.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "bolt/lib/Core/Relocation.cpp", "functions": ["extractSImmRISCV"]}]}
{"pr_number": 68588, "url": "https://github.com/llvm/llvm-project/pull/68588", "title": "[mlir][spirv] SCFToSPIRV: fix WhileOp block args types conversion", "body": "WhileOp before/after block args types weren't converted, resulting in invalid IR.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Conversion/SCFToSPIRV/SCFToSPIRV.cpp", "functions": ["guard"]}]}
{"pr_number": 68008, "url": "https://github.com/llvm/llvm-project/pull/68008", "title": "[AArch64] Fix x18 being used by nest ptrs with MSVC ABI", "body": "This patch fixes an issue where x18 is used for passing pointer parameters with\nthe nest attribute on Windows on AArch64. The x18 register is reserved in the\nWoA ABI so can't be used for this purpose. This is fixed by introducing a new\nWin64PCS calling convention that differs from the standard AAPCS only by not\nusing x18 for nest parameters.\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AArch64/AArch64RegisterInfo.cpp", "functions": ["HasReg"]}]}
{"pr_number": 68262, "url": "https://github.com/llvm/llvm-project/pull/68262", "title": "[LLVM][DWARF] Create thread safe context for DWP DWARFContext", "body": "Right now DWARFContext that is created is the same when input is DWO or DWP file.\r\nChanged so that for DWP it creates a thread safe context. This allows for a multi threaded safe access to {cu,tu}-index\r\n\r\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/DebugInfo/DWARF/DWARFContext.cpp", "functions": ["isThreadSafe"]}]}
{"pr_number": 67759, "url": "https://github.com/llvm/llvm-project/pull/67759", "title": "[AMDGPU][IGLP] SingleWaveOpt: Cache DSW Counters from PreRA", "body": "Allowing PERMs to fall into the generic VALU for this mutation is creating edges which block them being classified into the V_PERM SchedGroups. Since other groups in the pipeline depend on V_PERM placement (e.g. DS_WRITE group must be a succ of the V_PERM in stage 2a), not being able to place the V_PERM is a bit catastrophic.\r\n\r\nAdditionally, remove a bad assert in SharesPredWithPrevNthGroup -- it is possible that we will have an empty cache if OtherGroup has no elements which have a V_PERM pred (possible if the V_PERM SG is empty).", "feature_layers": ["ast"], "feature_directives": ["for", "single"], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp", "functions": ["if", "createIGroupLPDAGMutation"]}]}
{"pr_number": 67009, "url": "https://github.com/llvm/llvm-project/pull/67009", "title": "[mlir][docgen] Display full attribute descriptions in expandable regions", "body": "This updates the table of op attributes so that clicking the summary expands to show the complete description.\r\n\r\n```\r\n   Attribute | MLIR Type | Description\r\n   <name>      <type>      \u25b6 <summary>  <-- Click to expand\r\n```\r\n\r\nEnum attributes have now also been updated to generate a description that lists all the cases (with both their MLIR and C++ names). This makes viewing enums on the MLIR docs much nicer.\r\n\r\n**Example**\r\n\r\nDefault view:\r\n![image](https://github.com/llvm/llvm-project/assets/11597044/922669c7-b838-4230-bcfd-a77cde0f335d)\r\n\r\nExpanded:\r\n![image](https://github.com/llvm/llvm-project/assets/11597044/41da086e-a5ce-45dd-9f44-9d10a4d5f2e1)\r\n\r\n---\r\n\r\nThis requires: https://github.com/llvm/mlir-www/pull/158 (adds a very simple markdown shortcode)\r\n", "feature_layers": ["ir"], "feature_directives": ["requires"], "files_changed": [{"filename": "mlir/tools/mlir-tblgen/OpDocGen.cpp", "functions": ["resolveAttrDescription"]}]}
{"pr_number": 67619, "url": "https://github.com/llvm/llvm-project/pull/67619", "title": "[RISCV][GlobalISel] Select G_ICMP, G_LOAD, G_STORE, G_ZEXTLOAD", "body": "We use tablegen patterns to select for G_ICMP. There are existing SelectionDAG patterns for selecting G_LOAD, G_STORE and G_ZEXTLOAD with XLenVT type data. We introduce GIAddrRegImm to successfully import those patterns. \r\n\r\nThis PR contains two stacked patches. Once this PR is approved, both patches will be applied separately (not squashed and merged).", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp", "functions": ["selectAddrRegImm"]}]}
{"pr_number": 67605, "url": "https://github.com/llvm/llvm-project/pull/67605", "title": "[RISCV][GlobalISel] Select G_PTR_ADD", "body": "We lower G_PTR_ADD to G_ADD before selection. We choose to do this here and not post-legalization because G_PTR_ADD can still be combined with other instructions during selection.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp", "functions": ["select"]}]}
{"pr_number": 68452, "url": "https://github.com/llvm/llvm-project/pull/68452", "title": "[lldb] Fix `po` alias by printing fix-its to the console.", "body": "The `po` alias now matches the behavior of the `expression` command when the it can apply a Fix-It to an expression.\r\nModifications\r\n\r\n- Add has `m_fixed_expression` to the `CommandObjectDWIMPrint` class a `protected` member that stores the post Fix-It expression, just like the `CommandObjectExpression` class.\r\n- Converted messages to present tense.\r\n- Add test cases that confirms a Fix-It for a C++ expression for both `po` and `expressions`\r\n\r\nrdar://115317419", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "lldb/test/API/lang/cpp/dwim-print-fixit/main.cpp", "functions": ["main"]}, {"filename": "lldb/test/API/lang/cpp/expression-fixit/main.cpp", "functions": ["main"]}]}
{"pr_number": 68681, "url": "https://github.com/llvm/llvm-project/pull/68681", "title": "[Clang][PowerPC] Support tune directive in target attribute", "body": "", "feature_layers": ["ir"], "feature_directives": ["target"], "files_changed": [{"filename": "clang/test/Sema/attr-target.c", "functions": ["__attribute__"]}]}
{"pr_number": 67745, "url": "https://github.com/llvm/llvm-project/pull/67745", "title": "[asan] Ensure __asan_register_elf_globals is called in COMDAT asan.module_ctor", "body": "On ELF platforms, when there is no global variable and the unique module ID is\nnon-empty, COMDAT asan.module_ctor is created with no\n`__asan_register_elf_globals` calls. If this COMDAT is the prevailing copy\nselected by the linker, the linkage unit will have no\n`__asan_register_elf_globals` call: the redzone will not be poisoned and ODR\nviolation checker will not work (#67677).\n\nThis behavior is benign for -fno-sanitize-address-globals-dead-stripping because\nasan.module_ctor functions that call `__asan_register_globals`\n(`InstrumentGlobalsWithMetadataArray`) do not use COMDAT.\n\nTo fix #67677:\n\n* Use COMDAT for -fsanitize-address-globals-dead-stripping on ELF platforms.\n* Call `__asan_register_elf_globals` even if there is no global variable.\n* If the unique module ID is empty, don't call SetComdatForGlobalMetadata\n  (placing `@.str` in a COMDAT would incorrectly discard internal `@.str` in\n  other compile units)\n\nAlternatively, when there is no global variable, asan.module_ctor is not COMDAT\nand does not call `__asan_register_elf_globals`. However, the asan.module_ctor\nfunction cannot be eliminated by the linker.\n\nTested the following script. Only ELF -fsanitize-address-globals-dead-stripping has changed behaviors.\n```\necho > a.cc  # no global variable, empty uniqueModuleId\necho 'void f() {}' > b.cc  # with global variable, with uniqueModuleId\necho 'int g;' > c.cc  # with global variable\nfor t in x86_64-linux-gnu arm64-apple-macosx x86_64-windows-msvc; do\n  for gc in -f{,no-}sanitize-address-globals-dead-stripping; do\n    for f in a.cc b.cc c.cc; do\n      echo /tmp/Rel/bin/clang -S --target=$t -fsanitize=address $gc $f -o -\n      /tmp/Rel/bin/clang -S --target=$t -fsanitize=address $gc $f -o - | sed -n '/asan.module_ctor/,/ret/p'\n    done\n  done\ndone\n```", "feature_layers": [], "feature_directives": ["for", "target"], "files_changed": [{"filename": "llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp", "functions": ["InstrumentGlobals"]}]}
{"pr_number": 68732, "url": "https://github.com/llvm/llvm-project/pull/68732", "title": "Revert \"[MLIR][Transforms] Fix Mem2Reg removal order to respect dominance (#68687)\"", "body": "This commit causes the following issue with sanitizers:\r\n\r\n`include/c++/v1/__debug_utils/strict_weak_ordering_check.h:52: assertion !__comp(*(__first + __b), *(__first + __a)) failed: Your comparator is not a valid strict-weak ordering`\r\n\r\nprobably due to an invalid sort().\r\n\r\nRevert \"[MLIR][Transforms] Fix Mem2Reg removal order to respect dominance (#68687)\"\r\n\r\nThis reverts commit be81f42b551c8b3c520132c3d60bc19cfc1c72fb.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Transforms/Mem2Reg.cpp", "functions": ["computeBlockingUses"]}]}
{"pr_number": 68069, "url": "https://github.com/llvm/llvm-project/pull/68069", "title": "[clang][Interp] Add basic support for _BitInt", "body": "Make sure we pass the expected bitwidth around when casting to IntAP/IntAPS and move the tests to their own file.\r\n\r\nThis makes it easier to test the `IntegralAP` code for different bit widths than 128.", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/AST/Interp/intap.cpp", "functions": ["_BitInt"]}]}
{"pr_number": 68687, "url": "https://github.com/llvm/llvm-project/pull/68687", "title": "[MLIR][Transforms] Fix Mem2Reg removal order to respect dominance", "body": "This commit fixes a bug in the Mem2Reg operation erasure order. Replacing the topological order with a dominance based order ensures that no operation is removed before all its uses have been replaced. Additionally, the reliance on the `DenseMap` key order was eliminated by switching to a `MapVector`, that gives a deterministic iteration order.\r\n\r\nExample:\r\n\r\n```\r\n%ptr = alloca ...\r\n...\r\n%val0 = %load %ptr ... // LOAD0\r\nstore %val0 %ptr ...\r\n%val1 = load %ptr ... // LOAD1\r\n````\r\n\r\nWhen promoting the slot backing %ptr, it can happen that the LOAD0 was cleaned before LOAD1. This results in all uses of LOAD0 being replaced by its reaching definition, before LOAD1's result is replaced by LOAD0's result. The subsequent erasure of LOAD0 can thus not succeed, as it has remaining usages.", "feature_layers": ["sema", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Transforms/Mem2Reg.cpp", "functions": ["computeBlockingUses"]}]}
{"pr_number": 68646, "url": "https://github.com/llvm/llvm-project/pull/68646", "title": "[clang]Avoid diagnose invalid consteval call for invalid function decl", "body": "Fixes:#68542\r\nIt is meaningless to diagnose further error for a invalid function declaration.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/SemaCXX/PR68542.cpp", "functions": ["get_format", "f"]}]}
{"pr_number": 68710, "url": "https://github.com/llvm/llvm-project/pull/68710", "title": "[clang][C2x] Remove confusing diagnostic auto storage class specifier", "body": "When declaring `auto int` at local or file scope, we emit a warning intended for C++11 and later, which is incorrect and confusing in C23.\r\nSee [Godbolt example](https://godbolt.org/z/j1acGhecd).\r\nNow this diagnostic does not show up in C23.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/C/C2x/n3007.c", "functions": ["test_auto_int"]}]}
{"pr_number": 66188, "url": "https://github.com/llvm/llvm-project/pull/66188", "title": "[MachineBasicBlock] Fix use after free in SplitCriticalEdge", "body": "Remove use after free when attempting to update SlotIndexes in MachineBasicBlock::SplitCriticalEdge.\r\nAdd support to targets for updating SlotIndexes when inserting or removing branches.", "feature_layers": [], "feature_directives": ["for", "critical", "target"], "files_changed": [{"filename": "llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp", "functions": ["insertBranch"]}]}
{"pr_number": 66996, "url": "https://github.com/llvm/llvm-project/pull/66996", "title": "[SVE][CodeGenPrepare] Sink address calculations that match SVE gather/scatter addressing modes.", "body": "SVE supports scalar+vector and scalar+extw(vector) addressing modes.\nHowever, the masked gather/scatter intrinsics take a vector of\naddresses, which means address computations can be hoisted out of\nloops.  The is especially true for things like offsets where the\ntrue size of offsets is lost by the time you get to code generation.\n\nThis is problematic because it forces the code generator to legalise\ntowards `<vscale x 2 x ty>` vectors that will not maximise bandwidth\nif the main block datatypes is in fact i32 or smaller.\n\nThis patch sinks GEPs and extends for cases where one of the above\naddressing modes can be used.\n\nNOTE: There are cases where it would be better to split the extend\nin two with one half hoisted out of a loop and the other within the\nloop.  Whilst true I think this switch of default is still better\nthan before because the extra extends are an improvement over being\nforced to split a gather/scatter.\n", "feature_layers": ["codegen"], "feature_directives": ["for", "masked"], "files_changed": [{"filename": "llvm/lib/Target/AArch64/AArch64ISelLowering.cpp", "functions": ["shouldSinkVectorOfPtrs"]}]}
{"pr_number": 68414, "url": "https://github.com/llvm/llvm-project/pull/68414", "title": "FIR TBAA Pass", "body": "The first commits are from https://github.com/llvm/llvm-project/pull/68317\r\n\r\nSee RFC at\r\nhttps://discourse.llvm.org/t/rfc-propagate-fir-alias-analysis-information-using-tbaa/73755\r\n\r\nThis pass adds TBAA tags to all accesses to non-pointer/target dummy\r\narguments. These TBAA tags tell LLVM that these accesses cannot alias:\r\nallowing better dead code elimination, hoisting out of loops, and\r\nvectorization. The pass is not enabled by default in this patch.\r\n\r\nEach function has its own TBAA tree so that accesses between functions\r\nMayAlias after inlining.\r\n\r\nI also included code for adding tags for local allocations and for\r\nglobal variables. Enabling all three kinds of tag is known to produce a\r\nmiscompile and so these are disabled by default. But it isn't much\r\ncode and I thought it could be interesting to play with these later if\r\none is looking at a benchmark which looks like it would benefit from\r\nmore alias information. I'm open to removing this code too.\r\n\r\nTBAA tags are also added separately by TBAABuilder during CodeGen.\r\nTBAABuilder has to run during CodeGen because it adds tags to box\r\naccesses, many of which are implicit in FIR. This pass cannot (easily)\r\nrun in CodeGen because fir::AliasAnalysis has difficulty tracing values\r\nbetween blocks, and by the time CodeGen runs, structured control flow\r\nhas already been lowered.\r\n\r\nComing in follow up patches\r\n  - Change CodeGen/TBAABuilder to use TBAAForest to add tags within the\r\n    same per-function trees as are used here (delayed to a later patch\r\n    to make it easier to revert)\r\n  - Command line argument processing to actually enable the pass", "feature_layers": ["codegen", "ir"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "flang/lib/Optimizer/Analysis/TBAAForest.cpp", "functions": ["globalDataTree"]}, {"filename": "flang/lib/Optimizer/Transforms/AddAliasTags.cpp", "functions": ["runOnOperation", "getFuncArgName", "if", "getDeclareOp", "runOnAliasInterface"]}]}
{"pr_number": 66927, "url": "https://github.com/llvm/llvm-project/pull/66927", "title": "[AArch64][GlobalISel] Support more types for TRUNC", "body": "G_TRUNC will get lowered into trunc(merge(trunc(unmerge), trunc(unmerge))) if the source is larger than 128 bits or the truncation is more than half of the current bit size.\r\n\r\nNow mirrors ZEXT/SEXT code more closely for vector types.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp", "functions": ["lowerTRUNC"]}, {"filename": "llvm/lib/Target/AArch64/GISel/AArch64LegalizerInfo.cpp", "functions": ["legalizeVectorTrunc"]}]}
{"pr_number": 68632, "url": "https://github.com/llvm/llvm-project/pull/68632", "title": "[mlir][bufferization] Allow cyclic function graphs without tensors", "body": "Cyclic function call graphs are generally not supported by One-Shot Bufferize. However, they can be allowed when a function does not have tensor arguments or results. This is because it is then no longer necessary that the callee will be bufferized before the caller.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Bufferization/Transforms/OneShotModuleBufferize.cpp", "functions": ["hasTensorSignature"]}]}
{"pr_number": 68625, "url": "https://github.com/llvm/llvm-project/pull/68625", "title": "[mlir][bufferization][NFC] Simplify `bufferizeOp` function signature", "body": "Remove the `opFilter` and `copyBeforeWrite` function arguments. These options can already be configured in the `options` object.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Bufferization/Transforms/OneShotAnalysis.cpp", "functions": ["bufferizeOp"]}, {"filename": "mlir/lib/Dialect/Bufferization/Transforms/OneShotModuleBufferize.cpp", "functions": ["failure"]}]}
{"pr_number": 67530, "url": "https://github.com/llvm/llvm-project/pull/67530", "title": "[MLIR][NVGPU] Introduce `warpgroup.init.accumulator` Op", "body": "This Op generates and initilizes the accumulator matrix for `nvgpu.warpgroup.mma` op to perform matrix-multiply-and-accumulate (mma).\r\n\r\nIts associated transformation generates `!llvm.struct<>` and fill it with the initial values. The size of struct is number of required inout registers for `nvgpu.warpgroup.mma` op.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Conversion/NVGPUToNVVM/NVGPUToNVVM.cpp", "functions": ["b"]}, {"filename": "mlir/lib/Dialect/NVGPU/IR/NVGPUDialect.cpp", "functions": ["emitOpError", "success", "isAllowedSizeM"]}]}
{"pr_number": 68767, "url": "https://github.com/llvm/llvm-project/pull/68767", "title": "Reland: [MLIR][Transforms] Fix Mem2Reg removal order to respect dominance", "body": "Reverts the revert commit and fixes the weak ordering requirement of `llvm::sort`.\r\n\r\nOriginal commit message:\r\n\r\nThis commit fixes a bug in the Mem2Reg operation erasure order. Replacing the topological order with a dominance based order ensures that no operation is removed before all its uses have been replaced. Additionally, the reliance on the `DenseMap` key order was eliminated by switching to a `MapVector`, that gives a deterministic iteration order.\r\n\r\nExample:\r\n\r\n```\r\n%ptr = alloca ...\r\n...\r\n%val0 = %load %ptr ... // LOAD0\r\nstore %val0 %ptr ...\r\n%val1 = load %ptr ... // LOAD1\r\n````\r\n\r\nWhen promoting the slot backing %ptr, it can happen that the LOAD0 was cleaned before LOAD1. This results in all uses of LOAD0 being replaced by its reaching definition, before LOAD1's result is replaced by LOAD0's result. The subsequent erasure of LOAD0 can thus not succeed, as it has remaining usages.", "feature_layers": ["sema", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Transforms/Mem2Reg.cpp", "functions": ["computeBlockingUses"]}]}
{"pr_number": 68364, "url": "https://github.com/llvm/llvm-project/pull/68364", "title": "[OpenMPIRBuilder] Add ThreadLimit and NumTeams clauses to teams construct", "body": "This patch adds support for `thread_limit` and bounds on `num_teams` clause for the teams construct in OpenMP.\r\n\r\nAdded testcases for the same.", "feature_layers": ["ir"], "feature_directives": ["for", "teams"], "files_changed": [{"filename": "llvm/unittests/Frontend/OpenMPIRBuilderTest.cpp", "functions": ["OMPBuilder"]}]}
{"pr_number": 68729, "url": "https://github.com/llvm/llvm-project/pull/68729", "title": "[mlir][bufferization] Transfer `restrict` during empty tensor elimination", "body": "Empty tensor elimination is looking for `bufferization.materialize_in_destination` ops with a `tensor.empty` source. It replaces the `tensor.empty` with a `bufferization.to_tensor restrict` of the memref destination. As part of this rewrite, the `restrict` keyword should be removed, so that no second `to_tensor restrict` op will be inserted. Such IR would be invalid. `bufferization.materialize_in_destination` with memref destination and without the `restrict` attribute are ignored by empty tensor elimination.\r\n\r\nAlso relax the verifier of `materialize_in_destination`. The `restrict` keyword is not generally needed because the op does not expose the buffer as a tensor.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Bufferization/IR/BufferizationOps.cpp", "functions": ["emitOpError"]}]}
{"pr_number": 68437, "url": "https://github.com/llvm/llvm-project/pull/68437", "title": "[flang] use TBAA Forest in TBAABuilder", "body": "See previous reviews at https://github.com/llvm/llvm-project/pull/68414 and https://github.com/llvm/llvm-project/pull/68317\r\n\r\nThis is important to ensure that tags end up in the same trees that were\r\ncreated in the FIR TBAA pass. If they are in different trees then\r\neverything in one tree will be assumed to MayAlias with everything in the\r\nother tree. This leads to poor performance.\r\n\r\nAfter this change, the trees generated by TBAABuilder are separated per-function. This could lead to less precise alias information after in-lining, but no serious performance regressions have been found so far.\r\n\r\n@vzakhari requested that the old (not-per-function) trees are\r\nmaintained so I left the old test intact.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Optimizer/Analysis/TBAAForest.cpp", "functions": ["globalDataTree"]}, {"filename": "flang/lib/Optimizer/Transforms/AddAliasTags.cpp", "functions": ["getDeclareOp"]}, {"filename": "flang/lib/Optimizer/CodeGen/TBAABuilder.cpp", "functions": ["enableTBAA", "getAnyDataAccessTag", "getAnyBoxAccessTag"]}]}
{"pr_number": 68350, "url": "https://github.com/llvm/llvm-project/pull/68350", "title": "[mlir][sparse] simplify ConvertOp rewriting rules", "body": "Canonicalize complex convertOp into multiple stages, such that it can either be done by a direct conversion or by sorting.", "feature_layers": ["parse", "ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/IR/SparseTensorDialect.cpp", "functions": ["failure", "success"]}, {"filename": "mlir/lib/Dialect/SparseTensor/Transforms/SparseTensorRewriting.cpp", "functions": ["success", "getSSA", "sparse2DenseRewrite", "srcTp", "dense2SparseRewrite", "sparse2SparseRewrite", "failure", "es", "dstLcvs", "lcvs", "getIterSSA"]}, {"filename": "mlir/lib/Dialect/SparseTensor/Transforms/SparseTensorCodegen.cpp", "functions": ["failure", "success"]}, {"filename": "mlir/lib/Dialect/SparseTensor/Transforms/StageSparseOperations.cpp", "functions": ["failure", "success"]}]}
{"pr_number": 67220, "url": "https://github.com/llvm/llvm-project/pull/67220", "title": "[Support] Add `\\g<ref>` backreferences in Regex::sub()", "body": "The existing format of backreferences, `\\<ref>`, does not allow digits to be placed directly after the reference because they are included in the reference number. The new format solves this problem by adding explicit delimiters.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Support/Regex.cpp", "functions": ["if"]}]}
{"pr_number": 68558, "url": "https://github.com/llvm/llvm-project/pull/68558", "title": "[clang][dataflow] Add support for lambda captures", "body": "This adds support for copy, ref, and this lambda captures to the core framework and also adds relevant test in UncheckedOptionalAccessTest.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/unittests/Analysis/FlowSensitive/TestingSupport.cpp", "functions": ["checkDataflowWithNoopAnalysis"]}, {"filename": "clang/unittests/Analysis/FlowSensitive/TransferTest.cpp", "functions": ["target"]}, {"filename": "clang/unittests/Analysis/FlowSensitive/UncheckedOptionalAccessModelTest.cpp", "functions": ["ExpectDiagnosticsForLambda", "target"]}]}
{"pr_number": 68665, "url": "https://github.com/llvm/llvm-project/pull/68665", "title": "[MLIR] Refactor FuncOpToLLVM to operate on FunctionOpInterface instead of FuncOp (NFC)", "body": "* refactor `convertFuncOpToLLVMFuncOp` to accept a `FunctionOpInterface` instead of func::FuncOp\r\n* move `convertFuncOpToLLVMFuncOp` to corresponding public header, making it available for downstream project.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Conversion/FuncToLLVM/FuncToLLVM.cpp", "functions": ["result"]}]}
{"pr_number": 67214, "url": "https://github.com/llvm/llvm-project/pull/67214", "title": "[BasicBlockSections] Introduce the path cloning profile format to BasicBlockSectionsProfileReader.", "body": "Following up on prior RFC (https://lists.llvm.org/pipermail/llvm-dev/2020-September/145357.html) we can now improve above our highly-optimized basic-block-sections binary (e.g., 2% for clang) by applying path cloning. Cloning can improve performance by reducing taken branches.\r\n\r\nThis patch prepares the profile format for applying cloning actions.\r\n\r\nThe basic block cloning profile format extends the basic block sections profile in two ways.\r\n\r\n  1. Specifies the cloning paths with a 'p' specifier. For example, `p 1 4 5` specifies that blocks with BB ids 4 and 5 must be cloned along the edge 1 --> 4.\r\n  2. For each cloned block, it will appear in the cluster info as `<bb_id>.<clone_id>` where `clone_id` is the id associated with this clone.\r\n\r\nFor example, the following profile specifies one cloned block (2) and determines its cluster position as well.\r\n```\r\nf foo\r\np 1 2\r\nc 0 1 2.1 3 2 5\r\n```\r\n\r\nThis patch keeps backward-compatibility (retains the behavior for old profile formats). This feature is only introduced for profile version >= 1.", "feature_layers": [], "feature_directives": ["for", "sections"], "files_changed": [{"filename": "llvm/lib/CodeGen/BasicBlockSectionsProfileReader.cpp", "functions": ["getPathAndClusterInfoForFunction", "getRawProfileForFunction"]}]}
{"pr_number": 68765, "url": "https://github.com/llvm/llvm-project/pull/68765", "title": "[mlir][tosa] Add aggressiveReduceConstant argument for the constant reduce optimization", "body": "Adding the argument of aggressiveReduceConstant to the TosaLayerwiseConstantFoldPass which would\r\nallow performing the constant optimizations on the reduce ops always. (e.g. without considering the\r\nnumber of users of the input of the reduce operation)", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Tosa/Transforms/TosaLayerwiseConstantFoldPass.cpp", "functions": ["TosaLayerwiseConstantFoldPassBase"]}]}
{"pr_number": 68595, "url": "https://github.com/llvm/llvm-project/pull/68595", "title": "[flang] Add flags controlling whether to run the fir alias tags pass", "body": "**This does not enable the pass by default**\r\n\r\nThe ultimate intention is to have this pass enabled by default whenever\r\nwe are optimizing for speed. But for now, just add the arguments so this\r\ncan be more easily tested.\r\n\r\nPrevious PR in this series: https://github.com/llvm/llvm-project/pull/68437\r\n\r\nThis PR is only for review of https://github.com/llvm/llvm-project/pull/68595/commits/ca6751edec4207165e09070393b9f5489e85d4a4 (and any later fixups)", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Optimizer/Analysis/TBAAForest.cpp", "functions": ["globalDataTree"]}, {"filename": "flang/lib/Optimizer/Transforms/AddAliasTags.cpp", "functions": ["getDeclareOp"]}, {"filename": "flang/lib/Optimizer/CodeGen/TBAABuilder.cpp", "functions": ["enableTBAA", "getAnyDataAccessTag", "getAnyBoxAccessTag"]}]}
{"pr_number": 68694, "url": "https://github.com/llvm/llvm-project/pull/68694", "title": "[mlir][ODS] Omit printing default-valued attributes in oilists", "body": "This makes these match the behaviour of optional attributes (which are omitted when they are their default value of `none`). This allows for concise assembly formats without a custom printer.\r\n\r\nAn extra print of \" \" is also removed, this does change any existing uses of oilists, but if the parameter before the oilist is optional, that would previously add an extra space.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/tools/mlir-tblgen/OpFormatGen.cpp", "functions": ["tgfmt"]}]}
{"pr_number": 66737, "url": "https://github.com/llvm/llvm-project/pull/66737", "title": "[libcxx] <experimental/simd> Add generate constructor of class simd", "body": "Differential Revision: https://reviews.llvm.org/D159442", "feature_layers": [], "feature_directives": ["simd"], "files_changed": [{"filename": "libcxx/test/std/experimental/simd/simd.class/simd_ctor_generator.pass.cpp", "functions": ["main", "operator"]}]}
{"pr_number": 68095, "url": "https://github.com/llvm/llvm-project/pull/68095", "title": "[mlir][nvvm] Move `BasicPtxBuilder` Interface to Its Own File (NFC)", "body": "The `BasicPtxBuilder` interface plays a crucial role in generating PTX assembly from NVVM Ops. Previously, it was situated within `NVVM.td` and `NVVMToLLVM.cpp`. For the sake of code readability, this PR moves it into its own dedicated file. Additionally, it includes comprehensive documentation for the classes and interface.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Conversion/NVVMToLLVM/NVVMToLLVM.cpp", "functions": ["generator", "insertValue", "op", "getRegisterType", "getModifier", "ss", "build", "buildAndReplaceOp"]}, {"filename": "mlir/lib/Dialect/LLVMIR/IR/BasicPtxBuilderInterface.cpp", "functions": ["getRegisterType", "ss", "getModifier"]}]}
{"pr_number": 68877, "url": "https://github.com/llvm/llvm-project/pull/68877", "title": "Reland: [MLIR][Transforms] Fix Mem2Reg removal order to respect dominance", "body": "This commit fixes a bug in the Mem2Reg operation erasure order. Replacing the use-def based topological order with a dominance-based weak order ensures that no operation is removed before all its uses have been replaced. The order relation uses the topological order of blocks and block internal ordering to determine a deterministic operation order.\r\n\r\nAdditionally, the reliance on the `DenseMap` key order was eliminated by switching to a `MapVector`, that gives a deterministic iteration order.\r\n\r\nExample:\r\n\r\n```\r\n%ptr = alloca ...\r\n...\r\n%val0 = %load %ptr ... // LOAD0\r\nstore %val0 %ptr ...\r\n%val1 = load %ptr ... // LOAD1\r\n````\r\n\r\nWhen promoting the slot backing %ptr, it can happen that the LOAD0 was cleaned before LOAD1. This results in all uses of LOAD0 being replaced by its reaching definition, before LOAD1's result is replaced by LOAD0's result. The subsequent erasure of LOAD0 can thus not succeed, as it has remaining usages.", "feature_layers": ["sema", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Target/LLVMIR/ModuleTranslation.cpp", "functions": ["traversal"]}, {"filename": "mlir/lib/Transforms/Mem2Reg.cpp", "functions": ["computeBlockingUses", "dominanceSort"]}, {"filename": "mlir/lib/Transforms/Utils/RegionUtils.cpp", "functions": ["traversal"]}]}
{"pr_number": 68905, "url": "https://github.com/llvm/llvm-project/pull/68905", "title": "Revert \"[Remarks] Introduce count subcommand for llvm-remarkutil. (#66214)\"", "body": "This reverts commit 31c2cf1136179da2bd179d28ea632bd73f5c0ea9, as it results in a broken LLVM build.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/tools/llvm-remarkutil/RemarkCounter.cpp", "functions": ["getValForKey", "useCollectRemark", "CountReg", "getRemarkFilter", "if", "collectRemarks", "RC"]}]}
{"pr_number": 68827, "url": "https://github.com/llvm/llvm-project/pull/68827", "title": "[mlir][sparse] introduce sparse_tensor.reorder_coo operation", "body": "", "feature_layers": ["parse", "ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/IR/SparseTensorDialect.cpp", "functions": ["getImpl", "getInputCoo", "success"]}]}
{"pr_number": 68586, "url": "https://github.com/llvm/llvm-project/pull/68586", "title": "[mlir][ArmSVE] Add convert_to/from_svbool ops", "body": "This adds slightly higher-level ops for converting masks between svbool\r\nand SVE predicate types. The main reason to use these over the\r\nintrinsics is these ops support vectors of masks (via unrolling).\r\n\r\nE.g.\r\n\r\n```\r\n// Convert a svbool mask to a mask of SVE predicates:\r\n%svbool = vector.load %memref[%c0, %c0]\r\n                       : memref<2x?xi1>, vector<2x[16]xi1>\r\n%mask = arm_sve.convert_from_svbool %svbool : vector<2x[8]xi1>\r\n// => Results in vector<2x[8]xi1>\r\n```\r\nOr:\r\n```\r\n// Convert a mask of SVE predicates to a svbool mask:\r\n%mask = vector.create_mask %c2, %dim_size : vector<2x[2]xi1>\r\n%svbool = arm_sve.convert_to_svbool %mask : vector<2x[2]xi1>\r\n// => Results in vector<2x[16]xi1>\r\n```\r\n\r\nDepends on #68418", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/ArmSVE/Transforms/LegalizeForLLVMExport.cpp", "functions": ["success", "tileShape"]}]}
{"pr_number": 66516, "url": "https://github.com/llvm/llvm-project/pull/66516", "title": "[flang] Add comdats to functions with linkonce linkage", "body": "This fixes a bug where functions generated by the MLIR Math dialect, for\nexample ipowi, would fail to link with link.exe on Windows due to having\nlinkonce linkage but no associated comdat. Adding the comdat on ELF also\nallows linkers to perform better garbage collection in the binary.\n\nSimply adding comdats to all functions with this linkage type should\nalso cover future cases where linkonce or linkonce_odr functions might\nbe necessary.\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Optimizer/CodeGen/CodeGen.cpp", "functions": ["signalPassFailure", "comdatPM"]}]}
{"pr_number": 65270, "url": "https://github.com/llvm/llvm-project/pull/65270", "title": "[mlir] Add pass to add comdat to all linkonce functions", "body": "This adds a new pass to add an Any comdat to each linkonce\r\nand linkonce_odr function in the LLVM dialect. These comdats are necessary on Windows\r\nto allow the default system linker to link binaries containing these functions.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/LLVMIR/Transforms/AddComdats.cpp", "functions": ["runOnOperation", "guard"]}]}
{"pr_number": 68737, "url": "https://github.com/llvm/llvm-project/pull/68737", "title": "[libc++][mdspan] Fix extents CTAD", "body": "extents CTAD was requiring default constructibility of the extent arguments due to the way we implemented a pack expansion. This requirement is not in the standard.\r\n\r\nReported in issue #68671 https://github.com/llvm/llvm-project/issues/68671 by @hewillk.\r\n\r\nFixes #68671", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "libcxx/test/std/containers/views/mdspan/extents/ctad.pass.cpp", "functions": ["NoDefaultCtorIndex", "size_t"]}]}
{"pr_number": 67846, "url": "https://github.com/llvm/llvm-project/pull/67846", "title": "[SystemZ][z/OS] Add UtcClock extension to chrono.h/.cpp", "body": "This PR adds handling for UtcClock to chrono.h/.cpp.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Support/Chrono.cpp", "functions": ["getStructTMUtc"]}, {"filename": "llvm/unittests/Support/UTFTimeTest.cpp", "functions": ["T", "formatv"]}]}
{"pr_number": 68928, "url": "https://github.com/llvm/llvm-project/pull/68928", "title": "[libc++] Check formatting with clang-format 17", "body": "This updates the clang-format we use in libc++ to 17. This is necessary to start running the generated-files checks in GitHub Actions (in #68920). In fact this is a pre-existing issue regardless of #68920 -- right now our ignore_format.txt job disagrees with the LLVM-wide clang-format job.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "libcxx/test/std/strings/basic.string/string.cons/implicit_deduction_guides.pass.cpp", "functions": ["s", "sv", "s0", "win", "w0", "sin", "w"]}]}
{"pr_number": 68916, "url": "https://github.com/llvm/llvm-project/pull/68916", "title": "[mlir][sparse] implement sparse_tensor.reorder_coo", "body": "As a side effect of the change, it also unifies the convertOp implementation between lib/codegen path.", "feature_layers": ["parse", "codegen", "ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/IR/SparseTensorDialect.cpp", "functions": ["isUniqueCOOType"]}, {"filename": "mlir/lib/Dialect/SparseTensor/Transforms/SparseTensorCodegen.cpp", "functions": ["failure"]}, {"filename": "mlir/lib/Dialect/SparseTensor/Transforms/SparseTensorConversion.cpp", "functions": ["canUseDirectConversion", "createFuncCall"]}, {"filename": "mlir/lib/Dialect/SparseTensor/Transforms/SparseTensorRewriting.cpp", "functions": ["failure"]}]}
{"pr_number": 68935, "url": "https://github.com/llvm/llvm-project/pull/68935", "title": "[mlir][sparse] refactor dense2sparse and const2sparse conversion", "body": "The new code uses the MapRef data structure, which prepares our move to non-permutation types, such as block-sparsity", "feature_layers": ["parse", "ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/Transforms/SparseTensorConversion.cpp", "functions": ["getDimToLvl"]}, {"filename": "mlir/lib/ExecutionEngine/SparseTensorRuntime.cpp", "functions": ["lvlCoords", "endLexInsert", "endInsert", "endForwardingInsert"]}]}
{"pr_number": 68943, "url": "https://github.com/llvm/llvm-project/pull/68943", "title": "[mlir][sparse] remove dead code from utils", "body": "", "feature_layers": ["parse", "ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/Transforms/SparseTensorConversion.cpp", "functions": ["getDimToLvl"]}]}
{"pr_number": 68899, "url": "https://github.com/llvm/llvm-project/pull/68899", "title": "[mlir][affine] ValueBoundsConstraintSet: Fully compose affine.apply", "body": "Fully compose `affine.apply` ops before adding them to the underlying `FlatLinearConstraints`. This works around a limitation of `FlatLinearConstraints`, which cannot deduce a constant bound if it involves two identical local variables.\r\n\r\nDetails for future improvements of `FlatLinearConstraints`: The constraint set infrastructure fails to compute a constant bound of -8 for the first variable.\r\n```\r\nDomain: 0, Range: 1, Symbols: 4, Locals: 2\r\n8 constraints\r\n(None    None    None    None    None    Local    Local    const)\r\n 1    -1    0    0    0    0    0    0    = 0\r\n 0    1    -1    1    0    0    0    0    = 0\r\n 0    0    1    0    0    0    -16    0    = 0\r\n 0    0    0    1    0    -16    0    -8    = 0\r\n 0    0    0    0    -1    0    32    31    >= 0\r\n 0    0    0    0    1    0    -32    0    >= 0\r\n 0    0    0    0    -1    32    0    31    >= 0\r\n 0    0    0    0    1    -32    0    0    >= 0\r\n```", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Affine/IR/ValueBoundsOpInterfaceImpl.cpp", "functions": ["failure", "b"]}]}
{"pr_number": 68939, "url": "https://github.com/llvm/llvm-project/pull/68939", "title": "[mlir][sparse] add a forwarding insertion to SparseTensorStorage", "body": "", "feature_layers": ["parse", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/Transforms/SparseTensorConversion.cpp", "functions": ["success", "canUseDirectConversion", "3d8f29859dbb", "getDimToLvl", "params", "createFuncCall"]}, {"filename": "mlir/lib/ExecutionEngine/SparseTensorRuntime.cpp", "functions": ["lvlCoords", "endLexInsert", "endInsert", "endForwardingInsert"]}]}
{"pr_number": 68951, "url": "https://github.com/llvm/llvm-project/pull/68951", "title": "[mlir][sparse] remove unused sparse tensor iterator", "body": "", "feature_layers": ["parse", "ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/ExecutionEngine/SparseTensorRuntime.cpp", "functions": ["SparseTensorIterator", "coo"]}]}
{"pr_number": 68275, "url": "https://github.com/llvm/llvm-project/pull/68275", "title": "[CodeLayout] Faster basic block reordering, ext-tsp", "body": "Aggressive inlining might produce huge functions with >10K of basic \r\nblocks. Since BFI treats _all_ blocks and jumps as \"hot\" having \r\nnon-negative (but perhaps small) weight, the current implementation can\r\nbe slow, taking minutes to produce an layout. This change introduces a\r\nfew modifications that significantly (up to 50x on some instances) \r\nspeeds up the computation. Some notable changes:\r\n- reduced the maximum chain size to 512 (from the prior 4096);\r\n- introeuced MaxMergeDensityRatio param to avoid merging chains with\r\nvery differen densities;\r\n- dropped a couple of params that seem unnecessary.\r\n\r\nLooking at some \"offline\" metrics (e.g., the number of created \r\nfall-throughs), there shouldn't be problems; in fact, I do see some\r\nmetrics go up. But it might be hard/impossible to measure perf \r\ndifference for such small changes. I did test the performance clang-14 \r\nbinary and do not record a perf or i-cache-related differences.\r\n\r\nMy 5 benchmarks, with ext-tsp runtime (the lower the better) and \r\n\"tsp-score\" (the higher the better).\r\n**Before**:\r\n\r\n- benchmark 1:\r\n  reordering running time is 2486 milliseconds\r\n  score: 125503458 (128.3102%)\r\n- benchmark 2:\r\n  reordering running time is 3443 milliseconds\r\n  score: 12613997277 (129.7495%)\r\n- benchmark 2:\r\n  reordering running time is 1978 milliseconds\r\n  score: 1315881613 (105.8991%)\r\n- benchmark 4:\r\n  reordering running time is 7364 milliseconds\r\n  score: 89513906284 (100.3413%)\r\n- benchmark 5:\r\n  reordering running time is 372605 milliseconds\r\n  score: 21292505965077 (99.9979%)\r\n\r\n**After**:\r\n- benchmark 1:\r\n  reordering running time is 2498 milliseconds\r\n  score: 125510418 (128.3173%)\r\n\r\n- benchmark 2:\r\n  reordering running time is 3201 milliseconds\r\n  score: 12614502162 (129.7547%)\r\n\r\n- benchmark 3:\r\n  reordering running time is 2137 milliseconds\r\n  score: 1315938168 (105.9036%)\r\n\r\n- benchmark 4:\r\n  reordering running time is 6242 milliseconds\r\n  score: 89518095837 (100.3460%)\r\n\r\n- benchmark 5:\r\n  reordering running time is 5819 milliseconds\r\n  score: 21292295939119 (99.9969%)\r\n", "feature_layers": ["runtime", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Utils/CodeLayout.cpp", "functions": ["isSuccessor", "Index", "NodeT", "Jumps", "append", "MergedChain", "MergedJumps", "MergeGainT", "empty"]}]}
{"pr_number": 68869, "url": "https://github.com/llvm/llvm-project/pull/68869", "title": "[flang][runtime] Fix IsContiguous for zero and one element arrays", "body": "The byte strides in zero and one element array descriptor may not be perfect multiple of the element size and previous and extents.\r\n\r\nIsContiguous and its CFI equivalent should still return true for such arrays (Fortran 2018 standards says in 8.5.7 that an array is not contiguous if it has two or more elements and ....).", "feature_layers": ["runtime"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/unittests/Evaluate/ISO-Fortran-binding.cpp", "functions": ["run_CFI_is_contiguous_tests"]}]}
{"pr_number": 68740, "url": "https://github.com/llvm/llvm-project/pull/68740", "title": "[AMDGPU] Change the representation of double literals in operands", "body": "A 64-bit literal can be used as a 32-bit zero or sign extended operand. In case of double zeroes are added to the low 32 bits. Currently asm parser stores only high 32 bits of a double into an operand. To support codegen as requested by the https://github.com/llvm/llvm-project/issues/67781 we need to change the representation to store a full 64-bit value so that codegen can simply add immediates to an instruction.\r\n\r\nThere is some code to support compatibility with existing tests and asm kernels. We allow to use short hex strings to represent only a high 32 bit of a double value as a valid literal.", "feature_layers": ["parse", "codegen", "parser"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/Disassembler/AMDGPUDisassembler.cpp", "functions": ["decodeLiteralConstant", "decodeNonVGPRSrcOp"]}, {"filename": "llvm/lib/Target/AMDGPU/MCTargetDesc/AMDGPUInstPrinter.cpp", "functions": ["if", "formatHex"]}, {"filename": "llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.cpp", "functions": ["isValid32BitLiteral"]}]}
{"pr_number": 67560, "url": "https://github.com/llvm/llvm-project/pull/67560", "title": "[mlir][transform] Fix handling of transitive include in interpreter.", "body": "This is a new attempt at fixing transitive includes in the transform dialect interpreter (next to #67241) and a preparation for being able to load multiple transform library files (#67120).\r\n\r\nUntil now, the interpreter would only load those symbols from the provided library files that were declared in the main transform module. However, sequences in the library may include other sequences on their own. Until now, if such sequences were not *also* declared in the main transform module, the interpreter would fail to resolve them. Forward declaring all of them is undesirable as it defeats the purpose of encapsulation into library modules.\r\n\r\nThis PR implements a kind of linker for transform scripts to solve this problem. The linker merges all symbols of the library module into the main module before interpreting the latter. Symbols whose names collide are handled as follows: (1) if they are both functions (in the sense of `FunctionOpInterface`) with compatible signatures, one is external, and the other one is public, then they are merged; (2) of one of them is private, that one is renamed; and (3) an error is raised otherwise.\r\n\r\nTODO:\r\n- [x] Enable running interpreter several times (see discussion below).\r\n- [x] Fix several smaller issues marked with `XXX`.\r\n- [x] Fix reproducer: since injection of the library is now not idempotent anymore, we should not print the filename argument in the repro call.\r\n- [x] Revise CLI and function parameter documentation and description.", "feature_layers": ["ir"], "feature_directives": ["for", "declare"], "files_changed": [{"filename": "mlir/lib/Dialect/Transform/Transforms/TransformInterpreterPassBase.cpp", "functions": ["mergeInto", "canMergeInto"]}, {"filename": "mlir/lib/IR/SymbolTable.cpp", "functions": ["failure", "renameToUnique"]}]}
{"pr_number": 68708, "url": "https://github.com/llvm/llvm-project/pull/68708", "title": "[mlir][linalg] Add NHWC + FHWC Img2Col", "body": "Adds the Img2Col transformation for the fhwc channel ordering in a Conv2D. Because of how the channel ordering affects the matrix dimensions in the flattened filter this results in a slightly different implementation of the actual \"matrix multiplication\". Instead of doing a regular row-column dot-product this arrangement requires a row-row dot product, otherwise the filter matrix would first need to be transposed.\r\n\r\nAdds a lit test to the transform dialect to check the semantics of the optimization are correct.", "feature_layers": ["sema", "ir"], "feature_directives": ["for", "requires"], "files_changed": [{"filename": "mlir/lib/Dialect/Linalg/TransformOps/LinalgTransformOps.cpp", "functions": ["rewriteInIm2Col"]}, {"filename": "mlir/lib/Dialect/Linalg/Transforms/ConvertConv2DToImg2Col.cpp", "functions": ["failure", "success", "img2colIterators"]}]}
{"pr_number": 68880, "url": "https://github.com/llvm/llvm-project/pull/68880", "title": "[mlir][ODS] Omit printing default-valued attributes in oilists", "body": "This makes these match the behaviour of optional attributes (which are omitted when they are their default value of none). This allows for concise assembly formats without a custom printer.\r\n\r\nAn extra print of \" \" is also removed, this does change any existing uses of oilists, but if the parameter before the oilist is optional, that would previously add an extra space.\r\n\r\nThis #68694 + some fixes for the MLIR Python tests, unfortunately GitHub does not allow re-opening PRs :confused: ", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/tools/mlir-tblgen/OpFormatGen.cpp", "functions": ["tgfmt"]}]}
{"pr_number": 68963, "url": "https://github.com/llvm/llvm-project/pull/68963", "title": "Revert \"[Sema] Add check for bitfield assignments to integral types\"", "body": "This reverts commit 47e36266e93de9c34ba3028951a58124864bb2b4.\r\n\r\nThis change broke some arm8/arm7 build bots because int and void * have the same size.", "feature_layers": ["sema"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/SemaCXX/bitfield-width.c", "functions": ["foo5", "foo6", "foo2", "foo1", "foo8", "foo3", "fee", "foo7"]}]}
{"pr_number": 68900, "url": "https://github.com/llvm/llvm-project/pull/68900", "title": "[mlir][arith] Fix canon pattern for large ints in chained arith", "body": "The logic for chained basic arithmetic operations in the `arith` dialect was using `getInt()` on `IntegerAttr`. This is a problem for very large integers. Specifically, in https://github.com/llvm/llvm-project/issues/64774 the following assertion failed:\r\n\r\n```\r\nAssertion failed: (getSignificantBits() <= 64 && \"Too many bits for int64_t\"), function getSExtValue, file APInt.h, line 1510.\r\n```\r\n\r\nAccording to a comment on `getInt()`, calls to `getInt()` should be replaced by `getValue()`:\r\n\r\nhttps://github.com/llvm/llvm-project/blob/ab6a66dbec61654d0962f6abf6d6c5b776937584/mlir/include/mlir/IR/BuiltinAttributes.td#L707-L708\r\n\r\nThis patch fixes https://github.com/llvm/llvm-project/issues/64774 by doing such a replacement.\r\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Arith/IR/ArithOps.cpp", "functions": ["applyToIntegerAttrs"]}]}
{"pr_number": 68787, "url": "https://github.com/llvm/llvm-project/pull/68787", "title": "[LoongArch] Support finer-grained DBAR hints for LA664+", "body": "These are treated as DBAR 0 on older uarchs, so we can start to unconditionally emit the new hints right away.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp", "functions": ["lowerATOMIC_FENCE", "DL"]}]}
{"pr_number": 67673, "url": "https://github.com/llvm/llvm-project/pull/67673", "title": "Diagnose problematic uses of constructor/destructor attribute", "body": "Functions with these attributes will be automatically called before main() or after main() exits gracefully. In glibc environments, the constructor function is passed the same arguments as main(), so that signature is allowed. In all other environments, we require the function to accept no arguments and either return `void` or `int`. The functions must use the C calling convention. In C++ language modes, the functions cannot be a nonstatic member function, or a consteval function.\r\n\r\nAdditionally, these reuse the same priority logic as the init_priority attribute which explicitly reserved priorty values <= 100 or > 65535. So we now diagnose use of reserved priorities the same as we do for the init_priority attribute, but we downgrade the error to be a warning which defaults to an error to ease use for implementers like compiler-rt or libc.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Sema/SemaDeclAttr.cpp", "functions": ["if"]}, {"filename": "clang/test/CodeGen/PowerPC/aix-destructor-attribute.c", "functions": ["bar3", "bar"]}, {"filename": "clang/test/CodeGenCXX/aix-destructor-attribute.cpp", "functions": ["bar3", "bar"]}, {"filename": "clang/test/Sema/constructor-attribute-diag-group.c", "functions": ["f"]}, {"filename": "clang/test/Sema/constructor-attribute.c", "functions": ["i1", "nonmem2", "knr2", "nonmem4", "nonmem6", "i3", "mem2", "f", "g0", "nonmem1", "h0", "consteval_func1", "knr", "_BitInt", "consteval_func2", "mem1", "j1", "i4", "__attribute__", "g1", "nonmem5", "j3", "h2", "g2", "knr1", "h1", "i2", "j2", "j4"]}]}
{"pr_number": 68718, "url": "https://github.com/llvm/llvm-project/pull/68718", "title": "[mlir][Tosa] fix fp16/bf16 support for AvgPool2d", "body": "Currently, the AvgPool2d operation in the TOSA MLIR dialect does not accept half-precision Fp16 and Bf16 tensors, conversely to what stated in the [TOSA specification](https://www.mlplatform.org/tosa/tosa_spec.html#_avg_pool2d).\r\nThis issue was previously raised: #63424 here on Github and it is due to a bug in the AvgPool2d verifier.\r\n\r\nThis patch fixes the AvgPool2d verifier to accept fp16 & bf16 datatype for input/output tensors and accumulator, and it adds related LIT test cases in Tosa/ops.mlir.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Tosa/IR/TosaOps.cpp", "functions": ["emitOpError", "success"]}]}
{"pr_number": 68807, "url": "https://github.com/llvm/llvm-project/pull/68807", "title": "Lower std::string's alignment requirement from 16 to 8.", "body": "This allows smaller allocations to occur, closer to the actual std::string's required size. This is particularly effective in decreasing the allocation size upon initial construction (where __recommend is called to determine the size).\r\n\r\nAlthough the memory savings per-string are never more than 8 bytes per string initially, this quickly adds up. And has lead to not insigficant memory savings at Google.\r\n\r\nUnfortunately, this change is ABI breaking because it changes the value returned by max_size. So it has to be guarded.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "libcxx/test/libcxx/strings/basic.string/string.capacity/allocation_size.pass.cpp", "functions": ["test_string", "main"]}]}
{"pr_number": 68755, "url": "https://github.com/llvm/llvm-project/pull/68755", "title": "[lldb] Fix `po` alias by printing fix-its to the console.", "body": "The `po` alias now matches the behavior of the `expression` command when the it can apply a Fix-It to an expression.\r\nModifications\r\n\r\n- Add has `m_fixed_expression` to the `CommandObjectDWIMPrint` class a `protected` member that stores the post Fix-It expression, just like the `CommandObjectExpression` class.\r\n- Converted messages to present tense.\r\n- Add test cases that confirms a Fix-It for a C++ expression for both `po` and `expressions`\r\n\r\nrdar://115317419", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "lldb/test/API/lang/cpp/fixits/main.cpp", "functions": ["main"]}]}
{"pr_number": 67758, "url": "https://github.com/llvm/llvm-project/pull/67758", "title": "[InstCombine][ValueTracking] Improve logic for shift flags.", "body": "- [ValueTracking] Do more thorough non-zero check in `isKnownToBePowerOfTwo` when `OrZero` is no set.\n- [InstCombine] Tests for adding flags to shifts; NFC\n- [InstCombine] Improve logic for adding flags to shift instructions.\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Analysis/ValueTracking.cpp", "functions": ["isKnownToBeAPowerOfTwo"]}, {"filename": "llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp", "functions": ["setShiftFlags"]}]}
{"pr_number": 68837, "url": "https://github.com/llvm/llvm-project/pull/68837", "title": "[libc++] Introduce make_test_jthread for jthread tests", "body": "This patch introduces the support::make_test_jthread utility which is basically the same as support::make_test_thread but for std::jthread. It allows vendors to maintain a downstream way to create threads for use within the test suite, which is especially useful for embedded platforms.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "libcxx/test/std/thread/thread.jthread/assign.move.pass.cpp", "functions": ["j1", "j2", "j"]}, {"filename": "libcxx/test/std/thread/thread.jthread/dtor.pass.cpp", "functions": ["jt"]}, {"filename": "libcxx/test/std/thread/thread.jthread/swap.free.pass.cpp", "functions": ["t1"]}, {"filename": "libcxx/test/std/thread/thread.jthread/swap.member.pass.cpp", "functions": ["t1"]}]}
{"pr_number": 68907, "url": "https://github.com/llvm/llvm-project/pull/68907", "title": "[lldb][DataFormatter] VectorType: fix format for arrays with size not a power-of-2", "body": "To get the number of children for a VectorType (i.e.,\r\na type declared with a `vector_size`/`ext_vector_type` attribute)\r\nLLDB previously did following calculation:\r\n1. Get byte-size of the vector container from Clang (`getTypeInfo`).\r\n2. Get byte-size of the element type we want to interpret the array as.\r\n   (e.g., sometimes we want to interpret an `unsigned char vec[16]`\r\n   as a `float32[]`).\r\n3. `numChildren = containerSize / reinterpretedElementSize`\r\n\r\nHowever, for step 1, clang will return us the *aligned* container byte-size.\r\nSo for a type such as `float __attribute__((ext_vector_type(3)))`\r\n(which is an array of 3 4-byte floats), clang will round up the\r\nbyte-width of the array to `16`.\r\n(see [here](https://github.com/llvm/llvm-project/blob/ab6a66dbec61654d0962f6abf6d6c5b776937584/clang/lib/AST/ASTContext.cpp#L1987-L1992))\r\n\r\nThis means that for vectors where the size isn't a power-of-2, LLDB\r\nwill miscalculate the number of elements.\r\n\r\n**Solution**\r\n\r\nThis patch changes step 1 such that we calculate the container size\r\nas `numElementsInSource * byteSizeOfElement`.", "feature_layers": ["ast"], "feature_directives": ["for", "declare"], "files_changed": [{"filename": "lldb/test/API/functionalities/data-formatter/vector-types/main.cpp", "functions": ["__attribute__"]}]}
{"pr_number": 68941, "url": "https://github.com/llvm/llvm-project/pull/68941", "title": "Reland \"[mlir][arith] Canonicalization patterns for `arith.select` (#67809)\"", "body": "This cherry-picks the changes in\r\nllvm-project/5bf701a6687a46fd898621f5077959ff202d716b and extends the pattern to handle vector types.\r\n\r\nTo reuse `getBoolAttribute` method, it moves the static method above the include of generated file.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Arith/IR/ArithOps.cpp", "functions": ["getBoolAttribute"]}]}
{"pr_number": 68650, "url": "https://github.com/llvm/llvm-project/pull/68650", "title": "[scudo] Add specific die functions for linux specific failures.", "body": "While running into failures on unmap calls, it becomes difficult to figure out what's wrong. Break the dieOnMapUnmapError into specific versions for map, unmap, and then one for mprotect.\r\n\r\nAlso, put these in a common linux space so that all linux derived code can reuse this code.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "compiler-rt/lib/scudo/standalone/common.cpp", "functions": ["dieOnMapUnmapError"]}, {"filename": "compiler-rt/lib/scudo/standalone/linux.cpp", "functions": ["die"]}, {"filename": "compiler-rt/lib/scudo/standalone/linux_common.cpp", "functions": ["die", "dieOnProtectError", "dieOnUnmapError", "dieOnMapError"]}, {"filename": "compiler-rt/lib/scudo/standalone/trusty.cpp", "functions": ["die"]}, {"filename": "compiler-rt/lib/scudo/standalone/report.cpp", "functions": ["reportRawError"]}, {"filename": "compiler-rt/lib/scudo/standalone/report_linux.cpp", "functions": ["reportProtectError", "reportUnmapError", "dieOnProtectError", "reportMapError", "die", "dieOnMapError", "dieOnUnmapError"]}]}
{"pr_number": 67695, "url": "https://github.com/llvm/llvm-project/pull/67695", "title": "[Profile] Use upper 32 bits of profile version for profile variants.", "body": "Currently all upper 8 bits are reserved for different profile variants. We need more bits for new mods in the future. \r\nContext: https://discourse.llvm.org/t/how-to-add-a-new-mode-to-llvm-raw-profile-version/73688", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "compiler-rt/include/profile/InstrProfData.inc", "functions": ["bits"]}, {"filename": "llvm/include/llvm/ProfileData/InstrProfData.inc", "functions": ["bits"]}]}
{"pr_number": 68470, "url": "https://github.com/llvm/llvm-project/pull/68470", "title": "[RISCV][GISel] Add isel patterns for ADDIW/SRLIW/SRAIW/SLLIW and remove custom selection.", "body": "I had trouble getting patterns working previously because GISel was using an i32 immediate, but the instructions expected an i64 immediate because SelectionDAG doesn't have i32 as a legal type yet.\r\n\r\nAfter looking at other targets like AMDGPU, I discovered that I could use a SDNodeXForm and a cast to get the type checking in tablegen to allow me to do it.", "feature_layers": ["ast"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp", "functions": ["constrainSelectedInstRegOperands"]}]}
{"pr_number": 68660, "url": "https://github.com/llvm/llvm-project/pull/68660", "title": "[PowerPC][JITLink] Support R_PPC64_GOT_TLSGD_PCREL34", "body": "`R_PPC64_GOT_TLSGD_PCREL34` is generated for pwr10+.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "compiler-rt/test/orc/TestCases/Linux/ppc64/trivial-tls-pwr10.cpp", "functions": ["CPUModelIsPOWER10", "main", "__attribute__", "Test", "cpuinfo", "TestPOWER10"]}, {"filename": "compiler-rt/test/orc/TestCases/Linux/ppc64/Inputs/trivial-tls-main.cpp", "functions": ["TestPOWER10", "__attribute__", "Test"]}, {"filename": "compiler-rt/test/orc/TestCases/Linux/ppc64/Inputs/trivial-tls-pwr10.cpp", "functions": ["__attribute__"]}]}
{"pr_number": 69045, "url": "https://github.com/llvm/llvm-project/pull/69045", "title": "[clang-tidy] Ignore unused parameters in `rvalue-reference-param-not-moved check`", "body": "With this patch we no longer issue a warning for unused parameters which are marked as such.\r\n\r\nThis fixes #68209", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang-tools-extra/test/clang-tidy/checkers/cppcoreguidelines/rvalue-reference-param-not-moved.cpp", "functions": ["f7", "f3", "f5", "f8", "f1", "f6", "f4", "f2"]}]}
{"pr_number": 68507, "url": "https://github.com/llvm/llvm-project/pull/68507", "title": "[clang][driver] Add avr-libc's default linker script to lld", "body": "If `-fuse-ld=lld` is specified but no user linker script is offered, we try to use avr-libc's default one for lld. (not needed for GNU ld)", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Driver/ToolChains/AVR.cpp", "functions": ["Path"]}]}
{"pr_number": 68786, "url": "https://github.com/llvm/llvm-project/pull/68786", "title": "[MachineBasicBlock] Fix use after free in SplitCriticalEdge", "body": "Remove use after free when attempting to update SlotIndexes in MachineBasicBlock::SplitCriticalEdge.\r\n\r\nAdd delegate mechanism for MachineBasicBlock to observe instructions added or removed when calling target specific functions for updating branches and update SlotIndexes appropriately.", "feature_layers": [], "feature_directives": ["for", "critical", "target"], "files_changed": [{"filename": "llvm/lib/CodeGen/MachineBasicBlock.cpp", "functions": ["MF", "SlotUpdater"]}]}
{"pr_number": 69093, "url": "https://github.com/llvm/llvm-project/pull/69093", "title": "Added keyword #undef to llvm-tblgen and fixed a small bug for llvm-tb\u2026", "body": "### Motivation introduction\r\n\r\nI want a td file to contain part of other td files instead of the entire file, so when using macros to implement it, I found that llvm-tblgen provides #define, #ifdef, #ifndef, #endif but does not provide #undef, so this PR The main purpose is to provide #undef support in llvm-tblgen, and when I was debugging, I found that if a td file ends with #endif, a td syntax error will occur, so I added a line to correct this bug. If there are any deficiencies, please point out\r\n\r\n### bug in llvm-tblgen\r\n\r\nIf you remove a lot of spaces in the last line of the test file for testing the llvm-tblgen macro, you will find that a compilation error will occur.\r\nex: llvm/test/TableGen/prep-ifndef.td\r\n```\r\n// RUN: llvm-tblgen %s -DMACRO | FileCheck %s\r\n// RUN: llvm-tblgen %s | FileCheck %s --check-prefix=CHECK-NOMACRO\r\n\r\n#ifndef MACRO\r\n// CHECK-NOMACRO: def nomacro\r\ndef nomacro;\r\n#else\r\n// CHECK: def macro\r\ndef macro;\r\n#endif\r\n\r\n```\r\n", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/TableGen/TGLexer.cpp", "functions": ["LexToken", "Lex", "LexVarName", "LexBracket", "Str", "LexString", "ReturnError", "LexExclaim"]}]}
{"pr_number": 68500, "url": "https://github.com/llvm/llvm-project/pull/68500", "title": "[mlir][vector] Enable transfer op hoisting with dynamic indices", "body": "Recent changes (https://github.com/llvm/llvm-project/pull/66930) disabled vector transfer ops hoisting with view-like intermediate ops. The recommended way is to fold subview ops into transfer op indices before invoking hoisting. That would mean now we see transfer op indices involving dynamic values, instead of static constant values before with subview ops. Therefore hoisting won't kick in anymore. This breaks downstream users.\r\n\r\nTo fix it, this commit enables hoisting transfer ops with dynamic indices by using `ValueBoundsConstraintSet` to prove ranges are disjoint in `isDisjointTransferIndices`. Given that utility is used in many places including op folders, right now we introduce a flag to it and only set as true for \"heavy\" transforms in hoisting and load-store forwarding.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Vector/IR/VectorOps.cpp", "functions": ["isDisjointTransferIndices"]}, {"filename": "mlir/lib/Dialect/Affine/IR/ValueBoundsOpInterfaceImpl.cpp", "functions": ["failure"]}]}
{"pr_number": 67305, "url": "https://github.com/llvm/llvm-project/pull/67305", "title": "[mlir][Interfaces] `LoopLikeOpInterface`: Add helper to get yielded values", "body": "Add a new interface method that returns the yielded values.\r\n    \r\nAlso add a verifier that checks the number of inits/iter_args/yielded values. Most of the checked invariants (but not all of them) are already covered by the `RegionBranchOpInterface`, but the `LoopLikeOpInterface` now provides (additional) error messages that are easier to read.\r\n\r\n", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "flang/lib/Optimizer/Dialect/FIROps.cpp", "functions": ["getFinalValue"]}, {"filename": "mlir/lib/Interfaces/LoopLikeInterface.cpp", "functions": ["success"]}, {"filename": "mlir/test/lib/Dialect/SCF/TestSCFUtils.cpp", "functions": ["oldYieldValues"]}]}
{"pr_number": 68944, "url": "https://github.com/llvm/llvm-project/pull/68944", "title": "[X86] Add USER_MSR instructions.", "body": "For more details about this instruction, please refer to the latest ISE document: https://www.intel.com/content/www/us/en/develop/download/intel-architecture-instruction-set-extensions-programming-reference.html\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CodeGen/X86/usermsr-builtins-error-32.c", "functions": ["_urdmsr", "test_uwrmsr", "test_urdmsr"]}, {"filename": "clang/test/CodeGen/X86/usermsr-builtins.c", "functions": ["_urdmsr", "test_uwrmsr_const", "test_uwrmsr", "test_urdmsr_const", "test_urdmsr"]}, {"filename": "llvm/lib/Target/X86/Disassembler/X86Disassembler.cpp", "functions": ["consume"]}]}
{"pr_number": 67680, "url": "https://github.com/llvm/llvm-project/pull/67680", "title": "[clang][ASTImporter] Fix of possible crash \"Did not find base!\".", "body": "A problem with AST import could lead to multiple instances of the same template class specialization, with different template arguments. The difference was caused by pointers to different declarations of the same function.\r\nProblem is fixed by using the canonical declaration at import.", "feature_layers": ["ast"], "feature_directives": [], "files_changed": [{"filename": "clang/lib/AST/ASTImporter.cpp", "functions": ["TemplateArgument"]}, {"filename": "clang/unittests/AST/ASTImporterTest.cpp", "functions": ["f1", "A"]}]}
{"pr_number": 68691, "url": "https://github.com/llvm/llvm-project/pull/68691", "title": "[analyzer] Fix note for member reference", "body": "In the following code:\r\n```cpp\r\nint main() {\r\n    struct Wrapper {char c; int &ref; };\r\n    Wrapper w = {.c = 'a', .ref = *(int *)0 };\r\n    w.ref = 1;\r\n}\r\n```\r\n\r\nThe clang static analyzer will produce the following warnings and notes:\r\n```\r\ntest.cpp:12:11: warning: Dereference of null pointer [core.NullDereference]\r\n   12 |     w.ref = 1;\r\n      |     ~~~~~~^~~\r\ntest.cpp:11:5: note: 'w' initialized here\r\n   11 |     Wrapper w = {.c = 'a', .ref = *(int *)0 };\r\n      |     ^~~~~~~~~\r\ntest.cpp:12:11: note: Dereference of null pointer\r\n   12 |     w.ref = 1;\r\n      |     ~~~~~~^~~\r\n1 warning generated.\r\n```\r\nIn the line where `w` is created, the note gives information about the initialization of `w` instead of `w.ref`. Let's compare it to a similar case where a null pointer dereference happens to a pointer member:\r\n\r\n```cpp\r\nint main() {\r\n     struct Wrapper {char c; int *ptr; };\r\n     Wrapper w = {.c = 'a', .ptr = nullptr };\r\n     *w.ptr = 1;\r\n}\r\n```\r\n\r\nHere the following error and notes are seen:\r\n```\r\ntest.cpp:18:12: warning: Dereference of null pointer (loaded from field 'ptr') [core.NullDereference]\r\n   18 |     *w.ptr = 1;\r\n      |        ~~~ ^\r\ntest.cpp:17:5: note: 'w.ptr' initialized to a null pointer value\r\n   17 |     Wrapper w = {.c = 'a', .ptr = nullptr };\r\n      |     ^~~~~~~~~\r\ntest.cpp:18:12: note: Dereference of null pointer (loaded from field 'ptr')\r\n   18 |     *w.ptr = 1;\r\n      |        ~~~ ^\r\n1 warning generated.\r\n```\r\nHere the note that shows the initialization the initialization of `w.ptr` in shown instead of `w`.\r\n\r\nThis commit is here to achieve similar notes for member reference as the notes of member pointers, so the report looks like the following:\r\n\r\n```\r\ntest.cpp:12:11: warning: Dereference of null pointer [core.NullDereference]\r\n   12 |     w.ref = 1;\r\n      |     ~~~~~~^~~\r\ntest.cpp:11:5: note: 'w.ref' initialized to a null pointer value\r\n   11 |     Wrapper w = {.c = 'a', .ref = *(int *)0 };\r\n      |     ^~~~~~~~~\r\ntest.cpp:12:11: note: Dereference of null pointer\r\n   12 |     w.ref = 1;\r\n      |     ~~~~~~^~~\r\n1 warning generated.\r\n```\r\nHere the initialization of `w.ref` is shown instead of `w`.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/Analysis/diagnostics/deref-track-symbolic-region.cpp", "functions": ["testNullReferenceToPointer", "aaa"]}]}
{"pr_number": 68803, "url": "https://github.com/llvm/llvm-project/pull/68803", "title": "[ConstraintElim] Don't decompose values wider than 64 bits", "body": "Our coefficients are 64-bits, so adding/multiplying them can wrap in 64-bits even if there would be no wrapping the full bit width.\r\n\r\nThe alternative would be to check for overflows during all adds/muls in decomposition. I assume that we don't particularly care about handling wide integers here, so I've opted to bail out.\r\n\r\nFixes https://github.com/llvm/llvm-project/issues/68751.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Scalar/ConstraintElimination.cpp", "functions": ["decomposeGEP"]}]}
{"pr_number": 68836, "url": "https://github.com/llvm/llvm-project/pull/68836", "title": "[flang][openacc][NFC] Simplify lowering of recipe", "body": "Refactor some of the lowering in the reduction and firstprivate recipe to avoid duplicated code. ", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "flang/lib/Lower/OpenACC.cpp", "functions": ["areAllBoundConstant"]}]}
{"pr_number": 69068, "url": "https://github.com/llvm/llvm-project/pull/69068", "title": "[RISCV] Refactor performCONCAT_VECTORSCombine. NFC", "body": "Instead of doing a forward pass for positive strides and a reverse pass for\nnegative strides, we can just do one pass by negating the offset if the\npointers do happen to be in reverse order.\n\nWe can extend getPtrDiff later in #68726 to handle more constant offset\nsequences.\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVISelLowering.cpp", "functions": ["if", "SDValue"]}]}
{"pr_number": 69036, "url": "https://github.com/llvm/llvm-project/pull/69036", "title": "[mlir][sparse] simplify reader construction of new sparse tensor", "body": "Making the materialize-from-reader method part of the Swiss army knife suite again removes a lot of redundant boiler plate code and unifies the parameter setup into a single centralized utility. Furthermore, we now have minimized the number of entry points into the library that need a non-permutation map setup, simplifying what comes next", "feature_layers": ["parse", "ir"], "feature_directives": ["single"], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/Transforms/SparseTensorConversion.cpp", "functions": ["allocaBuffer"]}, {"filename": "mlir/lib/ExecutionEngine/SparseTensorRuntime.cpp", "functions": ["getSparseTensorReaderDimSize", "reader", "getSparseTensorReaderIsSymmetric", "getSparseTensorReaderRank", "readSparseTensorShape"]}]}
{"pr_number": 68881, "url": "https://github.com/llvm/llvm-project/pull/68881", "title": "[llvm-rc] Accept filenames provided as multiple string literals", "body": "GNU windres supports this, while MS rc.exe doesn't.\r\n\r\nMS rc.exe only supports treating consecutive string literals as if they were fused into one in a few fixed locations (most of which are already supported), while GNU windres supports this essentially anywhere in any string. See\r\nb989fcbae6f179ad887d19ceef83ace1c00b87cc for one recent change that extended support for this in one specific resource.\r\n\r\nA reasonable use case for multiple concatenated string literals that GNU windres accepts is `1 ICON DIR \"/name.ico\"`, where the directory is provided via the preprocessor, expanding to another string literal; this is https://github.com/llvm/llvm-project/issues/51286.\r\n\r\nExtend the parser to try to consume all consecutive string tokens, whenever reading a filename. Adjust the handling of user data resources read from a file to use the readFilename() helper.\r\n\r\nWhile this probably doesn't cover every single case where GNU windres might accept concatenated string literals, this is the primary missing case that has been reported so far.", "feature_layers": ["parse", "ir", "parser"], "feature_directives": ["for", "single"], "files_changed": [{"filename": "llvm/tools/llvm-rc/ResourceScriptParser.cpp", "functions": ["read"]}]}
{"pr_number": 68449, "url": "https://github.com/llvm/llvm-project/pull/68449", "title": "[libc] Add simple long double to printf float fuzz", "body": "Recent testing has uncovered some hard-to-find bugs in printf's long\ndouble support. This patch adds an extra long double path to the fuzzer\nwith minimal extra effort. While a more thorough long double fuzzer\nwould be useful, it would need to handle the non-standard cases of 80\nbit long doubles such as unnormal and pseudo-denormal numbers. For that\nreason, a standalone long double fuzzer is left for future development.\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "libc/fuzzing/stdio/printf_float_conv_fuzz.cpp", "functions": ["test_vals", "simple_strlen"]}]}
{"pr_number": 69117, "url": "https://github.com/llvm/llvm-project/pull/69117", "title": "[libc++][test] Add `stop_token` benchmark", "body": "This is transforming the `stop_token` benchmark that Lewis Baker had created into Google\nBench\nhttps://reviews.llvm.org/D154702\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "libcxx/benchmarks/stop_token.bench.cpp", "functions": ["reg_counts", "BM_stop_token_async_reg_unreg_callback", "reg_count", "operator", "BM_stop_token_single_thread_reg_unreg_callback", "cbs"]}]}
{"pr_number": 68067, "url": "https://github.com/llvm/llvm-project/pull/68067", "title": "Improve MLIR attribute get() method efficiency when complex members are involved", "body": "This ensures that the proper forward/move are involved, we go from 6 copy-constructions to 0 (!) when building without assertions.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/test/lib/Dialect/Test/TestAttributes.cpp", "functions": ["failure", "hash_value", "parse"]}, {"filename": "mlir/tools/mlir-tblgen/AttrOrTypeDefGen.cpp", "functions": ["formatv"]}, {"filename": "mlir/unittests/IR/AttributeTest.cpp", "functions": ["copyCount"]}]}
{"pr_number": 69247, "url": "https://github.com/llvm/llvm-project/pull/69247", "title": "[mlir][sparse] remove sparse2sparse path in library", "body": "This cleans up all external entry points that will  have to deal with non-permutations, making any  subsequent refactoring much more local to the lib files.", "feature_layers": ["parse", "ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/ExecutionEngine/SparseTensor/NNZ.cpp", "functions": ["lvlSizes"]}]}
{"pr_number": 66918, "url": "https://github.com/llvm/llvm-project/pull/66918", "title": "[compiler-rt] Implement __extendxftf2 and __trunctfxf2 for x86_64", "body": "This patch implements __extendxftf2 (long double -> f128) and\r\n__trunctfxf2 (f128 -> long double) on x86_64.\r\nThis is a preparation to unblock https://reviews.llvm.org/D53608,\r\nWe intentionally do not modify compiler-rt/lib/builtins/fp_lib.h in this PR\r\n(in particular, to limit the scope and avoid exposing other functions on X86_64 in this PR).\r\nInstead, TODOs were added to use fp_lib.h once it is available.\r\n\r\nTest plan:\r\n1. ninja check-compiler-rt (verified on X86_64 and on Aarch64)\r\nIn particular, new tests (extendxftf2_test.c and trunctfxf2_test.c) were added.\r\n2. compared the results of conversions with what other compilers (gcc) produce.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "compiler-rt/lib/builtins/extendxftf2.c", "functions": ["__extendXfYf2__", "__extendxftf2"]}, {"filename": "compiler-rt/lib/builtins/fp_extend_impl.inc", "functions": ["if"]}, {"filename": "compiler-rt/lib/builtins/fp_trunc_impl.inc", "functions": ["dstFromRep"]}, {"filename": "compiler-rt/lib/builtins/trunctfxf2.c", "functions": ["__truncXfYf2__", "__trunctfxf2"]}, {"filename": "compiler-rt/test/builtins/Unit/extendxftf2_test.c", "functions": ["test__extendxftf2", "main", "__extendxftf2"]}, {"filename": "compiler-rt/test/builtins/Unit/trunctfxf2_test.c", "functions": ["main", "__trunctfxf2", "test__trunctfxf2"]}]}
{"pr_number": 67608, "url": "https://github.com/llvm/llvm-project/pull/67608", "title": "[flang] Handle separate module procedures with INTERFACE dummy arguments", "body": "The code that duplicates the interface of a separate module procedure into its definition doesn't allow for a dummy procedure with an explicit INTERFACE declaration.  Extend the code to handle this case.\r\n\r\nFixes https://github.com/llvm/llvm-project/issues/66631.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Semantics/resolve-names-utils.cpp", "functions": ["CopySymbol"]}]}
{"pr_number": 67622, "url": "https://github.com/llvm/llvm-project/pull/67622", "title": "[flang] Fix construct names on labeled DO", "body": "Fortran requires that a DO construct with a construct name end with an END DO statement bearing the same name. This is true even if the DO construct begins with a label DO statement; e.g., \"constrName: do 10 j=1,10\" must end with \"10 end do constrName\".\r\n\r\nThe compiler presently basically ignores construct names that appear on label DO statements, because only non-label DO statements can be parsed as DO constructs.  This causes us to miss some errors, and (worse) breaks the usage of the construct name on CYCLE and EXIT statements.\r\n\r\nTo fix this, this patch changes the parse tree and parser so that a DO construct name on a putative label DO statement causes it to be parsed as a \"non-label\" DO statement... with a label.  Only true old-style labeled DO statements without construct names are now parsed as such.\r\n\r\nI did not change the class name NonLabelDoStmt -- it's widely used across the front-end, and is the name of a production in the standard's grammar.  But now it basically means DoConstructDoStmt.\r\n\r\nFixes https://github.com/llvm/llvm-project/issues/67283.", "feature_layers": ["parse", "ir", "parser"], "feature_directives": ["for", "requires"], "files_changed": [{"filename": "flang/lib/Semantics/resolve-labels.cpp", "functions": ["PushConstructName", "Post"]}]}
{"pr_number": 67208, "url": "https://github.com/llvm/llvm-project/pull/67208", "title": "[flang][runtime] Implement EX editing for input & output", "body": "Support the EX edit descriptor for hexadecimal real formatted output and hexadecimal real input for all forms of formatted input.. (We're possibly the first Fortran compiler to support this feature for input editing; only one other can handle EX output editing.)\r\n\r\nAs true (not BOZ) hexadecimal floating-point constants are not supported in Fortran source code, only in formatted input, the implementation takes place in the I/O editing portion of the runtime, not as new conversions in the Decimal library.", "feature_layers": ["runtime", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/runtime/edit-input.cpp", "functions": ["GetRadixPointChar", "GetDecimalPoint"]}, {"filename": "flang/runtime/edit-output.cpp", "functions": ["IsInfOrNaN", "EmitRepeated"]}]}
{"pr_number": 67361, "url": "https://github.com/llvm/llvm-project/pull/67361", "title": "[flang] Submodule names can clash only with submodule names", "body": "Name resolution creates symbols for submodules in their parents' scopes.  This can lead to bogus errors about name clashes between submodule names and other entities in the parents' scopes.\r\n\r\nCreate symbols for submodules but do not add them to a scope's dictionary.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Semantics/resolve-names.cpp", "functions": ["MakeSymbol"]}]}
{"pr_number": 68150, "url": "https://github.com/llvm/llvm-project/pull/68150", "title": "[LLDB][NFC] Create a namespace for the DWARF plugin", "body": "As a followup of https://github.com/llvm/llvm-project/pull/67851, I'm defining a new namespace `lldb_plugin::dwarf` for the classes in this Plugins/SymbolFile/DWARF folder. This change is very NFC and helped me with exporting the necessary symbols for my out-of-tree language plugin. The only class that I didn't change is ClangDWARFASTParser, because that shouldn't be in the same namespace as the generic language-agnostic dwarf parser.\r\nIt would be a good idea if other plugins follow the same namespace scheme.\r\n", "feature_layers": ["parse", "ast", "parser"], "feature_directives": ["for"], "files_changed": [{"filename": "lldb/source/Plugins/SymbolFile/DWARF/DWARFBaseDIE.cpp", "functions": ["DW_TAG_value_to_name"]}]}
{"pr_number": 69168, "url": "https://github.com/llvm/llvm-project/pull/69168", "title": "[clang][Interp] Check pointer inc/dec ops for null", "body": "", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/AST/Interp/arrays.cpp", "functions": ["nullptr1"]}]}
{"pr_number": 68923, "url": "https://github.com/llvm/llvm-project/pull/68923", "title": "[clang][dataflow] Check for backedges directly (instead of loop statements).", "body": "Widen on backedge nodes, instead of nodes with a loop statement as terminator.\nThis fixes #67834 and a precision loss from assignment in a loop condition. The\ncommit contains tests for both of these issues.\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Analysis/FlowSensitive/TypeErasedDataflowAnalysis.cpp", "functions": ["Worklist", "isBackedgeNode", "isLoopHead", "POV"]}, {"filename": "clang/unittests/Analysis/FlowSensitive/TransferTest.cpp", "functions": ["target", "foo"]}, {"filename": "clang/unittests/Analysis/FlowSensitive/TypeErasedDataflowAnalysisTest.cpp", "functions": ["target"]}]}
{"pr_number": 66642, "url": "https://github.com/llvm/llvm-project/pull/66642", "title": "[AArch64] Fix pairing different types of registers when computing CSRs.", "body": "If a function has odd number of same type of registers to save, and the calling convention also requires odd number of such type of CSRs, an FP register would be accidentally marked as saved when producePairRegisters returns true.\r\n\r\nThis patch also fixes the AArch64LowerHomogeneousPrologEpilog pass not handling AArch64::NoRegister; actually this pass must be fixed along with the register pairing so i can write a test for it.", "feature_layers": ["ir"], "feature_directives": ["for", "requires"], "files_changed": [{"filename": "llvm/lib/Target/AArch64/AArch64LowerHomogeneousPrologEpilog.cpp", "functions": ["Scale"]}]}
{"pr_number": 69164, "url": "https://github.com/llvm/llvm-project/pull/69164", "title": "[flang] Deallocate INTENT(OUT) dummy allocatable components", "body": "Non POINTER/ALLOCATABLE INTENT(OUT) dummy arguments with allocatable components were reset without a proper deallocation if needed. Add a call to Destroy runtime to deallocate the components on entry.\r\n\r\nNotes:\r\n1. The same logic is not needed on the callee side  of BIND(C) call because BIND(C) arguments cannot be derived type with allocatable components (C1806).\r\n2. When the argument is an INTENT(OUT) polymorphic, the dynamic type of the actual may contain allocatable components. This case is covered by the call to Destroy that uses dynamic type and was already inserted for INTENT(OUT) polymorphic dummies.", "feature_layers": ["runtime"], "feature_directives": ["for", "allocate"], "files_changed": [{"filename": "flang/lib/Lower/ConvertVariable.cpp", "functions": ["hasFinalization"]}]}
{"pr_number": 68952, "url": "https://github.com/llvm/llvm-project/pull/68952", "title": "[Clang][LoongArch] Support compiler options -mlsx/-mlasx for clang", "body": "This patch adds compiler options -mlsx/-mlasx which enables the instruction sets of LSX and LASX, and sets related predefined macros acording to the options.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Basic/Targets/LoongArch.cpp", "functions": ["if"]}, {"filename": "clang/lib/Driver/ToolChains/Arch/LoongArch.cpp", "functions": ["if"]}, {"filename": "clang/test/Driver/loongarch-mlasx.c", "functions": ["foo"]}, {"filename": "clang/test/Driver/loongarch-mlsx.c", "functions": ["foo"]}]}
{"pr_number": 68955, "url": "https://github.com/llvm/llvm-project/pull/68955", "title": "[Clang][LoongArch] Support the builtin functions for LSX", "body": "This patch does the following work:\r\n- Define the builtin functions for LSX\r\n- Add the header file lsxintrin.h\r\n- Add the immediate number range checking for LSX builtins", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Sema/SemaChecking.cpp", "functions": ["SemaBuiltinConstantArgRange"]}]}
{"pr_number": 68728, "url": "https://github.com/llvm/llvm-project/pull/68728", "title": "[mlir][nvgpu] Improve `WarpgroupAccumulator` type to simplify IR ", "body": "`WarpgroupAccumulator` (or `!nvgpu.warpgroup.accumulator`) is a type that keeps the accumulator matrix that is used by warp-group level matrix multiplication. It is handy to have a special type for that as the matrix is distributed among the threads of the warp-group. However, current transformations requires to create and use multiple `WarpgroupAccumulator` if the shape of GEMM is larger than the supported shape of `wgmma.mma_async` instruction. This makes IR looks dense.\r\n\r\nThis PR improves the transformation of `WarpgroupAccumulator` type in every nvgpu Op that uses it. \r\n\r\n**Example: Current GEMM in NVGPU-IR**\r\n```\r\n// Init\r\n%m1, %m2 = nvgpu.warpgroup.mma.init.accumulator ->  \r\n                    !nvgpu.warpgroup.accumulator<fragmented = vector<64x128xf32>>,\r\n                    !nvgpu.warpgroup.accumulator<fragmented = vector<64x128xf32>>\r\n\r\n// GEMM\r\n%r1, %r2 = nvgpu.warpgroup.mma %descA, %descB, %m1, %m2 {transposeB}: \r\n      !nvgpu.warpgroup.descriptor<tensor = memref<128x64xf16, 3>>, \r\n      !nvgpu.warpgroup.descriptor<tensor = memref<64x128xf16, 3>>, \r\n      !nvgpu.warpgroup.accumulator<fragmented = vector<64x128xf32>>,\r\n      !nvgpu.warpgroup.accumulator<fragmented = vector<64x128xf32>> \r\n      -> \r\n      !nvgpu.warpgroup.accumulator<fragmented = vector<64x128xf32>>,\r\n      !nvgpu.warpgroup.accumulator<fragmented = vector<64x128xf32>>  \r\n\r\n\r\n// Epilogue \r\nnvgpu.warpgroup.mma.store [%r1, %r2] to %sharedMemoryBuffer\r\n  : !nvgpu.warpgroup.accumulator<fragmented = vector<64x128xf32>>, \r\n    !nvgpu.warpgroup.accumulator<fragmented = vector<64x128xf32>>\r\n    into memref<128x128xf32,3>\r\n```\r\n\r\n**Example: This PR simplifies the IR as below:**\r\n```\r\n// Init\r\n%m = nvgpu.warpgroup.mma.init.accumulator ->  \r\n           !nvgpu.warpgroup.accumulator<fragmented = vector<128x128xf32>>\r\n\r\n// GEMM\r\n%r1 = nvgpu.warpgroup.mma %descA, %descB, %m1 {transposeB}: \r\n      !nvgpu.warpgroup.descriptor<tensor = memref<128x64xf16, 3>>, \r\n      !nvgpu.warpgroup.descriptor<tensor = memref<64x128xf16, 3>>, \r\n      !nvgpu.warpgroup.accumulator<fragmented = vector<128x128xf32>> \r\n      -> \r\n      !nvgpu.warpgroup.accumulator<fragmented = vector<128x128xf32>>  \r\n\r\n// Epilogue \r\nnvgpu.warpgroup.mma.store [%matrixD1, %matrixD2] to %sharedMemoryBuffer\r\n  : !nvgpu.warpgroup.accumulator<fragmented = vector<64x128xf32>>, \r\n    !nvgpu.warpgroup.accumulator<fragmented = vector<64x128xf32>>\r\n    into memref<128x128xf32,3>\r\n```", "feature_layers": ["ir"], "feature_directives": ["for", "distribute", "requires"], "files_changed": [{"filename": "mlir/lib/Conversion/NVGPUToNVVM/NVGPUToNVVM.cpp", "functions": ["generateWgmmaGroup", "op", "warpgroupGemm", "if", "generateWarpgroupMma", "lb", "b", "generateWgmma"]}, {"filename": "mlir/lib/Dialect/NVGPU/IR/NVGPUDialect.cpp", "functions": ["failure", "emitOpError", "success", "isAllowedSizeM"]}, {"filename": "mlir/lib/Dialect/NVGPU/TransformOps/NVGPUTransformOps.cpp", "functions": ["if"]}]}
{"pr_number": 67294, "url": "https://github.com/llvm/llvm-project/pull/67294", "title": "[libc++] Eliminate extra allocations from `std::move(oss).str()`", "body": "Add test coverage for the new behaviors, especially to verify that the returned string uses the correct allocator.\r\nFixes https://github.com/llvm/llvm-project/issues/64644\r\n\r\nMigrated from https://reviews.llvm.org/D157776 \u2014 @philnik777  @pfusik \r\n@ldionne @mordante \r\n please take another look!", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "libcxx/test/std/input.output/string.streams/istringstream/istringstream.members/str.allocator_propagation.pass.cpp", "functions": ["StringBuf", "test_allocation_is_pilfered", "main", "public_setg", "test_soccc_behavior", "ss", "test_no_foreign_allocations"]}, {"filename": "libcxx/test/std/input.output/string.streams/ostringstream/ostringstream.members/str.allocator_propagation.pass.cpp", "functions": ["test_allocation_is_pilfered", "test_no_foreign_allocations", "main", "test_soccc_behavior"]}, {"filename": "libcxx/test/std/input.output/string.streams/stringbuf/stringbuf.members/str.move.pass.cpp", "functions": ["buf", "test_altered_sequence_pointers", "public_setg"]}, {"filename": "libcxx/test/std/input.output/string.streams/stringbuf/stringbuf.members/str.pass.cpp", "functions": ["StringBuf", "public_setg", "src", "buf", "test_altered_sequence_pointers"]}, {"filename": "libcxx/test/std/input.output/string.streams/stringbuf/stringbuf.members/view.pass.cpp", "functions": ["test_altered_sequence_pointers", "public_setg"]}, {"filename": "libcxx/test/std/input.output/string.streams/stringstream/stringstream.members/str.allocator_propagation.pass.cpp", "functions": ["StringBuf", "test_allocation_is_pilfered", "main", "public_setg", "test_soccc_behavior", "ss", "test_no_foreign_allocations"]}]}
{"pr_number": 67566, "url": "https://github.com/llvm/llvm-project/pull/67566", "title": "Qualify non-dependent types of a class template with its declaration", "body": "When\r\n`clang::TypeName::getFullyQualifiedType`/`clang::TypeName::getFullyQualifiedName` encounter a non-dependent type/type alias that is defined under a templated class/struct, it qualifies the type/type alias under a specialization of the templated class, if any was declared.\r\n\r\nThat is, in:\r\n\r\n```\r\ntemplate<typename T>\r\nclass Foo {\r\n    using Bar = T;\r\n}\r\n\r\nusing Baz = Foo<int>;\r\n```\r\n\r\nUsages of `Foo::Bar` will be qualified as `Foo<int>::Bar`.\r\n\r\nWhen the `using Baz = Foo<int>;` line is removed, as there are would be no specialization encountered in the translation unit, usages of `Foo::Bar` would instead be qualified as `Foo<T>::Bar`.\r\n\r\nWhen multiple specializations are present, the one that is chosen is the first one that is encountered; due to the current implementation of the behavior and the fact that iterating the specialization of a `ClassTemplateDecl` respects the order in which the specializations were stored in.\r\n\r\nThat is, if we were to add a reference to some other specialization in the above example, so that it would be parsed before the current `using Baz = Foo<int>;`, say:\r\n\r\n```\r\ntemplate<typename T>\r\nclass Foo {\r\n    using Bar = T;\r\n}\r\n\r\nusing Bat = Foo<double>;\r\nusing Baz = Foo<int>;\r\n```\r\n\r\nThen usages of `Foo::Bar` would be qualified as `Foo<double>::Bar` instead of `Foo<int>::Bar`.\r\n\r\nShould the same declaration be added, instead, after the `using Baz = Foo<int>;` line, then the qualification would remain consistent with our previous version.\r\n\r\nTo provide a more consistent behavior, that avoids changing the output when relatively unrelated declarations are present in the translation unit,\r\n`clang::TypeName::getFullyQualifiedType`/`clang::TypeName::getFullyQualifiedName` will now qualify such types using the original templated declaration instead of one of the specializations.", "feature_layers": ["parse", "ir"], "feature_directives": ["for", "declare"], "files_changed": [{"filename": "clang/lib/AST/QualTypeNames.cpp", "functions": ["createNestedNameSpecifier"]}]}
{"pr_number": 68750, "url": "https://github.com/llvm/llvm-project/pull/68750", "title": "[Clang] Implement the 'counted_by' attribute", "body": "The 'counted_by' attribute is used on flexible array members. The argument for the attribute is the name of the field member in the same structure holding the count of elements in the flexible array. This information can be used to improve the results of the array bound sanitizer and the '__builtin_dynamic_object_size' builtin.\r\n\r\nThis example specifies the that the flexible array member 'array' has the number of elements allocated for it in 'count':\r\n\r\n  struct bar;\r\n  struct foo {\r\n    size_t count;\r\n     /* ... */\r\n    struct bar *array[] __attribute__((counted_by(count)));\r\n  };\r\n\r\nThis establishes a relationship between 'array' and 'count', specifically that 'p->array' must have *at least* 'p->count' number of elements available. It's the user's responsibility to ensure that this relationship is maintained through changes to the structure.\r\n\r\nIn the following, the allocated array erroneously has fewer elements than what's specified by 'p->count'. This would result in an out-of-bounds access not not being detected:\r\n\r\n  struct foo *p;\r\n\r\n  void foo_alloc(size_t count) {\r\n    p = malloc(MAX(sizeof(struct foo),\r\n                   offsetof(struct foo, array[0]) + count *\r\n                       sizeof(struct bar *)));\r\n    p->count = count + 42;\r\n  }\r\n\r\nThe next example updates 'p->count', breaking the relationship requirement that 'p->array' must have at least 'p->count' number of elements available:\r\n\r\n  struct foo *p;\r\n\r\n  void foo_alloc(size_t count) {\r\n    p = malloc(MAX(sizeof(struct foo),\r\n                   offsetof(struct foo, array[0]) + count *\r\n                       sizeof(struct bar *)));\r\n    p->count = count + 42;\r\n  }\r\n\r\n  void use_foo(int index) {\r\n    p->count += 42;\r\n    p->array[index] = 0; /* The sanitizer cannot properly check this access */\r\n  }\r\n\r\nReviewed By: nickdesaulniers, aaron.ballman\r\n\r\nDifferential Revision: https://reviews.llvm.org/D148381", "feature_layers": ["ir", "ast"], "feature_directives": ["for", "allocate"], "files_changed": [{"filename": "clang/lib/AST/Expr.cpp", "functions": ["if"]}, {"filename": "clang/lib/CodeGen/CGExpr.cpp", "functions": ["if", "SanScope"]}, {"filename": "clang/lib/Sema/SemaDeclAttr.cpp", "functions": ["ValidateCandidate", "clone", "Result", "MemResult", "CCC", "FieldDeclValidatorCCC", "OrdResult", "Filter"]}, {"filename": "clang/test/CodeGen/attr-counted-by.c", "functions": ["test4", "test3", "__counted_by", "test1", "test2"]}, {"filename": "clang/test/Sema/attr-counted-by.c", "functions": ["__counted_by"]}]}
{"pr_number": 67564, "url": "https://github.com/llvm/llvm-project/pull/67564", "title": "[mlir][nvvm] Add prefetch.tensormap", "body": "This PR adds `prefetch.tensormap` Op. It brings the cache line containing the given tma descriptor for subsequent use by the cp.async.bulk.tensor instruction.\n\nhttps://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-prefetch-prefetchu", "feature_layers": ["ir"], "feature_directives": ["parallel", "for"], "files_changed": [{"filename": "mlir/lib/Conversion/NVGPUToNVVM/NVGPUToNVVM.cpp", "functions": ["success"]}]}
{"pr_number": 69243, "url": "https://github.com/llvm/llvm-project/pull/69243", "title": "[AMDGPU][AsmParser] Eliminate custom predicates for named-bit operands.", "body": "isGDS() and isTFE() need special treatment, because they may be both named-bit and token operands.\r\n\r\nPart of #62629.", "feature_layers": ["parse", "parser"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp", "functions": ["isImmTy", "isA16", "isExpVM", "isUNorm", "isLWE", "isHigh", "isClampSI", "isDA", "isExpCompr", "isD16"]}]}
{"pr_number": 68908, "url": "https://github.com/llvm/llvm-project/pull/68908", "title": "[AArch64][SME] Remove immediate argument restriction for svldr and svstr", "body": "The svldr_vnum_za and svstr_vnum_za builtins/intrinsics currently require that the vnum argument be an immediate, but since vnum is used to modify the base register via a mul and add, that restriction is not necessary. This patch removes that restriction.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CodeGen/aarch64-sme-intrinsics/acle_sme_ldr.c", "functions": ["test_svldr_vnum_za_var"]}, {"filename": "clang/test/CodeGen/aarch64-sme-intrinsics/acle_sme_str.c", "functions": ["test_svstr_vnum_za_var"]}]}
{"pr_number": 67727, "url": "https://github.com/llvm/llvm-project/pull/67727", "title": "[flang][runtime] Fix SAME_TYPE_AS()/EXTENDS_TYPE_OF() for CLASS(*)", "body": "Ensure that the f18Addendum flag is preserved in AllocatableApplyMold(), that raw().type is reinitialized in AllocatableDeallocatePolymorphic(), and that the implementations of SameTypeAs() and ExtendsTypeOf() handle unallocated unlimited polymorphic arguments correctly.", "feature_layers": ["runtime"], "feature_directives": ["for", "allocate"], "files_changed": [{"filename": "flang/runtime/derived-api.cpp", "functions": ["CompareDerivedTypeNames"]}]}
{"pr_number": 69129, "url": "https://github.com/llvm/llvm-project/pull/69129", "title": "[RISCV] Use separate CCValAssign for both parts of f64 with ilp32.", "body": "Mark any registers as CustomReg.\r\n    \r\nThis allows us to more directly emit the register or memory access for the high part. Previously we needed a memory access if the low register was X17 and we assumed the stack offset was 0. If the low part wasn't X17, we assumed the high register was the next register after the low register.\r\n    \r\nThis is another part of supporting FP arguments with GISel.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVISelLowering.cpp", "functions": ["if"]}]}
{"pr_number": 66611, "url": "https://github.com/llvm/llvm-project/pull/66611", "title": "[InstCombine] Create a class to lazily track computed known bits", "body": "This patch adds a new class \"WithCache\" which stores a pointer to\r\nany type passable to computeKnownBits along with KnownBits\r\ninformation which is computed on-demand when getKnownBits()\r\nis called. This allows reusing the known bits information when it is\r\npassed as an argument to multiple functions.\r\n\r\nIt also changes a few functions to accept WithCache(s) so that\r\nknown bits information computed in some callees can be propagated to\r\nothers from the top level visitAddSub caller.\r\n\r\nThis gives a speedup of 0.12%:\r\nhttps://llvm-compile-time-tracker.com/compare.php?from=499d41cef2e7bbb65804f6a815b9fa8b27efce0f&to=fbea87f1f1e6d5552e2bc309f8e201a3af6d28ec&stat=instructions:u", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Analysis/ValueTracking.cpp", "functions": ["RHSKnown", "LHSKnown"]}, {"filename": "llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp", "functions": ["LHSCache"]}]}
{"pr_number": 68946, "url": "https://github.com/llvm/llvm-project/pull/68946", "title": "[YAMLParser] Improve plain scalar spec compliance", "body": "The `YAMLParser.h` header file claims support for YAML 1.2 with a few deviations, but our plain scalar parsing failed to parse some valid YAML according to the spec.  This change puts us more in compliance with the YAML spec, now letting us parse plain scalars containing additional special characters in cases where they are not ambiguous.", "feature_layers": ["parse", "parser"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Support/YAMLParser.cpp", "functions": ["isPlainSafeNonBlank", "isBlankOrBreak"]}, {"filename": "llvm/unittests/Support/YAMLParserTest.cpp", "functions": ["Stream"]}]}
{"pr_number": 69022, "url": "https://github.com/llvm/llvm-project/pull/69022", "title": "[mlir][sparse] implementating stageSparseOpPass as an interface", "body": "", "feature_layers": ["parse", "ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/IR/SparseTensorDialect.cpp", "functions": ["getDimension", "getSparseTensorType"]}, {"filename": "mlir/lib/Dialect/SparseTensor/IR/SparseTensorInterfaces.cpp", "functions": ["failure", "dstStt", "success"]}, {"filename": "mlir/lib/Dialect/SparseTensor/Transforms/SparseTensorRewriting.cpp", "functions": ["success", "getSSA", "updateSSA", "dstBuf", "isSparse", "finalize"]}, {"filename": "mlir/lib/Dialect/SparseTensor/Transforms/StageSparseOperations.cpp", "functions": ["failure", "success"]}]}
{"pr_number": 69362, "url": "https://github.com/llvm/llvm-project/pull/69362", "title": "[mlir][sparse] avoid tensor to memref conversion in sparse tensor rewri\u2026", "body": "\u2026ting rules.", "feature_layers": ["parse", "ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/Transforms/SparseTensorRewriting.cpp", "functions": ["getSSA", "updateSSA", "getSparseTensorEncoding", "isSparse", "insert"]}]}
{"pr_number": 69139, "url": "https://github.com/llvm/llvm-project/pull/69139", "title": "[OpenMPIRBuilder] Added `if` clause for `teams`", "body": "This patch adds support for the `if` clause on `teams` construct. The value of the argument must be an integer value. If the value evaluates to true (non-zero) integer, then the number of threads is determined by `num_threads` clause (or default and ICV if `num_threads` is absent). When the condition evaluates to false (zero), then the bounds are set to 1. ([OpenMP 5.2 Section 10.2](https://www.openmp.org/spec-html/5.2/openmpse58.html))\r\n\r\nThis essentially means that\r\n```\r\nupperbound = ifexpr ? upperbound : 1\r\nlowerbound = ifexpr ? lowerbound : 1\r\n```", "feature_layers": ["ir"], "feature_directives": ["for", "teams"], "files_changed": [{"filename": "llvm/unittests/Frontend/OpenMPIRBuilderTest.cpp", "functions": ["OMPBuilder"]}]}
{"pr_number": 68254, "url": "https://github.com/llvm/llvm-project/pull/68254", "title": "[RISCV][GlobalISel] Select G_FRAME_INDEX", "body": "This patch is a bandage to get G_FRAME_INDEX working. We could import the SelectionDAG patterns for the ComplexPattern FrameAddrRegImm, and perhaps we will do that in the future. For now we just select it as an addition with 0.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp", "functions": ["constrainSelectedInstRegOperands"]}]}
{"pr_number": 67304, "url": "https://github.com/llvm/llvm-project/pull/67304", "title": "[XCOFF][OBJECT] get symbol size by calling XCOFF interfaces", "body": "Computing the symbol size as the gap between sorted symbols are not right for XCOFF. \r\n\r\nFor XCOFF, the size info is stored in aux symbol and can be got from existing XCOFF interface `getSymbolSize()`.\r\nThis patch changes XCOFFObjectFile to call this API to get sizes for symbols.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Object/XCOFFObjectFile.cpp", "functions": ["generateXCOFFFixedNameStringRef", "getObject"]}]}
{"pr_number": 69190, "url": "https://github.com/llvm/llvm-project/pull/69190", "title": "[mlir][transform] Fix new interpreter and library preloading passes.", "body": "This PR fixes the two recently added passes from #68661, which were non-functional and untested. In particular:\r\n* The passes did not declare their dependent dialects, so they could not run at all in the most simple cases.\r\n* The mechanism of loading the library module in the initialization of the intepreter pass is broken by design (but, fortunately, also not necessary). This is because the initialization of all passes happens before the execution of any other pass, so the \"preload library\" pass has not run yet at the time the interpreter pass gets initialized. Instead, the library is now loaded every time the interpreter pass is run. This should not be exceedingly expensive, since it only consists of looking up the library in the dialect. Also, this removes the library module from the pass state, making it possible in the future to preload libraries in several passes.\r\n* The PR adds tests for the two passes, which were completely untested previously.", "feature_layers": ["ir"], "feature_directives": ["for", "declare"], "files_changed": [{"filename": "mlir/lib/Dialect/Transform/Transforms/InterpreterPass.cpp", "functions": ["success", "initialize"]}]}
{"pr_number": 68661, "url": "https://github.com/llvm/llvm-project/pull/68661", "title": "[mlir][Transform] Create a transform interpreter and a preloader pass", "body": "This revision provides the ability to use an arbitrary named sequence op as\r\nthe entry point to a transform dialect strategy.\r\n\r\nIt is also a step towards better transform dialect usage in pass pipelines\r\nthat need to preload a transform library rather thanparse it on the fly.\r\n\r\nThe interpreter itself is significantly simpler than its testing counterpart\r\nby avoiding payload/debug root tags and multiple shared modules.\r\n\r\nIn the process, the NamedSequenceOp::apply function is adapted to allow it\r\nbeing an entry point.\r\n\r\nNamedSequenceOp is **not** extended to take the PossibleTopLevelTrait at this\r\ntime, because the implementation of the trait is specific to allowing one\r\ntop-level dangling op with a region such as SequenceOp or AlternativesOp.\r\nIn particular, the verifier of PossibleTopLevelTrait does not allow for an\r\nempty body, which is necessary to declare a NamedSequenceOp that gets linked\r\nin separately before application.\r\n\r\nIn the future, we should dispense with the PossibleTopLevelTrait altogether\r\nand always enter the interpreter with a NamedSequenceOp.\r\n\r\nLastly, relevant TD linking utilities are moved to TransformInterpreterUtils\r\nand reused from there.\r\n", "feature_layers": ["parse", "ir", "ast"], "feature_directives": ["for", "declare"], "files_changed": [{"filename": "mlir/lib/Dialect/Transform/IR/TransformOps.cpp", "functions": ["applySequenceBlock", "emitDefiniteFailure"]}, {"filename": "mlir/lib/Dialect/Transform/Transforms/InterpreterPass.cpp", "functions": ["runOnOperation", "success", "signalPassFailure", "initialize"]}, {"filename": "mlir/lib/Dialect/Transform/Transforms/PreloadLibraryPass.cpp", "functions": ["runOnOperation", "success", "signalPassFailure", "failure", "initialize"]}, {"filename": "mlir/lib/Dialect/Transform/Transforms/TransformInterpreterPassBase.cpp", "functions": ["success", "emitError"]}, {"filename": "mlir/lib/Dialect/Transform/Transforms/TransformInterpreterUtils.cpp", "functions": ["failure", "emitError"]}]}
{"pr_number": 69099, "url": "https://github.com/llvm/llvm-project/pull/69099", "title": "[lld] Sort code section chunks by range types on Arm64EC targets.", "body": "This is a refreshed version of https://reviews.llvm.org/D157141 and depends on #69098.\r\n\r\nMore description about Arm64EC code layout can be found here: https://wiki.winehq.org/ARM64ECToolchain#Code_layout\r\n\r\nThis patch extends `getMachine` to work on other chunk types that may contain code. While I386 and ARMNT are not strictly needed for this patch, I think it makes sense to add it here for consistency. It will be useful in the future work to be able to use it in code that's not guarded by `isArm64EC()`.\r\n\r\nloadconfig is very important for Arm64EC binaries and will be useful in more tests, so I added it to Inputs/. Some builtin linker symbols are not yet implemented, see comments there.\r\n\r\nManually coded code maps will be removed once we have proper support for builtin `__hybrid_code_map` symbol. The weird alignment in tests assembly will also not be needed once the linker handles that. I will create a dependent PR implementing both of those feature.\r\n\r\ncc @bylaws ", "feature_layers": ["ir"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "lld/COFF/DLL.cpp", "functions": ["getMachine"]}, {"filename": "lld/COFF/Writer.cpp", "functions": ["sortECChunks"]}]}
{"pr_number": 69341, "url": "https://github.com/llvm/llvm-project/pull/69341", "title": "[mlir][VectorOp] Move VectorMaskOpConversionBase template to header (NFC)", "body": "This will be needed within the ArmSME conversions to lower masked outer products. The name has been updated to `ConvertVectorMaskOpToLLVMPattern` to fit in more with the other pattern base classes.", "feature_layers": ["ir"], "feature_directives": ["masked"], "files_changed": [{"filename": "mlir/lib/Conversion/VectorToLLVM/ConvertVectorToLLVM.cpp", "functions": ["failure", "matchAndRewriteMaskableOp"]}]}
{"pr_number": 67788, "url": "https://github.com/llvm/llvm-project/pull/67788", "title": "[Support] Add KnownBits::computeForSubBorrow", "body": "- [Support] Add KnownBits::computeForSubBorrow\r\n- [CodeGen] Implement USUBC, USUBO_CARRY, and SSUBO_CARRY with KnownBits::computeForSubBorrow\r\n- [CodeGen] Compute unknown bits for Carry/Borrow for ADD/SUB\r\n- [CodeGen] Compute known bits of Carry/Borrow for UADDO, SADDO, USUBO, and SSUBO\r\n\r\nFixes #65893", "feature_layers": ["codegen"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/unittests/Support/KnownBitsTest.cpp", "functions": ["Known"]}, {"filename": "llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp", "functions": ["if"]}]}
{"pr_number": 68969, "url": "https://github.com/llvm/llvm-project/pull/68969", "title": "[mlir] Fix use-after-free bugs in {RankedTensorType|VectorType}::Builder", "body": "Previously, these would set their ArrayRef members to reference their storage SmallVectors after a copy-on-write (COW) operation. This leads to a use-after-free if the builder is copied and the original destroyed (as the new builder would still reference the old SmallVector).\r\n\r\nThis could easily accidentally occur in code like (annotated):\r\n```c++\r\n// 1. `VectorType::Builder(type)` constructs a new temporary builder\r\n// 2. `.dropDim(0)` updates the temporary builder by reference, and returns a `VectorType::Builder&`\r\n//    - Modifying the shape is a COW operation, so `storage` is used, and `shape` updated the reference it\r\n// 3. Assigning the reference to `auto` copies the builder (via the default C++ copy ctor)\r\n//    -  There's no special handling for `shape` and `storage`, so the new shape points to the old builder's `storage`\r\nauto newType = VectorType::Builder(type).dropDim(0);\r\n// 4. When this line is reached the original temporary builder is destroyed\r\n//    - Actually constructing the vector type is now a use-after-free\r\nVectorType newVectorType = VectorType(newType);\r\n```\r\n\r\nThis is fixed with these changes by using `CopyOnWriteArrayRef<T>`, which implements the same functionality, but ensures no \r\ndangling references are possible if it's copied. \r\n\r\n---\r\n\r\nThe VectorType::Builder also set the ArrayRef<bool> scalableDims member to a temporary SmallVector when the provided scalableDims are empty. This again leads to a use-after-free, and is unnecessary as VectorType::get already handles being passed an empty scalableDims array.\r\n\r\nThese bugs were in-part caught by UBSAN, see:\r\nhttps://lab.llvm.org/buildbot/#/builders/5/builds/37355", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/unittests/IR/ShapedTypeTest.cpp", "functions": ["builder"]}]}
{"pr_number": 69358, "url": "https://github.com/llvm/llvm-project/pull/69358", "title": "Attributes", "body": "- [Libomptarget] Make the references to 'malloc' and 'free' weak.\n- [Libomptarget][NFC] Use C++ style attributes instead\n", "feature_layers": [], "feature_directives": ["target"], "files_changed": [{"filename": "openmp/libomptarget/DeviceRTL/src/Configuration.cpp", "functions": ["CONSTANT"]}, {"filename": "openmp/libomptarget/DeviceRTL/src/Mapping.cpp", "functions": ["__kmpc_get_hardware_num_threads_in_block", "SHARED", "__attribute__", "__kmpc_get_warp_size", "__kmpc_get_hardware_thread_id_in_block"]}, {"filename": "openmp/libomptarget/DeviceRTL/src/Parallelism.cpp", "functions": ["__kmpc_kernel_parallel", "__kmpc_kernel_end_parallel"]}, {"filename": "openmp/libomptarget/DeviceRTL/src/State.cpp", "functions": ["__attribute__", "__kmpc_free_shared"]}, {"filename": "openmp/libomptarget/DeviceRTL/src/Synchronization.cpp", "functions": ["__kmpc_barrier_simple_spmd"]}]}
{"pr_number": 66998, "url": "https://github.com/llvm/llvm-project/pull/66998", "title": "[CodeExtractor] Allow to use 0 addr space for aggregate arg", "body": "The user of CodeExtractor should be able to specify that\r\nthe aggregate argument should be passed as a pointer in zero address\r\nspace.\r\n\r\nCodeExtractor is used to generate outlined functions required by OpenMP\r\nruntime. The arguments of the outlined functions for OpenMP GPU code\r\nare in 0 address space. 0 address space does not need to be the default\r\naddress space for GPU device. That's why there is a need to allow\r\nthe user of CodeExtractor to specify, that the allocated aggregate param\r\nis passed as pointer in zero address space.\r\n\r\nThe proposed changes are used in PR: https://github.com/llvm/llvm-project/pull/67000", "feature_layers": ["runtime", "ir"], "feature_directives": ["for", "allocate"], "files_changed": [{"filename": "llvm/unittests/Transforms/Utils/CodeExtractorTest.cpp", "functions": ["CEAC"]}]}
{"pr_number": 68628, "url": "https://github.com/llvm/llvm-project/pull/68628", "title": "[CFI/MergeFunctions] Modify MergeFunctions to propagate type information", "body": "When MergeFuncs creates a thunk, it does not modify the function in place, but creates a new one altogether. If type metadata is not properly forwarded to this new function, LowerTypeTests will be unable to put this thunk into the dispatch table.\r\n\r\nThe fix here is to just forward the type metadata to the newly created functions.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/IPO/MergeFunctions.cpp", "functions": ["copyMetadataIfPresent"]}]}
{"pr_number": 69406, "url": "https://github.com/llvm/llvm-project/pull/69406", "title": "[mlir][sparse] implement non-permutation MapRef encoding", "body": "This enables reading block sparse from file using libgen! (and soon also direct IR codegen)", "feature_layers": ["parse", "codegen", "ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/Transforms/CodegenUtils.cpp", "functions": ["encodeDim"]}]}
{"pr_number": 69482, "url": "https://github.com/llvm/llvm-project/pull/69482", "title": "[RISCV] Don't let performBUILD_VECTORCombine form a division or remainder with undef elements.", "body": "Division/remainder by undef is immediate UB across the entire vector.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVISelLowering.cpp", "functions": ["SDValue"]}]}
{"pr_number": 69506, "url": "https://github.com/llvm/llvm-project/pull/69506", "title": "[flang][openacc] Avoid privatizing symbols during semantics", "body": "During flang handling of semantics of OpenACC private/firstprivate/ reduction clauses (including the implicitly private loop IV), a new scoped symbol was being created. This could lead to ambiguity in the lowered FIR - aka having multiple fir.declare for the same symbol. Because lowering of OpenACC does not materialize the meaning of the private clauses (by actually creating a scoped local symbol), it does not make sense to create a new symbol in semantics either.\r\n\r\nI updated the acc-symbols01.f90 test to reflect this updated approach. Technically, the test could be removed, but it made sense to keep in place to highlight this intentional decision.", "feature_layers": ["sema", "ir"], "feature_directives": ["for", "declare"], "files_changed": [{"filename": "flang/lib/Semantics/resolve-directives.cpp", "functions": ["CheckAssociatedLoopIndex", "DeclarePrivateAccessEntity", "PrivatizeAssociatedLoopIndex", "DeclareOrMarkOtherAccessEntity"]}]}
{"pr_number": 69509, "url": "https://github.com/llvm/llvm-project/pull/69509", "title": "[Tosa] Rename variables to coding style guideline", "body": "This patch fixes variable names in the style guide. Specifically, names in the form xyz_abc are changed to the form xyzAbc\r\n\r\n\r\nChange-Id: Ifceca302eb8c32b2153f7f6439cf64d81ac9ea4e", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Tosa/Transforms/TosaValidation.cpp", "functions": ["levelCheckScale"]}]}
{"pr_number": 67863, "url": "https://github.com/llvm/llvm-project/pull/67863", "title": "[RISCV][GISel] Add ISel supports for SHXADD from Zba extension", "body": "This patch consists of porting SDISel patterns of SHXADD instructions to GISel.\r\nNote that `non_imm12`, a predicate that was implemented with `PatLeaf`, is now turned into a `PatFrag` of `<op>_with_non_imm12` where `op` is the operator that uses `the non_imm12` operand, as GISel doesn't have equivalence of `PatLeaf` at this moment.\r\n\r\nI'll put ISel supports for SHXADD_UW in a separate patch since the current one is getting a little big.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp", "functions": ["selectNonImm12"]}]}
{"pr_number": 67278, "url": "https://github.com/llvm/llvm-project/pull/67278", "title": "[X86][RFC] Support AVX10 options", "body": "AVX10 Architecture Specification: https://cdrdv2.intel.com/v1/dl/getContent/784267\r\nAVX10 Technical Paper: https://cdrdv2.intel.com/v1/dl/getContent/784343\r\nRFC: https://discourse.llvm.org/t/rfc-design-for-avx10-options-support/73672", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Basic/Targets/X86.cpp", "functions": ["if"]}, {"filename": "clang/test/CodeGen/X86/avx512-error.c", "functions": ["_knot_mask64", "__builtin_ia32_sqrtpd512"]}, {"filename": "clang/test/CodeGen/attr-target-x86.c", "functions": ["__attribute__"]}]}
{"pr_number": 69425, "url": "https://github.com/llvm/llvm-project/pull/69425", "title": "[ELF] Merge copyLocalSymbols and demoteLocalSymbolsInDiscardedSections", "body": "Follow-up to #69295: In `Writer<ELFT>::run`, the symbol passes are flexible:\nthey can be placed almost everywhere before `scanRelocations`, with a constraint\nthat the `computeIsPreemptible` pass must be invoked for linker-defined\nnon-local symbols.\n\nMerge copyLocalSymbols and demoteLocalSymbolsInDiscardedSections to simplify\ncode:\n\n* Demoting local symbols can be made unconditional, not constrainted to /DISCARD/ uses due to performance concerns\n* `includeInSymtab` can be made faster\n* Make symbol passes close to each other\n* Decrease data cache misses due to saving an iteration over local symbols\n\nThere is no speedup, likely due to the unconditional `dr->section` access in `demoteAndCopyLocalSymbols`.\n\n`gc-sections-tls.s` no longer reports an error because the TLS symbol is\nconverted to an Undefined.", "feature_layers": ["ast"], "feature_directives": ["for", "sections"], "files_changed": [{"filename": "lld/ELF/Writer.cpp", "functions": ["copyLocalSymbols", "timeScope", "if", "demoteLocalSymbolsInDiscardedSections", "demoteAndCopyLocalSymbols"]}]}
{"pr_number": 69300, "url": "https://github.com/llvm/llvm-project/pull/69300", "title": "[LoongArch] Implement COPY instruction between CFRs", "body": "With this patch, all CFRs can be used for register allocation.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/LoongArch/LoongArchExpandPseudoInsts.cpp", "functions": ["LoongArchExpandPseudo", "getPassName", "expandMBB", "runOnMachineFunction", "expandCopyCFR"]}]}
{"pr_number": 68777, "url": "https://github.com/llvm/llvm-project/pull/68777", "title": "[lld][ELF] Demote symbols in discarded sections to Undefined.", "body": "After linker script processing, it may be the case that sections\nwere discarded via /DISCARD/, but relocations to symbols in those\nsections remain. Currently, such symbols are still considered\nDefined even though their section is not live and will not be\nplaced anywhere. This results in a silently broken binary.\n\nThis patch goes through the symbols after placement and changes\nthem from Defined to Undefined if their section is no longer\nlive at that point. During relocation processing, we will catch\nsuch undefined symbols and report an error.\n\nSee #58891.\n", "feature_layers": ["ir"], "feature_directives": ["sections"], "files_changed": [{"filename": "lld/ELF/Driver.cpp", "functions": ["timeScope"]}, {"filename": "lld/ELF/Symbols.cpp", "functions": ["if"]}]}
{"pr_number": 67023, "url": "https://github.com/llvm/llvm-project/pull/67023", "title": "[libc++] Add assertions for potential OOB reads in std::nth_element", "body": "Same as https://reviews.llvm.org/D147089 but for std::nth_element", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "libcxx/test/libcxx/algorithms/alg.sorting/assert.sort.invalid_comparator.pass.cpp", "functions": ["compare", "ComparisonResults"]}]}
{"pr_number": 67726, "url": "https://github.com/llvm/llvm-project/pull/67726", "title": "[SPIR-V] Emit proper pointer type for OpenCL kernel arguments", "body": "", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/SPIRV/SPIRVUtils.cpp", "functions": ["hasBuiltinTypePrefix"]}]}
{"pr_number": 69349, "url": "https://github.com/llvm/llvm-project/pull/69349", "title": "[RISCV] Fix assertion failure from performBUILD_VECTORCombine when the binop is a shift.", "body": "The RHS of a shift can have a different type than the LHS. If there are undefs in the vector, we need the undef added to the RHS to match the type of any shift amounts that are also added to the vector.\r\n\r\nFor now just don't add shifts if their RHS and LHS don't match.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVISelLowering.cpp", "functions": ["SDValue"]}]}
{"pr_number": 68336, "url": "https://github.com/llvm/llvm-project/pull/68336", "title": "[SPIR-V] Remove calls to deprecated PointerType methods (1/2)", "body": "Please consider only the second commit in this patch. This patch removes calls to deprecated PointerType methods where it does not require any further work or explanation. Another patch removing the rest is coming.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/Target/SPIRV/SPIRVUtils.cpp", "functions": ["hasBuiltinTypePrefix"]}, {"filename": "llvm/lib/Target/SPIRV/SPIRVGlobalRegistry.cpp", "functions": ["if"]}]}
{"pr_number": 68081, "url": "https://github.com/llvm/llvm-project/pull/68081", "title": "[clang][Interp] IntegralAP zero-init", "body": "Not adding any tests since I'm waiting for https://github.com/llvm/llvm-project/pull/68069/", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/AST/Interp/intap.cpp", "functions": ["_BitInt"]}]}
{"pr_number": 69277, "url": "https://github.com/llvm/llvm-project/pull/69277", "title": "[X86] Support -march=pantherlake,clearwaterforest", "body": "", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CodeGen/attr-target-mv.c", "functions": ["__attribute__"]}]}
{"pr_number": 68793, "url": "https://github.com/llvm/llvm-project/pull/68793", "title": "[Tablegen] Add keyword `dump`.", "body": "The keyword is intended for debugging purpose. It prints a message to stderr.\r\n\r\nThis patch is based on code originally written by Adam Nemet, and on the feedback received by the reviewers in\r\nhttps://reviews.llvm.org/D157492.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/TableGen/Error.cpp", "functions": ["CheckDump", "dumpMessage"]}, {"filename": "llvm/lib/TableGen/Record.cpp", "functions": ["R"]}, {"filename": "llvm/lib/TableGen/TGParser.cpp", "functions": ["ParseDump"]}]}
{"pr_number": 69563, "url": "https://github.com/llvm/llvm-project/pull/69563", "title": "[RISCV] Combine (and (select cond, x, -1), c) to (select cond, x, (and x, c)) with Zicond.", "body": "It's only beneficial when cond is setcc with integer equality condition code. For other case, it has same instruction count as the original.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVISelLowering.cpp", "functions": ["SDValue"]}]}
{"pr_number": 67118, "url": "https://github.com/llvm/llvm-project/pull/67118", "title": "[AMDGPU] Remove Code Object V3", "body": "V3 has been deprecated for a while as well, so it can safely be removed like V2 was removed.\r\n\r\n- [Clang] Set minimum code object version to 4\r\n- [lld] Fix tests using code object v3\r\n- Remove code object V3 from the AMDGPU backend, and delete or port v3 tests to v4.\r\n- Update docs to make it clear V3 can no longer be emitted.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp", "functions": ["legalizeTrapHsaQueuePtr"]}, {"filename": "llvm/lib/Target/AMDGPU/SIISelLowering.cpp", "functions": ["lowerTrapHsaQueuePtr"]}, {"filename": "llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.cpp", "functions": ["isHsaAbiVersion3"]}]}
{"pr_number": 69324, "url": "https://github.com/llvm/llvm-project/pull/69324", "title": "[DAG] Constant fold FMAD", "body": "This has very little effect on codegen in practice, but is a nice to have I think.\r\n\r\nSee #68315", "feature_layers": ["codegen"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp", "functions": ["visitFMAD"]}]}
{"pr_number": 67412, "url": "https://github.com/llvm/llvm-project/pull/67412", "title": "[ARM] fix \"+fp.dp\" in multilib selection", "body": "When the FPU was selected with \"+(no)fp(.dp)\" extensions in \"-march\" or \"-mcpu\" options, the FPU used for multilib selection was still the default one for given architecture or CPU.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/TargetParser/ARMTargetParser.cpp", "functions": ["findSinglePrecisionFPU"]}]}
{"pr_number": 69467, "url": "https://github.com/llvm/llvm-project/pull/69467", "title": "[mlir][nvvm] Introduce `nvvm.stmatrix` Op", "body": "This PR adds `nvvm.stmatrix` Op to NVVM dialect. The Op collectively store one or more matrices across all threads in a warp to the given address location in shared memory.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/LLVMIR/IR/NVVMDialect.cpp", "functions": ["emitOpError", "success"]}]}
{"pr_number": 69518, "url": "https://github.com/llvm/llvm-project/pull/69518", "title": "[Libomptarget] Add a test for the `libc` implementation of assert", "body": "Summary:\nThe `libcgpu.a` file provides its own implementation of `__assert_fail`.\nThis adds a test to make sure it's usable in OpenMP offloading as\nexpected. Currently this requires linking `libcgpu.a` before the OpenMP\ndevice RTL however. We also disable the test on the CPU as the format of\nthe string will be different.\n", "feature_layers": ["ir"], "feature_directives": ["for", "target", "requires"], "files_changed": [{"filename": "openmp/libomptarget/test/libc/assert.c", "functions": ["main"]}]}
{"pr_number": 68738, "url": "https://github.com/llvm/llvm-project/pull/68738", "title": "[clang-tidy] Add check to diagnose coroutine-hostile RAII objects", "body": "This check detects **hostile-RAII** objects which should not **persist across a suspension point in a coroutine**.\r\n\r\nSome objects require that they be destroyed on the same thread that created them. Traditionally this requirement was often phrased as \"must be a local variable\", under the assumption that local variables always work this way. However this is incorrect with **C++20 coroutines**, since an intervening `co_await` may cause the coroutine to suspend and later be resumed on another thread.\r\n\r\nThe lifetime of an object that requires being destroyed on the same thread must  not encompass a `co_await` or `co_yield` point. If you create/destroy an object, you must do so without allowing the coroutine to suspend in the meantime.\r\n\r\nThe check considers the following type as hostile:\r\n\r\n - **Scoped-lockable types**: A scoped-lockable object persisting across a suspension point is problematic as the lock held by this object could be unlocked by a different thread. This would be undefined behaviour.\r\n\r\n - Types belonging to a configurable **denylist**.\r\n\r\n```cpp\r\n  // Call some async API while holding a lock.\r\nconst my::MutexLock l(&mu_);\r\n\r\n// Oops! The async Bar function may finish on a different\r\n// thread from the one that created the MutexLock object and therefore called\r\n// Mutex::Lock -- now Mutex::Unlock will be called on the wrong thread.\r\nco_await Bar();\r\n```\r\n", "feature_layers": ["ir"], "feature_directives": ["for", "requires"], "files_changed": [{"filename": "clang-tools-extra/clang-tidy/misc/CoroutineSuspensionHostileCheck.cpp", "functions": ["ClangTidyCheck"]}, {"filename": "clang-tools-extra/test/clang-tidy/checkers/misc/coroutine-suspension-hostile.cpp", "functions": ["final_suspend", "unhandled_exception", "bool", "yield_value", "destroy", "operator", "from_promise", "scopedLockableTest", "await_suspend", "resume", "initial_suspend", "denyListTest", "done", "from_address", "await_ready", "get_return_object", "await_resume"]}, {"filename": "clang-tools-extra/clang-tidy/misc/CoroutineHostileRAIICheck.cpp", "functions": ["ClangTidyCheck"]}, {"filename": "clang-tools-extra/test/clang-tidy/checkers/misc/coroutine-hostile-raii.cpp", "functions": ["BasicWarning", "BasicNoWarning", "scopedLockableBasic"]}]}
{"pr_number": 68706, "url": "https://github.com/llvm/llvm-project/pull/68706", "title": "[libomptarget][OpenMP] Initial implementation of omp_target_memset() and omp_target_memset_async()", "body": "This PR adds the newly landed OpenMP API routines omp_target_memset() and omp_target_memset_sync() to fill memory in the device memory. This first implementation is based on a slow path that initializes memory on the host and then issues a H2D transfer to fill the memory on the target device. A future PR will introduce an offloaded kernel (or driver-side API to do fill the memory on the target device)", "feature_layers": ["ir"], "feature_directives": ["target"], "files_changed": [{"filename": "openmp/libomptarget/src/api.cpp", "functions": ["libomp_target_memcpy_async_helper", "libomp_target_memcpy_async_task", "libomp_target_memset_async_task", "libomp_target_memset_async_helper"]}, {"filename": "openmp/libomptarget/test/api/omp_target_memset.c", "functions": ["main"]}]}
{"pr_number": 67048, "url": "https://github.com/llvm/llvm-project/pull/67048", "title": "[libc][math] Implement double precision expm1 function correctly rounded for all  rounding modes.", "body": "Implementing expm1 function for double precision based on exp function algorithm:\r\n\r\n- Reduced x = log2(e) * (hi + mid1 + mid2) + lo, where:\r\n  * hi is an integer\r\n  * mid1 * 2^-6 is an integer\r\n  * mid2 * 2^-12 is an integer\r\n  * |lo| < 2^-13 + 2^-30\r\n- Then exp(x) - 1 = 2^hi * 2^mid1 * 2^mid2 * exp(lo) - 1 ~ 2^hi * (2^mid1 * 2^mid2 * (1 + lo * P(lo)) - 2^(-hi) )\r\n- We evaluate fast pass with P(lo) is a degree-3 Taylor polynomial of (e^lo - 1) / lo in double precision\r\n- If the Ziv accuracy test fails, we use degree-6 Taylor polynomial of (e^lo - 1) / lo in double double precision\r\n- If the Ziv accuracy test still fails, we re-evaluate everything in 128-bit precision.", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "libc/src/math/generic/expm1.cpp", "functions": ["poly_approx_f128", "expm1_f128", "poly_approx_dd", "xbits", "set_exceptional", "poly_approx_d"]}, {"filename": "libc/test/src/math/expm1_test.cpp", "functions": ["__r"]}]}
{"pr_number": 68876, "url": "https://github.com/llvm/llvm-project/pull/68876", "title": "[mlir][ODS] Add `OptionalTypesMatchWith` and remove a custom assemblyFormat", "body": "This is just a slight specialization of `TypesMatchWith` that returns success if an optional parameter is missing.\r\n\r\nThere may be other places this could help e.g.:\r\nhttps://github.com/llvm/llvm-project/blob/eb21049b4b904b072679ece60e73c6b0dc0d1ebf/mlir/include/mlir/Dialect/X86Vector/X86Vector.td#L58-L59\r\n...but I'm leaving those to avoid some churn.\r\n\r\nThis constraint will be handy for us in some later patches, it's a formalization of a short circuiting trick with the `comparator` of the `TypesMatchWith` constraint (devised for #69195).\r\n\r\n```\r\nTypesMatchWith<\r\n  \"padding type matches element type of result (if present)\",\r\n  \"result\", \"padding\",\r\n  \"::llvm::cast<VectorType>($_self).getElementType()\",\r\n  // This returns true if no padding is present, or it's present with a type that matches the element type of `result`.\r\n  \"!getPadding() || std::equal_to<>()\">\r\n```\r\n\r\nThis is a little non-obvious, so after this patch you can instead do:\r\n```\r\nOptionalTypesMatchWith<\r\n  \"padding type matches element type of result (if present)\",\r\n  \"result\", \"padding\",\r\n  \"::llvm::cast<VectorType>($_self).getElementType()\">\r\n```\r\n \r\n", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Vector/IR/VectorOps.cpp", "functions": ["failure", "success"]}]}
{"pr_number": 69389, "url": "https://github.com/llvm/llvm-project/pull/69389", "title": "[mlir][sparse] Update verifier for block sparsity and singleton", "body": "Updates:\r\n1. Verification of block sparsity.\r\n2. Verification of singleton level type can only follow compressed or loose_compressed levels. And all level types after singleton should be singleton.\r\n3. Added getBlockSize function.\r\n4. Added an invalid encoding test for an incorrect lvlToDim map that user provides.", "feature_layers": ["parse", "ir"], "feature_directives": ["for", "single"], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/IR/SparseTensorDialect.cpp", "functions": ["emitError"]}, {"filename": "mlir/lib/Dialect/SparseTensor/IR/Detail/DimLvlMap.cpp", "functions": ["AffineMap"]}]}
{"pr_number": 69496, "url": "https://github.com/llvm/llvm-project/pull/69496", "title": "Allow empty dimension arrays in `linalg::inferContractionDims`", "body": "This function was returning failure when any of the intersection sets was empty, but this is actually legitimate in \"matrix times vector\" cases, where some of the operands have lower dimensionality, implying unit-dimension semantics for the \"missing\" dimensions.\r\n\r\nExample:\r\n\r\n```mlir\r\nfunc.func @transpose_extend_batch_matmul(\r\n    %vec: tensor<32x128xi16>,\r\n    %mat: tensor<11008x32x128xi4>) -> tensor<11008x32xi32> {\r\n  %c0_i32 = arith.constant 0 : i32\r\n  %cst_0 = arith.constant 0.000000e+00 : f32\r\n  %0 = tensor.empty() : tensor<11008x32xi32>\r\n  %1 = linalg.fill ins(%c0_i32 : i32) outs(%0 : tensor<11008x32xi32>) -> tensor<11008x32xi32>\r\n  %2 = tensor.empty() : tensor<11008xf32>\r\n  %3 = linalg.fill ins(%cst_0 : f32) outs(%2 : tensor<11008xf32>) -> tensor<11008xf32>\r\n  %batch_matmul_result = linalg.generic {indexing_maps = [affine_map<(d0, d1, d2) -> (d1, d2)>, \r\n                                                          affine_map<(d0, d1, d2) -> (d0, d1, d2)>, \r\n                                                          affine_map<(d0, d1, d2) -> (d0, d1)>], \r\n                                         iterator_types = [\"parallel\", \"parallel\", \"reduction\"]} \r\n                                         ins(%vec, %mat : tensor<32x128xi16>, tensor<11008x32x128xi4>) \r\n                                         outs(%1 : tensor<11008x32xi32>) {\r\n  ^bb0(%in: i16, %in_3: i4, %out: i32):\r\n      %19 = arith.extsi %in : i16 to i32\r\n      %20 = arith.extui %in_3 : i4 to i32\r\n      %21 = arith.muli %19, %20 : i32\r\n      %22 = arith.addi %21, %out : i32\r\n      linalg.yield %22 : i32\r\n  } -> tensor<11008x32xi32>\r\n  return %batch_matmul_result : tensor<11008x32xi32>\r\n}\r\n```\r\n\r\nHere, we were returning failure because `ac` is empty. With this PR, we return this useful information:\r\n\r\n```\r\nbatch: [ 1 ]\r\nm: [ ]\r\nn: [ 0 ]\r\nk: [ 2 ]\r\n```", "feature_layers": ["sema", "ir"], "feature_directives": ["parallel", "for"], "files_changed": [{"filename": "mlir/lib/Dialect/Linalg/IR/LinalgInterfaces.cpp", "functions": ["failure"]}]}
{"pr_number": 66034, "url": "https://github.com/llvm/llvm-project/pull/66034", "title": "[libc][libm][GPU] Add missing vendor entrypoints to the GPU version of `libm`", "body": "There are a number of entry points in `libm` for which no target-agnostic implementations exist, and the built-ins do not lower correctly on either AMDGPU or NVPTX targets. This patch adds the vendor entry points as a temporary solution.", "feature_layers": [], "feature_directives": ["for", "target"], "files_changed": [{"filename": "libc/src/math/gpu/llrint.cpp", "functions": ["__builtin_llrint"]}, {"filename": "libc/src/math/gpu/llrintf.cpp", "functions": ["__builtin_llrintf"]}, {"filename": "libc/src/math/gpu/llround.cpp", "functions": ["__builtin_llround"]}, {"filename": "libc/src/math/gpu/llroundf.cpp", "functions": ["__builtin_lroundf"]}]}
{"pr_number": 68764, "url": "https://github.com/llvm/llvm-project/pull/68764", "title": "[mlir][python] fix value builders", "body": "I goofed and didn't correctly anticipate the interplay of generated builders and mixin classes (in `_ext.py`s). This fixes by generating a check for `__has_mixin__` and branching accordingly (in the generated value builder). This also makes a small modification in which ops get run through `get_op_result_or_op_results` (i.e., skip for ops with no results).\r\n\r\nNote, an alternative way to perform the check is `if len(SimpleOp.__bases__) > 1` but I don't think that is as robust as having a particular \"token\" (expected field).", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/tools/mlir-tblgen/OpPythonBindingGen.cpp", "functions": ["_get_op_result_or_op_results", "op"]}]}
{"pr_number": 69623, "url": "https://github.com/llvm/llvm-project/pull/69623", "title": "[ValueTracking] Fixup bugprone logic in non-zero of `select`/`phi`; NFC", "body": "The match logic's correctness implicitly relies on canonicalization of\nconstants the RHS and that `cmpExcludesZero` only works for constants.\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Analysis/ValueTracking.cpp", "functions": ["cmpExcludesZero"]}]}
{"pr_number": 69624, "url": "https://github.com/llvm/llvm-project/pull/69624", "title": "[mlir][sparse] Remove old syntax", "body": "", "feature_layers": ["parse", "ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/IR/SparseTensorDialect.cpp", "functions": ["parseDLT"]}]}
{"pr_number": 69630, "url": "https://github.com/llvm/llvm-project/pull/69630", "title": "[mlir][sparse] introduce sparse_tensor.crd_translate operation", "body": "", "feature_layers": ["parse", "ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/IR/SparseTensorDialect.cpp", "functions": ["getOracle", "getEncoder"]}]}
{"pr_number": 69031, "url": "https://github.com/llvm/llvm-project/pull/69031", "title": "[scudo] Add ConditionVariable in SizeClassAllocator64", "body": "This may improve the waiting of `Region->MMLock` while trying to refill the freelist. Instead of always waiting on the completion of `populateFreeListAndPopBatch()` or `releaseToOSMaybe()`, `pushBlocks()` also refills the freelist. This increases the chance of earlier return from `popBatches()`.\r\n\r\nThe support of condition variable hasn't been done for all platforms. Therefore, add another `popBatchWithCV()` and it can be configured in the allocator configuration by setting `Primary::UseConditionVariable` and the desired `ConditionVariableT`.\r\n\r\nReviewed By: cferris\r\n\r\nDifferential Revision: https://reviews.llvm.org/D156146", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "compiler-rt/lib/scudo/standalone/tests/condition_variable_test.cpp", "functions": ["simpleWaitAndNotifyAll", "L"]}]}
{"pr_number": 69646, "url": "https://github.com/llvm/llvm-project/pull/69646", "title": "[mlir][sparse] support BSR for cuSPARSE (libgen path only)", "body": "", "feature_layers": ["parse", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/Transforms/SparseGPUCodegen.cpp", "functions": ["isAdmissibleBSR"]}]}
{"pr_number": 69549, "url": "https://github.com/llvm/llvm-project/pull/69549", "title": "[Scalar] Use LLVMContext::MD_mem_parallel_loop_access directly (NFC)", "body": "This patch \"constant propagates\"\nLLVMContext::MD_mem_parallel_loop_access into wherever\nParallelLoopAccessMDKind is used.\n", "feature_layers": ["ir"], "feature_directives": ["parallel"], "files_changed": [{"filename": "llvm/lib/Transforms/Scalar/Scalarizer.cpp", "functions": ["DT", "Impl", "ParallelLoopAccessMDKind"]}]}
{"pr_number": 69547, "url": "https://github.com/llvm/llvm-project/pull/69547", "title": "[X86] Remove unused function createX86PreAMXConfigPass", "body": "The last use was removed by:\n\n  commit 496156ac57da3abd9c8a6dc422852b7bdfaa448f\n  Author: Luo, Yuanke <yuanke.luo@intel.com>\n  Date:   Tue May 3 18:57:25 2022 +0800\n", "feature_layers": ["ast"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/Target/X86/X86PreAMXConfig.cpp", "functions": ["X86PreAMXConfigPass"]}]}
{"pr_number": 68379, "url": "https://github.com/llvm/llvm-project/pull/68379", "title": "[clang][Sema] Use original template pattern when declaring implicit deduction guides for nested template classes", "body": "When a nested template is instantiated, the template pattern of the inner class is not copied into the outer class ClassTemplateSpecializationDecl. The specialization contains a ClassTemplateDecl with an empty record that points to the original template pattern instead.\r\n\r\nAs a result, when looking up the constructors of the inner class, no results are returned. This patch finds the original template pattern and uses that for the lookup instead.\r\n\r\nBased on CWG2471 we must also substitute the known outer template arguments when creating deduction guides for the inner class.\r\n\r\nFixes #46200\r\nFixes #57812", "feature_layers": ["sema"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/SemaTemplate/nested-implicit-deduction-guides.cpp", "functions": ["N"]}]}
{"pr_number": 68795, "url": "https://github.com/llvm/llvm-project/pull/68795", "title": "[Tablegen] Bugfix and refactor VarLenCodeEmitter HwModes.", "body": "VarLenCodeEmitterGen produced code that did not compile if using\nalternative encoding in different HwModes. It's not possbile to assign\n\n    unsigned **Index = Index_<mode>[][2] = { ... };\n\nAs a fix, Index and InstBits where removed in favor of mode specific\ngetInstBits_<mode> functions since this is the only place the arrays are\naccessed.\n\nHandling of HwModes is now concentrated to the VarLenCodeEmitterGen::run\nmethod reducing the overall amount of code and enabling other types of\nalternative encodings not related to HwModes.\n\nAdded a test for VarLenCodeEmitterGen HwModes.\n\nMake sure that HwModes are supported in the same way they are supported\nfor the standard CodeEmitter. It should be possible to define\ninstructions with universal encoding across modes, distinct encodings\nfor each mode or only define encodings for some modes.\n\nFixed indentation in generated code.\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/utils/TableGen/VarLenCodeEmitterGen.cpp", "functions": ["getInstructionCases", "getInstructionCase", "getInstructionCaseForEncoding", "EBM"]}]}
{"pr_number": 69569, "url": "https://github.com/llvm/llvm-project/pull/69569", "title": "[X86][AMX] remove related code of X86PreAMXConfigPass", "body": "In https://reviews.llvm.org/D125075, we switched to use FastPreTileConfig in O0 and abandoned X86PreAMXConfigPass.\r\nwe can remove related code of X86PreAMXConfigPass safely.", "feature_layers": ["ast"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/Target/X86/X86PreAMXConfig.cpp", "functions": ["addTileConfig", "findConfigShapes", "AllocaInst", "isTileLoad", "brokenVolatile", "getAnalysisUsage", "isAMXIntrinsic", "runOnFunction", "PCFG", "preTileConfig", "onlyTileDef", "isTileStore", "X86PreAMXConfigPass", "Builder", "getKeyAMXShapes"]}]}
{"pr_number": 66072, "url": "https://github.com/llvm/llvm-project/pull/66072", "title": "[RISCV] Match prefetch address with offset", "body": "A new ComplexPattern `AddrRegImmLsb00000` is added, which is like\r\n`AddrRegImm` except that if the least significant 5 bits isn't all\r\nzeros, we will fail back to offset 0.\r\n\r\nThis PR is stacked on #67644.", "feature_layers": ["ast"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp", "functions": ["DL"]}]}
{"pr_number": 65480, "url": "https://github.com/llvm/llvm-project/pull/65480", "title": "[RISCV][MC] Implement evaluateBranch for auipc+jalr pairs", "body": "This patch implements `MCInstrAnalysis` state in order to be able analyze auipc+jalr pairs inside `evaluateBranch`.\r\n\r\nThis is implemented as follows:\r\n- State: array of currently known GPR values;\r\n- Whenever an auipc is detected in `updateState`, update the state value of RD with the immediate;\r\n- Whenever a jalr is detected in `evaluateBranch`, check if the state holds a value for RS1 and use that to compute its target.\r\n\r\nNote that this is similar to how binutils implements it and the output of llvm-objdump should now mostly match the one of GNU objdump.\r\n\r\nThis patch also updates the relevant llvm-objdump patches and adds a new one testing the output for interleaved auipc+jalr pairs.\r\n\r\nThis PR builds on #65479. Please only review the top commit here.", "feature_layers": ["ir"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/MCTargetDesc/RISCVMCTargetDesc.cpp", "functions": ["setGPRState", "getGPRState", "updateState", "getRegIndex", "resetState", "isGPR"]}]}
{"pr_number": 69192, "url": "https://github.com/llvm/llvm-project/pull/69192", "title": "[mlir][Tosa] fix fp16/bf16 support for Clamp min/max attributes", "body": "In TOSA MLIR dialect, fix the definition of the Clamp op to\r\naccept fp16 & bf16 datatype for the min_fp and max_fp attributes.\r\nAdd ClampOp verifier to check attributes types compatibility.\r\nAdd related test cases in Tosa/ops.mlir.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Tosa/IR/TosaOps.cpp", "functions": ["emitOpError", "success"]}]}
{"pr_number": 69348, "url": "https://github.com/llvm/llvm-project/pull/69348", "title": "[flang][hlfir] Make the parent type the first component", "body": "Type extension is currently handled in FIR by inlining the parents components as the first member of the record type.\r\n\r\nThis is not correct from a memory layout point of view since the storage size of the parent type may be bigger than the sum of the size of its component (due to alignment requirement). To avoid making FIR types target dependent and fix this issue, make the parent component a single component with the parent type at the beginning of the record type.\r\n\r\nThis also simplifies addressing since parent component is now a \"normal\" component that can be designated with hlfir.designate.\r\n\r\nStructureComponent lowering however is a bit more complex since the symbols in the structure component may refer to subcomponents of parent types.\r\n\r\nNotes:\r\n1. The fix is only done in HLFIR for now, a similar fix should be done in ConvertExpr.cpp to fix the path without HLFIR (I will likely still do it in a new patch since it would be an annoying bug to investigate for people testing flang without HLFIR).\r\n2. The private component extra mangling is useless after this patch. I will remove it after 1.\r\n3. The \"parent component\" TODO in constant CTOR is free to implement for HLFIR after this patch, but I would rather remove it and test it in a different patch.\r\n\r\n", "feature_layers": ["ir"], "feature_directives": ["for", "single", "target"], "files_changed": [{"filename": "flang/lib/Lower/ConvertExprToHLFIR.cpp", "functions": ["genDataRefAndSkipParentComponents", "gen"]}]}
{"pr_number": 69474, "url": "https://github.com/llvm/llvm-project/pull/69474", "title": "[InstCombine] Don't consider aligned_alloc removable if icmp uses result", "body": "At the moment, all alloc-like functions are assumed to return non-null pointers, if their return value is only used in a compare. This is based on being allowed to substitute the allocation function with one that doesn't fail to allocate the required memory.\r\n\r\naligned_alloc however must also return null if the required alignment cannot be satisfied, so I don't think the same reasoning as above can be applied to it.\r\n\r\nThis patch adds a bail-out for aligned_alloc calls to isAllocSiteRemovable.", "feature_layers": ["ir"], "feature_directives": ["for", "allocate"], "files_changed": [{"filename": "llvm/lib/Analysis/MemoryBuiltins.cpp", "functions": ["getAllocFnKind"]}, {"filename": "llvm/lib/Transforms/InstCombine/InstructionCombining.cpp", "functions": ["match"]}]}
{"pr_number": 69320, "url": "https://github.com/llvm/llvm-project/pull/69320", "title": "[mlir][transform] Handle multiple library preloading passes", "body": "The transform dialect stores a \"library module\" that the preload pass\r\ncan populate. Until now, each pass registered an additional module by\r\nsimply pushing it to a vector; however, the interpreter only used the\r\nfirst of them. This commit turns the registration into \"loading\", i.e.,\r\neach newly added module gets merged into the existing one. This allows\r\nthe loading to be split into several passes, and using the library in\r\nthe interpreter now takes all of them into account. While this design\r\navoids repeated merging every time the library is accessed, it requires\r\nthat the implementation of merging modules lives in the\r\n`TransformDialect` target (since it at the dialect depend on each\r\nother).\r\n\r\nThis resolves #69111.", "feature_layers": ["ir"], "feature_directives": ["for", "target", "requires"], "files_changed": [{"filename": "mlir/lib/Dialect/Transform/IR/TransformDialect.cpp", "functions": ["ModuleOp"]}, {"filename": "mlir/lib/Dialect/Transform/Transforms/TransformInterpreterUtils.cpp", "functions": ["ModuleOp", "success", "otherSymbolTable", "targetSymbolTable", "failure", "if", "canMergeInto", "rewriter", "emitError"]}]}
{"pr_number": 68495, "url": "https://github.com/llvm/llvm-project/pull/68495", "title": "[mlir][spirv][webgpu] Add lowering of IAddCarry to IAdd", "body": "WebGPU does not currently support extended arithmetic, this is an issue when we want to lower from SPIR-V. This commit adds a pattern to transform and emulate spirv.IAddCarry with spirv.IAdd operations\r\n\r\nFixes #65154", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/SPIRV/Transforms/SPIRVWebGPUTransforms.cpp", "functions": ["success"]}]}
{"pr_number": 65759, "url": "https://github.com/llvm/llvm-project/pull/65759", "title": "[Analysis] Add Scalable field in MemoryLocation.h", "body": "  This is the first of a series of patch to improve Alias Analysis on\r\n  Scalable quantities.\r\n  Keep Scalable information from TypeSize which\r\n  will be used in Alias Analysis.\r\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Analysis/BasicAliasAnalysis.cpp", "functions": ["LocationSize"]}, {"filename": "llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp", "functions": ["LocationSize"]}]}
{"pr_number": 69650, "url": "https://github.com/llvm/llvm-project/pull/69650", "title": "[libc++] mdspan - implement layout_stride", "body": "This implements layout_stride for C++23 and with that completes the implementation of the C++23 mdspan header. The feature test macro is added, and the status pages updated.\r\n\r\nCo-authored-by: Damien L-G <dalg24@gmail.com>\r\n\r\nDifferential Revision: https://reviews.llvm.org/D157171", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "libcxx/test/libcxx/containers/views/mdspan/layout_left/assert.ctor.layout_stride.pass.cpp", "functions": ["arg", "main"]}, {"filename": "libcxx/test/libcxx/containers/views/mdspan/layout_right/assert.ctor.layout_stride.pass.cpp", "functions": ["arg", "main"]}, {"filename": "libcxx/test/libcxx/containers/views/mdspan/layout_stride/assert.conversion.pass.cpp", "functions": ["main"]}, {"filename": "libcxx/test/libcxx/containers/views/mdspan/layout_stride/assert.ctor.extents_array.non_unique.pass.cpp", "functions": ["main"]}, {"filename": "libcxx/test/libcxx/containers/views/mdspan/layout_stride/assert.ctor.extents_array.pass.cpp", "functions": ["main"]}, {"filename": "libcxx/test/libcxx/containers/views/mdspan/layout_stride/assert.ctor.extents_span.non_unique.pass.cpp", "functions": ["main"]}, {"filename": "libcxx/test/libcxx/containers/views/mdspan/layout_stride/assert.ctor.extents_span.pass.cpp", "functions": ["main"]}, {"filename": "libcxx/test/libcxx/containers/views/mdspan/layout_stride/assert.index_operator.pass.cpp", "functions": ["main"]}, {"filename": "libcxx/test/libcxx/containers/views/mdspan/layout_stride/assert.stride.pass.cpp", "functions": ["main"]}, {"filename": "libcxx/test/std/containers/views/mdspan/layout_left/ctor.layout_stride.pass.cpp", "functions": ["constexpr", "test_static_extent_mismatch", "main", "src", "test_conversion", "test", "dest", "test_rank_mismatch"]}, {"filename": "libcxx/test/std/containers/views/mdspan/layout_right/ctor.layout_stride.pass.cpp", "functions": ["constexpr", "test_static_extent_mismatch", "main", "src", "test_conversion", "test", "dest", "test_rank_mismatch"]}, {"filename": "libcxx/test/std/containers/views/mdspan/layout_stride/comparison.pass.cpp", "functions": ["test_comparison_different_rank", "constexpr", "map", "main", "src", "test_comparison_index_type", "other_map", "test_comparison_with", "test", "dest", "test_comparison_same_rank"]}, {"filename": "libcxx/test/std/containers/views/mdspan/layout_stride/ctor.default.pass.cpp", "functions": ["test", "main", "constexpr", "test_construction"]}, {"filename": "libcxx/test/std/containers/views/mdspan/layout_stride/ctor.extents_array.pass.cpp", "functions": ["m", "constexpr", "main", "test", "test_construction"]}, {"filename": "libcxx/test/std/containers/views/mdspan/layout_stride/ctor.extents_span.pass.cpp", "functions": ["m", "constexpr", "main", "test", "test_construction"]}, {"filename": "libcxx/test/std/containers/views/mdspan/layout_stride/ctor.strided_mapping.pass.cpp", "functions": ["constexpr", "From", "test_no_implicit_conversion", "test_static_extent_mismatch", "main", "test_layout", "src", "test_conversion", "test", "dest", "test_rank_mismatch"]}, {"filename": "libcxx/test/std/containers/views/mdspan/layout_stride/deduction.pass.cpp", "functions": ["test", "main"]}, {"filename": "libcxx/test/std/containers/views/mdspan/layout_stride/extents.verify.cpp", "functions": ["not_extents", "representable"]}, {"filename": "libcxx/test/std/containers/views/mdspan/layout_stride/index_operator.pass.cpp", "functions": ["m", "test_iteration", "constexpr", "iterate_stride", "main", "test", "check_operator_constraints", "test_large"]}, {"filename": "libcxx/test/std/containers/views/mdspan/layout_stride/is_exhaustive_corner_case.pass.cpp", "functions": ["m", "test", "main"]}, {"filename": "libcxx/test/std/containers/views/mdspan/layout_stride/properties.pass.cpp", "functions": ["m", "test", "main"]}, {"filename": "libcxx/test/std/containers/views/mdspan/layout_stride/required_span_size.pass.cpp", "functions": ["test_required_span_size", "m", "test", "main"]}, {"filename": "libcxx/test/std/containers/views/mdspan/layout_stride/static_requirements.pass.cpp", "functions": ["main", "test_mapping_requirements", "test_layout_mapping_requirements", "test_layout_mapping_stride"]}, {"filename": "libcxx/test/std/containers/views/mdspan/layout_stride/stride.pass.cpp", "functions": ["m", "test", "main", "test_stride"]}]}
{"pr_number": 69465, "url": "https://github.com/llvm/llvm-project/pull/69465", "title": "[clang-tidy]Add new check bugprone-casting-through-void", "body": "This check detects usage of ``static_cast`` pointer to the other pointer throght `static_cast` to `void *` in C++ code.\r\nFixes: #68532", "feature_layers": ["ast"], "feature_directives": [], "files_changed": [{"filename": "clang-tools-extra/test/clang-tidy/checkers/bugprone/casting-through-void.cpp", "functions": ["const_test", "const_pointer_test", "normal_test", "reinterpret_cast_test", "cxx_functional_cast", "c_style_cast_test", "test", "bit_cast"]}]}
{"pr_number": 67382, "url": "https://github.com/llvm/llvm-project/pull/67382", "title": "[MLIR][Presburger] Implement matrix inverse", "body": "Shift the `determinant()` function from LinearTransform to Matrix.\r\nImplement a FracMatrix class, inheriting from Matrix<Fraction>, for inverses.\r\nImplement inverse for FracMatrix and intInverse for IntMatrix.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Analysis/FlatLinearValueConstraints.cpp", "functions": ["mat"]}, {"filename": "mlir/lib/Analysis/Presburger/IntegerRelation.cpp", "functions": ["dirs"]}, {"filename": "mlir/unittests/Analysis/Presburger/LinearTransformTest.cpp", "functions": ["m3", "m5", "m1", "m6", "m4", "testColumnEchelonForm", "m2"]}, {"filename": "mlir/unittests/Analysis/Presburger/MatrixTest.cpp", "functions": ["invM", "inv"]}, {"filename": "mlir/lib/Analysis/Presburger/Simplex.cpp", "functions": ["output"]}, {"filename": "mlir/lib/Analysis/Presburger/Matrix.cpp", "functions": ["FracMatrix"]}, {"filename": "mlir/unittests/Analysis/Presburger/FractionTest.cpp", "functions": ["f"]}]}
{"pr_number": 65695, "url": "https://github.com/llvm/llvm-project/pull/65695", "title": "[tsan][go]: add atomic or/and functions", "body": "These atomic primitives are required in order to implement the race\r\nvariants of the new And and Or operators in Go's sync/atomic package.\r\nSee Github issue golang/go#61395.", "feature_layers": ["ir"], "feature_directives": ["atomic"], "files_changed": [{"filename": "compiler-rt/lib/tsan/rtl/tsan_interface_atomic.cpp", "functions": ["__tsan_go_atomic32_fetch_or", "__tsan_go_atomic64_fetch_and", "__tsan_go_atomic64_fetch_or", "__tsan_go_atomic32_fetch_and"]}]}
{"pr_number": 69144, "url": "https://github.com/llvm/llvm-project/pull/69144", "title": "[RISCV][GISel] Disable call lowering for integers larger than 2*XLen.", "body": "Types larger than 2*XLen are passed indirectly which is not supported yet. Currently, we will incorrectly pass X10 multiple times.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/GISel/RISCVCallLowering.cpp", "functions": ["isSupportedReturnType", "isSupportedArgumentType"]}]}
{"pr_number": 69761, "url": "https://github.com/llvm/llvm-project/pull/69761", "title": "[Libomptarget][NFC] Remove use of VLA in the AMDGPU plugin", "body": "Summary:\nWe should not rely on a VLA in C++ for the handling of this string. The\nsize is a true runtime value so we cannot rely on constexpr handling. We\nsimply use a small vector, whose default size is most likely large\nenough to handle whatever size gets output within the stack, but is safe\nin cases where it is not.\n", "feature_layers": ["runtime"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "openmp/libomptarget/plugins-nextgen/amdgpu/src/rtl.cpp", "functions": ["ISAName", "TripleTarget"]}]}
{"pr_number": 69786, "url": "https://github.com/llvm/llvm-project/pull/69786", "title": "[mlir][sparse] fix stack overflow due to memref.alloca in loops", "body": "", "feature_layers": ["parse", "ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/Transforms/SparseTensorConversion.cpp", "functions": ["guard"]}]}
{"pr_number": 65493, "url": "https://github.com/llvm/llvm-project/pull/65493", "title": "[openacc][openmp] Add dialect representation for acc atomic operations", "body": "The OpenACC standard specifies an `atomic` construct in section 2.12 (of 3.3 spec), used to ensure that a specific location is accessed or updated atomically. Four different clauses are allowed: `read`, `write`, `update`, or `capture`. If no clause appears, it is as if `update` is used.\r\n\r\nThe OpenMP specification defines the same clauses for `omp atomic`. The types of expression and the clauses in the OpenACC spec match the OpenMP spec exactly. The main difference is that the OpenMP specification is a superset - it includes clauses for `hint` and `memory order`. It also allows conditional expression statements. But otherwise, the expression definition matches.\r\n\r\nThus, for OpenACC, we refactor and reuse the OpenMP implementation as follows:\r\n* The atomic operations are duplicated in OpenACC dialect. This is preferable so that each language's semantics are precisely represented even if specs have divergence.\r\n* However, since semantics overlap, a common interface between the atomic operations is being added. The semantics for the interfaces are not generic enough to be used outside of OpenACC and OpenMP, and thus new folders were added to hold common pieces of the two dialects.\r\n* The atomic interfaces define common accessors (such as getting `x` or `v`) which match the OpenMP and OpenACC specs. It also adds common verifiers intended to be called by each dialect's operation verifier.\r\n* The OpenMP write operation was updated to use `x` and `expr` to be consistent with its other operations (that use naming based on spec).\r\n\r\nThe frontend lowering necessary to generate the dialect can also be reused. This will be done in a follow up change.\r\n\r\nDifferential Revision: https://reviews.llvm.org/D158768", "feature_layers": ["sema", "frontend"], "feature_directives": ["for", "atomic"], "files_changed": [{"filename": "mlir/lib/Dialect/OpenACC/IR/OpenACC.cpp", "functions": ["success", "verifyCommon", "failure", "verifyRegionsCommon", "getElementType"]}, {"filename": "mlir/lib/Dialect/OpenMP/IR/OpenMPDialect.cpp", "functions": ["success", "verifyRegionsCommon", "emitError"]}]}
{"pr_number": 69653, "url": "https://github.com/llvm/llvm-project/pull/69653", "title": "[mlir][sparse] implement sparse_tensor.crd_translate operation", "body": "", "feature_layers": ["parse", "ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/IR/SparseTensorDialect.cpp", "functions": ["retType"]}, {"filename": "mlir/lib/Dialect/SparseTensor/Transforms/SparseTensorRewriting.cpp", "functions": ["args"]}]}
{"pr_number": 69757, "url": "https://github.com/llvm/llvm-project/pull/69757", "title": "[RISCV][GISel] Minor refactoring of RISCVCallReturnHandler and RISCVIncomingValueHandler to match other targets", "body": "Forward assignValueToReg to the base class to make the copy. Add markPhysRegUsed to contain the differences between call handling and argument handling. Introduce RISCVFormalArgHandler.\r\n\r\nThis structure matches how AArch64, AMDGPU, and X86 are structured.\r\n\r\nI've also added `MIRBuilder.getMRI()->addLiveIn(PhysReg);` to match the other targets.", "feature_layers": ["ir"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/GISel/RISCVCallLowering.cpp", "functions": ["Handler", "RISCVIncomingValueHandler", "markPhysRegUsed"]}]}
{"pr_number": 68085, "url": "https://github.com/llvm/llvm-project/pull/68085", "title": "[mlir][index][spirv] Add conversion for index to spirv", "body": "Due to an issue when lowering from scf to spirv as there was no conversion pass for index to spirv, we are motivated to add a conversion pass from the Index dialect to the SPIR-V dialect. Furthermore, we add the new conversion patterns to the scf-to-spirv conversion.\r\n\r\nFixes #63713", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Conversion/IndexToSPIRV/IndexToSPIRV.cpp", "functions": ["runOnOperation", "success", "typeConverter", "patterns"]}]}
{"pr_number": 67236, "url": "https://github.com/llvm/llvm-project/pull/67236", "title": "[InstCombine] optimize powi(X,Y)/X with Ofast", "body": "Try to transform the powi(X, Y) / X into powi(X, Y-1) with Ofast.\r\n\r\nFor this case, when the Y is 3, then powi(X, 2) is replaced by X * X in the further step.\r\nFixes https://github.com/llvm/llvm-project/pull/67216", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp", "functions": ["replaceInstUsesWith"]}]}
{"pr_number": 68510, "url": "https://github.com/llvm/llvm-project/pull/68510", "title": "[clang][dataflow]Use cast_or_null instead of cast to prevent crash", "body": "`getStorageLocation` may return `nullptr` and this will produce crash when use `cast`, use `dyn_cast_or_null` instead. I test it locally using [FTXUI](https://github.com/ArthurSonzogni/FTXUI) and it may be the cause of issue [issue](https://github.com/llvm/llvm-project/issues/68412), but I am not sure.", "feature_layers": ["ast"], "feature_directives": [], "files_changed": [{"filename": "clang-tools-extra/test/clang-tidy/checkers/bugprone/unchecked-optional-access.cpp", "functions": ["empty", "foo"]}, {"filename": "clang/unittests/Analysis/FlowSensitive/UncheckedOptionalAccessModelTest.cpp", "functions": ["target", "getOptional"]}]}
{"pr_number": 69746, "url": "https://github.com/llvm/llvm-project/pull/69746", "title": "[MLIR][python bindings] invalidate ops after PassManager run", "body": "Fixes https://github.com/llvm/llvm-project/issues/69730 (also see https://reviews.llvm.org/D155543).\r\n\r\nThere are  two things outstanding (why I didn't land before):\r\n\r\n1. add some C API tests for `mlirOperationWalk`;\r\n2. potentially refactor how the invalidation in `run` works; the first version of the code looked like this:\r\n    ```cpp\r\n    if (invalidateOps) {\r\n      auto *context = op.getOperation().getContext().get();\r\n      MlirOperationWalkCallback invalidatingCallback =\r\n          [](MlirOperation op, void *userData) {\r\n            PyMlirContext *context =\r\n                static_cast<PyMlirContext *>(userData);\r\n            context->setOperationInvalid(op);\r\n          };\r\n      auto numRegions =\r\n          mlirOperationGetNumRegions(op.getOperation().get());\r\n      for (int i = 0; i < numRegions; ++i) {\r\n        MlirRegion region =\r\n            mlirOperationGetRegion(op.getOperation().get(), i);\r\n        for (MlirBlock block = mlirRegionGetFirstBlock(region);\r\n             !mlirBlockIsNull(block);\r\n             block = mlirBlockGetNextInRegion(block))\r\n          for (MlirOperation childOp =\r\n                   mlirBlockGetFirstOperation(block);\r\n               !mlirOperationIsNull(childOp);\r\n               childOp = mlirOperationGetNextInBlock(childOp))\r\n            mlirOperationWalk(childOp, invalidatingCallback, context,\r\n                              MlirWalkPostOrder);\r\n      }\r\n    }\r\n    ```\r\n    This is verbose and ugly but it has the important benefit of not executing `mlirOperationEqual(rootOp->get(), op)` for every op underneath the root op. \r\n\r\nSupposing there's no desire for the slightly more efficient but highly convoluted approach, I can land this \"posthaste\".\r\nBut, since we have eyes on this now, any suggestions or approaches (or needs/concerns) are welcome.", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/test/CAPI/ir.c", "functions": ["walkCallBack", "testOperationWalk"]}]}
{"pr_number": 68833, "url": "https://github.com/llvm/llvm-project/pull/68833", "title": "[mlir][memref] Fix index delinearization for CollapseShapeOp folding", "body": "The `resolveSourceIndicesCollapseShape` method is used to compute indices into the source `MemRef` of a `CollapseShapeOp` from the collapsed indices. This method didn't check for dynamic sizes of the source shape which led to a crash.\r\n\r\nFix https://github.com/llvm/llvm-project/issues/68483", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/MemRef/Transforms/FoldMemRefAliasOps.cpp", "functions": ["failure", "sizes"]}]}
{"pr_number": 67883, "url": "https://github.com/llvm/llvm-project/pull/67883", "title": "[mlir][scf] Implement getSingle... of LoopLikeOpInterface for scf::ForallOp", "body": "The `getSingle(IterationVar|UpperBound|LowerBound|Step)` methods of `LoopLikeOpInterface` are\r\nuseful to quickly query the iteration space of unidimensional loops. Until now,\r\n`scf::ForallOp` always fell back to the default implementation of these methods,\r\nreturning `std::nullopt`.\r\n\r\nThis patch implements those methods, returning the respective bounds or steps\r\nin the special case of `rank == 1`.", "feature_layers": ["ir"], "feature_directives": ["for", "single"], "files_changed": [{"filename": "mlir/lib/Dialect/SCF/IR/SCF.cpp", "functions": ["getInductionVar"]}]}
{"pr_number": 69424, "url": "https://github.com/llvm/llvm-project/pull/69424", "title": "[MachineBasicBlock] Fix SlotIndexUpdater for insertion order", "body": "Follow up fix for #68786 to address that MachineFunction handleInsertion is actually called before a new instruction has been inserted into the block. Hence new instructions must be recorded and SlotIndex updates performed after the delegate call.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/CodeGen/MachineBasicBlock.cpp", "functions": ["if"]}]}
{"pr_number": 67895, "url": "https://github.com/llvm/llvm-project/pull/67895", "title": "[InstCombine] Fold comparison of adding two z/sext booleans", "body": "- Add test coverage for sext/zext boolean additions\r\n- [InstCombine] Fold comparison of adding two z/sext booleans\r\n\r\nFixes https://github.com/llvm/llvm-project/issues/64859.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp", "functions": ["replaceInstUsesWith", "One"]}]}
{"pr_number": 69783, "url": "https://github.com/llvm/llvm-project/pull/69783", "title": "[lldb] improve dwo path in missing dwo error when relative", "body": "When the debug info refers to a dwo with relative `DW_AT_comp_dir` and `DW_AT_dwo_name`, we only print the `DW_AT_comp_dir` in our error message if we can't find it. This often isn't very helpful, especially when the `DW_AT_comp_dir` is \".\":\r\n```\r\n(lldb) fr v\r\nerror: unable to locate .dwo debug file \".\" for skeleton DIE 0x000000000000003c\r\n```\r\n\r\nI'm updating the error message to include both `DW_AT_comp_dir` (if it exists) and `DW_AT_dwo_name` when the `DW_AT_dwo_name` is relative. The behavior when `DW_AT_dwo_name` is absolute should be the same.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "lldb/source/Plugins/SymbolFile/DWARF/SymbolFileDWARF.cpp", "functions": ["error_dwo_path"]}, {"filename": "lldb/test/Shell/SymbolFile/DWARF/Inputs/dwo-missing-error.c", "functions": ["main"]}]}
{"pr_number": 69806, "url": "https://github.com/llvm/llvm-project/pull/69806", "title": "[OpenMP] Basic BumpAllocator for (AMD)GPUs", "body": "The patch contains a basic BumpAllocator for (AMD)GPUs to allow us to run more tests. The allocator implements `malloc`, both internally and externally, while we continue to default to the NVIDIA `malloc` when we target NVIDIA GPUs. Once we have smarter or customizable allocators we should consider this choice, for now, this allocator is better than none. It traps if it is out of memory, making it easy to debug. Heap size is configured via `LIBOMPTARGET_HEAP_SIZE` and defaults to 512MB. It allows to track allocation statistics via\r\n`LIBOMPTARGET_DEVICE_RTL_DEBUG=8` (together with\r\n`-fopenmp-target-debug=8`). Two tests were added, and one was enabled.\r\n\r\nThis is the next step towards fixing\r\n https://github.com/llvm/llvm-project/issues/66708", "feature_layers": [], "feature_directives": ["for", "target"], "files_changed": [{"filename": "openmp/libomptarget/DeviceRTL/src/Allocator.cpp", "functions": ["free"]}, {"filename": "openmp/libomptarget/DeviceRTL/src/State.cpp", "functions": ["free"]}, {"filename": "openmp/libomptarget/plugins-nextgen/amdgpu/src/rtl.cpp", "functions": ["setDeviceHeapSize"]}, {"filename": "openmp/libomptarget/plugins-nextgen/cuda/src/rtl.cpp", "functions": ["shouldSetupDeviceMemoryPool"]}, {"filename": "openmp/libomptarget/plugins-nextgen/generic-elf-64bit/src/rtl.cpp", "functions": ["shouldSetupDeviceMemoryPool"]}, {"filename": "openmp/libomptarget/test/offloading/malloc.c", "functions": ["main"]}, {"filename": "openmp/libomptarget/test/offloading/malloc_parallel.c", "functions": ["main"]}]}
{"pr_number": 67213, "url": "https://github.com/llvm/llvm-project/pull/67213", "title": "[clangd] Show alignment for records and fields decls", "body": "Shows align for records and fields declarations in hover information.\r\n\r\nExample:\r\n```cpp\r\nstruct A {\r\n  char a;\r\n  short b;\r\n};\r\n```\r\n\r\nFor this struct hover informations shows:\r\n```\r\nSize: 4 bytes, alignment 2 bytes\r\n```\r\n\r\n![image](https://github.com/llvm/llvm-project/assets/12231048/a130b353-f3f6-4203-b0d7-3d592b7a7855)\r\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang-tools-extra/clangd/unittests/HoverTests.cpp", "functions": ["bits", "bytes"]}]}
{"pr_number": 69297, "url": "https://github.com/llvm/llvm-project/pull/69297", "title": "[TableGen][NFC] Remove MultiClass argument and Scoper in QualifyName", "body": "MultiClass argument is not used any more since aa84326.\n\nBesides, for maintainability, we should put the implementation of\nqualifying name in one place (that is `QualifyName` function), so\n`Scoper` is removed and we use `IsMC` to indicate that we are in a\nmulticlass.\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/TableGen/TGParser.cpp", "functions": ["QualifyName"]}]}
{"pr_number": 69161, "url": "https://github.com/llvm/llvm-project/pull/69161", "title": "[BOLT][RISCV] Implement getCalleeSavedRegs", "body": "The main reason for implementing this now is to ensure the `assume=abi.test` test passes on RISC-V. Since it uses `--indirect-call-promotion=all`, it requires some support for register analysis on the target.\r\n\r\nFurther testing and implementation of register/frame analysis on RISC-V will come later.", "feature_layers": ["ir"], "feature_directives": ["for", "target", "requires"], "files_changed": [{"filename": "bolt/lib/Target/RISCV/RISCVMCPlusBuilder.cpp", "functions": ["getCalleeSavedRegs"]}]}
{"pr_number": 69837, "url": "https://github.com/llvm/llvm-project/pull/69837", "title": "[BOLT][RISCV] Set minimum function alignment to 2 for RVC", "body": "In #67707, the minimum function alignment on RISC-V was set to 4. When\r\nRVC (compressed instructions) is enabled, the minimum alignment can be\r\nreduced to 2.\r\n\r\nThis patch implements this by delegating the choice of minimum alignment\r\nto a new `MCPlusBuilder::getMinFunctionAlignment` function. This way,\r\nthe target-dependent code in `BinaryFunction` is minimized.", "feature_layers": [], "feature_directives": ["for", "target"], "files_changed": [{"filename": "bolt/lib/Target/AArch64/AArch64MCPlusBuilder.cpp", "functions": ["getMinFunctionAlignment"]}, {"filename": "bolt/lib/Target/RISCV/RISCVMCPlusBuilder.cpp", "functions": ["getMinFunctionAlignment"]}]}
{"pr_number": 69712, "url": "https://github.com/llvm/llvm-project/pull/69712", "title": "[clang] Fix designated initializers inside templates", "body": "Skip anonymous members when rebuilding DesignatedInitExpr since designated inits for them are meant to be created during\r\n`InitListChecker::CheckDesignatedInitializer` routine.\r\n\r\nFixes https://github.com/llvm/llvm-project/issues/65143", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/SemaCXX/cxx2b-designated-initializers.cpp", "functions": ["bar", "f"]}]}
{"pr_number": 68960, "url": "https://github.com/llvm/llvm-project/pull/68960", "title": "[libc++] <experimental/simd> Add operator value_type() of simd reference", "body": "", "feature_layers": [], "feature_directives": ["simd"], "files_changed": [{"filename": "libcxx/test/std/experimental/simd/simd.reference/reference_value_type.pass.cpp", "functions": ["main", "operator"]}, {"filename": "libcxx/test/std/experimental/simd/simd.class/simd_subscr.pass.cpp", "functions": ["main", "operator"]}, {"filename": "libcxx/test/std/experimental/simd/simd.mask.class/simd_mask_subscr.pass.cpp", "functions": ["main", "operator"]}]}
{"pr_number": 68685, "url": "https://github.com/llvm/llvm-project/pull/68685", "title": "[llvm-rc] Concatenate consecutive string tokens in windres mode", "body": "A number of constructs allow more than one string literal for what represents one single string - version info values, string tables, user data resources, etc. This mostly works like how a C compiler merges consecutive string literals, like \"foo\" \"bar\" as producing the same as \"foobar\". This is beneficial for producing strings with some elements provided by the preprocessor.\r\n\r\nMS rc.exe only supports this in a few fixed locations (most of which are already supported), while GNU windres supports this essentially anywhere in any string. See b989fcbae6f179ad887d19ceef83ace1c00b87cc for one recent change that extended support for this in one specific resource.\r\n\r\nA reasonable use case for multiple concatenated string literals that GNU windres accepts is `1 ICON DIR \"/name.ico\"`, where the directory is provided via the preprocessor, expanding to another string literal; this is https://github.com/llvm/llvm-project/issues/51286.\r\n\r\nTo support this, extend the tokenizer to concatenate consecutive quoted string tokens, when invoked in windres mode.\r\n\r\nFor cases where the difference between narrow and wide strings is significant (e.g. in userdata resources), GNU windres treats `L\"aaa\" \"bbb\"` the same as `L\"aaabbb\"`, contrary to rc.exe which treats it as the wide string `\"aaa\"` followed by the narrow string `\"bbb\"`. Similarly, windres rejects the sequence `\"aaa\" L\"bbb\"`.\r\n\r\nHowever, in contexts where the end result actually is UTF16, GNU windres does accept such mismatched string representations. Therefore, it seems clear that GNU windres doesn't do the merging on the string token level.\r\n\r\nMany of the existing windres tests happen to use tag-stringtable-basic.rc as test input; this file contains a case of `\"wor\" L\"ld\"` which now is rejected by the tokenizer in windres mode - therefore switch those tests, where the actual input file doesn't matter, to a different file.\r\n", "feature_layers": ["ir"], "feature_directives": ["for", "single"], "files_changed": [{"filename": "llvm/tools/llvm-rc/ResourceScriptToken.cpp", "functions": ["Tokenizer", "RCToken", "tokenizeRC", "getStringError", "Data"]}, {"filename": "llvm/tools/llvm-rc/llvm-rc.cpp", "functions": ["Saver"]}]}
{"pr_number": 69456, "url": "https://github.com/llvm/llvm-project/pull/69456", "title": "[mlir][VectorOps] Add fold `ExtractOp(CreateMask) -> CreateMask`", "body": "This allows folding extracts from `vector.create_mask` ops that have a known value. Currently, there's no fold for this, but you get the same effect from the unrolling in LowerVectorMask (part of -convert-vector-to-llvm), then folds after that. However, for a future patch, this simplification needs to be done before lowering to LLVM, hence the need for this fold.\r\n\r\nE.g.:\r\n\r\n```\r\n%0 = vector.create_mask %c1, %dimA, %dimB : vector<1x[4]x[4]xi1>\r\n%1 = vector.extract %mask[0] : vector<[4]x[4]xi1>\r\n```\r\n->\r\n```\r\n%0 = vector.create_mask %dimA, %dimB : vector<[4]x[4]xi1>\r\n```", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Vector/IR/VectorOps.cpp", "functions": ["failure", "if", "newMaskType"]}]}
{"pr_number": 68922, "url": "https://github.com/llvm/llvm-project/pull/68922", "title": "Use the correct namespace for looking up matching operator!=", "body": "`S.getScopeForContext` determins the **active** scope associated with the given `declContext`. \r\nThis fails to find the matching `operator!=` if candidate `operator==` was found via ADL since that scope is not active.\r\n\r\nInstead, just directly lookup using the namespace decl of `operator==`\r\n\r\nFixes #68901", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CXX/over/over.match/over.match.funcs/over.match.oper/p3-2a.cpp", "functions": ["foo"]}]}
{"pr_number": 69908, "url": "https://github.com/llvm/llvm-project/pull/69908", "title": "[Clang] Report an error and crash on source location exhaustion in macros", "body": "`createExpansionLocImpl` has an assert that checks if we ran out of source locations. We have observed this happening on real code and in release builds the assertion does not fire and the compiler just keeps running indefinitely without giving any indication that something went wrong.\r\n\r\nDiagnose this problem and reliably crash to make sure the problem is easy to detect.\r\n\r\nI have also tried:\r\n- returning invalid source locations,\r\n- reporting sloc address space usage on error.\r\n\r\nBoth caused the compiler to run indefinitely. It would be nice to dig further why that happens, but until then crashing seems like a better alternative.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "clang/lib/Basic/SourceManager.cpp", "functions": ["SourceLocation"]}]}
{"pr_number": 69252, "url": "https://github.com/llvm/llvm-project/pull/69252", "title": "[Clang] Handle real and imaginary parts of complex lvalue in `APValue::printPretty`", "body": "This patch handles formatting of real and imaginary parts of complex lvalue.\r\nFixes #69218.\r\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CodeGen/complex.c", "functions": ["t10"]}, {"filename": "clang/test/Sema/complex-imag.c", "functions": ["f5"]}]}
{"pr_number": 68039, "url": "https://github.com/llvm/llvm-project/pull/68039", "title": "[clang][Interp] Only evaluate the source array initialization of an `ArrayInitLoopExpr` once", "body": "At the moment in `Interp` the source array initialization (`getCommonExpr()`) of an `ArrayInitLoopExpr` is evaluated during every iteration, when it should only be evaluated once.\r\n\r\nThe initializer is always wrapped inside an `OpaqueValueExpr`, which in `ExprConstant` is evaluated once per scope and their result is stored so that the next time `ExprConstant` sees the same expression, it can return the result only.\r\n\r\nThis patch intents to achieve a similar functionality inside `Interp` by storing the result of the `OpaqueValueExpr` in a local variable.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "clang/lib/AST/Interp/ByteCodeExprGen.cpp", "functions": ["StoredOpaqueScope"]}, {"filename": "clang/test/AST/Interp/cxx20.cpp", "functions": ["bool", "ternary"]}]}
{"pr_number": 69315, "url": "https://github.com/llvm/llvm-project/pull/69315", "title": "[lldb] Add a single bit constructor for RegisterFlags::Field", "body": "This means you don't have to do RegisterField(\"\", 0, 0), you can do RegisterField(\"\", 0).\r\n\r\nWhich is useful for testing and even more useful when we are writing definitions of real registers which have 10s of single bit fields.", "feature_layers": [], "feature_directives": ["for", "single"], "files_changed": [{"filename": "lldb/unittests/Target/RegisterFlagsTest.cpp", "functions": ["f1", "make_field", "single_bit"]}]}
{"pr_number": 69901, "url": "https://github.com/llvm/llvm-project/pull/69901", "title": "[AArch64] Don't generate st2 for 64bit store that can use stp", "body": "D142966 made it so that st2 that do not start at element 0 use zip2 instead of st2. This extends that to any 64bit store that has a nearby load that can better become a LDP operation, which is expected to have a higher throughput. It searches up to 20 instructions away for a store to p+16 or p-16.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AArch64/AArch64ISelLowering.cpp", "functions": ["hasNearbyPairedStore", "OffsetA"]}]}
{"pr_number": 69104, "url": "https://github.com/llvm/llvm-project/pull/69104", "title": "[clang] Add clang::preferred_type attribute for bitfields", "body": "This attribute allows user to specify type of the bitfield that will be emitted to debug info without affecting semantics of the program. Since it doesn't affect semantics, this attribute can be safely ignored by other compilers.\r\n\r\nThis is useful when user is forced to use the same type for all bitfields in a class to get better [layout](https://godbolt.org/z/ovWqzqv9x) and [codegen](https://godbolt.org/z/bdoqvz9e6) from MSVC, because it allows debuggers to interpret the value of bitfield in the most human-friendly way (e.g. when value actually comes from an enum). This is driven by my work on LLDB formatters for Clang. I have two use cases for this:\r\n```cpp\r\nnamespace Clang {\r\nclass Type {\r\n  enum TypeClass { ... };\r\n  struct TypeBitfields {\r\n    [[clang::debug_info_type(clang::Type::TypeClass)]] unsigned TC: 8;\r\n    [[clang::debug_info_type(bool)]] mutable unsigned FromAST : 1;\r\n  };\r\n};\r\n}\r\n```", "feature_layers": ["sema", "codegen", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Sema/SemaDeclAttr.cpp", "functions": ["if"]}]}
{"pr_number": 67750, "url": "https://github.com/llvm/llvm-project/pull/67750", "title": "[clang] Support fixed point types in C++", "body": "This initially just adds support for mangling.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CodeGenCXX/fixed-point-mangle.cpp", "functions": ["func", "func2"]}]}
{"pr_number": 69772, "url": "https://github.com/llvm/llvm-project/pull/69772", "title": "[MLIR,Flang,OpenMP] Remove usage of getElementType in OpenMPTranslation", "body": "Remove usage of getElementType in OpenMPTranslation to pave way for switching to opaque pointers in MLIR and Flang. The approach chosen stores the elementType in a new field in MapInfo called varType. A similar approach was chosen for AtomicReadOp in\r\nhttps://github.com/llvm/llvm-project/commit/81767f52f49339be2c78fc9bf831856b9f57e2f0", "feature_layers": ["ir"], "feature_directives": ["for", "atomic"], "files_changed": [{"filename": "mlir/lib/Conversion/OpenMPToLLVM/OpenMPToLLVM.cpp", "functions": ["failure", "success"]}, {"filename": "mlir/lib/Target/LLVMIR/Dialect/OpenMP/OpenMPToLLVMIRTranslation.cpp", "functions": ["getSizeInBytes"]}]}
{"pr_number": 69977, "url": "https://github.com/llvm/llvm-project/pull/69977", "title": "[amdgpu] D2D memcpy via streams and HSA", "body": "\r\n\r\nhsa_amd_memory_async_copy can handle device to device copies if passed the corresponding parameters.\r\n\r\nNo functional change - currently D2D copy goes through a fallback in libomptarget that stages through a host malloc, after this it goes directly through HSA.\r\n\r\nWorks under exactly the situations that HSA works. Verified locally on a performance benchmark. Hoping to attract further testing from internal developers after it lands.", "feature_layers": ["ir"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "openmp/libomptarget/plugins-nextgen/amdgpu/src/rtl.cpp", "functions": ["Lock"]}]}
{"pr_number": 69762, "url": "https://github.com/llvm/llvm-project/pull/69762", "title": "[lldb][NFC] Implement llvm-style RTTI for DWARFASTParser", "body": "", "feature_layers": ["parse", "ast", "parser"], "feature_directives": ["for"], "files_changed": [{"filename": "lldb/source/Plugins/SymbolFile/DWARF/DWARFASTParserClang.cpp", "functions": ["m_ast", "DWARFASTParser"]}]}
{"pr_number": 69137, "url": "https://github.com/llvm/llvm-project/pull/69137", "title": "[mlir][Interfaces] `LoopLikeOpInterface`: Expose mutable inits/yielded values", "body": "Expose a `MutableArrayRef<OpOperand>` instead of `ValueRange`/`OperandRange`. This allows users of this interface to change the yielded values and the init values. The names of the interface methods are the same as the auto-generated op accessor names (`get...()` returns `OperandRange`, `get...Mutable()` returns `MutableOperandRange`).\r\n\r\nNote: The interface methods return a `MutableArrayRef` instead of a `MutableOperandRange` because a loop op may not implement `getYieldedValuesMutable` etc. and there is no safe way to return an \"empty\" range with a `MutableOperandRange`.\r\n\r\n", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "flang/lib/Optimizer/Dialect/FIROps.cpp", "functions": ["getFinalValue"]}, {"filename": "mlir/lib/Dialect/SCF/IR/SCF.cpp", "functions": ["getInitArgsMutable", "getYieldOp"]}]}
{"pr_number": 68177, "url": "https://github.com/llvm/llvm-project/pull/68177", "title": "[clangd] Adapt Inlay Hint support for Deducing This", "body": "This is a follow-up for D140828, making Clangd omit the explicit object parameter in a call to member function with Deducing This.\r\n\r\nGiven that the parent patch is still in its infancy and might undergo several reverting-relanding processes, one can feel free to revert this if encountering any CI failure. And please let me know if I should alter anything.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang-tools-extra/clangd/InlayHints.cpp", "functions": ["chooseParameterNames"]}, {"filename": "clang-tools-extra/clangd/unittests/InlayHintTests.cpp", "functions": ["function", "work", "operator", "Self"]}]}
{"pr_number": 67552, "url": "https://github.com/llvm/llvm-project/pull/67552", "title": "[AArch64] Lower mathlib call ldexp into fscale when sve is enabled", "body": "The function of 'fscale' is equivalent to mathlib call ldexp, but has better performance. This patch lowers ldexp into fscale when sve is enabled.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AArch64/AArch64ISelLowering.cpp", "functions": ["SDValue", "LowerFLDEXP", "DL"]}]}
{"pr_number": 69721, "url": "https://github.com/llvm/llvm-project/pull/69721", "title": "[clang][Diagnostics] Provide source range to constexpr function diags", "body": "Before:\r\n```console\r\n./array.cpp:290:16: error: constexpr function never produces a constant expression [-Winvalid-constexpr]\r\n  290 | constexpr void neverValid() {\r\n      |                ^\r\n./array.cpp:291:3: note: subexpression not valid in a constant expression\r\n  291 |   throw;\r\n      |   ^~~~~\r\n```\r\n\r\nAfter:\r\n```console\r\n./array.cpp:290:16: error: constexpr function never produces a constant expression [-Winvalid-constexpr]\r\n  290 | constexpr void neverValid() {\r\n      |                ^~~~~~~~~~\r\n./array.cpp:291:3: note: subexpression not valid in a constant expression\r\n  291 |   throw;\r\n      |   ^~~~~\r\n```", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/Misc/constexpr-source-ranges.cpp", "functions": ["neverValid"]}]}
{"pr_number": 69437, "url": "https://github.com/llvm/llvm-project/pull/69437", "title": "[DAG] Constant Folding for U/SMUL_LOHI", "body": "", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp", "functions": ["getNode"]}]}
{"pr_number": 69919, "url": "https://github.com/llvm/llvm-project/pull/69919", "title": "[TableGen][NFC] Add record kind to `Record` class", "body": "enum `RecordKind` is added to indicate the kind of Record (which\r\ncan be a normal record definition, anonymous record definition,\r\nclass or multiclass).\r\n\r\nSome arguments like `IsMC` and `IsDefm` are removed since we can\r\nget the information from `RecordKind`.\r\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/TableGen/TGParser.cpp", "functions": ["QualifiedNameOfImplicitName", "QualifyName"]}]}
{"pr_number": 69819, "url": "https://github.com/llvm/llvm-project/pull/69819", "title": "[clang][dataflow] Remove `declToLocConsistent()` assertion.", "body": "As described [here](https://discourse.llvm.org/t/70086/6), there are legitimate\nnon-bug scenarios where two `DeclToLoc` maps to be joined contain different\nstorage locations for the same declaration. This patch also adds a test\ncontaining an example of such a situation. (The test fails without the other\nchanges in this patch.)\n\nWith the assertion removed, the existing logic in `intersectDenseMaps()` will\nremove the corresponding declaration from the joined DeclToLoc map.\n\nWe also remove `removeDecl()`'s precondition (that the declaration must be\nassociated with a storage location) because this may no longer hold if the\ndeclaration was previously removed during a join, as described above.\n", "feature_layers": ["sema"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/unittests/Analysis/FlowSensitive/TransferTest.cpp", "functions": ["target", "begin", "end"]}]}
{"pr_number": 67990, "url": "https://github.com/llvm/llvm-project/pull/67990", "title": "[clang][Interp] Only emit function_param_value_unknown in C++11", "body": "This is also what the current interpreter does.\r\n\r\nNo test for now since the only reproducer I have is from https://reviews.llvm.org/D156565 and doesn't work without that patch.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/SemaCXX/offsetof.cpp", "functions": ["test_ice"]}]}
{"pr_number": 67814, "url": "https://github.com/llvm/llvm-project/pull/67814", "title": "[clang][Interp] Handle variadic functions", "body": "Similarly to the code we already had for builtin functions, we need to check the call expression for the arguments passed.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/AST/Interp/Interp.cpp", "functions": ["popBuiltinArgs", "popArg", "cleanupAfterFunctionCall"]}, {"filename": "clang/test/AST/Interp/functions.cpp", "functions": ["f1", "int", "variadic_function2", "variadic_function"]}]}
{"pr_number": 69790, "url": "https://github.com/llvm/llvm-project/pull/69790", "title": "Reland: \"[mlir][index][spirv] Add conversion for index to spirv\"", "body": "Due to an issue when lowering from scf to spirv as there was no conversion pass for index to spirv, we are motivated to add a conversion pass from the Index dialect to the SPIR-V dialect. Furthermore, we add the new conversion patterns to the scf-to-spirv conversion.\r\n\r\nFixes https://github.com/llvm/llvm-project/issues/63713", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Conversion/IndexToSPIRV/IndexToSPIRV.cpp", "functions": ["runOnOperation", "success", "typeConverter", "patterns"]}]}
{"pr_number": 67663, "url": "https://github.com/llvm/llvm-project/pull/67663", "title": "[analyzer][clangsa] Add new option to alpha.security.cert.InvalidPtrChecker", "body": "**This PR is a continuation of the Phabricator review https://reviews.llvm.org/D154603**\r\n\r\nThe invalidation of pointer pointers returned by subsequent calls to genenv is\r\nsuggested by the POSIX standard, but is too strict from a practical point of\r\nview. A new checker option 'InvalidatingGetEnv' is introduced, and is set to a\r\nmore lax default value, which does not consider consecutive getenv calls\r\ninvalidating.\r\nThe handling of the main function's possible specification where an environment\r\npointer is also pecified as a third parameter is also considered now.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "clang/test/Analysis/cert/env34-c-cert-examples.c", "functions": ["setenv", "incorrect_usage_double_getenv_invalidation", "incorrect_usage_setenv_getenv_invalidation", "incorrect_usage"]}, {"filename": "clang/test/Analysis/invalid-ptr-checker.c", "functions": ["multiple_invalidation_no_duplicate_notes"]}, {"filename": "clang/lib/StaticAnalyzer/Checkers/cert/InvalidPtrChecker.cpp", "functions": ["InitInvalidPtrBugType"]}]}
{"pr_number": 68526, "url": "https://github.com/llvm/llvm-project/pull/68526", "title": "[mlir][linalg] Enable CollapseLinalgDimensions to collapse linalg::CopyOp", "body": "- [mlir][linalg] Enable CollapseLinalgDimensions to collapse memref based operations\r\n- [mlir][linalg] Enable CollapseLinalgDimensions to collapse linalg::CopyOp\r\n", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/Linalg/Transforms/ElementwiseOpFusion.cpp", "functions": ["getCollapsedOpIndexingMap"]}]}
{"pr_number": 69773, "url": "https://github.com/llvm/llvm-project/pull/69773", "title": "[flang][OpenMP] Fix LASTPRIVATE for iteration variables", "body": "Iteration variables behave slightly different with LASTPRIVATE,\nas they must be assigned the value that the copy would have after\nsequential execution of the loop. This case is now handled.\n\nThis patch also fixes LASTPRIVATE for loops where the step is\ndifferent from 1.\n\nFixes https://github.com/llvm/llvm-project/issues/64055\n", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Lower/OpenMP.cpp", "functions": ["setLoopIV"]}]}
{"pr_number": 67540, "url": "https://github.com/llvm/llvm-project/pull/67540", "title": "[builtins] Convert more int to fp functions to use common implementation", "body": "Builds on #66903, converting the rest of the low-hanging fruit to use the common implementation.\r\n\r\nI was holding off posting more of the patch series as it's (sadly) rather awkward on GitHub. But I'll post this next patch in the hope it better demonstrates the direction.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "compiler-rt/lib/builtins/floatdisf.c", "functions": ["__floatdisf"]}, {"filename": "compiler-rt/lib/builtins/floattidf.c", "functions": ["__floattidf"]}, {"filename": "compiler-rt/lib/builtins/floattisf.c", "functions": ["__floattisf"]}, {"filename": "compiler-rt/lib/builtins/floattitf.c", "functions": ["__floattitf"]}, {"filename": "compiler-rt/lib/builtins/floatundisf.c", "functions": ["__floatundisf"]}, {"filename": "compiler-rt/lib/builtins/floatuntidf.c", "functions": ["__floatuntidf"]}, {"filename": "compiler-rt/lib/builtins/floatuntisf.c", "functions": ["__floatuntisf"]}, {"filename": "compiler-rt/lib/builtins/floatuntitf.c", "functions": ["__floatuntitf"]}]}
{"pr_number": 70040, "url": "https://github.com/llvm/llvm-project/pull/70040", "title": "[mlir] use transform-interpreter in test passes", "body": "Update most test passes to use the transform-interpreter pass instead of the test-transform-dialect-interpreter-pass. The new \"main\" interpreter pass has a named entry point instead of looking up the top-level op with `PossibleTopLevelOpTrait`, which is arguably a more understandable interface. The change is mechanical, rewriting an unnamed sequence into a named one and wrapping the transform IR in to a module when necessary.\r\n\r\nAdd an option to the transform-interpreter pass to target a tagged payload op instead of the root anchor op, which is also useful for repro generation.\r\n\r\nOnly the test in the transform dialect proper and the examples have not been updated yet. These will be updated separately after a more careful consideration of testing coverage of the transform interpreter logic.", "feature_layers": ["ir"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "mlir/lib/Dialect/Transform/Transforms/InterpreterPass.cpp", "functions": ["signalPassFailure"]}]}
{"pr_number": 69331, "url": "https://github.com/llvm/llvm-project/pull/69331", "title": "[mlir][transform] Improve error when merging of modules fails.", "body": "This resolved #69112.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Transform/Transforms/TransformInterpreterPassBase.cpp", "functions": ["emitError"]}, {"filename": "mlir/lib/Dialect/Transform/Transforms/TransformInterpreterUtils.cpp", "functions": ["InFlightDiagnostic", "success", "failure"]}]}
{"pr_number": 68878, "url": "https://github.com/llvm/llvm-project/pull/68878", "title": "[clang]Transform uninstantiated ExceptionSpec in TemplateInstantiator", "body": "Fixes #68543, #42496", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/SemaCXX/dependent-noexcept-uninstantiated.cpp", "functions": ["f0"]}]}
{"pr_number": 69936, "url": "https://github.com/llvm/llvm-project/pull/69936", "title": "[flang][openacc] Allow acc routine at the top level", "body": "Some compilers allow the `$acc routine(<name>)` to be placed at the program unit level. To be compatible, this patch enables the use of acc routine at this level. These acc routine directives must have a name.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "flang/lib/Lower/Bridge.cpp", "functions": ["genFIR"]}, {"filename": "flang/lib/Lower/PFTBuilder.cpp", "functions": ["enterConstructOrDirective", "Pre", "getNodeIndex"]}, {"filename": "flang/lib/Semantics/resolve-directives.cpp", "functions": ["PushContext", "DirectiveAttributeVisitor", "AccAttributeVisitor"]}, {"filename": "flang/lib/Semantics/resolve-names.cpp", "functions": ["constexpr"]}]}
{"pr_number": 68640, "url": "https://github.com/llvm/llvm-project/pull/68640", "title": "[flang][openacc] Support assumed shape array in firstprivate recipe", "body": "Add support for assumed shape arrays in lowering of the copy region of the firstprivate recipe. Information is passed in block arguments as it is done for the reduction recipe. ", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Lower/OpenACC.cpp", "functions": ["isConstantBound", "areAllBoundConstant"]}]}
{"pr_number": 68261, "url": "https://github.com/llvm/llvm-project/pull/68261", "title": "[flang][openacc] Add support for allocatable and pointer arrays in reduction", "body": "This patch adds support for allocatable and pointer arrays in the reduction recipe lowering.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Lower/OpenACC.cpp", "functions": ["getReductionInitValue", "extractSequenceType", "isSupportedReductionType"]}, {"filename": "flang/lib/Optimizer/Dialect/FIRType.cpp", "functions": ["isAllocatableOrPointerArray"]}]}
{"pr_number": 69672, "url": "https://github.com/llvm/llvm-project/pull/69672", "title": "[ModuleInliner] Remove an extraneous pair of std::push_heap and std::pop_heap (NFC)", "body": "Immediately after the \"while\" loop in adjust, Heap.back() is\nguaranteed to be the highest priority item for the current values of\nPriorities.  std::push_back() at the end of adjust moves the highest\npriority item to Heap.front(), but std::pop_heap() in pop moves it\nright back to Heap.back().\n\nThis roundtrip is wasteful.  This patch removes the extraneous pair of\nstd::push_heap and std::pop_heap.  This patch cuts down about 45% of\ncalls to std::push_heap and std::pop_heap in InlineOrder.cpp while\nbuilding clang with FDO+ThinLTO.\n\nStrictly speaking, removing the pair of calls may change the order in\nwhich call sites with identical priorities are removed from the\npriority queue, but we do not need to worry about that.\n\nSince the functionality of adjust becomes more like a smart version of\npop_heap, this patch renames adjust to pop_heap_adjust.\n", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Analysis/InlineOrder.cpp", "functions": ["adjust", "pop_heap_adjust"]}]}
{"pr_number": 70035, "url": "https://github.com/llvm/llvm-project/pull/70035", "title": "[SLP] Fix condition for avoiding scheduling of instructions", "body": "To correctly avoid scheduling we must ensure that the instruction isn't used in the same basic block AND it's operands are not instructions themselves.\r\n\r\nFixes #70004.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp", "functions": ["areAllOperandsNonInsts", "isUsedOutsideBlock", "isOnlyUsedOutsideBlock"]}]}
{"pr_number": 69963, "url": "https://github.com/llvm/llvm-project/pull/69963", "title": "Revert \"[clang] Support fixed point types in C++ (#67750)\"", "body": "This reverts commit a3a7d6318027bb86e6614c022e77e0bd81aef6dc.\r\n\r\nWhen compiling with MSVC2022 in  C++32 mode this is giving an error.\r\nCompiling this simple test case:\r\nt1.cpp:\r\nwith -std=c++23 will give the following error:\r\n\r\nIn file included from C:\\Users\\zahiraam\\t1.cpp:1:\r\nc:\\Program files\\Microsoft Visual Studio\\2022\\Professional\\VC\\Tools\\MSVC\\14.35.32215\\include\\vector:3329:16: error:\r\n      compile with '-ffixed-point' to enable fixed point types\r\n 3329 |         _Vbase _Accum = 0;\r\n      |                ^\r\nc:\\Program files\\Microsoft Visual Studio\\2022\\Professional\\VC\\Tools\\MSVC\\14.35.32215\\include\\vector:3329:23: error:\r\n      expected unqualified-id\r\n 3329 |         _Vbase _Accum = 0;\r\n      |                       ^\r\nc:\\Program files\\Microsoft Visual Studio\\2022\\Professional\\VC\\Tools\\MSVC\\14.35.32215\\include\\vector:3334:13: error:\r\n      compile with '-ffixed-point' to enable fixed point types\r\n 3334 |             _Accum |= _Tmp ? _Mask : _Vbase{0};\r\n      |             ^\r\nc:\\Program files\\Microsoft Visual Studio\\2022\\Professional\\VC\\Tools\\MSVC\\14.35.32215\\include\\vector:3334:20: error:\r\n      expected unqualified-id\r\n 3334 |             _Accum |= _Tmp ? _Mask : _Vbase{0};\r\n      |                    ^\r\nc:\\Program files\\Microsoft Visual Studio\\2022\\Professional\\VC\\Tools\\MSVC\\14.35.32215\\include\\vector:3336:53: error:\r\n      expected '(' for function-style cast or type construction\r\n 3336 |                 this->_Emplace_back_unchecked(_Accum);\r\n      |                                               ~~~~~~^\r\nc:\\Program files\\Microsoft Visual Studio\\2022\\Professional\\VC\\Tools\\MSVC\\14.35.32215\\include\\vector:3337:17: error:\r\n      compile with '-ffixed-point' to enable fixed point types\r\n 3337 |                 _Accum = 0;\r\n      |                 ^\r\nc:\\Program files\\Microsoft Visual Studio\\2022\\Professional\\VC\\Tools\\MSVC\\14.35.32215\\include\\vector:3337:24: error:\r\n      expected unqualified-id\r\n 3337 |                 _Accum = 0;\r\n      |                        ^\r\nc:\\Program files\\Microsoft Visual Studio\\2022\\Professional\\VC\\Tools\\MSVC\\14.35.32215\\include\\vector:3343:49: error:\r\n      expected '(' for function-style cast or type construction\r\n 3343 |             this->_Emplace_back_unchecked(_Accum);\r\n      |                                           ~~~~~~^\r\nc:\\Program files\\Microsoft Visual Studio\\2022\\Professional\\VC\\Tools\\MSVC\\14.35.32215\\include\\vector:3352:16: error:\r\n      compile with '-ffixed-point' to enable fixed point types\r\n 3352 |         _Vbase _Accum    = 0;\r\n      |                ^\r\nc:\\Program files\\Microsoft Visual Studio\\2022\\Professional\\VC\\Tools\\MSVC\\14.35.32215\\include\\vector:3352:26: error:\r\n      expected unqualified-id\r\n 3352 |         _Vbase _Accum    = 0;\r\n      |                          ^\r\nc:\\Program files\\Microsoft Visual Studio\\2022\\Professional\\VC\\Tools\\MSVC\\14.35.32215\\include\\vector:3357:13: error:\r\n      compile with '-ffixed-point' to enable fixed point types\r\n 3357 |             _Accum |= _Tmp ? _Mask : _Vbase{0};\r\n      |             ^\r\nc:\\Program files\\Microsoft Visual Studio\\2022\\Professional\\VC\\Tools\\MSVC\\14.35.32215\\include\\vector:3357:20: error:\r\n      expected unqualified-id\r\n 3357 |             _Accum |= _Tmp ? _Mask : _Vbase{0};\r\n      |                    ^\r\nc:\\Program files\\Microsoft Visual Studio\\2022\\Professional\\VC\\Tools\\MSVC\\14.35.32215\\include\\vector:3359:46: error:\r\n      expected '(' for function-style cast or type construction\r\n 3359 |                 this->_Myvec.push_back(_Accum);\r\n      |                                        ~~~~~~^\r\nc:\\Program files\\Microsoft Visual Studio\\2022\\Professional\\VC\\Tools\\MSVC\\14.35.32215\\include\\vector:3360:17: error:\r\n      compile with '-ffixed-point' to enable fixed point types\r\n 3360 |                 _Accum = 0;\r\n      |                 ^\r\nc:\\Program files\\Microsoft Visual Studio\\2022\\Professional\\VC\\Tools\\MSVC\\14.35.32215\\include\\vector:3360:24: error:\r\n      expected unqualified-id\r\n 3360 |                 _Accum = 0;\r\n      |                        ^\r\nc:\\Program files\\Microsoft Visual Studio\\2022\\Professional\\VC\\Tools\\MSVC\\14.35.32215\\include\\vector:3366:42: error:\r\n      expected '(' for function-style cast or type construction\r\n 3366 |             this->_Myvec.push_back(_Accum);\r\n      |                                    ~~~~~~^\r\n16 errors generated.\r\n\r\nSee also comment here: https://github.com/llvm/llvm-project/pull/67750#issuecomment-1775264907", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CodeGenCXX/fixed-point-mangle.cpp", "functions": ["func", "func2"]}]}
{"pr_number": 69843, "url": "https://github.com/llvm/llvm-project/pull/69843", "title": "[mlir][tosa] Add verifiers to ReduceOps, fix shape inference crash", "body": "The `tosa.reduce_*` ops take an `axis` Attribute that determines along which dimension the reduction takes place. A crash can occur during shape inference when the input tensor rank is so low that the given axis doesn't exist.\r\n\r\nFix https://github.com/llvm/llvm-project/issues/68187\r\n", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/Tosa/IR/TosaOps.cpp", "functions": ["failure"]}]}
{"pr_number": 70000, "url": "https://github.com/llvm/llvm-project/pull/70000", "title": "[BOLT] Fix incorrect basic block output addresses", "body": "Some optimization passes may duplicate basic blocks and assign the same input offset to a number of different blocks in a function. This is done e.g. to correctly map debugging ranges for duplicated code.\r\n\r\nHowever, duplicate input offsets present a problem when we use AddressMap to generate new addresses for basic blocks. The output address is calculated based on the input offset and will be the same for blocks with identical offsets. The result is potentially incorrect debug info and BAT records.\r\n\r\nTo address the issue, we have to eliminate the dependency on input offsets while generating output addresses for a basic block. Each block has a unique label, hence we extend AddressMap to include address lookup based on MCSymbol and use the new functionality to update block addresses.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "bolt/lib/Core/AddressMap.cpp", "functions": ["DE", "emitLabel", "Cursor"]}]}
{"pr_number": 67723, "url": "https://github.com/llvm/llvm-project/pull/67723", "title": "[OpenMPIRBuilder] Remove wrapper function in `createTask`, `createTeams`", "body": "This patch removes the wrapper function in `OpenMPIRBuilder::createTask` and `OpenMPIRBuilder.createTeams`. The outlined function is directly of the form that is expected by the runtime library calls. This patch also adds a utility function to help add fake values and their uses, which will be deleted in finalization callbacks.\r\n\r\n**Why we needed wrappers earlier?**\r\nBefore the post outline callbacks are executed, the IR has the following structure:\r\n```\r\ndefine @func() {\r\n  ;...\r\n  call void @outlined_fn(ptr %data)\r\n  ;...\r\n}\r\ndefine void @outlined_fn(ptr %data)\r\n```\r\nOpenMP offloading expects a specific signature for the outlined function in a runtime call. For example, `__kmpc_fork_teams` expects the following signature:\r\n```\r\ndefine @outlined_fn(ptr %global.tid, ptr %data)\r\n```\r\nAs there is no way to change a function's arguments after it has been created, a wrapper function with the expected signature is created that calls the outlined function inside it. \r\n\r\n**How we are handling it now?**\r\nTo handle this in the current patch, we create a \"fake\" global tid and add a \"fake\" use for it in the to-be-outlined region. We need to create these fake values so the outliner sees it as something it needs to pass to the outlined function. We also tell the outliner to exclude this global tid value from the aggregate `data` argument, so it comes as a separate argument in the beginning. This way, we are able to directly get the outlined function in the expected format. This is inspired by the way `createParallel` handles outlining (using fake values and then deleting them later). Tasks are handled with a similar approach. This simplifies the generated code and the code to do this itself also becomes simpler (because we no longer have to construct a new function).", "feature_layers": ["runtime", "ir"], "feature_directives": ["task", "parallel", "for", "teams"], "files_changed": [{"filename": "llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp", "functions": ["OuterAllocaIP"]}]}
{"pr_number": 69759, "url": "https://github.com/llvm/llvm-project/pull/69759", "title": "[RISCV][VSETVLI] Prefer VTYPE for immediate known to be less than VLMAX", "body": "If we have a vsetvli which is toggling from a state with a constant AVL, to a state with the same constant AVL, then the vsetvli can use the x0, x0 VL preserving form provided that said VL is less than or equal to the minimal VLMAX of either state.  (i.e. that AVL=VL for both states)\r\n\r\nVTYPE-only toggles are generally cheaper, and these patterns show up a lot with mixed width arithmetic and large types which have been legalized via splitting.\r\n\r\nMeta comments for the review:\r\n* I noticed this opportunity in the delta from https://github.com/llvm/llvm-project/pull/69259.  I honestly feel quite silly for never noticing it before as it turned out to be both fairly trivial to implement and quite wide spread.\r\n* There's two refactorings in the current patch - one is just code motion and a rename, the other is adding the subtarget variable to the pass.  Happy to separate these and land them if reviewers find it helpful.  ", "feature_layers": ["ir"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp", "functions": ["hasFixedResult", "willVLBeAVL"]}]}
{"pr_number": 69532, "url": "https://github.com/llvm/llvm-project/pull/69532", "title": "[AArch64][GlobalISel] Add support for post-indexed loads/stores.", "body": "Gives small code size improvements across the board at -Os CTMark.\r\n\r\nMuch of the work is porting the existing heuristics in the DAGCombiner.\r\n\r\nThis is part of a stack of changes: https://github.com/llvm/llvm-project/pull/69533", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp", "functions": ["getIndexedOpc"]}, {"filename": "llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp", "functions": ["selectIndexedLoad", "selectIndexedStore"]}]}
{"pr_number": 69718, "url": "https://github.com/llvm/llvm-project/pull/69718", "title": "Add support for DFP IR type.", "body": "Add decimal32, decimal64 and decimal128 IR types.\r\nStill to be done:\r\nAPFloat\r\nConstant Folding", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/IR/Type.cpp", "functions": ["getDecimal32Ty", "getDecimal64Ty", "getDecimal128Ty"]}]}
{"pr_number": 69775, "url": "https://github.com/llvm/llvm-project/pull/69775", "title": "[clangd] Fix RawStringLiteral being available to C and C++ versions prior to C++11", "body": "The `RawStringLiteral` code action runs both on C and C++ versions prior to C++11, where this feature is unavailable.\r\n\r\nThis patch adds a condition to check if the context is running a version equal or greater than C++11 and adds tests for failing in the wrong versions.\r\n\r\nFixes https://github.com/clangd/clangd/issues/1795.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang-tools-extra/clangd/refactor/tweaks/RawStringLiteral.cpp", "functions": ["isFeatureAvailable"]}]}
{"pr_number": 70127, "url": "https://github.com/llvm/llvm-project/pull/70127", "title": "Dfpir types", "body": "", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "clang/lib/Sema/SemaChecking.cpp", "functions": ["Diag"]}, {"filename": "clang/test/Driver/dfp-enablement-lang.c", "functions": ["__attribute__"]}, {"filename": "clang/test/Sema/dfp-types.c", "functions": ["test_generic", "__attribute", "__attribute__", "test_d64", "test_builtin_complex", "test_d32", "test_d128"]}, {"filename": "clang/test/SemaCXX/dfp-types.cpp", "functions": ["__attribute"]}, {"filename": "llvm/lib/IR/Type.cpp", "functions": ["getDecimal32Ty", "getDecimal64Ty", "getDecimal128Ty"]}]}
{"pr_number": 69972, "url": "https://github.com/llvm/llvm-project/pull/69972", "title": "[RISCV][GISel] Add ISel support for SHXADD_UW and SLLI.UW", "body": "This patch also includes:\r\n  - Remove legacy non_imm12 PatLeaf from RISCVInstrInfoZb.td\r\n  - Implement a custom GlobalISel operand renderer for TrailingZeros SDNodeXForm", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp", "functions": ["selectSHXADD_UWOp"]}]}
{"pr_number": 69283, "url": "https://github.com/llvm/llvm-project/pull/69283", "title": "`clangd`: support `-stdlib=` flags from `compile_commands.json`.", "body": "The `--stdlib` flag can affect the system headers used by `clang` during compilation. By default, `clang` will use the platform-installed C++ standard headers, but with `--stdlib=libc++`, `clang` can use headers included in the distribution for its `libc++` implementation.\r\n\r\nPrior to this patch, if `compile_commands.json` specified `-stdlib=libc++` or an equivalent form and `--query-driver` took effect, `clangd` would ignore `stdlib` and index based on the platform's headers. When these mismatch, e.g. due to version differences, `clangd`'s completions and the actual compilation can differ.\r\n\r\nfixes clangd/clangd#1784", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang-tools-extra/clangd/SystemIncludeExtractor.cpp", "functions": ["if"]}]}
{"pr_number": 69238, "url": "https://github.com/llvm/llvm-project/pull/69238", "title": "[lldb-vscode] Allow specifying a custom escape prefix for LLDB commands", "body": "We've been using the backtick as our escape character, however that leads to a weird experience on VS Code, because on most hosts, as soon as you type the backtick on VS Code, the IDE will introduce another backtick. As changing the default escape character might be out of question because other plugins might rely on it, we can instead introduce an option to change this variable upon lldb-vscode initialization.\nFWIW, my users will be using : instead ot the backtick.\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "lldb/tools/lldb-dap/JSONUtils.cpp", "functions": ["GetString"]}]}
{"pr_number": 69944, "url": "https://github.com/llvm/llvm-project/pull/69944", "title": "[flang] Allow lowering of sub-expressions to be overridden", "body": "OpenACC/OpenMP atomic lowering needs a finer control over expression lowering. This patch allows mapping evaluate::Expr<T> to mlir::Value so that any subsequent expression lowering will use these values when an operand is a mapped Expr<T>.\r\n\r\nThis is an alternative to https://github.com/llvm/llvm-project/pull/69866 From which I took the test.\r\n\r\nThe same tests as in https://github.com/llvm/llvm-project/pull/69866 are failing because the \"non atomic part\" is now out of the atomic.update op, which in some cases is causing verification failures because this is generated in the middle of an omp.atomic.capture. I did not try fixing these failures. My patch is about the lowering infrastructure and how to use it rather than the OpenMP semantics.", "feature_layers": ["sema", "ir", "ast"], "feature_directives": ["atomic"], "files_changed": [{"filename": "flang/lib/Lower/ConvertExpr.cpp", "functions": ["getIfOverridenExpr"]}, {"filename": "flang/lib/Lower/ConvertExprToHLFIR.cpp", "functions": ["constexpr"]}]}
{"pr_number": 69692, "url": "https://github.com/llvm/llvm-project/pull/69692", "title": "[flang][codegen] Update FIR codegen to use mlir.llvm opaque pointers", "body": "!llvm.ptr<T> typed pointers are depreciated in MLIR LLVM dialects. Flang codegen still generated them and relied on mlir.llvm codegen to LLVM to turn them into opaque pointers.\r\n\r\nThis patch update FIR codegen to directly emit and work with LLVM opaque pointers.\r\n\r\nAddresses https://github.com/llvm/llvm-project/issues/69303\r\n\r\n@kiranchandramohan and @TIFitis, this patch cannot be merged currently because the MLIR OpenMP dialect OpenMPToLLVMIRTranslation codegen pass relies on getting typed pointers (* see [1] below) and needs to be updated first.\r\nBut this patch is still submitted for review to help the OpenMP dialect update. See failing flang test OpenMP/FIR/function-filtering.f90.\r\n\r\n- All places generating GEPs need to add an extra type argument with the base type (the T that was previously in the llvm.ptr<T> of the base).\r\n\r\n- llvm.alloca must also be provided the object type. In the process, I doscovered that we were shamelessly copying all the attribute from fir.alloca to the llvm.alloca, which makes no sense for the operand segments. The updated code that cannot take an attribute dictionnary in the llvm.alloca builder with opaque pointers only propagate the \"pinned\" and \"bindc_name\" attributes to help debugging the generated IR.\r\n\r\n- Updating all the places that rely on getting the llvm object type from lowered llvm.ptr<T> arguments to get it from a type conversion of the original fir types.\r\n\r\n- Updating all the places that were generating llvm.ptr<T> types to generate the opaque llvm.ptr type.\r\n\r\n- Updating all the codegen tests checking generated MLIR llvm dialect. Many tests are testing directly LLVM IR, and this change is a no-op for those (which is expected).\r\n\r\n[1]: https://github.com/llvm/llvm-project/blob/54881c9225e612830a9e78574a805309b516627b/mlir/lib/Target/LLVMIR/Dialect/OpenMP/OpenMPToLLVMIRTranslation.cpp#L1542", "feature_layers": ["codegen", "ir"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "flang/lib/Optimizer/CodeGen/CodeGen.cpp", "functions": ["getI8Type", "voidPtrTy", "doRewriteBox", "getBoxEleTy", "computeElementDistance", "getBoxTypePair", "lowerTy", "convertObjectType", "getLlvmObjectTypeFromBoxType", "getVoidPtrType", "getBaseAddrTypeFromBox", "doRewriteRefOrPtr", "getLlvmPtrType"]}, {"filename": "flang/lib/Optimizer/CodeGen/TypeConverter.cpp", "functions": ["convertBoxType"]}]}
{"pr_number": 69705, "url": "https://github.com/llvm/llvm-project/pull/69705", "title": "[mlir][transform] Handle multiple library preloading passes.", "body": "This is a new attempt at #69320.\r\n\r\nThe transform dialect stores a \"library module\" that the preload pass\r\ncan populate. Until now, each pass registered an additional module by\r\nsimply pushing it to a vector; however, the interpreter only used the\r\nfirst of them. This commit turns the registration into \"loading\", i.e.,\r\neach newly added module gets merged into the existing one. This allows\r\nthe loading to be split into several passes, and using the library in\r\nthe interpreter now takes all of them into account. While this design\r\navoids repeated merging every time the library is accessed, it requires\r\nthat the implementation of merging modules lives in the\r\nTransformDialect target (since it at the dialect depend on each\r\nother).\r\n\r\nThis resolves https://github.com/llvm/llvm-project/issues/69111.", "feature_layers": ["ir"], "feature_directives": ["for", "target", "requires"], "files_changed": [{"filename": "mlir/lib/Dialect/Transform/IR/Utils.cpp", "functions": ["InFlightDiagnostic", "otherSymbolTable", "targetSymbolTable", "if", "canMergeInto"]}, {"filename": "mlir/lib/Dialect/Transform/Transforms/TransformInterpreterUtils.cpp", "functions": ["success"]}]}
{"pr_number": 69681, "url": "https://github.com/llvm/llvm-project/pull/69681", "title": "[Clang][DebugInfo] Clang generates an extra spurious unnamed 'dbg.declare'", "body": "Do not emit call to llvm.dbg.declare when the variable declaration\r\nis a DecompositionDecl as its instance class is always unnamed.\r\n\r\nThe emitted debug declare looks like:\r\n```\r\ncall void @llvm.dbg.declare(metadata ..., metadata !xx, metadata ...)\r\n!xx = !DILocalVariable(scope: !..., file: !..., line: ..., type: !...)\r\n```\r\n", "feature_layers": [], "feature_directives": ["declare"], "files_changed": [{"filename": "clang/test/CodeGenCXX/debug-info-structured-binding-field.cpp", "functions": ["main"]}]}
{"pr_number": 70174, "url": "https://github.com/llvm/llvm-project/pull/70174", "title": "[mlir][LLVM] Verify too many indices in GEP verifier", "body": "The current verifier stopped verification with a success value as soon as a type was encountered that cannot be indexed into. The correct behaviour in this case is to error out as there are too many indices for the element type. Not doing so leads to bad user-experience as an invalid GEP is likely to fail only later during LLVM IR translation.\r\n\r\nThis PR implements the correct verification behaviour. Some tests upstream had to also be fixed as they were creating invalid GEPs.\r\n\r\nFixes https://github.com/llvm/llvm-project/issues/70168", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/LLVMIR/IR/LLVMDialect.cpp", "functions": ["log", "GEPIndexError", "convertToErrorCode"]}]}
{"pr_number": 68727, "url": "https://github.com/llvm/llvm-project/pull/68727", "title": "[flang] add tbaa tags to global and direct values", "body": "The commit to be reviewed here is ba1bbbe7f9af23e1814faa40223d330a3f9553b5 (and any fixups). The others are from previous \"stacked PRs\", the previous one is https://github.com/llvm/llvm-project/pull/68595\r\n\r\nThese turn out to be useful for spec2017/fotonik3d and are safe so long as\r\nthey are not used along side TBAA tags for local allocations. LLVM may\r\nbe able to figure out local allocations by itself anyway.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Optimizer/Analysis/TBAAForest.cpp", "functions": ["globalDataTree"]}, {"filename": "flang/lib/Optimizer/Transforms/AddAliasTags.cpp", "functions": ["getDeclareOp"]}, {"filename": "flang/lib/Optimizer/CodeGen/TBAABuilder.cpp", "functions": ["enableTBAA", "getAnyDataAccessTag", "getAnyBoxAccessTag"]}]}
{"pr_number": 70037, "url": "https://github.com/llvm/llvm-project/pull/70037", "title": "[LLD] [MinGW] Hook up --icf=safe to -opt:safeicf", "body": "Back when the --icf= option was hooked up in the MinGW frontend in LLD, in 2017, lld-link didn't support safe ICF, and mapping it to noicf was suggested in review: https://reviews.llvm.org/D40019\r\n\r\nLater in 2021, lld-link did get support for safe ICF in 5bdc5e7efda4100c4d11085c2da8f1fb932ccce4 / https://reviews.llvm.org/D97436.\r\n\r\nHook this up for the MinGW frontend as well.", "feature_layers": ["frontend"], "feature_directives": ["for"], "files_changed": [{"filename": "lld/MinGW/Driver.cpp", "functions": ["if"]}]}
{"pr_number": 70107, "url": "https://github.com/llvm/llvm-project/pull/70107", "title": "[C23] Use thread_local semantics", "body": "When implementing thread_local as a keyword in C23, we accidentally started using C++11 thread_local semantics when using that keyword instead of using C11 _Thread_local semantics.\r\n\r\nThis oversight is fixed by pretending the user wrote _Thread_local instead. This doesn't have the best behavior in terms of diagnostics, but it does correct the semantic behavior.\r\n\r\nFixes https://github.com/llvm/llvm-project/issues/70068", "feature_layers": ["sema"], "feature_directives": [], "files_changed": [{"filename": "clang/test/CodeGen/thread_local.c", "functions": ["func"]}, {"filename": "clang/test/Sema/thread_local.c", "functions": ["func"]}]}
{"pr_number": 69958, "url": "https://github.com/llvm/llvm-project/pull/69958", "title": "[SystemZ][NFC] Fix a couple of style issues", "body": "Some fixes for style issues pointed out by clang-tidy:\r\n\r\n- Upper case/lower case fixes\r\n- No else after return\r\n- Removed unused #include's\r\n- Added NOLINTNEXTLINE() for the LLVM* functions\r\n\r\nAll changes are NFC.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp", "functions": ["Kind"]}, {"filename": "llvm/lib/Target/SystemZ/MCTargetDesc/SystemZMCCodeEmitter.cpp", "functions": ["MCII"]}]}
{"pr_number": 70116, "url": "https://github.com/llvm/llvm-project/pull/70116", "title": "[Offloading][NFC] Move creation of offloading entries from OpenMP", "body": "Summary:\r\nThis patch is a first step to remove dependencies on the OpenMPIRBuilder\r\nfor creating generic offloading entries. This patch changes no\r\nfunctionality and merely moves the code around. In the future the\r\ninterface will be changed to allow for more code re-use in the\r\nregistration and creation of offloading entries as well as a more\r\ngeneric interface for CUDA, HIP, OpenMP, and SYCL(?). Doing this as a\r\nfirst step to reduce the noise involved in the functional changes.\r\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/CodeGen/CGCUDANV.cpp", "functions": ["OMPBuilder"]}]}
{"pr_number": 69916, "url": "https://github.com/llvm/llvm-project/pull/69916", "title": "[clang][NFC] Refactor `Selector` to use `PointerIntPair` inside", "body": "Refactor `uintptr_t` inside of `clang::Selector` that holds a pointer to `IdentifierInfo` or `MultiKeywordSelector` and `IdentifierInfoFlag` enum into `PointerIntPair`. This is a part of `PointerIntPair` migration outlined in https://github.com/llvm/llvm-project/issues/69835, and a necessary step toward the same refactoring of `clang::DeclarationName`.\r\n\r\nUnlike `uintpt_t`, `PointerIntPair` required pointee types to be complete, so I had to shuffle definitions of `MultiKeywordSelector` and `detail::DeclarationNameExtra` around to make them complete at `Selector`. Also, there were outdated specializations of `PointerLikeTypeTraits` for `IdentifierInfo *`, which are no longer needed, because `alignof` that primary template use works just fine. Not just that, but they declared that `IdentifierInfo *` has only 1 spare lower bit, but today they are 8-byte aligned.", "feature_layers": ["ir"], "feature_directives": ["for", "declare"], "files_changed": [{"filename": "clang/lib/Basic/IdentifierTable.cpp", "functions": ["alignas", "keyword_end", "getName", "Profile", "DeclarationNameExtra", "keyword_begin"]}]}
{"pr_number": 65974, "url": "https://github.com/llvm/llvm-project/pull/65974", "title": "[lldb] Treat user aliases the same as built-ins when tab completing", "body": "Previously we would check all built-ins first for suggestions,\r\nthen check built-ins and aliases. This meant that if you had\r\nan alias brkpt -> breakpoint, \"br\" would complete to \"breakpoint\".\r\n\r\nInstead of giving you the choice of \"brkpt\" or \"breakpoint\".", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "lldb/source/Interpreter/CommandInterpreter.cpp", "functions": ["GetCommandSP"]}]}
{"pr_number": 70046, "url": "https://github.com/llvm/llvm-project/pull/70046", "title": "[clang][dataflow] Add `Environment::allows()`.", "body": "This allows querying whether, given the flow condition, a certain formula still\nhas a solution (though it is not necessarily implied by the flow condition, as\n`flowConditionImplies()` would check).\n\nThis can be checked today, but only with a double negation, i.e. to check\nwhether, given the flow condition, a formula F has a solution, you can check\n`!Env.flowConditionImplies(Arena.makeNot(F))`. The double negation makes this\nhard to reason about, and it would be nicer to have a way of directly checking\nthis.\n\nFor consistency, this patch also renames `flowConditionImplies()` to `proves()`;\nthe old name is kept around for compatibility but deprecated.\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Analysis/FlowSensitive/DataflowAnalysisContext.cpp", "functions": ["isSatisfiable"]}]}
{"pr_number": 69595, "url": "https://github.com/llvm/llvm-project/pull/69595", "title": "[clang] Handle templated operators with reversed arguments", "body": "\r\nhttps://github.com/llvm/llvm-project/pull/68999 correctly computed conversion sequence for reversed args to a template operators. This was a breaking change as code, previously accepted in C++17, starts to break in C++20.\r\n\r\nExample:\r\n```cpp\r\nstruct P {};\r\ntemplate<class S> bool operator==(const P&, const S &);\r\n\r\nstruct A : public P {};\r\nstruct B : public P {};\r\nbool check(A a, B b) { return a == b; }  // This is now ambiguous in C++20.\r\n```\r\n\r\nIn order to minimise widespread breakages, as a clang extension, we had previously accepted such ambiguities with a warning (`-Wambiguous-reversed-operator`) for non-template operators. Due to the same reasons, we extend this relaxation for template operators.\r\n\r\nFixes https://github.com/llvm/llvm-project/issues/53954", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CXX/over/over.match/over.match.funcs/over.match.oper/p3-2a.cpp", "functions": ["fine"]}]}
{"pr_number": 69138, "url": "https://github.com/llvm/llvm-project/pull/69138", "title": "[RISCV][GISel] Add FP calling convention support", "body": "This includes support for using GPRs, FPRs, and stack. Commits are split between registers and memory.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/GISel/RISCVCallLowering.cpp", "functions": ["MemTy"]}]}
{"pr_number": 69388, "url": "https://github.com/llvm/llvm-project/pull/69388", "title": "[lldb] Refactor InstrumentationRuntimeAsan and add a new plugin", "body": "[lldb] Refactor InstrumentationRuntimeAsan and add a new plugin InstrumentationRuntimeLibsanitizers.\r\n\r\nThis commit adds InstrumentationRuntimeLibsanitizers, a new runtime plugin for ASan. The plugin provides the same\r\nfunctionality as InstrumentationRuntimeASan, but provides a different set of symbols/library names to search for while activating the plugin.\r\n\r\nThe code can be made a lot cleaner by templatizing the InstrumentationRuntimeASan class, and providing the symbol names through the template argument. However, at the moment the plugin infrastructure does not seem to support templatized plugin classes.\r\n\r\nrdar://112491689", "feature_layers": ["runtime", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "lldb/source/Plugins/InstrumentationRuntime/ASan/InstrumentationRuntimeASan.cpp", "functions": ["__asan_report_present", "__asan_get_report_access_type", "symbol_name", "__asan_get_report_access_size"]}, {"filename": "lldb/source/Plugins/InstrumentationRuntime/Utility/ReportRetriever.cpp", "functions": ["__asan_report_present", "__asan_get_report_access_type", "__asan_get_report_access_size"]}, {"filename": "lldb/source/Plugins/InstrumentationRuntime/ASanLibsanitizers/InstrumentationRuntimeASanLibsanitizers.cpp", "functions": ["InstrumentationRuntimeASanLibsanitizers"]}]}
{"pr_number": 70248, "url": "https://github.com/llvm/llvm-project/pull/70248", "title": "[mlir][sparse] add verification of absent value in sparse_tensor.unary", "body": "This value should always be a plain contant or something invariant computed outside the surrounding linalg operation, since there is no co-iteration defined on anything done in this branch.\r\n\r\nFixes:\r\nhttps://github.com/llvm/llvm-project/issues/69395", "feature_layers": ["parse", "ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/IR/SparseTensorDialect.cpp", "functions": ["failure", "emitError"]}]}
{"pr_number": 70254, "url": "https://github.com/llvm/llvm-project/pull/70254", "title": "[mlir][sparse] test for linalg tensor semantics", "body": "This test used to be here, but somehow got lost while linalg rewrote their interfaces. It is essential to test this on entry of sparsification, however, since all subsequent analysis simply assumes tensor types.\r\n\r\nFixes:\r\nhttps://github.com/llvm/llvm-project/issues/64325", "feature_layers": ["parse", "sema", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/Transforms/Sparsification.cpp", "functions": ["failure"]}]}
{"pr_number": 69075, "url": "https://github.com/llvm/llvm-project/pull/69075", "title": "[Clang] Fix dependence handling of nttp for variable templates", "body": "The dependence of a template argument is not only determined by the argument itself, but also by the type of the template parameter:\r\n\r\n> Furthermore, a non-type [template-argument](https://eel.is/c++draft/temp.names#nt:template-argument) is dependent if the corresponding non-type [template-parameter](https://eel.is/c++draft/temp.param#nt:template-parameter) is of reference or pointer type and the [template-argument](https://eel.is/c++draft/temp.names#nt:template-argument) designates or points to a member of the current instantiation or a member of a dependent type[.](https://eel.is/c++draft/temp.dep#temp-3.sentence-1)\r\n\r\nFor example:\r\n\r\n```cpp\r\nstruct A{};\r\n\r\ntemplate <const A& T>\r\nconst A JoinStringViews = T;\r\n\r\ntemplate <int V>\r\nclass Builder {\r\npublic:\r\n    static constexpr A Equal{};\r\n    static constexpr auto Val = JoinStringViews<Equal>;\r\n};\r\n```\r\n\r\nThe constant expression `Equal` is not dependent, but because the type of the template parameter is a reference type and `Equal` is a member of the current instantiation, the template argument of `JoinStringViews<Equal>` is actually dependent, which makes `JoinStringViews<Equal>` dependent.\r\n\r\nWhen a template-id of a variable template is dependent, `CheckVarTemplateId` will return an `UnresolvedLookupExpr`, but `UnresolvedLookupExpr` calculates dependence by template arguments only (the `ConstantExpr` `Equal` here), which is not dependent. This causes type deduction to think that `JoinStringViews<Equal>` is `OverloadTy` and treat it as a function template, which is clearly wrong.\r\n\r\nThis PR adds a `KnownDependent` parameter to the constructor of `UnresolvedLookupExpr`. After canonicalization, if `CanonicalConverted` contains any dependent argument, `KnownDependent` is set to `true`. This fixes the dependence calculation of  `UnresolvedLookupExpr` for dependent variable templates.\r\n\r\nFixes #65153 .", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/AST/ExprCXX.cpp", "functions": ["new"]}]}
{"pr_number": 70157, "url": "https://github.com/llvm/llvm-project/pull/70157", "title": "[LLDB][NFC] Remove DWARFASTParserClang as friend from SymbolFileDWARF", "body": "This effectively moves a few functions from protected to public. In any case, for the sake of having a cleaner SymbolFileDWARF API, it's better if it's not a friend of a one of its consumers, DWARFASTParserClang.\nAnother effect of this change is that I can use SymbolFileDWARF for the out-of-tree mojo dwarf parser, which relies on pretty much the same functions that DWARFASTParserClang needs from SymbolFileDWARF.\n", "feature_layers": ["parse", "ast", "parser"], "feature_directives": ["for"], "files_changed": [{"filename": "lldb/source/Plugins/SymbolFile/DWARF/SymbolFileDWARFDwo.cpp", "functions": ["GetBaseSymbolFile"]}]}
{"pr_number": 69983, "url": "https://github.com/llvm/llvm-project/pull/69983", "title": "[RISCV] Add an experimental pseudoinstruction to represent a rematerializable constant materialization sequence.", "body": "Rematerialization during register allocation is currently limited to a single instruction with no inputs.\r\n\r\nThis patch introduces a pseudoinstruction that represents the materialization of a constant. I've started with a sequence of 2 instructions for now, which covers at least the common LUI+ADDI(W) case. This instruction will be expanded into real instructions immediately after register allocation using a new pass. This gives the post-RA scheduler a chance to separate the 2 instructions to improve ILP.\r\n\r\nI believe this matches the approach used by AArch64.\r\n\r\nUnfortunately, this loses some CSE opportunies when an LUI value is used by multiple constants with different LSBs.\r\n\r\nThis feature is off by default and a new backend command line option is added to enable it for testing.\r\n\r\nThis avoids the spill and reloads reported in #69586.", "feature_layers": ["ast"], "feature_directives": ["for", "single"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVPostRAExpandPseudoInsts.cpp", "functions": ["expandMovImm", "getPassName", "expandMBB", "runOnMachineFunction", "RISCVPostRAExpandPseudo"]}]}
{"pr_number": 68564, "url": "https://github.com/llvm/llvm-project/pull/68564", "title": "[TableGen][NFC] Format CompressInstEmitter", "body": "Format code, fix linter warnings and format comments.\n\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/utils/TableGen/CompressInstEmitter.cpp", "functions": ["run", "SourceInst", "emitCompressInstEmitter"]}]}
{"pr_number": 70276, "url": "https://github.com/llvm/llvm-project/pull/70276", "title": "[mlir][sparse] avoid excessive macro magic", "body": "The shorthands are not even always shorter and the code is less clear than when simply written out.", "feature_layers": ["parse", "ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/IR/SparseTensorDialect.cpp", "functions": ["failure", "verifySparsifierGetterSetter", "success"]}]}
{"pr_number": 69501, "url": "https://github.com/llvm/llvm-project/pull/69501", "title": "[clang-tidy] Improved cppcoreguidelines-pro-type-const-cast", "body": "Improved cppcoreguidelines-pro-type-const-cast check to ignore casts to const type (controlled by  option) and casts in implicitly invoked code.\r\n\r\nFixes #69319", "feature_layers": ["ast"], "feature_directives": [], "files_changed": [{"filename": "clang-tools-extra/clang-tidy/cppcoreguidelines/ProTypeConstCastCheck.cpp", "functions": ["hasVolatileQualifier"]}, {"filename": "clang-tools-extra/test/clang-tidy/checkers/cppcoreguidelines/pro-type-const-cast.cpp", "functions": ["f"]}]}
{"pr_number": 69067, "url": "https://github.com/llvm/llvm-project/pull/69067", "title": "[clang-tidy] Support functional cast in bugprone-dangling-handle", "body": "Add support for constructor conversion based functional\r\ncast. Allows to detect issues like:\r\nconst std::string_view test1 = std::string(a);\r\n", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang-tools-extra/clang-tidy/bugprone/DanglingHandleCheck.cpp", "functions": ["handleFrom"]}]}
{"pr_number": 69575, "url": "https://github.com/llvm/llvm-project/pull/69575", "title": "[Support] Better error msg when cache dir can't be created.", "body": "On windows if you passed /lldltocache:D:\\tmp to lld and you didn't have D: mounted it fail to create the cache dir D:\\tmp, but the error message is pretty hard to understand:\r\n\r\n```\r\nc:\\code\\llvm\\llvm-project\\out\\debug>bin\\lld-link.exe /lldltocache:D:\\tmp\r\nhello.obj\r\nLLVM ERROR: no such file or directory\r\n\r\nPLEASE submit a bug report to\r\nhttps://github.com/llvm/llvm-project/issues/ and include the crash\r\nbacktrace.\r\nException Code: 0xC000001D\r\n```\r\n\r\nWhich lead one of our users to report this as a crash. I have just added a bit better message so it now says:\r\n\r\n```\r\nc:\\code\\llvm\\llvm-project\\out\\debug>bin\\lld-link.exe /lldltocache:D:\\tmp\r\nhello.obj\r\nLLVM ERROR: Can't create cache directory: D:\\tmp\r\n\r\nPLEASE submit a bug report to\r\nhttps://github.com/llvm/llvm-project/issues/ and include the crash\r\nbacktrace.\r\n```\r\n\r\nI am not sure this is a fatal error because it's not something that really should be reported as a bug to LLVM. But at least this gives a bit more visibility on what to change.", "feature_layers": ["ir", "ast"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/Support/Caching.cpp", "functions": ["createStringError"]}]}
{"pr_number": 68290, "url": "https://github.com/llvm/llvm-project/pull/68290", "title": "[ValueTracking] Use SimplifyQuery in some public APIs (NFC)", "body": "This patch moves SimplifyQuery into a separate header, so that both InstSimplify and ValueTracking can use it in their public API. ValueTracking already (mostly) uses SimplifyQuery for its internal recursive calls, but the public API accepts unpacked arguments.\r\n\r\nI'd like to move things towards accepting SimplifyQuery in the public API as well. This patch in particular migrates the computeOverflowXYZ() APIs.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Scalar/LICM.cpp", "functions": ["SQ"]}, {"filename": "llvm/lib/Transforms/Scalar/NaryReassociate.cpp", "functions": ["SQ"]}]}
{"pr_number": 69951, "url": "https://github.com/llvm/llvm-project/pull/69951", "title": "[lldb][lldb-server] Enable sending RegisterFlags as XML", "body": "This adds ToXML methods to encode RegisterFlags and its fields into XML according to GDB's target XML format:\r\nhttps://sourceware.org/gdb/onlinedocs/gdb/Target-Description-Format.html#Target-Description-Format\r\n\r\nlldb-server does not use libXML to build XML, so this follows the existing code that uses strings. Indentation is used so the result is still human readable.\r\n\r\n```\r\n<flags id=\\\"Foo\\\" size=\\\"4\\\">\r\n  <field name=\\\"abc\\\" start=\\\"0\\\" end=\\\"0\\\"/>\r\n</flags>\r\n```\r\n\r\nThis is used by lldb-server when building target XML, though no one sets any fields yet. That'll come in a later commit.", "feature_layers": [], "feature_directives": ["for", "target"], "files_changed": [{"filename": "lldb/source/Target/RegisterFlags.cpp", "functions": ["m_name"]}]}
{"pr_number": 70026, "url": "https://github.com/llvm/llvm-project/pull/70026", "title": "[AArch64][SVE2] Use rshrnb for masked stores", "body": "This patch is a follow up on https://reviews.llvm.org/D155299. This patch combines add+lsr to rshrnb when 'B' in:\r\n\r\n  C = A + B\r\n  D = C >> Shift\r\n\r\nis equal to (1 << (Shift-1), and the bits in the top half of each vector element are zeroed or ignored, such as in a truncating masked store.", "feature_layers": [], "feature_directives": ["for", "masked"], "files_changed": [{"filename": "llvm/lib/Target/AArch64/AArch64ISelLowering.cpp", "functions": ["SDValue", "isHalvingTruncateOfLegalScalableType"]}]}
{"pr_number": 69813, "url": "https://github.com/llvm/llvm-project/pull/69813", "title": "NFC. Move out and expose affine expression simplification utility out of AffineOps lib", "body": "Move out trivial affine expression simplification out of AffineOps library.  Expose it from libIR. Users of such methods shouldn't have to rely on the AffineOps dialect. For eg., with this change, the method can be used now from lib/Analysis/ (FlatLinearConstraints) as well as AffineOps dialect canonicalization.\r\n\r\nThis way those one won't need to depend on AffineOps for some simplification of affine expressions.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Affine/IR/AffineOps.cpp", "functions": ["flattener"]}, {"filename": "mlir/lib/IR/AffineExpr.cpp", "functions": ["flattener"]}]}
{"pr_number": 65177, "url": "https://github.com/llvm/llvm-project/pull/65177", "title": "[libc++] Implement LWG3545: std::pointer_traits should be SFINAE-friendly.", "body": "See https://wg21.link/LWG3545 for background and details.\r\n\r\nDifferential Revision: https://reviews.llvm.org/D158922\r\n\r\nOne question I have is if this needs to be limited to C++23 and above. For full disclosure, it would be more useful to me if it were not, and it seems like it'd be OK to allow this to leak through to previous C++ versions, since those programs wouldn't have compiled anyway.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "libcxx/test/libcxx/iterators/iterator.requirements/iterator.concepts/iterator.concept.random.access/contiguous_iterator.verify.cpp", "functions": ["test"]}, {"filename": "libcxx/test/std/utilities/memory/pointer.conversion/pointer_traits.pass.cpp", "functions": ["pointer_to", "main", "test"]}, {"filename": "libcxx/test/std/utilities/memory/pointer.conversion/to_address.verify.cpp", "functions": ["test"]}, {"filename": "libcxx/test/std/utilities/memory/pointer.conversion/to_address_without_pointer_traits.pass.cpp", "functions": ["test", "main"]}, {"filename": "libcxx/test/std/utilities/memory/pointer.traits/difference_type.pass.cpp", "functions": ["main"]}, {"filename": "libcxx/test/std/utilities/memory/pointer.traits/element_type.pass.cpp", "functions": ["main"]}, {"filename": "libcxx/test/std/utilities/memory/pointer.traits/pointer.pass.cpp", "functions": ["main"]}, {"filename": "libcxx/test/std/utilities/memory/pointer.traits/rebind.pass.cpp", "functions": ["main"]}, {"filename": "libcxx/test/std/utilities/memory/pointer.traits/types.pass.cpp", "functions": ["pointer_to", "test"]}, {"filename": "libcxx/test/std/utilities/memory/pointer.traits/types.compile.pass.cpp", "functions": ["pointer_to", "main", "constexpr"]}]}
{"pr_number": 68778, "url": "https://github.com/llvm/llvm-project/pull/68778", "title": "[AMDGPU] Rematerialize scalar loads", "body": "Extend the list of instructions that can be rematerialized in SIInstrInfo::isReallyTriviallyReMaterializable() to support scalar loads.\r\n\r\nTry shrinking instructions to remat only the part needed for current context. Add SIInstrInfo::reMaterialize target hook, and handle shrinking of S_LOAD_DWORDX16_IMM to S_LOAD_DWORDX8_IMM as a proof of concept.", "feature_layers": [], "feature_directives": ["for", "target"], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/SIInstrInfo.cpp", "functions": ["canRemat"]}]}
{"pr_number": 70015, "url": "https://github.com/llvm/llvm-project/pull/70015", "title": "[IR] Require index width to be ule pointer width", "body": "I don't think there is a use case for having an index type that is wider than the pointer type, and I'm not entirely clear what semantics this would even have.\r\n\r\nAlso clarify the GEP semantics to explicitly say that it only affects the bits up to the index type width.", "feature_layers": ["sema", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/IR/DataLayout.cpp", "functions": ["reportError"]}]}
{"pr_number": 70041, "url": "https://github.com/llvm/llvm-project/pull/70041", "title": "[DAG] SimplifyDemandedBits - ensure we demand the high bits for shl nsw/nuw ops", "body": "Matches InstCombinerImpl::SimplifyDemandedUseBits\r\n\r\nThis also requires a tweak to the \"AND(CTPOP(X),1) -> PARITY(X)\" fold to allow us to demand known zero upper bits as well.\r\n\r\nFixes #69965  ", "feature_layers": ["ir"], "feature_directives": ["for", "requires"], "files_changed": [{"filename": "llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp", "functions": ["if"]}]}
{"pr_number": 68794, "url": "https://github.com/llvm/llvm-project/pull/68794", "title": "[mlir][ArmSVE] Add `-arm-sve-legalize-vector-storage` pass ", "body": "This patch adds a pass that ensures that loads, stores, and allocations of SVE vector types will be legal in the LLVM backend. It does this at the memref level, so this pass must be applied before lowering all the way to LLVM.\r\n\r\nThis pass currently fixes two issues.\r\n\r\n## Loading and storing predicate types\r\n\r\nIt is only legal to load/store predicate types equal to (or greater than) a full predicate register, which in MLIR is `vector<[16]xi1>`. Smaller predicate types (`vector<[1|2|4|8]xi1>`) must be converted to/from a full predicate type (referred to as a `svbool`) before and after storing and loading respectively. This pass does this by widening allocations and inserting conversion intrinsics.\r\n\r\nFor example:\r\n\r\n\r\n```mlir\r\n%alloca = memref.alloca() : memref<vector<[4]xi1>>\r\n%mask = vector.constant_mask [4] : vector<[4]xi1>\r\nmemref.store %mask, %alloca[] : memref<vector<[4]xi1>>\r\n%reload = memref.load %alloca[] : memref<vector<[4]xi1>>\r\n```\r\nBecomes:\r\n```mlir\r\n%alloca = memref.alloca() {alignment = 1 : i64} : memref<vector<[16]xi1>>\r\n%mask = vector.constant_mask [4] : vector<[4]xi1>\r\n%svbool = arm_sve.convert_to_svbool %mask : vector<[4]xi1>\r\nmemref.store %svbool, %alloca[] : memref<vector<[16]xi1>>\r\n%reload_svbool = memref.load %alloca[] : memref<vector<[16]xi1>>\r\n%reload = arm_sve.convert_from_svbool %reload_svbool : vector<[4]xi1>\r\n```\r\n\r\n## Relax alignments for SVE vector allocas\r\n\r\nThe storage for SVE vector types only needs to have an alignment that matches the element type (for example 4 byte alignment for `f32`s). However, the LLVM backend currently defaults to aligning to `base size x element size` bytes. For non-legal vector types like `vector<[8]xf32>` this results in 8 x 4 = 32-byte alignment, but the backend only supports up to 16-byte alignment for SVE vectors on the stack. Explicitly setting a smaller alignment prevents this issue.\r\n\r\nDepends on: #68586 and #68695 (for testing)", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/ArmSVE/Transforms/LegalizeVectorStorage.cpp", "functions": ["isSVEMaskType", "isLogicalSVEMaskType"]}]}
{"pr_number": 69898, "url": "https://github.com/llvm/llvm-project/pull/69898", "title": "Let M68kMCCodeEmitter set Scratch size.", "body": "The Scratch buffer passed to getBinaryCodeForInst needs to be able to\nhold any value returned by getMachineOpValue or other custom encoders.\nIt's better to let the caller of getBinaryCodeForInst set the size of\nScratch as it's impossible for VarLenCodeEmitterGen to know what the\nsmallest needed size is.\n\nVarLenCodeEmitterGen now calculates its smallest needed Scratch bit\nwidth based on the slice operations and zero extends Scratch if it's too\nsmall. This only guarantees that Scratch has enough bits for the\ngenerated code not for getMachineOpValue or custom encoders.\n\nThe smallest internal APInt representation uses one uint64_t word so\nthere is no point in using a smaller size.\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/M68k/MCTargetDesc/M68kMCCodeEmitter.cpp", "functions": ["Scratch"]}, {"filename": "llvm/utils/TableGen/VarLenCodeEmitterGen.cpp", "functions": ["RS"]}]}
{"pr_number": 69504, "url": "https://github.com/llvm/llvm-project/pull/69504", "title": "[VP] Check if VP ops with functional intrinsics are speculatable", "body": "Noticed whilst working on #69494. VP intrinsics whose functional equivalent is\r\nan intrinsic were being marked as their lanes being non-speculatable, even if\r\nthe underlying intrinsic was speculatable.\r\n\r\nThis meant that\r\n\r\n```llvm\r\n  %1 = call <4 x i32> @llvm.vp.umax(<4 x i32> %x, <4 x i32> %y, <4 x i1> %mask, i32 %evl)\r\n```\r\n\r\nwould be expanded out to\r\n\r\n```llvm\r\n  %.splatinsert = insertelement <4 x i32> poison, i32 %evl, i64 0\r\n  %.splat = shufflevector <4 x i32> %.splatinsert, <4 x i32> poison, <4 x i32> zeroinitializer\r\n  %1 = icmp ult <4 x i32> <i32 0, i32 1, i32 2, i32 3>, %.splat\r\n  %2 = and <4 x i1> %1, %mask\r\n  %3 = call <4 x i32> @llvm.umax.v4i32(<4 x i32> %x, <4 x i32> %y)\r\n```\r\n\r\ninstead of\r\n\r\n```llvm\r\n  %1 = call <4 x i32> @llvm.umax.v4i32(<4 x i32> %x, <4 x i32> %y)\r\n```\r\n\r\nThe cause of this was isSafeToSpeculativelyExecuteWithOpcode checking the\r\nfunction attributes for the VP instruction itself, not the functional\r\nintrinsic.  Since isSafeToSpeculativelyExecuteWithOpcode expects an already\r\nmaterialized instruction, we can't use it directly for the intrinsic case. So\r\nthis fixes it by manually checking the function attributes on the intrinsic.\r\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/CodeGen/ExpandVectorPredication.cpp", "functions": ["isSafeToSpeculativelyExecuteWithOpcode"]}]}
{"pr_number": 69140, "url": "https://github.com/llvm/llvm-project/pull/69140", "title": "[clang][Interp] Correctly emit destructors for multi-dimensional arrays", "body": "We were not taking those into account correctly when emitting destructors. Fix that and add tests for it.\r\n\r\nFixes #69115", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/AST/Interp/arrays.cpp", "functions": ["foo2", "assert", "foo", "F"]}]}
{"pr_number": 66542, "url": "https://github.com/llvm/llvm-project/pull/66542", "title": "[SLP]Improve isGatherShuffledEntry by trying per-register shuffle.", "body": "Currently when building gather/buildvector node, we try to build nodes\nshuffles without taking into account separate vector registers. We can\nimprove final codegen and the whole vectorization process by including\nthis info into the analysis and the vector code emission, allows to emit\nbetter vectorized code.\n\nDifferential Revision: https://reviews.llvm.org/D149742\n", "feature_layers": ["codegen"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp", "functions": ["any_of", "VecMask", "add"]}]}
{"pr_number": 68888, "url": "https://github.com/llvm/llvm-project/pull/68888", "title": "[clang][Interp] Add explicit dummy descriptors", "body": "Instead of (ab)using incomplete array types for this, add a 'Dummy' bit to Descriptor. We need to be able to differentiate between the two when adding an offset.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/AST/Interp/Descriptor.cpp", "functions": ["Source"]}, {"filename": "clang/lib/AST/Interp/Interp.cpp", "functions": ["CheckDummy"]}]}
{"pr_number": 67572, "url": "https://github.com/llvm/llvm-project/pull/67572", "title": "[analyzer][NFC] Simplifications in ArrayBoundV2", "body": "I'm planning to improve diagnostics generation in `ArrayBoundCheckerV2` but before that I'm refactoring the source code to clean up some over-complicated code and an inaccurate comment.\r\n\r\nChanges in this commit:\r\n- Remove the `mutable std::unique_ptr<BugType>` boilerplate, because it's no longer needed.\r\n- Remove the code duplication between the methods `reportOOB()` and `reportTaintedOOB()`.\r\n- Eliminate the class `RegionRawOffsetV2` because it's just a \"reinvent the wheel\" version of `std::pair` and it was used only once, as a temporary object that was immediately decomposed. (I suspect that `RegionRawOffset` in MemRegion.cpp could also be eliminated.)\r\n- Flatten the code of `computeOffset()` which had contained six nested indentation levels before this commit.\r\n- Ensure that `computeOffset()` returns `std::nullopt` instead of a `{Region, <zero array index>}` pair in the case when it encounters a `Location` that is not an `ElementRegion`. This ensures that the `checkLocation` callback returns early when it handles a memory access where it has \"nothing to do\" (no subscript operation or equivalent pointer arithmetic). (Note that this is still NFC because zero is a valid index everywhere, so the old logic without this shortcut eventually reached the same conclusion.)\r\n- Correct a wrong explanation comment in `getSimplifiedOffsets()`.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/StaticAnalyzer/Checkers/ArrayBoundCheckerV2.cpp", "functions": ["getByteOffset", "os", "RegionRawOffsetV2", "BugType", "dump", "baseRegion", "Out", "dumpToStream"]}]}
{"pr_number": 68206, "url": "https://github.com/llvm/llvm-project/pull/68206", "title": "[mlir][emitc] Add a structured for operation", "body": "Add an emitc.for op to the EmitC dialect as a lowering target for\nscf.for, replacing its current direct translation to C; The translator\nnow handles emitc.for instead.\n", "feature_layers": ["ir"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "mlir/lib/Conversion/SCFToEmitC/SCFToEmitC.cpp", "functions": ["success", "guard"]}, {"filename": "mlir/lib/Dialect/EmitC/IR/EmitC.cpp", "functions": ["success", "guard", "getUpperBound", "failure", "if"]}, {"filename": "mlir/lib/Target/Cpp/TranslateToCpp.cpp", "functions": ["failure", "printOperation", "success"]}]}
{"pr_number": 69727, "url": "https://github.com/llvm/llvm-project/pull/69727", "title": "[MemDep] Use EarliestEscapeInfo", "body": "Use BatchAA with EarliestEscapeInfo instead of callCapturesBefore() in MemDepAnalysis. The advantage of this is that it will also take not-captured-before information into account for non-calls (see test_store_before_capture for a representative example), and that this is a cached analysis. The disadvantage is that EII is slightly less precise than full CapturedBefore analysis.\r\n\r\nIn practice the impact is positive, with gvn.NumGVNLoad going from 22022 to 22808 on test-suite. Full list of diffs: https://gist.github.com/nikic/9b6b4187d96d25249e9d874b47be99df\r\n\r\nThe impact to compile-time is also positive, mainly in the ThinLTO configuration: http://llvm-compile-time-tracker.com/compare.php?from=97e06a0d83a55ff67e5fd0c7328233c44415de33&to=4921af8845260f2cea9aed0a350aec4e8c7b10e6&stat=instructions:u", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Analysis/MemoryDependenceAnalysis.cpp", "functions": ["BatchAA"]}]}
{"pr_number": 65876, "url": "https://github.com/llvm/llvm-project/pull/65876", "title": "Ensure NoTrapAfterNoreturn is false for the wasm backend", "body": "In the WebAssembly back end, the TrapUnreachable option is currently load-bearing for correctness, inserting wasm `unreachable` instructions where needed to create valid wasm. There is another option, NoTrapAfterNoreturn, that removes some of those traps and causes incorrect wasm to be emitted.\r\n\r\nThe first commit adds a command line flag for NoTrapAfterNoreturn so that it can be tested, and adds new tests (and fixes some typos).\r\nThe second commit turns off NoTrapAfterNoreturn for the Wasm backend.\r\nThe third commit adds a new peephole optimisation, to remove some common cases of unnecessary instructions around `unreachable`. Properly modelling how `unreachable` can be a sink and a source for operands would be better, but this will do for now.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/WebAssembly/WebAssemblyPeephole.cpp", "functions": ["eraseDeadCodeAroundUnreachable"]}]}
{"pr_number": 66903, "url": "https://github.com/llvm/llvm-project/pull/66903", "title": "[builtins] Start to refactor int to fp conversion functions to use a common implementation", "body": "After this patch, the softfp implementations of floatdidf and floatundidf use a common implementation (int_to_fp.h and int_to_fp_impl.inc). This roughly follows the pattern used for a wide range of other builtins, e.g. fp_trunc_impl.inc.\r\n\r\nCurrently there is substantial copy and paste for the various int to fp conversion functions, with just a few constants being changed. This is a barrier to maintainability, and it's also not attractive to copy this approach as we introduce additional int to fp conversion functions for bf16 and half (which we currently lack, but need - see <https://reviews.llvm.org/D157509>).\r\n\r\nI welcome feedback on the approach taken here, as well as the best way to move forward to land it. I've opted to conservatively start by replacing just two functions, leaving a follow-up patch to replace others that follow the same pattern. Also, for better or worse I've left the logic in float[un]didf largely unchanged other than using a similar approach to fp_trunc_impl.inc to remove the constants that are tied to a specific output floating point format.\r\n\r\nFor something like this I really miss the stacked reviews we had on Phabricator, but getting some feedback on this rough first patch is probably sensible before pushing out a longer series.", "feature_layers": ["ir", "ast"], "feature_directives": ["for", "barrier"], "files_changed": [{"filename": "compiler-rt/lib/builtins/floatdidf.c", "functions": ["__floatdidf"]}, {"filename": "compiler-rt/lib/builtins/floatundidf.c", "functions": ["__floatundidf"]}, {"filename": "compiler-rt/lib/builtins/int_to_fp_impl.inc", "functions": ["__floatXiYf__", "dstFromRep"]}]}
{"pr_number": 70279, "url": "https://github.com/llvm/llvm-project/pull/70279", "title": "[mlir][sparse] cleanup merger test, add header", "body": "", "feature_layers": ["parse", "ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/unittests/Dialect/SparseTensor/MergerTest.cpp", "functions": ["synZeroMatch", "Match", "compareExpression", "Pattern", "tensorMatch", "kind", "tensorPattern", "synZeroPattern"]}]}
{"pr_number": 69500, "url": "https://github.com/llvm/llvm-project/pull/69500", "title": "[libc++] Optimize string operator[] for known large inputs", "body": "If we know that index is larger than SSO size, we know that we can't be in SSO case, and should access the pointer. This removes extra check from operator[] for inputs known at compile time to be larger than SSO.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "libcxx/test/std/strings/basic.string/string.access/index.pass.cpp", "functions": ["test_string_long", "s"]}]}
{"pr_number": 70185, "url": "https://github.com/llvm/llvm-project/pull/70185", "title": "[AArch64][GlobalISel] Add support for pre-indexed loads/stores.", "body": "The pre-index matcher just needs some small heuristics to make sure it doesn't cause regressions. Apart from that it's a simple change, since the only difference is an immediate operand of '1' vs '0' in the instruction.\r\n\r\nPart of a stack https://github.com/llvm/llvm-project/pull/69533", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp", "functions": ["all_of"]}]}
{"pr_number": 70256, "url": "https://github.com/llvm/llvm-project/pull/70256", "title": "Reland [dsymutil] Add support for mergeable libraries", "body": "Reland https://reviews.llvm.org/D158124\r\nFixed `-fpermissive` error reported by gcc only.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/TargetParser/Triple.cpp", "functions": ["getArchTypeName"]}, {"filename": "llvm/tools/dsymutil/DebugMap.cpp", "functions": ["Res"]}, {"filename": "llvm/tools/dsymutil/DwarfLinkerForBinary.cpp", "functions": ["OS", "errorCodeToError", "error", "RM"]}, {"filename": "llvm/tools/dsymutil/MachODebugMapParser.cpp", "functions": ["switchToNewDebugMapObject", "Path", "Parser", "ProductName", "RMPath", "FallbackPath", "DSYMPath"]}, {"filename": "llvm/tools/dsymutil/RelocationMap.cpp", "functions": ["yout", "yin"]}, {"filename": "llvm/tools/llvm-dwarfutil/DebugInfoLinker.cpp", "functions": ["needToSaveValidRelocs", "getLibraryInstallName"]}]}
{"pr_number": 69529, "url": "https://github.com/llvm/llvm-project/pull/69529", "title": "[clang-tidy] Add StrictMode to cppcoreguidelines-pro-type-static-cast-downcast", "body": "Add StrictMode option that controls behavior whatever\r\nwarnings are emitted for casts on non-polymorphic types.\r\n\r\nFixes: #69414", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang-tools-extra/clang-tidy/cppcoreguidelines/ProTypeStaticCastDowncastCheck.cpp", "functions": ["ClangTidyCheck"]}]}
{"pr_number": 70268, "url": "https://github.com/llvm/llvm-project/pull/70268", "title": "[clang][OpenMP] Fix target data if/logical expression assert fail", "body": "Fixed assertion failure\r\n\r\n  Basic Block in function 'main' does not have terminator!\r\n  label %land.end\r\n\r\ncaused by premature setting of CodeGenIP upon entry to emitTargetDataCalls, where subsequent evaluation of logical expression created new basic blocks, leaving CodeGenIP pointing to the wrong basic block. CodeGenIP is now set near the end of the function, just prior to generating a comparison of the logical expression result (from the if clause) which uses CodeGenIP to insert new IR.", "feature_layers": ["codegen", "ir"], "feature_directives": ["target"], "files_changed": [{"filename": "clang/lib/CodeGen/CGOpenMPRuntime.cpp", "functions": ["OmpLoc", "AllocaIP", "CodeGenIP"]}, {"filename": "clang/test/OpenMP/target_data_if_logical_codegen.cpp", "functions": ["foo", "main", "if_logical"]}]}
{"pr_number": 67159, "url": "https://github.com/llvm/llvm-project/pull/67159", "title": "[RISCV] Extend InstSeq (used in constant mat) to support multiple live regs", "body": "Posted mostly for discussion.  This turned out to be more invasive and fiddly than I'd expected when I first started.  My guess is that we probably won't land this, but I wanted to show what the option looked like.  \r\n\r\nThis moves the logic for constant materialization with an additional vreg into common code.  It does so by extending the InstSeq construct to support multiple live values in the sequence.  This converts an InstSeq from being a linear chain of instructions to being a DAG of instructions.\r\n\r\nNote that the emergency-slot.mir test change is in principle a bug fix; we're setting kill flags on a register which has later usage.  Its probably an uninteresting bug in practice since it only happens on X0 which is a constant physreg and thus the kill flag is fairly meaningless.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp", "functions": ["generateInstSeq"]}, {"filename": "llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp", "functions": ["SDValue"]}]}
{"pr_number": 69533, "url": "https://github.com/llvm/llvm-project/pull/69533", "title": "STACK: GlobalISel: indexed load/stores support for AArch64", "body": "This is a stack. See https://github.com/llvm/llvm-project/pull/70373 for the next patch to be reviewed.\r\n\r\n- [AArch64][GlobalISel] Add support for post-indexed loads/stores.\r\n- [AArch64][GlobalISel] Add support for pre-indexed loads/stores.\r\n- [AArch64][GlobalISel] Add support for extending indexed loads.\r\n\r\nThese changes in totality provide some good code size improvements at -Os CTMark:\r\n```\r\nProgram                                       size.__text\r\n                                              output3rsutb82 outputy9pewxwy diff\r\nconsumer-typeset/consumer-typeset             407484.00      407936.00       0.1%\r\ntramp3d-v4/tramp3d-v4                         393300.00      393424.00       0.0%\r\nSPASS/SPASS                                   410444.00      410340.00      -0.0%\r\nlencod/lencod                                 427804.00      427676.00      -0.0%\r\nBullet/bullet                                 457988.00      457828.00      -0.0%\r\nkimwitu++/kc                                  453156.00      452988.00      -0.0%\r\n7zip/7zip-benchmark                           592268.00      591684.00      -0.1%\r\nmafft/pairlocalalign                          243460.00      243156.00      -0.1%\r\nClamAV/clamscan                               380684.00      380176.00      -0.1%\r\nsqlite3/sqlite3                               285316.00      284448.00      -0.3%\r\n                           Geomean difference                               -0.1%\r\n```", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp", "functions": ["all_of"]}, {"filename": "llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp", "functions": ["selectIndexedExtLoad"]}]}
{"pr_number": 67083, "url": "https://github.com/llvm/llvm-project/pull/67083", "title": "[mlir][TilingInterface] Add scf::tileUsingSCFForallOp method to tile using the interface to generate `scf::forall`.", "body": "Similar to `scf::tileUsingSCFForOp` that is a method that tiles\r\noperations that implement the `TilingInterface`, using `scf.for`\r\noperations, this method introduces tiling of operations using\r\n`scf.forall`. Most of this implementation is derived from\r\n`linalg::tileToForallOp` method. Eventually that method will either be\r\ndeprecated or moved to use the method introduced here.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/SCF/Transforms/TileUsingInterface.cpp", "functions": ["getAsOpFoldResult"]}, {"filename": "mlir/test/lib/Interfaces/TilingInterface/TestTilingInterface.cpp", "functions": ["failure", "success", "filter"]}]}
{"pr_number": 70287, "url": "https://github.com/llvm/llvm-project/pull/70287", "title": "[NFC] In InstrProf, generalize helper functions to take 'GlobalObject'. They currently take 'Functions' as function parameters or have 'Func' in the name.", "body": "- For instance, `collectPGOFuncNameStrings` is reused a lot in [pr/66825](https://github.com/llvm/llvm-project/pull/66825) to collect vtable names; and in some added callsites it's just weird to see 'func' since context clearly shows it's not. This function currently just takes a list of strings as input so name it to `collectGlobalObjectNameStrings`\r\n- Do the rename in a standalone patch since the method is used in non-llvm codebase. It's easier to rollback this NFC in case rename in that codebase takes longer.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/ProfileData/InstrProf.cpp", "functions": ["getIRPGONameForGlobalObject", "lookupPGONameFromMetadata", "getIRPGOObjectName", "getIRPGOFuncName", "lookupPGOFuncName"]}]}
{"pr_number": 70018, "url": "https://github.com/llvm/llvm-project/pull/70018", "title": "[Clang] Mark declarators invalid in the presence of ill-formed explicit parameters.", "body": "To avoid crashes later in sema.\r\n\r\nFixes #69962\r\nFixes #69838", "feature_layers": ["sema"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CXX/drs/dr25xx.cpp", "functions": ["f"]}, {"filename": "clang/test/SemaCXX/cxx2b-deducing-this.cpp", "functions": ["g", "j", "i", "f", "nonmember", "h", "test"]}]}
{"pr_number": 70317, "url": "https://github.com/llvm/llvm-project/pull/70317", "title": "[flang] Move whole allocatable assignment implicit conversion to lowering", "body": "The front-end is making implicit conversions explicit in assignment and structure constructors.\r\n\r\nWhile this generally helps and is needed by semantics to fold structure constructors correctly, this is incorrect when the LHS or component is an allocatable. The RHS may have non default lower bounds that should be propagated to the LHS, and making the conversion explicit changes the semantics. In the structure constructor, the situation is even worse since Fortran 2018 7.5.10 point 7 allows the value to be a reference to an unallocated allocatable, and adding an explicit conversion in semantics will cause a segfault.\r\n\r\nThis patch removes the explicit convert in semantics when the LHS/component is a whole allocatable, and update lowering to deal with the conversion insertion, dealing with preserving the lower bounds and the tricky structure constructor case.", "feature_layers": ["sema"], "feature_directives": ["for", "allocate"], "files_changed": [{"filename": "flang/lib/Lower/ConvertExprToHLFIR.cpp", "functions": ["gen"]}, {"filename": "flang/lib/Semantics/expression.cpp", "functions": ["ConvertToType"]}]}
{"pr_number": 70343, "url": "https://github.com/llvm/llvm-project/pull/70343", "title": "[flang] Implement legacy %VAL and %REF actual arguments", "body": "Update evaluate::ActualArgument to propagate the %VAL and %REF markers until lowering.\r\nSemantic checks are added to %VAL to ensure the argument is a numerical or logical scalar.\r\n\r\nI did not push these markers into the characteristics because other compilers do not complain about inconsistent usages (e.g. using %VAL in a call on a procedure with an interface without VALUE dummies is not flagged by any compilers I tested, and it is not an issue for lowering, so I decided to stay simple here and minimize the footprint of these legacy features).\r\n\r\nLowering retrieve these markers and does the right thing: pass %VAL in registers and pass %REF by address without adding any extra arguments for characters.\r\n\r\nNote that %LOC was already handled (rewritten as LOC intrinsic), but this patch tests that %VAL(%LOC()) allows skipping copy-in/copy-out as described [in gfortran documentation](https://gcc.gnu.org/onlinedocs/gcc-3.4.6/g77/_0025LOC_0028_0029.html#g_t_0025LOC_0028_0029).", "feature_layers": ["sema"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Semantics/expression.cpp", "functions": ["AnalyzeVariable"]}]}
{"pr_number": 70292, "url": "https://github.com/llvm/llvm-project/pull/70292", "title": "[mlir][vector] Fix off-by-one error in `getTransferChunkAccessed`", "body": "If a dimension does not appear in the permutation map of a vector transfer op, the size of the accessed slice in that dimension is `1`. Before this fix, `getTransferChunkAccessed` used to return `0` for such dimensions, which would means that `0` elements in the underlying tensor/memref are accessed.\r\n\r\nNote: There is no test case that fails due to this bug and because this interface method is currently only used in one place, it is hard to write a regression test. This fix is in preparation of subset hoisting functionality that will be added in subsequent commits.\r\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Vector/IR/VectorOps.cpp", "functions": ["failure"]}]}
{"pr_number": 70373, "url": "https://github.com/llvm/llvm-project/pull/70373", "title": "[AArch64][GlobalISel] Add support for extending indexed loads.", "body": "This is the final patch in the stack https://github.com/llvm/llvm-project/pull/69533", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp", "functions": ["selectIndexedExtLoad"]}]}
{"pr_number": 70121, "url": "https://github.com/llvm/llvm-project/pull/70121", "title": "Reland [mlir][tools] Introduce tblgen-to-irdl tool", "body": "This patch relands the reverted commit https://github.com/llvm/llvm-project/commit/e6e9beb977555c84fb16ffdd8dca8649c7d3091d after fixing the sanitizer issue.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/tools/tblgen-to-irdl/OpDefinitionsGen.cpp", "functions": ["if"]}, {"filename": "mlir/tools/tblgen-to-irdl/tblgen-to-irdl.cpp", "functions": ["main"]}]}
{"pr_number": 69788, "url": "https://github.com/llvm/llvm-project/pull/69788", "title": "[RISCV] Keep same SEW/LMUL ratio if possible in forward transfer", "body": "For instructions like vmv.s.x and friends where we don't care about LMUL or the\nSEW/LMUL ratio, we can change the LMUL in its state so that it has the same\nSEW/LMUL ratio as the previous state. This allows us to avoid more VL toggles\nlater down the line (i.e. use vsetvli zero, zero, which requires that the\nSEW/LMUL ratio must be the same)\n\nThis is an alternative approach to the idea in #69259, but note that they \ndon't catch exactly the same test cases.\n", "feature_layers": ["ir"], "feature_directives": ["for", "requires"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp", "functions": ["setVLMul"]}]}
{"pr_number": 68052, "url": "https://github.com/llvm/llvm-project/pull/68052", "title": "[lldb/Interpreter] Make ScriptedInterface Object creation more generic", "body": "This patch changes the way plugin objects used with Scripted Interfaces\r\nare created.\r\n\r\nInstead of implementing a different SWIG method to create the object for\r\nevery scripted interface, this patch makes the creation more generic by\r\nre-using some of the ScriptedPythonInterface templated Dispatch code.\r\n\r\nThis patch also improves error handling of the object creation by\r\nreturning an `llvm::Expected`.\r\n\r\nSigned-off-by: Med Ismail Bennani <ismail@bennani.ma>", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "lldb/source/Plugins/ScriptInterpreter/Python/Interfaces/ScriptedPlatformPythonInterface.cpp", "functions": ["sd_impl", "args_impl"]}, {"filename": "lldb/source/Plugins/ScriptInterpreter/Python/Interfaces/ScriptedProcessPythonInterface.cpp", "functions": ["sd_impl", "args_impl"]}, {"filename": "lldb/source/Plugins/ScriptInterpreter/Python/Interfaces/ScriptedThreadPythonInterface.cpp", "functions": ["sd_impl", "args_impl"]}]}
{"pr_number": 69923, "url": "https://github.com/llvm/llvm-project/pull/69923", "title": "[AMDGPU] Add writelane and readlane pseudos for SGPR spilling", "body": "For a future patch, is it important to keep the lowered SGPR spills to be recognized as spill instructions during regalloc. Directly lowering them into V_WRITELANE/V_READLANE won't allow us to attach the SPILL flag to their instructions.\r\n\r\nThis patch introduces the readlane/writelane pseudo instructions with the SGPRSpill flag set in their Desc. They will get lowered to hardware instructions later during post RA pseudo expansion.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/SIFrameLowering.cpp", "functions": ["if"]}]}
{"pr_number": 69013, "url": "https://github.com/llvm/llvm-project/pull/69013", "title": "[VPlan] Add initial anlysis to infer scalar type of VPValues.", "body": "This patch adds initial type inferrence for VPValues. It infers the scalar type of a VPValue, by bottom-up traversing through defining recipes until root nodes with known types are reached (e.g. live-ins or memory recipes). The types are then propagated top down through operations.\r\n\r\nThis is intended as building block for a VPlan-based cost model, which will need access to type information for VPValues/recipes.\r\n\r\nInitial testing is done by asserting the inferred type matches the type of the result value generated for a widen recipe.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Vectorize/VPlanAnalysis.cpp", "functions": ["inferScalarType"]}, {"filename": "llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp", "functions": ["A"]}, {"filename": "llvm/lib/Transforms/Vectorize/LoopVectorize.cpp", "functions": ["A"]}]}
{"pr_number": 70316, "url": "https://github.com/llvm/llvm-project/pull/70316", "title": "[clang-tidy]Fix PreferMemberInitializer false positive for reassignment", "body": "- assignment twice cannot be simplified to once when assigning to reference type\r\n- safe assignment cannot be advanced before unsafe assignment", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang-tools-extra/clang-tidy/cppcoreguidelines/PreferMemberInitializerCheck.cpp", "functions": ["canAdvanceAssignment"]}]}
{"pr_number": 70263, "url": "https://github.com/llvm/llvm-project/pull/70263", "title": "[AMDGPU] Shrink to SOPK with 32-bit signed literals", "body": "A literal like 0xffff8000 is valid to be used as KIMM in a SOPK instruction, but at the moment our checks expect it to be fully sign extended to a 64-bit signed integer. This is not required since all cases which are being shrunk only accept 32-bit operands.\r\n\r\nWe need to sign extend the operand to 64-bit though so it passes the verifier and properly printed.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/SIShrinkInstructions.cpp", "functions": ["if"]}]}
{"pr_number": 70512, "url": "https://github.com/llvm/llvm-project/pull/70512", "title": "[LLVM][DWARF] Add support for monolithic types in .debug_names", "body": "Enable Type Units with DWARF5 accelerator tables for monolithic DWARF.\nImplementation relies on linker to tombstone offset in LocalTU list to -1 when\nit deduplciates type units using COMDAT.\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp", "functions": ["getUniqueTags", "ID", "getTagFromAbbreviationTag", "if", "OffsetVal", "emitTUList", "populateAbbrevsMap", "CompUnitCount"]}]}
{"pr_number": 70518, "url": "https://github.com/llvm/llvm-project/pull/70518", "title": "[mlir][sparse] unify sparse_tensor.out rewriting rules", "body": "", "feature_layers": ["parse", "ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/Transforms/SparseTensorConversion.cpp", "functions": ["success"]}]}
{"pr_number": 70523, "url": "https://github.com/llvm/llvm-project/pull/70523", "title": "[mlir][sparse] remove obsoleted output methods from runtime", "body": "Our CODE and LIB are more unified every day!", "feature_layers": ["parse", "runtime", "ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/ExecutionEngine/SparseTensorRuntime.cpp", "functions": ["writeExtFROSTT"]}]}
{"pr_number": 70500, "url": "https://github.com/llvm/llvm-project/pull/70500", "title": "[mlir][tosa] Add verifier for tosa.reverse", "body": "This patch adds a verifier to tosa.reverse which checks the axis argument and input/output tensor ranks for validity. We allow a special case where `axis == 0 && rank == 0`.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Tosa/IR/TosaOps.cpp", "functions": ["emitOpError", "success"]}]}
{"pr_number": 69107, "url": "https://github.com/llvm/llvm-project/pull/69107", "title": "[MLIR][Presburger] Add simplify function", "body": "Added the simplify function to reduce the size of the constraint system, referencing the ISL implementation.\r\n\r\nTested it on a simple Benchmark implemented by myself, calling SImplify before the operation and calling Simplify on the result after Subtract were tested, respectively.\r\n\r\nThe Benchmark can be found here: [benchmark](https://github.com/gilsaia/llvm-project-test-fpl/blob/develop_benchmark/mlir/benchmark/presburger/Benchmark.cpp)\r\n\r\nFor the case of calling Simplify before each operation, the overall result is shown in the following figure.\r\n![image](https://github.com/llvm/llvm-project/assets/38588948/7099286e-b9a2-42e0-bc2a-1ed6627ead00)\r\n\r\nA comparison of the constraint system sizes and time for each operation is as follows\r\n![image](https://github.com/llvm/llvm-project/assets/38588948/e5d0e488-f76e-4438-b19e-f6163699c526)\r\n![image](https://github.com/llvm/llvm-project/assets/38588948/119a08de-4ee1-4cde-886c-50a91b502d93)\r\n![image](https://github.com/llvm/llvm-project/assets/38588948/7a8b69ac-6cdb-41ab-9a75-cd016664fa5a)\r\n![image](https://github.com/llvm/llvm-project/assets/38588948/c84b6eb1-62dc-4bae-a771-67d97ebf514a)\r\n![image](https://github.com/llvm/llvm-project/assets/38588948/cdbfa3ed-0155-481e-9273-9d6dba3a2d7b)\r\n![image](https://github.com/llvm/llvm-project/assets/38588948/8c945cff-a0a4-472a-a178-6b6a70a1b16a)\r\n![image](https://github.com/llvm/llvm-project/assets/38588948/0bfe3a2b-3568-4d31-bebf-bd1b3c4e734e)\r\n![image](https://github.com/llvm/llvm-project/assets/38588948/f1a99d56-edf5-45de-a506-512c0584f1d8)\r\n![image](https://github.com/llvm/llvm-project/assets/38588948/ffef3312-6c99-494c-bb52-73aa8df275bb)\r\n![image](https://github.com/llvm/llvm-project/assets/38588948/3e5924a7-8e1f-49d1-bd27-02a2e10a5cc4)\r\n![image](https://github.com/llvm/llvm-project/assets/38588948/cec8be0e-dd19-46fa-88b4-2585d4031c9e)\r\n![image](https://github.com/llvm/llvm-project/assets/38588948/3cb68e89-82c7-4cd2-b6bc-70f15e495ce8)\r\n\r\nFor the case of calling Simplify on the result after Subtract, the overall results are as follows\r\n![image](https://github.com/llvm/llvm-project/assets/38588948/be5b9c50-7417-42c8-abbf-8a50f093c3f5)\r\n\r\nA comparison of the constraint system sizes and time for subtract is as follows\r\n![image](https://github.com/llvm/llvm-project/assets/38588948/fafe10ba-f8bd-43cd-b281-aaebf09af0af)\r\n![image](https://github.com/llvm/llvm-project/assets/38588948/24662b40-42fc-47ee-a0a3-1b8b8f5778d2)\r\n\r\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Analysis/Presburger/IntegerRelation.cpp", "functions": ["negIneq"]}, {"filename": "mlir/lib/Analysis/Presburger/PresburgerRelation.cpp", "functions": ["getNumDisjuncts"]}]}
{"pr_number": 70592, "url": "https://github.com/llvm/llvm-project/pull/70592", "title": "[X86] Avoid returning the same shuffle operation for broadcast", "body": "This is to fix a crash since aab8b2eb080d, which generates a new pattern\r\n```\r\n      t35: v8i32 = xor t11, t14\r\n    t36: v8i32 = vector_shuffle<0,1,0,1,0,1,0,1> t35, undef:v8i32\r\n```\r\n\r\nThe pattern exposed a bug introduced since f885c08034, which breaks element widen but doesn't handle the broadcast case.\r\n\r\nThe patch just solved the crash issue. I observed performance regression cased by above patches in the test, which may need further investigation.", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/X86/X86ISelLowering.cpp", "functions": ["SDValue"]}]}
{"pr_number": 70383, "url": "https://github.com/llvm/llvm-project/pull/70383", "title": "[OpenMP] Associate the KernelEnvironment with the GenericKernelTy", "body": "By associating the kernel environment with the generic kernel we can\r\n      access middle-end information easily, including the launch bounds ranges\r\n      that are acceptable. By constraining the number of threads accordingly,\r\n      we now obey the user-provided bounds that were passed via attributes.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "openmp/libomptarget/plugins-nextgen/amdgpu/src/rtl.cpp", "functions": ["GenericKernelTy"]}, {"filename": "openmp/libomptarget/plugins-nextgen/common/PluginInterface/PluginInterface.cpp", "functions": ["KernelEnv"]}, {"filename": "openmp/libomptarget/plugins-nextgen/cuda/src/rtl.cpp", "functions": ["GenericKernelTy"]}, {"filename": "openmp/libomptarget/plugins-nextgen/generic-elf-64bit/src/rtl.cpp", "functions": ["GenericKernelTy"]}]}
{"pr_number": 70247, "url": "https://github.com/llvm/llvm-project/pull/70247", "title": "[OpenMP] Pass min/max thread and team count to the OMPIRBuilder", "body": "We now provide the information about the min/max thread and team count from to the OMPIRBuilder, no matter what the source was. That means we unify `thread_limit`, `num_teams`, `num_threads` handling with the target specific attriutes (`__launch_bounds__` and `amdgpu_flat_work_group_size`). This is in preparation to pass the values to the runtime, and to allow the middle-end (OpenMP-opt) to tighten the values if it seems appropriate. There is no \"real\" change after this commit.", "feature_layers": ["runtime", "ir", "ompirbuilder"], "feature_directives": ["for", "target", "teams"], "files_changed": [{"filename": "clang/lib/CodeGen/CGOpenMPRuntime.cpp", "functions": ["if"]}]}
{"pr_number": 70396, "url": "https://github.com/llvm/llvm-project/pull/70396", "title": "[openmp] Fixed Support for VA for record-replay.", "body": "The commit was discussed in phabricator (https://reviews.llvm.org/D157186). \r\n\r\nRecord replay currently fails on AMD as it conflicts with the heap memory allocator introduced in #69806. The workaround is setting  `LIBOMPTARGET_HEAP_SIZE=0` during both record and replay run. ", "feature_layers": [], "feature_directives": ["for", "target"], "files_changed": [{"filename": "openmp/libomptarget/plugins-nextgen/amdgpu/src/rtl.cpp", "functions": ["getDeviceMemorySize"]}, {"filename": "openmp/libomptarget/plugins-nextgen/common/PluginInterface/PluginInterface.cpp", "functions": ["Status", "deinit", "preAllocateVAMemory", "preAllocateHeuristic", "preallocateDeviceMemory"]}, {"filename": "openmp/libomptarget/plugins-nextgen/cuda/src/rtl.cpp", "functions": ["getDeviceMemorySize", "supportVAManagement", "memoryVAMap", "memoryVAUnMap"]}]}
{"pr_number": 69857, "url": "https://github.com/llvm/llvm-project/pull/69857", "title": "[mlir][tosa] Fix not to crash with large permutation indexes ", "body": "The tosa-infer-shape pass does not check the permutation validity if it\u2019s a constant value. We need to compare the rank size with the input tensor not to crash the pass.\r\n\r\ncloses https://github.com/llvm/llvm-project/issues/67763\r\n", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/Tosa/IR/TosaOps.cpp", "functions": ["failure"]}]}
{"pr_number": 70581, "url": "https://github.com/llvm/llvm-project/pull/70581", "title": "[MLIR][mlir-opt] Add `registerationAndParseCLIOptions` for `MlirOptMain`.", "body": "Seprate registeration and CLI parsing from `MlirOptMain` to `mlir::registrationAndParseCLIOptions` and a new `MlirOptMain` so that external tools to drive mlir-opt can call these two new APIs to get CLI option values before running MlirOptMain.", "feature_layers": ["parse", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Tools/mlir-opt/MlirOptMain.cpp", "functions": ["MlirOptMain", "outputFilename", "os"]}]}
{"pr_number": 70005, "url": "https://github.com/llvm/llvm-project/pull/70005", "title": "[mlir][spirv] Handle failed conversions of struct elements", "body": "LLVMStructTypes could be emitted with some null elements. This caused a crash later in the LLVMDialect verifier.\r\n\r\nNow, properly check that all struct elements were successfully converted before passing them to the LLVMStructType ctor.\r\n\r\nSee #59990", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Conversion/SPIRVToLLVM/SPIRVToLLVM.cpp", "functions": ["convertTypes"]}, {"filename": "mlir/lib/Dialect/SPIRV/IR/SPIRVTypes.cpp", "functions": ["ElementTypeRange", "TypeRange"]}]}
{"pr_number": 66067, "url": "https://github.com/llvm/llvm-project/pull/66067", "title": "[JITLink][RISCV] Implement .eh_frame handling", "body": "This patch enables .eh_frame handling on RISC-V by using the common `DWARFRecordSectionSplitter`, `EHFrameEdgeFixer`, and `EHFrameNullTerminator` passes.\r\n\r\nThis mostly works out of the box but a minor change was needed for `EHFrameEdgeFixer`: on RISC-V, ADD/SUB relocations are used to calculate the length of a sequence of instructions when relaxation is enabled. Since both relocations are at the same offset, this caused an error to be raised by `EHFrameEdgeFixer`. I have solved this issue by simply ignoring relocations at the same offset on RISC-V. I believe this is fine since the DWARF fields where they are used (PC-range and `DW_CFA_advance_loc`) don't need any special handling.\r\n\r\nBesides this, two new edge kinds needed to be implemented for RISC-V: `Delta64` and `NegDelta32`", "feature_layers": [], "feature_directives": ["for", "sections"], "files_changed": [{"filename": "llvm/lib/ExecutionEngine/JITLink/ELF_riscv.cpp", "functions": ["makeTargetOutOfRangeError"]}]}
{"pr_number": 70551, "url": "https://github.com/llvm/llvm-project/pull/70551", "title": "[clang][DebugInfo] Emit global variable definitions for static data members with constant initializers", "body": "When an LLDB user asks for the value of a static data member, LLDB starts by\r\nsearching the Names accelerator table for the corresponding variable definition\r\nDIE. For static data members with out-of-class definitions that works fine,\r\nbecause those get represented as global variables with a location and making them\r\neligible to be added to the Names table. However, in-class definitions won\u2019t get\r\nindexed because we usually don't emit global variables for them. So in DWARF\r\nwe end up with a single `DW_TAG_member` that usually holds the constant initializer.\r\nBut we don't get a corresponding CU-level `DW_TAG_variable` like we do for\r\nout-of-class definitions.\r\n\r\nTo make it more convenient for debuggers to get to the value of inline static data members,\r\nthis patch makes sure we emit definitions for static variables with constant initializers\r\nthe same way we do for other static variables. This also aligns Clang closer to GCC, which\r\nproduces CU-level definitions for inline statics and also emits these into `.debug_pubnames`.\r\n\r\nThe implementation keeps track of newly created static data members. Then in\r\n`CGDebugInfo::finalize`, we emit a global `DW_TAG_variable` with a `DW_AT_const_value` for\r\nany of those declarations that didn't end up with a definition in the `DeclCache`.\r\n\r\nThe newly emitted `DW_TAG_variable` will look as follows:\r\n```\r\n0x0000007b:   DW_TAG_structure_type\r\n                DW_AT_calling_convention        (DW_CC_pass_by_value)\r\n                DW_AT_name      (\"Foo\")\r\n                ...\r\n\r\n0x0000008d:     DW_TAG_member\r\n                  DW_AT_name    (\"i\")\r\n                  DW_AT_type    (0x00000062 \"const int\")\r\n                  DW_AT_external        (true)\r\n                  DW_AT_declaration     (true)\r\n                  DW_AT_const_value     (4)\r\n\r\nNewly added\r\nvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv\r\n\r\n0x0000009a:   DW_TAG_variable\r\n                DW_AT_specification     (0x0000008d \"i\")\r\n                DW_AT_const_value       (4)\r\n                DW_AT_linkage_name      (\"_ZN2t2IiE1iIfEE\")\r\n```", "feature_layers": [], "feature_directives": ["for", "single"], "files_changed": [{"filename": "clang/lib/CodeGen/CGDebugInfo.cpp", "functions": ["if"]}, {"filename": "clang/test/CodeGenCXX/debug-info-static-inline-member.cpp", "functions": ["func", "main"]}]}
{"pr_number": 70572, "url": "https://github.com/llvm/llvm-project/pull/70572", "title": "[MLIR][LLVM] Change CAPI pointer factory to create opaque pointers", "body": "This commit changes the LLVM dialect's CAPI pointer getters to drop support for typed pointers. Typed pointers are deprecated and should no longer be generated.\r\n\r\nI'm not really sure whom to assign as reviewers for this change. Feel free to add some potential candidates.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/CAPI/Dialect/LLVM.cpp", "functions": ["mlirLLVMPointerTypeGet", "wrap"]}]}
{"pr_number": 66769, "url": "https://github.com/llvm/llvm-project/pull/66769", "title": "[APINotes] Upstream APINotesReader", "body": "This upstreams more of the Clang API Notes functionality that is currently implemented in the Apple fork: https://github.com/apple/llvm-project/tree/next/clang/lib/APINotes", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/APINotes/APINotesReader.cpp", "functions": ["APINotesReader", "readUnversioned", "Key", "Results", "ReadVariableInfo", "ReadCommonTypeInfo", "ComputeHash", "getSelector", "Implementation", "EqualKey", "ReadFunctionInfo", "ReadParamInfo", "ReadKey", "getIdentifier", "GetExternalKey", "GetInternalKey", "ContextID", "Cursor", "ReadVersionTuple", "IdentifierID", "ReadCommonEntityInfo"]}]}
{"pr_number": 69911, "url": "https://github.com/llvm/llvm-project/pull/69911", "title": "[clang][Interp] Fix truncateCast()", "body": "The added test case used to fail because we converted the LHS to `-1`.", "feature_layers": ["ast"], "feature_directives": [], "files_changed": [{"filename": "clang/test/AST/Interp/intap.cpp", "functions": ["_BitInt"]}]}
{"pr_number": 70250, "url": "https://github.com/llvm/llvm-project/pull/70250", "title": "[flang][mlir][openacc] Switch device_type representation to an enum", "body": "Switch the representation from scalar integer to a enumeration. The parser transform the string in the input to the correct enumeration. ", "feature_layers": ["parse", "ir", "parser"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/OpenACC/IR/OpenACC.cpp", "functions": ["getOperand"]}]}
{"pr_number": 69521, "url": "https://github.com/llvm/llvm-project/pull/69521", "title": "[Sema] Fixed faulty shift count warning", "body": "Constant values of _BitInt have the bitwith to exactly fit the constant number. This patch fix a problem in Sema when building an APInt where the supplied bitwidth can become too small and simply truncate the value leading to a faulty warning.\r\n", "feature_layers": ["sema"], "feature_directives": [], "files_changed": [{"filename": "clang/lib/Sema/SemaExpr.cpp", "functions": ["LeftBits"]}]}
{"pr_number": 69351, "url": "https://github.com/llvm/llvm-project/pull/69351", "title": "[OpenMP][NFC] Refactor to prepare for SDMA engine patch", "body": "This is a refactoring in preparation of another patch that I'm working on.\r\n\r\nRight now, we dispatch the memory copies via `hsa_amd_memory_async_copy`.\r\nThis selects the default SDMA engine for the data transfer, which may not be ideal.\r\nWith ROCm 5.7 a new API is introduced that allows to select the SDMA engine\r\nused for a specific transfer. In order to make the functional changes more visible,\r\nI'd like to first land this NFC.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "openmp/libomptarget/plugins-nextgen/amdgpu/src/rtl.cpp", "functions": ["Lock"]}]}
{"pr_number": 68342, "url": "https://github.com/llvm/llvm-project/pull/68342", "title": "[flang] Check for overflows in RESHAPE folding", "body": "TotalElementCount() was modified to return std::optional<uint64_t>,\r\nwhere std::nullopt means overflow occurred. Besides the additional\r\ncheck in RESHAPE folding, all callers of TotalElementCount() were\r\nchanged, to also check for overflows.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Evaluate/constant.cpp", "functions": ["TotalElementCount"]}]}
{"pr_number": 70678, "url": "https://github.com/llvm/llvm-project/pull/70678", "title": "[OpenMP] Add a test for D158802", "body": "In D158802 we honored user's `thread_limit` value even with the optimization\nintroduced in D152014. This patch adds a simple test.\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "openmp/libomptarget/test/offloading/small_trip_count_thread_limit.cpp", "functions": ["main"]}]}
{"pr_number": 68689, "url": "https://github.com/llvm/llvm-project/pull/68689", "title": "[Flang][OpenMP][MLIR] Initial array section mapping MLIR -> LLVM-IR lowering utilising omp.bounds", "body": "This patch seeks to add initial lowering of OpenMP array sections within target region map clauses from MLIR to LLVM IR.\r\n\r\nThis patch seeks to support fixed sized contiguous (don't think OpenMP supports anything other than contiguous sections from my reading but i could be wrong) arrays initially, before looking toward assumed size and shaped arrays. The patch also currently does not include stride, it's left for future work. \r\n\r\nAlthough, assumed size works in some fashion (dummy arguments) with some minor alterations to the OMPEarlyOutliner, so it is possible changes made in the IsolatedFromAbove series may allow this to work with no further required patches.\r\n\r\nIt utilises the generated omp.bounds to calculate the size of the mapped OpenMP array (both for sectioned and un-sectioned arrays) as well as the offset to be passed to the kernel argument structure.\r\n\r\nAlongside these changes some refactoring of how map data is handled is attempted, using a new MapData structure to keep track of information utilised in the lowering of mapped values.\r\n\r\nThe initial addition of a more complex createDeviceArgumentAccessor that utilises capture kinds similarly to (and loosely based on) Clang to generate different kernel argument accesses is also added.\r\n\r\nA similar function for altering how the kernel argument is passed to the kernel argument structure on the host is also utilised (createAlteredByCaptureMap), which allows modification of the pointer/basePointer based on their capture (and bounds information). It's of note ByRef, is the default for explicit mappings and ByCopy will be the default for implicit captures, so the former is currently tested in this patch and the latter is not for the moment.", "feature_layers": ["ir"], "feature_directives": ["for", "sections", "target"], "files_changed": [{"filename": "mlir/lib/Target/LLVMIR/Dialect/OpenMP/OpenMPToLLVMIRTranslation.cpp", "functions": ["fail", "append", "getArrayElementSizeInBits", "getSizeInBytes"]}]}
{"pr_number": 67699, "url": "https://github.com/llvm/llvm-project/pull/67699", "title": "[MachineInstr] add insert method for variadic instructions", "body": "As alluded to in #20571, it would be nice if we could mutate operand\r\nlists of MachineInstr's more safely. Add an insert method that together\r\nwith removeOperand allows for easier splicing of operands.\r\n\r\nSplitting this patch off early to get feedback; I need to either:\r\n- mutate an INLINEASM{_BR} MachinInstr's MachineOperands from being\r\n  registers (physical or virtual) to memory\r\n  (MachineOperandType::MO_FrameIndex).  These are not 1:1 operand\r\n  replacements, but N:M operand replacements. i.e. we need to\r\n  update 2 MachineOperands into the middle of the operand list to 5 (at\r\n  least for x86_64).\r\n- copy, modify, write a new MachineInstr which has its relevant operands\r\n  replaced.\r\n\r\nEither approaches are hazarded by existing references to either the\r\noperands being moved, or the instruction being removed+replaced. For my\r\npurposes in regalloc, either seem to work for me, so hopefully reviewers\r\ncan help me determine which approach is preferable. The second would\r\ninvolve no new methods on MachineInstr.\r\n\r\nOne question I had while looking at this was: \"why does MachineInstr\r\nhave BOTH a NumOperands member AND a MCInstrDesc member that itself has\r\na NumOperands member? How many operands can a MachineInstr have? Do I\r\nneed to update BOTH (keeping them in sync)?\" FWICT, only \"variadic\"\r\nMachineInstrs have MCInstrDesc with NumOperands (of the MCInstrDesc) set\r\nto zero.  If the MCInstrDesc's NumOperands is non-zero, then the NumOperands\r\non the MachineInstr itself cannot exceed this value (IIUC) else an assert will\r\nbe triggered.\r\n\r\nFor most non-psuedo instructions (or at least non-varidic instructions),\r\ninsert is less likely to be useful.\r\n\r\nTo run the newly added unittest:\r\n    $ pushd llvm/build; ninja CodeGenTests; popd\r\n    $ ./llvm/build/unittests/CodeGen/CodeGenTests \\\r\n        --gtest_filter=MachineInstrTest.SpliceOperands\r\n\r\nThis is meant to mirror `MCInst::insert`.", "feature_layers": ["codegen", "ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/unittests/CodeGen/MachineInstrTest.cpp", "functions": ["Mod"]}]}
{"pr_number": 70727, "url": "https://github.com/llvm/llvm-project/pull/70727", "title": "[mlir][sparse] split post-sparsification-rewriting into two passes.", "body": "", "feature_layers": ["parse", "ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/Transforms/SparseTensorPasses.cpp", "functions": ["runOnOperation", "patterns"]}]}
{"pr_number": 70737, "url": "https://github.com/llvm/llvm-project/pull/70737", "title": "[mlir][sparse] implements tensor.insert on sparse tensors.", "body": "", "feature_layers": ["parse", "ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/Transforms/SparseReinterpretMap.cpp", "functions": ["failure", "success"]}, {"filename": "mlir/lib/Dialect/SparseTensor/Transforms/SparseTensorRewriting.cpp", "functions": ["dstLcvs", "success", "offDimCrd"]}]}
{"pr_number": 69754, "url": "https://github.com/llvm/llvm-project/pull/69754", "title": "[builtins] Avoid using long double in generic sources", "body": "Use of long double can be error-prone since it could be one of 80-bit\r\nextended precision float, IEEE 128-bit float, or IBM 128-bit float.\r\nInstead use an explicit xf_float typedef for the remaining cases where\r\nlong double is being used in the implementation. This patch does not touch\r\nthe PPC specializations which still use long double.\r\n\r\nDepends on #68132 (to be committed after that PR).", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "compiler-rt/lib/builtins/extendxftf2.c", "functions": ["__extendxftf2"]}, {"filename": "compiler-rt/lib/builtins/fixunsxfdi.c", "functions": ["__fixunsxfdi"]}, {"filename": "compiler-rt/lib/builtins/fixunsxfsi.c", "functions": ["__fixunsxfsi"]}, {"filename": "compiler-rt/lib/builtins/fixunsxfti.c", "functions": ["__fixunsxfti"]}, {"filename": "compiler-rt/lib/builtins/fixxfdi.c", "functions": ["__fixxfdi"]}, {"filename": "compiler-rt/lib/builtins/fixxfti.c", "functions": ["__fixxfti"]}, {"filename": "compiler-rt/lib/builtins/floatdixf.c", "functions": ["__floatdixf"]}, {"filename": "compiler-rt/lib/builtins/floattixf.c", "functions": ["__floattixf"]}, {"filename": "compiler-rt/lib/builtins/floatundixf.c", "functions": ["__floatundixf"]}, {"filename": "compiler-rt/lib/builtins/floatuntixf.c", "functions": ["__floatuntixf"]}, {"filename": "compiler-rt/lib/builtins/powixf2.c", "functions": ["__powixf2"]}, {"filename": "compiler-rt/lib/builtins/ppc/multc3.c", "functions": ["__multc3"]}, {"filename": "compiler-rt/lib/builtins/trunctfxf2.c", "functions": ["__truncXfYf2__", "__trunctfxf2"]}, {"filename": "compiler-rt/lib/builtins/x86_64/floatdixf.c", "functions": ["__floatdixf"]}]}
{"pr_number": 70262, "url": "https://github.com/llvm/llvm-project/pull/70262", "title": "[Driver] Reject unsupported -mcmodel=", "body": "-mcmodel= is supported for a few architectures. Reject the option for\nother architectures.\n\n* -mcmodel= is unsupported on x86-32.\n* -mcmodel=large is unsupported for PIC on AArch64.\n* -mcmodel= is unsupported for aarch64_32 triples.\n* https://reviews.llvm.org/D67066 (for RISC-V) made -mcmodel=medany/-mcmodel=medlow aliases for all architectures. Restrict this to RISC-V.\n* llvm/lib/Target/Sparc has some small/medium/large support, but the values listed on https://gcc.gnu.org/onlinedocs/gcc/SPARC-Options.html had been supported before https://reviews.llvm.org/D67066. Consider -mcmodel= unsupported for Sparc.\n* https://reviews.llvm.org/D106371 translated -mcmodel=medium to -mcmodel=large on AIX, even for 32-bit systems. Retain this behavior but reject -mcmodel= for other PPC32 systems.\n\nIn general the accept/reject behavior is more similar to GCC.\n\nerr_drv_invalid_argument_to_option is less clear than\nerr_drv_unsupported_option_argument. As the supported values are different for\ndifferent architectures, add a err_drv_unsupported_option_argument_for_target\nfor better clarity.\n", "feature_layers": [], "feature_directives": ["for", "target"], "files_changed": [{"filename": "clang/lib/Driver/ToolChains/Clang.cpp", "functions": ["if"]}]}
{"pr_number": 70404, "url": "https://github.com/llvm/llvm-project/pull/70404", "title": "[Clang][LoongArch] Support builtin functions for LSX and LASX", "body": "These commits support builtin functions for LSX and LASX.\r\nThey do the following work:\r\n\r\nSupport compiler options -mlsx and -mlasx\r\nAdd ABI implementation of passing vectors\r\nDefine the builtin functions for LSX\r\nDefine the builtin functions for LASX", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Basic/Targets/LoongArch.cpp", "functions": ["if"]}, {"filename": "clang/lib/Driver/ToolChains/Arch/LoongArch.cpp", "functions": ["if"]}, {"filename": "clang/test/Driver/loongarch-mlasx.c", "functions": ["foo"]}, {"filename": "clang/test/Driver/loongarch-mlsx.c", "functions": ["foo"]}, {"filename": "clang/lib/Sema/SemaChecking.cpp", "functions": ["SemaBuiltinConstantArgRange"]}]}
{"pr_number": 70709, "url": "https://github.com/llvm/llvm-project/pull/70709", "title": "[clang-tidy] Fix crash in modernize-use-trailing-return-type", "body": "Resolved the crash that occurred during the use of a user-defined C-style string literal. The fix entails checking whether the identifier is non-empty before attempting to read its name.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang-tools-extra/test/clang-tidy/checkers/modernize/use-trailing-return-type-cxx20.cpp", "functions": ["CustomCompileTimeString", "decltype"]}]}
{"pr_number": 70731, "url": "https://github.com/llvm/llvm-project/pull/70731", "title": "[MLIR][AsyncToLLVM] Remove typed pointer support", "body": "This commit removes the support for lowering Async to LLVM dialect with typed pointers. Typed pointers have been deprecated for a while now and it's planned to soon remove them from the LLVM dialect.\r\n\r\nRelated PSA: https://discourse.llvm.org/t/psa-removal-of-typed-pointers-from-the-llvm-dialect/74502", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Conversion/AsyncToLLVM/AsyncToLLVM.cpp", "functions": ["awaitAllAndExecuteFunctionType", "emplaceValueFunctionType", "awaitTokenAndExecuteFunctionType", "llvmOpaquePointers", "isValueErrorFunctionType", "convertAsyncTypes", "awaitValueFunctionType", "getValueStorageFunctionType", "setValueErrorFunctionType", "addAsyncRuntimeApiDeclarations", "useOpaquePointers", "opaquePointerType", "addOrDropRefFunctionType", "awaitValueAndExecuteFunctionType", "executeFunctionType", "getPointerType", "addResumeFunction", "createValueFunctionType", "resumeFunctionType"]}]}
{"pr_number": 66894, "url": "https://github.com/llvm/llvm-project/pull/66894", "title": "[clang] Implement constexpr bit_cast for vectors", "body": "This makes __builtin_bit_cast support converting to and from vector types in a constexpr context.", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/AST/ExprConstant.cpp", "functions": ["APValue", "Success", "QualType", "visitVector", "handleRValueToRValueBitCast", "SValInt", "visit", "Error"]}, {"filename": "clang/lib/CodeGen/CGExprConstant.cpp", "functions": ["if"]}, {"filename": "clang/test/SemaCXX/constexpr-builtin-bit-cast-fp80.cpp", "functions": ["__attribute"]}, {"filename": "clang/test/SemaCXX/constexpr-builtin-bit-cast.cpp", "functions": ["__attribute__"]}]}
{"pr_number": 69313, "url": "https://github.com/llvm/llvm-project/pull/69313", "title": "[Clang][LoongArch] Support builtin functions for LSX and LASX", "body": "These commits support builtin functions for LSX and LASX.\r\nThey do the following work:\r\n- Support compiler options -mlsx and -mlasx\r\n-  Add ABI implementation of passing vectors\r\n- Define the builtin functions for LSX\r\n- Define the builtin functions for LASX\r\n- Add builtin functions test cases for LSX(by Chenli(<chenli@loongson.cn>))\r\n- Add builtin functions test cases for LASX(by Chenli(<chenli@loongson.cn>))", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Basic/Targets/LoongArch.cpp", "functions": ["if"]}, {"filename": "clang/lib/Driver/ToolChains/Arch/LoongArch.cpp", "functions": ["if"]}, {"filename": "clang/test/Driver/loongarch-mlasx.c", "functions": ["foo"]}, {"filename": "clang/test/Driver/loongarch-mlsx.c", "functions": ["foo"]}, {"filename": "clang/lib/Sema/SemaChecking.cpp", "functions": ["SemaBuiltinConstantArgRange"]}, {"filename": "clang/test/CodeGen/LoongArch/lsx/builtin-alias-error.c", "functions": ["vssrarni_du_q", "vssrani_du_q", "vreplvei_b", "vaddi_hu", "vslli_h", "vslti_du", "vrepli_w", "vmini_wu", "vsllwil_h_b", "vbitrevi_b", "vslei_bu", "vreplvei_d", "vmini_du", "vbitseti_b", "vbitseti_w", "vsllwil_du_wu", "vldrepl_b", "vsat_wu", "vbitseti_d", "vbitclri_h", "vslti_wu", "vnori_b", "vxori_b", "vsrli_h", "vslei_b", "vslei_w", "vsrlri_h", "vbsll_v", "vseqi_b", "vseqi_d", "vssrlni_d_q", "vpickve2gr_du", "vssrlrni_du_q", "vsrlrni_b_h", "vmaxi_bu", "vrotri_h", "vssrarni_hu_w", "vssrlni_b_h", "vmaxi_du", "vbsrl_v", "vinsgr2vr_h", "vsubi_bu", "vsubi_wu", "vssrlrni_h_w", "vssrarni_w_d", "vshuf4i_h", "vsrlri_w", "vssrani_wu_d", "vseqi_w", "vsrli_d", "vreplvei_w", "vssrarni_bu_h", "vssrlni_w_d", "vbitrevi_w", "vsrlni_h_w", "vfrstpi_h", "vsat_hu", "vori_b", "vldrepl_h", "vsrlni_d_q", "vrepli_b", "vpickve2gr_bu", "vextrins_h", "vsat_w", "vsrari_w", "vsrani_d_q", "vslti_bu", "vssrani_bu_h", "vsat_du", "vslti_hu", "vextrins_b", "vrepli_h", "vbitseti_h", "vinsgr2vr_w", "vssrarni_wu_d", "vsrlni_w_d", "vstelm_b", "vmaxi_h", "vbitseli_b", "vssrani_d_q", "vsrari_d", "vssrarni_b_h", "vsrlrni_w_d", "vstelm_b_idx", "vstelm_d_idx", "vsrlrni_d_q", "vbitrevi_h", "vbitclri_w", "vslti_h", "vpickve2gr_d", "vssrani_b_h", "vssrlrni_w_d", "vslti_w", "vsat_d", "vsrani_w_d", "vmaxi_w", "vstelm_w", "vssrlrni_bu_h", "vrotri_w", "vsrai_w", "vmini_bu", "vsllwil_d_w", "vshuf4i_w", "vpickve2gr_h", "vssrlni_h_w", "vmaxi_wu", "vsllwil_w_h", "vslei_h", "vssrarni_d_q", "vextrins_d", "vsrli_b", "vrotri_d", "vsat_bu", "vld", "vsrarni_h_w", "vfrstpi_b", "vssrlni_du_q", "vreplvei_h", "vmaxi_hu", "vaddi_wu", "vmini_w", "vsrari_h", "vpickve2gr_wu", "vsrlni_b_h", "vssrani_h_w", "vrepli_d", "vsllwil_hu_bu", "vsrai_d", "vsubi_du", "vslti_d", "vsrlri_d", "vbitrevi_d", "vbitclri_d", "vssrani_w_d", "vssrlni_wu_d", "vslli_d", "vrotri_b", "vsubi_hu", "vsllwil_wu_hu", "vldrepl_d", "vsrlrni_h_w", "vinsgr2vr_d", "vstelm_d", "vsrarni_d_q", "vssrlrni_hu_w", "vssrlni_hu_w", "vpermi_w", "vslti_b", "vmini_h", "vsrai_h", "vslli_w", "vslei_wu", "vpickve2gr_hu", "vshuf4i_b", "vsrani_b_h", "vslli_b", "vseqi_h", "vandi_b", "vaddi_bu", "vstelm_w_idx", "vextrins_w", "vssrani_hu_w", "vldrepl_w", "vsrarni_b_h", "vshuf4i_d", "vmini_b", "vpickve2gr_b", "vpickve2gr_w", "vsrarni_w_d", "vsrani_h_w", "vslei_hu", "vmaxi_d", "vsrlri_b", "vinsgr2vr_b", "vsrli_w", "vmaxi_b", "vsat_h", "vmini_hu", "vslei_du", "vstelm_h_idx", "vsat_b", "vsrari_b", "vstelm_h", "vssrlrni_d_q", "vssrarni_h_w", "vssrlrni_wu_d", "vssrlrni_b_h", "vmini_d", "vbitclri_b", "vst", "vldi", "vslei_d", "vssrlni_bu_h", "vsrai_b", "vaddi_du"]}, {"filename": "clang/test/CodeGen/LoongArch/lsx/builtin-alias.c", "functions": ["vfrintrne_d", "vaddi_hu", "vsadd_w", "vfmaxa_d", "vseq_w", "vmod_h", "__lsx_vssrarni_hu_w", "vssrarn_bu_h", "vbitrevi_b", "__lsx_vmadd_h", "vreplvei_d", "vsadd_wu", "vdiv_hu", "vbitseti_w", "vmul_d", "vmuh_w", "vsle_w", "vsigncov_d", "vsrl_b", "vpickod_h", "vaddwod_q_du_d", "vslei_b", "vseqi_b", "vmaddwev_h_bu", "vslt_bu", "vavg_wu", "vabsd_hu", "vreplgr2vr_w", "vaddwod_q_d", "vshuf_b", "vfcmp_sun_d", "vftintrneh_l_s", "vpackod_h", "vneg_b", "vmulwev_d_wu_w", "vxor_v", "vsrlri_w", "vsub_d", "vsll_d", "vreplvei_w", "vftintrz_w_d", "__lsx_vmadd_b", "vadd_w", "__lsx_vshuf_b", "vmax_w", "vmaddwev_d_wu", "vsigncov_b", "vori_b", "__lsx_vssrlrni_wu_d", "vrepli_b", "vextrins_h", "__lsx_vmaddwev_d_wu", "vfsqrt_s", "vfcmp_sule_d", "vsubwev_h_b", "vfrintrp_s", "vmulwod_w_hu", "vfmsub_d", "vbitseti_h", "vfsqrt_d", "__lsx_vmaddwev_w_hu", "__lsx_vssrlrni_hu_w", "vssrarni_wu_d", "vmul_w", "vsrln_b_h", "vftintrm_l_d", "vssrani_d_q", "vbitclr_b", "vmaddwod_w_h", "vsrari_d", "vor_v", "vssrarni_b_h", "vftintrmh_l_s", "__lsx_vmsub_h", "vssrln_w_d", "vshuf_d", "vaddwod_d_wu_w", "vmin_d", "vilvh_b", "vclo_d", "vilvl_d", "vmaddwev_q_d", "vadd_d", "vfrintrm_s", "bz_b", "vmaxi_w", "vstelm_w", "vfmadd_d", "vdiv_h", "vclo_h", "vmadd_h", "vaddwev_d_w", "vrotri_w", "vmini_bu", "vshuf4i_w", "vmsub_b", "vmskgez_b", "vpackev_h", "vslei_h", "vmax_bu", "__lsx_vfmadd_d", "vreplve_w", "vmaddwev_w_hu_h", "vmaddwod_q_du_d", "vssrarn_hu_w", "bnz_d", "vfcmp_cult_s", "vsadd_b", "vdiv_wu", "vfcmp_cule_d", "vftintrz_l_d", "vmod_d", "vftintrne_w_d", "vsra_w", "vrotr_w", "vrepli_d", "vssub_h", "vslti_d", "vhsubw_d_w", "__lsx_vfmsub_d", "vsrlri_d", "vssrlrn_h_w", "vbitclri_d", "vldx", "vfcmp_caf_d", "__lsx_vaddwev_q_du_d", "vreplve_h", "__lsx_vfmadd_s", "vexth_hu_bu", "vffint_s_l", "vmuh_h", "vhsubw_wu_hu", "vavgr_wu", "vavgr_b", "vpickod_b", "__lsx_vmaddwod_h_bu", "vmaddwev_q_du", "vsrarni_d_q", "vftintrzl_l_s", "vmin_h", "vfcmp_cle_d", "vfcmp_clt_d", "__lsx_vmaddwod_q_du_d", "vpermi_w", "__lsx_vfnmsub_s", "vmulwod_q_du_d", "vslli_w", "vmulwod_h_b", "bnz_h", "vpcnt_d", "__lsx_vmaddwod_q_du", "vsrani_b_h", "vaddi_bu", "vssrani_hu_w", "vsubwev_q_du", "vsadd_hu", "vshuf4i_d", "__lsx_vmaddwod_d_wu_w", "vavg_hu", "vfcmp_clt_s", "__lsx_vmadd_d", "vfclass_d", "vmaxi_d", "vsrlri_b", "vmuh_d", "vpackev_d", "vmaxi_b", "vfrsqrt_s", "vftintrne_l_d", "vfcmp_sle_d", "vsat_h", "vstelm_h", "vsat_b", "vclz_b", "vfdiv_s", "vmax_b", "vclo_b", "vsll_h", "vbitclri_b", "vmaddwev_h_bu_b", "vssub_wu", "vsigncov_w", "vaddwod_h_bu_b", "vexth_du_wu", "vsra_h", "vftintrpl_l_s", "vfcmp_sule_s", "vsubwev_h_bu", "__lsx_vssrarni_bu_h", "vaddi_du", "vfcvt_s_d", "vmulwod_w_hu_h", "vbitset_b", "vssrarn_wu_d", "vpackev_b", "vilvh_h", "vfrstp_h", "vslti_du", "vsubwev_w_hu", "vsrlr_b", "__lsx_vmaddwod_h_b", "vmaddwod_w_hu", "vexth_wu_hu", "vssrln_b_h", "vsllwil_h_b", "vbitseti_b", "vpickev_b", "vsat_wu", "vavg_b", "vbitseti_d", "__lsx_vmaddwod_w_h", "vfcmp_cor_d", "vxori_b", "vslei_w", "vssrarn_h_w", "vseqi_d", "vsrlrni_b_h", "vaddwev_w_h", "vmaddwod_w_hu_h", "bnz_v", "vftintrp_w_d", "vmulwod_d_wu_w", "vfcmp_cune_d", "vsubi_bu", "vhsubw_du_wu", "vpickev_w", "vsubwod_d_wu", "vssrlrni_h_w", "vfrstp_b", "vssrani_wu_d", "vsrli_d", "__lsx_vmadd_w", "vsubwod_q_d", "vfmin_d", "vfcmp_sune_d", "vmin_du", "vsrlni_h_w", "vbitclr_d", "__lsx_vmulwod_q_du_d", "vldrepl_h", "vsrlni_d_q", "vpickve2gr_bu", "vsat_w", "vmulwev_w_h", "vfcmp_caf_s", "vsrari_w", "__lsx_vfrstp_h", "vsrani_d_q", "vsat_du", "vslti_hu", "vextrins_b", "vavg_w", "vmsub_h", "vsubwod_d_w", "vfcmp_ceq_s", "vclz_w", "vhaddw_wu_hu", "__lsx_vaddwod_h_bu_b", "vfrecip_d", "vmaxi_h", "vfnmadd_d", "vhaddw_q_d", "vftintrz_wu_s", "vfcmp_slt_d", "__lsx_vmsub_d", "vbitrev_w", "vslt_d", "vfsub_d", "vfsub_s", "vaddwev_q_du_d", "vsrlrni_d_q", "vdiv_du", "__lsx_vmaddwev_d_wu_w", "vslti_h", "__lsx_vmaddwev_w_h", "vsle_d", "vslti_w", "vsat_d", "vftintl_l_s", "__lsx_vmulwod_d_wu_w", "vssrlrni_bu_h", "vexth_d_w", "vmin_wu", "vaddwod_h_b", "vsllwil_d_w", "vssrlni_h_w", "vadda_d", "vsran_w_d", "__lsx_vmulwev_h_bu_b", "vsllwil_w_h", "vmaddwod_q_d", "__lsx_vmaddwev_q_d", "vsle_bu", "vreplgr2vr_d", "__lsx_vmulwev_d_wu_w", "vextrins_d", "vssub_du", "vsat_bu", "vssub_bu", "vld", "vsrarni_h_w", "vssrlni_du_q", "vmaddwev_h_b", "vsrar_h", "vfmul_d", "vmini_w", "__lsx_vmulwev_w_hu_h", "__lsx_vfnmadd_d", "vssrani_h_w", "vand_v", "vssran_h_w", "vclo_w", "vsrai_d", "vfadd_d", "vsub_q", "vfrint_s", "vsrlrn_w_d", "__lsx_vmulwev_q_du_d", "__lsx_vmaddwev_q_du_d", "vmadd_b", "vhsubw_h_b", "vssrlni_wu_d", "vnor_v", "vsubi_hu", "vsra_b", "vsllwil_wu_hu", "vsub_h", "vldrepl_d", "vinsgr2vr_d", "vstelm_d", "vfcmp_cueq_d", "vreplgr2vr_b", "vreplgr2vr_h", "vssrlrni_hu_w", "vmulwev_w_hu_h", "vsubwod_h_b", "vfmsub_s", "vsubwod_w_hu", "vslt_wu", "vmax_du", "vsadd_du", "vslli_b", "vfmax_s", "vmuh_hu", "vfnmadd_s", "vfcmp_sne_d", "vmod_du", "vaddwod_w_hu_h", "vssrlrn_b_h", "__lsx_vfmsub_s", "vaddwod_w_hu", "vhaddw_hu_bu", "vldrepl_w", "vfrintrm_d", "vftintrph_l_s", "vsigncov_h", "vaddwev_d_wu", "vslt_hu", "vsrarni_w_d", "vsrani_h_w", "__lsx_vshuf_h", "vslei_hu", "vmulwev_q_du", "vextl_q_d", "vpackod_d", "vfmin_s", "vinsgr2vr_b", "vadda_h", "vffinth_d_w", "vssrlrni_d_q", "vmax_hu", "__lsx_vshuf_w", "vsadd_d", "vmuh_du", "vmulwod_q_du", "vfcmp_slt_s", "vslei_d", "vssrarn_b_h", "vsrarn_w_d", "vsrln_h_w", "vsrlrn_h_w", "vssrani_du_q", "vaddwev_h_bu_b", "bz_h", "vslli_h", "vssub_d", "vftintrm_w_s", "vslei_bu", "vmini_du", "vslt_b", "vldrepl_b", "vseq_b", "vsadd_bu", "__lsx_vbitsel_v", "vfnmsub_d", "vhaddw_h_b", "vbitclri_h", "vslti_wu", "vnori_b", "__lsx_vfnmsub_d", "vilvl_h", "vmaddwev_d_wu_w", "vmuh_bu", "vfrintrz_d", "vsrlri_h", "vpickve2gr_du", "vsle_h", "vmaxi_bu", "__lsx_vmaddwod_w_hu_h", "vssrarni_hu_w", "vmskltz_w", "vmod_bu", "vmaxi_du", "vrotr_d", "vsubwev_q_d", "__lsx_vmsub_b", "vsubi_wu", "vsll_b", "vssran_wu_d", "vaddwev_w_hu", "__lsx_vssrlrni_du_q", "vsub_b", "bz_v", "vmaddwod_h_b", "__lsx_vaddwev_w_hu_h", "vssrarni_bu_h", "vfcvth_d_s", "vfcmp_saf_d", "vflogb_d", "vmadd_d", "vbitrevi_w", "vaddwod_d_w", "vbitsel_v", "vabsd_bu", "vexth_q_d", "vpackev_w", "vffint_s_w", "vfcmp_cne_d", "vbitrev_b", "vslti_bu", "vrepli_h", "vshuf_h", "vfcmp_sult_s", "__lsx_vmaddwev_h_bu", "vsrlni_w_d", "vslt_du", "vstelm_b", "vfmul_s", "vsran_h_w", "vftintrz_w_s", "__lsx_vmaddwod_d_w", "vilvl_w", "vssrarn_w_d", "vssrln_wu_d", "vmaddwev_w_h", "bnz_b", "vbitrev_d", "vsrlrni_w_d", "vfcmp_cueq_s", "vssran_w_d", "vsle_b", "vbitrevi_h", "vfrintrp_d", "vabsd_h", "vbitclri_w", "vmax_d", "vpickve2gr_d", "vaddwod_d_wu", "vsrani_w_d", "bnz_w", "vabsd_d", "vsrar_b", "vssub_w", "vfcmp_sle_s", "vpickev_h", "vftintrp_l_d", "vfcmp_sne_s", "__lsx_vmsub_w", "vilvh_w", "vaddwev_d_wu_w", "vmax_wu", "vmulwod_h_bu", "vaddwod_w_h", "__lsx_vmaddwev_q_du", "vsrln_w_d", "vfdiv_d", "vsle_du", "vsrli_b", "vftintrml_l_s", "vaddwev_q_du", "vrotr_h", "__lsx_vssrarni_du_q", "vsle_hu", "vftint_l_d", "vfrintrne_s", "vavgr_d", "vpickod_w", "vfcmp_sor_d", "vilvl_b", "vftint_w_s", "vneg_d", "vshuf_w", "vssub_b", "vsubi_du", "__lsx_vmaddwod_h_bu_b", "vpackod_w", "vfcmp_sune_s", "vfcmp_cule_s", "vreplve_d", "vslli_d", "vfcmp_seq_s", "vrotri_b", "vslt_w", "vfcmp_cle_s", "vpcnt_b", "vabsd_du", "vfmaxa_s", "vfclass_s", "vbitclr_h", "vmsknz_b", "vavg_h", "vpackod_b", "vslti_b", "vmini_h", "vslei_wu", "vpickve2gr_hu", "vmulwev_h_bu_b", "vmin_b", "vshuf4i_b", "__lsx_vaddwod_q_du_d", "vexth_qu_du", "vsrar_d", "vandi_b", "vavgr_w", "vslt_h", "__lsx_vaddwod_w_hu_h", "vmulwev_q_d", "vextrins_w", "vsubwod_q_du", "vsrl_w", "vmulwev_d_w", "vssub_hu", "vmskltz_b", "vmini_b", "vpickve2gr_w", "vsadd_h", "vsrarn_h_w", "vsubwev_d_w", "vhsubw_w_h", "vftint_wu_s", "vhsubw_hu_bu", "vmaddwev_w_hu", "vpickev_d", "vsrli_w", "vmini_hu", "vexth_w_h", "vslei_du", "vssrln_bu_h", "vmskltz_d", "__lsx_vmaddwev_d_w", "vaddwev_h_bu", "vftintrnel_l_s", "vadd_q", "vmulwev_h_b", "__lsx_vmaddwev_h_b", "vst", "vftintrzh_l_s", "vsubwod_h_bu", "vmulwod_h_bu_b", "__lsx_vmulwod_h_bu_b", "vftint_lu_d", "vmulwev_q_du_d", "__lsx_vshuf_d", "vadda_w", "vfcvtl_d_s", "vclz_d", "vfnmsub_s", "vssrarni_du_q", "vavg_d", "vreplvei_b", "vextl_qu_du", "vfcmp_cne_s", "vpickod_d", "vavgr_h", "vrepli_w", "vmini_wu", "vpcnt_w", "vhaddw_d_w", "vmod_hu", "vmadd_w", "vfrsqrt_d", "vaddwev_h_b", "vsll_w", "vmul_h", "vsllwil_du_wu", "__lsx_vssrarni_wu_d", "bz_w", "__lsx_vmaddwod_q_d", "vsrl_h", "vmulwev_h_bu", "__lsx_vmaddwev_h_bu_b", "vsrli_h", "vbsll_v", "vmaddwod_d_wu_w", "vssrlni_d_q", "vfcvtl_s_h", "vmaddwod_h_bu_b", "vssrlrni_du_q", "vhaddw_du_wu", "vssrln_h_w", "vrotri_h", "vrotr_b", "vreplve_b", "vpcnt_h", "vfmadd_s", "vssrlni_b_h", "vbsrl_v", "vneg_h", "vinsgr2vr_h", "vexth_h_b", "vmskltz_h", "vssrarni_w_d", "vshuf4i_h", "vdiv_b", "vseqi_w", "vssrlni_w_d", "vaddwod_h_bu", "vavgr_hu", "vfrstpi_h", "vsat_hu", "vfcmp_sult_d", "vclz_h", "vftint_w_d", "vfcmp_sun_s", "vftintrm_w_d", "vmuh_b", "vfmina_d", "vssrani_bu_h", "vsra_d", "vmaddwev_q_du_d", "vinsgr2vr_w", "vfcmp_ceq_d", "vssran_bu_h", "vftintrz_lu_d", "vfcvt_h_s", "vfcmp_sueq_d", "vftintrp_w_s", "__lsx_vssrlrni_bu_h", "vbitseli_b", "vsrlr_h", "vhaddw_qu_du", "vdiv_w", "vftinth_l_s", "vffintl_d_w", "vmin_w", "vorn_v", "vavg_bu", "vfcmp_cor_s", "vmsub_d", "vfadd_s", "vstx", "vfmax_d", "vaddwev_q_d", "vmaddwod_d_wu", "vmax_h", "vbitset_w", "vsrar_w", "vfcmp_cun_d", "vssrani_b_h", "vssrlrni_w_d", "vsrlr_w", "vffint_d_lu", "vmulwod_d_wu", "vsub_w", "vavgr_du", "vilvh_d", "vavg_du", "__lsx_vfnmadd_s", "vsrai_w", "vssran_hu_w", "vpickve2gr_h", "vandn_v", "vmod_b", "vfrintrz_s", "vmaxi_wu", "vflogb_s", "vmaddwev_d_w", "__lsx_vmaddwod_d_wu", "vfcmp_cult_d", "vssrarni_d_q", "vmin_hu", "vrotri_d", "vabsd_b", "vmulwod_d_w", "vsrlr_d", "vfrstpi_b", "vreplvei_h", "vmaxi_hu", "vdiv_bu", "vaddi_wu", "vsran_b_h", "vsrari_h", "vmod_w", "vmul_b", "vpickve2gr_wu", "vsrlni_b_h", "bz_d", "vmulwod_q_d", "vsllwil_hu_bu", "vfcmp_seq_d", "vsubwev_w_h", "vssrani_w_d", "vsle_wu", "vbitrevi_d", "vffint_s_wu", "vaddwev_w_hu_h", "vmod_wu", "__lsx_vmaddwev_w_hu_h", "vfrecip_s", "vssrlrn_wu_d", "vabsd_w", "vabsd_wu", "vadd_b", "vsubwod_w_h", "vavgr_bu", "vneg_w", "vsrlrni_h_w", "__lsx_vfrstp_b", "vmulwod_w_h", "vmaddwod_d_w", "vmulwev_d_wu", "vftintrne_w_s", "vssrlni_hu_w", "vmin_bu", "vssrlrn_w_d", "vhsubw_qu_du", "vfcmp_cun_s", "vsrai_h", "vsrl_d", "vbitset_h", "vmsub_w", "vmulwev_w_hu", "vmuh_wu", "vseqi_h", "vssran_b_h", "vfcmp_sor_s", "vssrln_hu_w", "vaddwod_q_du", "vbitclr_w", "vffint_d_l", "vsrarni_b_h", "vfmina_s", "vadda_b", "vfcmp_cune_s", "vpickve2gr_b", "vhsubw_q_d", "vseq_h", "vbitset_d", "__lsx_vaddwev_d_wu_w", "__lsx_vaddwev_h_bu_b", "__lsx_vaddwod_d_wu_w", "vsrlrn_b_h", "vssrlrn_bu_h", "vfcmp_sueq_s", "vsrarn_b_h", "vhaddw_w_h", "__lsx_vmaddwod_w_hu", "vadd_h", "vfrint_d", "vfcvth_s_h", "vsrari_b", "vmaddwod_h_bu", "vbitrev_h", "vssrlrn_hu_w", "vssrarni_h_w", "vssrlrni_wu_d", "vssrlrni_b_h", "vmini_d", "vfcmp_saf_s", "vdiv_d", "vsubwev_d_wu", "__lsx_vmulwod_w_hu_h", "vldi", "vmaddwod_q_du", "vssrlni_bu_h", "vsrai_b", "vseq_d"]}, {"filename": "clang/test/CodeGen/LoongArch/lsx/builtin-error.c", "functions": ["vssrarni_du_q", "vssrani_du_q", "vreplvei_b", "vaddi_hu", "vslli_h", "vslti_du", "vrepli_w", "vmini_wu", "vsllwil_h_b", "vbitrevi_b", "vslei_bu", "vreplvei_d", "vmini_du", "vbitseti_b", "vbitseti_w", "vsllwil_du_wu", "vldrepl_b", "vsat_wu", "vbitseti_d", "vbitclri_h", "vslti_wu", "vnori_b", "vxori_b", "vsrli_h", "vslei_b", "vslei_w", "vsrlri_h", "vbsll_v", "vseqi_b", "vseqi_d", "vssrlni_d_q", "vpickve2gr_du", "vssrlrni_du_q", "vsrlrni_b_h", "vmaxi_bu", "vrotri_h", "vssrarni_hu_w", "vssrlni_b_h", "vmaxi_du", "vbsrl_v", "vinsgr2vr_h", "vsubi_bu", "vsubi_wu", "vssrlrni_h_w", "vssrarni_w_d", "vshuf4i_h", "vsrlri_w", "vssrani_wu_d", "vseqi_w", "vsrli_d", "vreplvei_w", "vssrarni_bu_h", "vssrlni_w_d", "vbitrevi_w", "vsrlni_h_w", "vfrstpi_h", "vsat_hu", "vori_b", "vldrepl_h", "vsrlni_d_q", "vrepli_b", "vpickve2gr_bu", "vextrins_h", "vsat_w", "vsrari_w", "vsrani_d_q", "vslti_bu", "vssrani_bu_h", "vsat_du", "vslti_hu", "vextrins_b", "vrepli_h", "vbitseti_h", "vinsgr2vr_w", "vssrarni_wu_d", "vsrlni_w_d", "vstelm_b", "vmaxi_h", "vbitseli_b", "vssrani_d_q", "vsrari_d", "vssrarni_b_h", "vsrlrni_w_d", "vstelm_b_idx", "vstelm_d_idx", "vsrlrni_d_q", "vbitrevi_h", "vbitclri_w", "vslti_h", "vpickve2gr_d", "vssrani_b_h", "vssrlrni_w_d", "vslti_w", "vsat_d", "vsrani_w_d", "vmaxi_w", "vstelm_w", "vssrlrni_bu_h", "vrotri_w", "vsrai_w", "vmini_bu", "vsllwil_d_w", "vshuf4i_w", "vpickve2gr_h", "vssrlni_h_w", "vmaxi_wu", "vsllwil_w_h", "vslei_h", "vssrarni_d_q", "vextrins_d", "vsrli_b", "vrotri_d", "vsat_bu", "vld", "vsrarni_h_w", "vfrstpi_b", "vssrlni_du_q", "vreplvei_h", "vmaxi_hu", "vaddi_wu", "vmini_w", "vsrari_h", "vpickve2gr_wu", "vsrlni_b_h", "vssrani_h_w", "vrepli_d", "vsllwil_hu_bu", "vsrai_d", "vsubi_du", "vslti_d", "vsrlri_d", "vbitrevi_d", "vbitclri_d", "vssrani_w_d", "vssrlni_wu_d", "vslli_d", "vrotri_b", "vsubi_hu", "vsllwil_wu_hu", "vldrepl_d", "vsrlrni_h_w", "vinsgr2vr_d", "vstelm_d", "vsrarni_d_q", "vssrlrni_hu_w", "vssrlni_hu_w", "vpermi_w", "vslti_b", "vmini_h", "vsrai_h", "vslli_w", "vslei_wu", "vpickve2gr_hu", "vshuf4i_b", "vsrani_b_h", "vslli_b", "vseqi_h", "vandi_b", "vaddi_bu", "vstelm_w_idx", "vextrins_w", "vssrani_hu_w", "vldrepl_w", "vsrarni_b_h", "vshuf4i_d", "vmini_b", "vpickve2gr_b", "vpickve2gr_w", "vsrarni_w_d", "vsrani_h_w", "vslei_hu", "vmaxi_d", "vsrlri_b", "vinsgr2vr_b", "__attribute__", "vsrli_w", "vmaxi_b", "vsat_h", "vmini_hu", "vslei_du", "vstelm_h_idx", "vsat_b", "vsrari_b", "vstelm_h", "vssrlrni_d_q", "vssrarni_h_w", "vssrlrni_wu_d", "vssrlrni_b_h", "vmini_d", "vbitclri_b", "vst", "vldi", "vslei_d", "vssrlni_bu_h", "vsrai_b", "vaddi_du"]}, {"filename": "clang/test/CodeGen/LoongArch/lsx/builtin.c", "functions": ["vfrintrne_d", "__builtin_lsx_vssub_h", "vaddi_hu", "vsadd_w", "vfmaxa_d", "__builtin_lsx_vmaddwev_d_wu", "vseq_w", "__builtin_lsx_vfsub_d", "vmod_h", "__builtin_lsx_vhsubw_d_w", "__builtin_lsx_vfmul_s", "__builtin_lsx_vbitset_d", "__builtin_lsx_vfrstpi_b", "__builtin_lsx_vsubwod_h_bu", "vssrarn_bu_h", "vbitrevi_b", "vreplvei_d", "vsadd_wu", "__builtin_lsx_vssrlrni_w_d", "vdiv_hu", "vbitseti_w", "vmul_d", "vmuh_w", "vsle_w", "__builtin_lsx_vpickve2gr_wu", "vsigncov_d", "__builtin_lsx_vhsubw_q_d", "__builtin_lsx_vhsubw_w_h", "vsrl_b", "vpickod_h", "vaddwod_q_du_d", "vslei_b", "vseqi_b", "vmaddwev_h_bu", "__builtin_lsx_vmaddwev_h_b", "__builtin_lsx_vfcmp_cueq_d", "__builtin_lsx_vfcmp_sule_d", "vslt_bu", "vavg_wu", "vabsd_hu", "__builtin_lsx_vilvh_h", "vreplgr2vr_w", "vaddwod_q_d", "__builtin_lsx_vssrlrn_hu_w", "vshuf_b", "vfcmp_sun_d", "__builtin_lsx_vaddwev_h_b", "vftintrneh_l_s", "vpackod_h", "vneg_b", "vmulwev_d_wu_w", "vxor_v", "__builtin_lsx_vpackod_w", "vsrlri_w", "vsub_d", "vsll_d", "__builtin_lsx_vsadd_du", "__builtin_lsx_vhaddw_d_w", "vreplvei_w", "vftintrz_w_d", "__builtin_lsx_vmaddwod_h_b", "__builtin_lsx_vfadd_d", "vadd_w", "vmax_w", "vmaddwev_d_wu", "vsigncov_b", "__builtin_lsx_vmulwev_w_hu_h", "vori_b", "vrepli_b", "__builtin_lsx_vshuf4i_d", "vextrins_h", "__builtin_lsx_vmaddwev_q_du", "vfsqrt_s", "__builtin_lsx_vpackev_w", "__builtin_lsx_vssrlrni_bu_h", "vfcmp_sule_d", "vsubwev_h_b", "__builtin_lsx_vandn_v", "__builtin_lsx_vssub_du", "__builtin_lsx_vssrlrni_h_w", "vfrintrp_s", "vmulwod_w_hu", "vfmsub_d", "__builtin_lsx_vfcvt_h_s", "vbitseti_h", "vfsqrt_d", "__builtin_lsx_vpickev_b", "vssrarni_wu_d", "vmul_w", "vsrln_b_h", "__builtin_lsx_vhsubw_qu_du", "vftintrm_l_d", "vssrani_d_q", "vbitclr_b", "__builtin_lsx_vfmadd_d", "vmaddwod_w_h", "vsrari_d", "vor_v", "vssrarni_b_h", "__builtin_lsx_vfmax_s", "__builtin_lsx_vssrln_hu_w", "vftintrmh_l_s", "__builtin_lsx_vsrarni_w_d", "__builtin_lsx_vssrarni_bu_h", "vssrln_w_d", "vshuf_d", "vaddwod_d_wu_w", "vmin_d", "vilvh_b", "vclo_d", "vilvl_d", "vmaddwev_q_d", "__builtin_lsx_vssrani_d_q", "vadd_d", "vfrintrm_s", "bz_b", "vmaxi_w", "__builtin_lsx_vfmina_s", "__builtin_lsx_vfcmp_cule_s", "__builtin_lsx_vssrarn_h_w", "vfmadd_d", "vstelm_w", "vdiv_h", "vclo_h", "__builtin_lsx_vmaddwev_w_hu", "vmadd_h", "vaddwev_d_w", "vrotri_w", "vmini_bu", "vshuf4i_w", "vmsub_b", "vmskgez_b", "__builtin_lsx_vsran_b_h", "vpackev_h", "vslei_h", "vmax_bu", "__builtin_lsx_vfcmp_cule_d", "__builtin_lsx_vsrlrni_w_d", "vreplve_w", "vmaddwev_w_hu_h", "vmaddwod_q_du_d", "vssrarn_hu_w", "bnz_d", "vfcmp_cult_s", "__builtin_lsx_vmax_hu", "vsadd_b", "vdiv_wu", "__builtin_lsx_vaddwev_w_hu", "__builtin_lsx_vfcmp_ceq_s", "__builtin_lsx_vilvl_h", "vftintrz_l_d", "vmod_d", "__builtin_lsx_vaddwev_h_bu", "vfcmp_cule_d", "vftintrne_w_d", "__builtin_lsx_vsrlni_b_h", "vsra_w", "__builtin_lsx_vmaddwev_d_wu_w", "vrotr_w", "__builtin_lsx_vhaddw_du_wu", "vrepli_d", "__builtin_lsx_vsrarn_h_w", "vssub_h", "vslti_d", "__builtin_lsx_vavgr_wu", "vhsubw_d_w", "vsrlri_d", "vssrlrn_h_w", "vbitclri_d", "vldx", "vfcmp_caf_d", "__builtin_lsx_vsubwod_d_w", "__builtin_lsx_vmaddwev_h_bu_b", "__builtin_lsx_vmin_du", "__builtin_lsx_vmadd_h", "__builtin_lsx_vfcmp_cult_s", "vreplve_h", "vexth_hu_bu", "__builtin_lsx_vpermi_w", "vffint_s_l", "vmuh_h", "vhsubw_wu_hu", "vavgr_wu", "__builtin_lsx_vfnmsub_d", "vavgr_b", "vpickod_b", "__builtin_lsx_vpickod_b", "__builtin_lsx_vsllwil_hu_bu", "__builtin_lsx_vstelm_h", "vmaddwev_q_du", "__builtin_lsx_vssrarn_bu_h", "vftintrzl_l_s", "__builtin_lsx_vssrlrni_b_h", "vmin_h", "__builtin_lsx_vpickve2gr_du", "vsrarni_d_q", "vfcmp_cle_d", "vfcmp_clt_d", "vpermi_w", "__builtin_lsx_vfcmp_sne_d", "__builtin_lsx_vaddwod_q_du", "vmulwod_q_du_d", "vslli_w", "vmulwod_h_b", "bnz_h", "__builtin_lsx_vsadd_d", "__builtin_lsx_vmuh_du", "vpcnt_d", "vsrani_b_h", "__builtin_lsx_vhaddw_h_b", "__builtin_lsx_vmaddwod_w_hu_h", "__builtin_lsx_vfsub_s", "__builtin_lsx_vpickod_w", "vaddi_bu", "__builtin_lsx_vssrarni_w_d", "__builtin_lsx_vsrlr_d", "__builtin_lsx_vmulwev_d_wu", "vssrani_hu_w", "__builtin_lsx_vpickod_h", "vsubwev_q_du", "__builtin_lsx_vsrar_h", "__builtin_lsx_vbitclr_d", "__builtin_lsx_vsigncov_w", "vsadd_hu", "vshuf4i_d", "__builtin_lsx_vfnmadd_d", "__builtin_lsx_vmaddwod_d_wu_w", "__builtin_lsx_vhsubw_wu_hu", "vavg_hu", "__builtin_lsx_vsrani_h_w", "__builtin_lsx_vavgr_hu", "vfcmp_clt_s", "__builtin_lsx_vfcmp_saf_d", "vfclass_d", "vmaxi_d", "vsrlri_b", "__builtin_lsx_vfcvt_s_d", "vmuh_d", "__builtin_lsx_vpickev_h", "vpackev_d", "vmaxi_b", "vfrsqrt_s", "vftintrne_l_d", "__builtin_lsx_vsllwil_du_wu", "__builtin_lsx_vftintrm_w_d", "vfcmp_sle_d", "__builtin_lsx_vssrlrn_b_h", "vsat_h", "__builtin_lsx_vfcmp_cne_s", "vstelm_h", "vsat_b", "vclz_b", "vfdiv_s", "vmax_b", "vclo_b", "vsll_h", "vbitclri_b", "vmaddwev_h_bu_b", "vssub_wu", "vsigncov_w", "__builtin_lsx_vaddwod_d_w", "vaddwod_h_bu_b", "vexth_du_wu", "vsra_h", "__builtin_lsx_vextrins_d", "__builtin_lsx_vfcmp_sor_s", "vftintrpl_l_s", "__builtin_lsx_vssran_bu_h", "vfcmp_sule_s", "__builtin_lsx_vpickve2gr_hu", "__builtin_lsx_vaddwod_h_bu_b", "vaddi_du", "vfcvt_s_d", "__builtin_lsx_vbitrev_w", "vsubwev_h_bu", "vmulwod_w_hu_h", "__builtin_lsx_vsrarni_d_q", "__builtin_lsx_vsrar_w", "vbitset_b", "vssrarn_wu_d", "__builtin_lsx_vssrarni_d_q", "vpackev_b", "vilvh_h", "vfrstp_h", "vslti_du", "__builtin_lsx_vfnmadd_s", "vsrlr_b", "vsubwev_w_hu", "__builtin_lsx_vabsd_wu", "vmaddwod_w_hu", "vexth_wu_hu", "vssrln_b_h", "vsllwil_h_b", "vbitseti_b", "vpickev_b", "vsat_wu", "vavg_b", "vbitseti_d", "vfcmp_cor_d", "__builtin_lsx_vssrarni_wu_d", "vxori_b", "__builtin_lsx_vmaddwev_w_hu_h", "__builtin_lsx_vfmsub_d", "vslei_w", "vssrarn_h_w", "vseqi_d", "__builtin_lsx_vmod_bu", "__builtin_lsx_vfrstp_b", "vaddwev_w_h", "vsrlrni_b_h", "__builtin_lsx_vavgr_w", "__builtin_lsx_vssrlni_w_d", "vmaddwod_w_hu_h", "bnz_v", "vftintrp_w_d", "vmulwod_d_wu_w", "vfcmp_cune_d", "__builtin_lsx_vssrani_du_q", "__builtin_lsx_vreplve_h", "__builtin_lsx_vsle_wu", "__builtin_lsx_vbitclr_b", "vsubi_bu", "vhsubw_du_wu", "__builtin_lsx_vavgr_b", "__builtin_lsx_vhsubw_du_wu", "__builtin_lsx_vssub_bu", "vpickev_w", "vsubwod_d_wu", "vfrstp_b", "vssrlrni_h_w", "__builtin_lsx_vssrlrni_du_q", "vssrani_wu_d", "__builtin_lsx_vfcmp_sor_d", "vsrli_d", "__builtin_lsx_vsrlrni_d_q", "vsubwod_q_d", "vfmin_d", "__builtin_lsx_vftintrne_w_d", "vmin_du", "vfcmp_sune_d", "vsrlni_h_w", "vbitclr_d", "__builtin_lsx_vavg_wu", "__builtin_lsx_vavg_hu", "__builtin_lsx_vshuf_h", "vldrepl_h", "__builtin_lsx_vsle_du", "vpickve2gr_bu", "vsrlni_d_q", "__builtin_lsx_vfcmp_cle_s", "__builtin_lsx_vfcmp_seq_d", "__builtin_lsx_vfmaxa_s", "vsat_w", "vmulwev_w_h", "__builtin_lsx_vfcmp_cne_d", "__builtin_lsx_vmulwod_d_w", "vfcmp_caf_s", "__builtin_lsx_vfcmp_sune_d", "vsrari_w", "vsrani_d_q", "vsat_du", "vslti_hu", "__builtin_lsx_vfdiv_s", "vextrins_b", "vavg_w", "vmsub_h", "vsubwod_d_w", "vfcmp_ceq_s", "__builtin_lsx_vmaddwod_d_w", "__builtin_lsx_vstelm_b", "vclz_w", "__builtin_lsx_vfcmp_clt_d", "vhaddw_wu_hu", "vfrecip_d", "vmaxi_h", "__builtin_lsx_vmadd_w", "vfnmadd_d", "__builtin_lsx_vfcmp_caf_s", "__builtin_lsx_vssrlrni_wu_d", "__builtin_lsx_vmsub_w", "__builtin_lsx_vaddwod_w_hu_h", "vhaddw_q_d", "__builtin_lsx_vfmaxa_d", "__builtin_lsx_vilvh_w", "vftintrz_wu_s", "vfcmp_slt_d", "__builtin_lsx_vbitrev_d", "__builtin_lsx_vfcmp_sult_s", "vbitrev_w", "__builtin_lsx_vmaddwod_q_du_d", "vslt_d", "vfsub_d", "__builtin_lsx_vabsd_h", "__builtin_lsx_vrotr_b", "__builtin_lsx_vmaddwev_w_h", "vfsub_s", "vaddwev_q_du_d", "vsrlrni_d_q", "vdiv_du", "__builtin_lsx_vssrlrni_hu_w", "__builtin_lsx_vreplve_d", "vslti_h", "__builtin_lsx_vsadd_w", "__builtin_lsx_vaddwev_w_h", "__builtin_lsx_vsrln_w_d", "__builtin_lsx_vaddwev_q_d", "vsle_d", "vslti_w", "vsat_d", "__builtin_lsx_vmuh_bu", "vftintl_l_s", "__builtin_lsx_vmaddwod_h_bu_b", "__builtin_lsx_vmaddwev_d_w", "__builtin_lsx_vpickve2gr_bu", "vssrlrni_bu_h", "vexth_d_w", "vmin_wu", "__builtin_lsx_vssrarni_b_h", "__builtin_lsx_vfcmp_cune_s", "vaddwod_h_b", "vsllwil_d_w", "vssrlni_h_w", "__builtin_lsx_vssran_hu_w", "__builtin_lsx_vpickev_w", "vadda_d", "vsran_w_d", "vsllwil_w_h", "__builtin_lsx_vsubwod_w_h", "vmaddwod_q_d", "__builtin_lsx_vbitset_h", "vsle_bu", "__builtin_lsx_vslt_wu", "__builtin_lsx_vadda_h", "vreplgr2vr_d", "__builtin_lsx_vssrani_b_h", "vextrins_d", "vssub_du", "vsat_bu", "vssub_bu", "__builtin_lsx_vfnmsub_s", "__builtin_lsx_vsrarn_b_h", "vsrarni_h_w", "vld", "vssrlni_du_q", "__builtin_lsx_vmuh_hu", "vmaddwev_h_b", "vsrar_h", "vfmul_d", "__builtin_lsx_vaddwod_w_hu", "__builtin_lsx_vdiv_du", "vmini_w", "__builtin_lsx_vmulwod_h_bu", "vssrani_h_w", "__builtin_lsx_vilvl_b", "vand_v", "vssran_h_w", "vclo_w", "vsrai_d", "vfadd_d", "vsub_q", "vfrint_s", "__builtin_lsx_vsran_w_d", "__builtin_lsx_vsllwil_wu_hu", "vsrlrn_w_d", "__builtin_lsx_vsubwev_q_du", "vmadd_b", "vhsubw_h_b", "__builtin_lsx_vmulwev_h_b", "vssrlni_wu_d", "__builtin_lsx_vpackod_h", "__builtin_lsx_vssub_b", "vnor_v", "__builtin_lsx_vsigncov_h", "__builtin_lsx_vsubwod_q_d", "vsubi_hu", "vsra_b", "__builtin_lsx_vrotr_d", "vsllwil_wu_hu", "vsub_h", "vldrepl_d", "__builtin_lsx_vssrani_wu_d", "vinsgr2vr_d", "vstelm_d", "vfcmp_cueq_d", "vreplgr2vr_b", "__builtin_lsx_vfcmp_saf_s", "vreplgr2vr_h", "__builtin_lsx_vinsgr2vr_w", "vssrlrni_hu_w", "vmulwev_w_hu_h", "vsubwod_h_b", "vfmsub_s", "__builtin_lsx_vsrlrni_b_h", "vsubwod_w_hu", "__builtin_lsx_vmaddwod_w_h", "vslt_wu", "vmax_du", "vsadd_du", "__builtin_lsx_vavgr_h", "vslli_b", "vfmax_s", "vmuh_hu", "vfnmadd_s", "__builtin_lsx_vssrlni_d_q", "vmod_du", "vfcmp_sne_d", "vaddwod_w_hu_h", "__builtin_lsx_vextrins_h", "__builtin_lsx_vaddwev_d_w", "vssrlrn_b_h", "__builtin_lsx_vshuf_b", "vaddwod_w_hu", "__builtin_lsx_vmax_bu", "__builtin_lsx_vsrlni_w_d", "__builtin_lsx_vhaddw_hu_bu", "__builtin_lsx_vssrlni_b_h", "vhaddw_hu_bu", "vldrepl_w", "__builtin_lsx_vffint_s_l", "vfrintrm_d", "__builtin_lsx_vsrlr_w", "vftintrph_l_s", "__builtin_lsx_vabsd_w", "__builtin_lsx_vssrln_b_h", "vsigncov_h", "__builtin_lsx_vssran_wu_d", "vslt_hu", "vaddwev_d_wu", "vsrani_h_w", "vsrarni_w_d", "vslei_hu", "vmulwev_q_du", "__builtin_lsx_vfmin_d", "vpackod_d", "vextl_q_d", "vfmin_s", "__builtin_lsx_vhsubw_hu_bu", "__builtin_lsx_vdiv_bu", "vinsgr2vr_b", "__builtin_lsx_vsubwev_h_b", "__builtin_lsx_vssrlrn_h_w", "__builtin_lsx_vmin_wu", "vadda_h", "__builtin_lsx_vfcmp_caf_d", "vffinth_d_w", "vssrlrni_d_q", "__builtin_lsx_vssrlrn_bu_h", "__builtin_lsx_vmaddwod_q_d", "vmax_hu", "__builtin_lsx_vpackod_b", "__builtin_lsx_vmulwod_d_wu_w", "vmuh_du", "vsadd_d", "__builtin_lsx_vsran_h_w", "vmulwod_q_du", "__builtin_lsx_vmaddwod_d_wu", "__builtin_lsx_vaddwod_d_wu", "vfcmp_slt_s", "vslei_d", "vssrarn_b_h", "__builtin_lsx_vfcmp_cle_d", "vsrarn_w_d", "__builtin_lsx_vaddwev_h_bu_b", "vsrln_h_w", "__builtin_lsx_vmuh_wu", "vsrlrn_h_w", "vssrani_du_q", "vaddwev_h_bu_b", "bz_h", "vslli_h", "__builtin_lsx_vmax_du", "__builtin_lsx_vssub_wu", "__builtin_lsx_vmulwev_h_bu_b", "vssub_d", "vftintrm_w_s", "__builtin_lsx_vfcmp_ceq_d", "__builtin_lsx_vsle_bu", "vslei_bu", "vmini_du", "vslt_b", "__builtin_lsx_vsadd_b", "vseq_b", "vsadd_bu", "__builtin_lsx_vmulwod_q_d", "vldrepl_b", "__builtin_lsx_vbitset_w", "__builtin_lsx_vfcmp_sueq_d", "vfnmsub_d", "vhaddw_h_b", "vbitclri_h", "vslti_wu", "__builtin_lsx_vilvh_d", "vnori_b", "vilvl_h", "vmaddwev_d_wu_w", "vmuh_bu", "__builtin_lsx_vftint_w_d", "vfrintrz_d", "vsrlri_h", "__builtin_lsx_vmod_du", "__builtin_lsx_vfrstpi_h", "__builtin_lsx_vssrln_w_d", "vpickve2gr_du", "vsle_h", "__builtin_lsx_vhaddw_qu_du", "__builtin_lsx_vextrins_w", "vmaxi_bu", "__builtin_lsx_vfmsub_s", "vssrarni_hu_w", "__builtin_lsx_vslt_du", "vmskltz_w", "vmod_bu", "__builtin_lsx_vaddwev_q_du_d", "__builtin_lsx_vmin_hu", "vmaxi_du", "vrotr_d", "__builtin_lsx_vshuf_w", "vsubwev_q_d", "__builtin_lsx_vmsub_d", "vsubi_wu", "vsll_b", "vssran_wu_d", "vaddwev_w_hu", "__builtin_lsx_vssrarni_hu_w", "vsub_b", "__builtin_lsx_vsrlr_h", "__builtin_lsx_vmulwev_d_wu_w", "vmaddwod_h_b", "bz_v", "__builtin_lsx_vssrarn_b_h", "vssrarni_bu_h", "vfcvth_d_s", "vfcmp_saf_d", "vflogb_d", "__builtin_lsx_vssran_w_d", "vmadd_d", "vbitrevi_w", "vaddwod_d_w", "vbitsel_v", "__builtin_lsx_vhaddw_wu_hu", "__builtin_lsx_vfcmp_sule_s", "vabsd_bu", "__builtin_lsx_vilvh_b", "__builtin_lsx_vpackev_b", "vpackev_w", "vffint_s_w", "__builtin_lsx_vaddwev_d_wu", "vbitrev_b", "vexth_q_d", "vfcmp_cne_d", "__builtin_lsx_vreplve_w", "__builtin_lsx_vssrani_bu_h", "__builtin_lsx_vfcmp_sle_d", "__builtin_lsx_vfmin_s", "vslti_bu", "__builtin_lsx_vmadd_b", "__builtin_lsx_vfcmp_cun_d", "vrepli_h", "__builtin_lsx_vsadd_wu", "vshuf_h", "__builtin_lsx_vavg_du", "vfcmp_sult_s", "__builtin_lsx_vmulwev_w_h", "__builtin_lsx_vpackev_h", "__builtin_lsx_vmulwev_w_hu", "vslt_du", "__builtin_lsx_vsigncov_d", "vstelm_b", "__builtin_lsx_vaddwod_q_d", "vfmul_s", "__builtin_lsx_vssrln_bu_h", "vsrlni_w_d", "__builtin_lsx_vbitrev_b", "__builtin_lsx_vfmina_d", "vsran_h_w", "vftintrz_w_s", "__builtin_lsx_vabsd_b", "vilvl_w", "vssrarn_w_d", "vssrln_wu_d", "vmaddwev_w_h", "__builtin_lsx_vbitclr_h", "bnz_b", "vbitrev_d", "__builtin_lsx_vstelm_d", "vsrlrni_w_d", "vfcmp_cueq_s", "vssran_w_d", "vsle_b", "__builtin_lsx_vrotr_w", "vbitrevi_h", "__builtin_lsx_vilvl_w", "vfrintrp_d", "vabsd_h", "vbitclri_w", "vmax_d", "vpickve2gr_d", "vaddwod_d_wu", "vsrani_w_d", "bnz_w", "vabsd_d", "vsrar_b", "__builtin_lsx_vmaddwev_q_d", "vssub_w", "vfcmp_sle_s", "vpickev_h", "__builtin_lsx_vaddwod_q_du_d", "__builtin_lsx_vaddwev_q_du", "vftintrp_l_d", "vfcmp_sne_s", "__builtin_lsx_vssrlni_h_w", "__builtin_lsx_vaddwev_w_hu_h", "vilvh_w", "__builtin_lsx_vavgr_du", "vaddwev_d_wu_w", "vmax_wu", "vmulwod_h_bu", "vaddwod_w_h", "__builtin_lsx_vabsd_du", "__builtin_lsx_vmin_bu", "__builtin_lsx_vbitrev_h", "__builtin_lsx_vadda_w", "__builtin_lsx_vsrar_b", "vsrln_w_d", "__builtin_lsx_vsubwod_d_wu", "__builtin_lsx_vmulwod_d_wu", "vfdiv_d", "__builtin_lsx_vssrarn_w_d", "vsle_du", "__builtin_lsx_vfdiv_d", "vsrli_b", "vftintrml_l_s", "vaddwev_q_du", "vrotr_h", "vsle_hu", "vftint_l_d", "vfrintrne_s", "vavgr_d", "vpickod_w", "__builtin_lsx_vmulwev_q_d", "__builtin_lsx_vssrarni_h_w", "vfcmp_sor_d", "__builtin_lsx_vssrlrni_d_q", "__builtin_lsx_vshuf_d", "vilvl_b", "__builtin_lsx_vsrlrn_b_h", "vftint_w_s", "vneg_d", "vshuf_w", "__builtin_lsx_vrotr_h", "__builtin_lsx_vsubwod_w_hu", "__builtin_lsx_vaddwod_h_b", "__builtin_lsx_vmaddwev_q_du_d", "vssub_b", "__builtin_lsx_vssub_hu", "__builtin_lsx_vfcmp_cult_d", "vsubi_du", "__builtin_lsx_vmsub_h", "__builtin_lsx_vmulwod_w_h", "__builtin_lsx_vmulwod_w_hu_h", "__builtin_lsx_vsubwev_h_bu", "__builtin_lsx_vmaddwev_h_bu", "vpackod_w", "__builtin_lsx_vfcmp_clt_s", "vfcmp_cule_s", "__builtin_lsx_vssrln_wu_d", "vfcmp_sune_s", "__builtin_lsx_vsrlrn_h_w", "vreplve_d", "__builtin_lsx_vpackod_d", "vslli_d", "__builtin_lsx_vfcmp_sun_s", "__builtin_lsx_vsrar_d", "vrotri_b", "vfcmp_seq_s", "vslt_w", "vfcmp_cle_s", "__builtin_lsx_vsadd_h", "vpcnt_b", "vabsd_du", "vfmaxa_s", "__builtin_lsx_vfmul_d", "__builtin_lsx_vbitseli_b", "vfclass_s", "vbitclr_h", "__builtin_lsx_vsadd_hu", "vmsknz_b", "vavg_h", "__builtin_lsx_vsrani_b_h", "__builtin_lsx_vsrani_w_d", "vpackod_b", "vslti_b", "__builtin_lsx_vftintrz_w_d", "vmini_h", "__builtin_lsx_vmulwev_q_du_d", "vslei_wu", "vpickve2gr_hu", "vmulwev_h_bu_b", "vmin_b", "__builtin_lsx_vpickev_d", "vshuf4i_b", "vexth_qu_du", "__builtin_lsx_vextrins_b", "__builtin_lsx_vsubwev_w_h", "vsrar_d", "vandi_b", "vavgr_w", "vslt_h", "__builtin_lsx_vssrlni_wu_d", "__builtin_lsx_vfcmp_sle_s", "vmulwev_q_d", "vextrins_w", "vsubwod_q_du", "vsrl_w", "__builtin_lsx_vabsd_hu", "vmulwev_d_w", "vssub_hu", "vmskltz_b", "__builtin_lsx_vssrlni_hu_w", "__builtin_lsx_vssrarni_du_q", "vmini_b", "__builtin_lsx_vmod_wu", "vpickve2gr_w", "__builtin_lsx_vhaddw_q_d", "__builtin_lsx_vfcmp_cor_s", "vsadd_h", "vsrarn_h_w", "__builtin_lsx_vsigncov_b", "vsubwev_d_w", "vhsubw_w_h", "__builtin_lsx_vftintrp_w_d", "__builtin_lsx_vfcmp_slt_d", "vftint_wu_s", "vhsubw_hu_bu", "vmaddwev_w_hu", "__builtin_lsx_vavgr_d", "vpickev_d", "__builtin_lsx_vaddwod_d_wu_w", "__builtin_lsx_vmulwev_d_w", "vsrli_w", "__builtin_lsx_vavgr_bu", "__builtin_lsx_vssrarn_wu_d", "vmini_hu", "__builtin_lsx_vsadd_bu", "vslei_du", "vssrln_bu_h", "vmskltz_d", "vexth_w_h", "__builtin_lsx_vfcmp_sun_d", "vaddwev_h_bu", "vftintrnel_l_s", "vadd_q", "__builtin_lsx_vssrlni_du_q", "vmulwev_h_b", "vst", "vftintrzh_l_s", "vsubwod_h_bu", "vmulwod_h_bu_b", "__builtin_lsx_vssrln_h_w", "__builtin_lsx_vpackev_d", "vftint_lu_d", "vmulwev_q_du_d", "__builtin_lsx_vsubwev_d_wu", "vadda_w", "__builtin_lsx_vadda_d", "vclz_d", "vfcvtl_d_s", "vfnmsub_s", "vssrarni_du_q", "vavg_d", "vreplvei_b", "__builtin_lsx_vslt_hu", "__builtin_lsx_vfmax_d", "vextl_qu_du", "__builtin_lsx_vsle_hu", "__builtin_lsx_vsrarni_b_h", "vfcmp_cne_s", "vpickod_d", "vavgr_h", "vrepli_w", "vmini_wu", "vpcnt_w", "vhaddw_d_w", "vmod_hu", "vmadd_w", "vfrsqrt_d", "vaddwev_h_b", "vsll_w", "vmul_h", "vsllwil_du_wu", "bz_w", "vsrl_h", "vmulwev_h_bu", "vsrli_h", "vbsll_v", "vmaddwod_d_wu_w", "__builtin_lsx_vsrarn_w_d", "vssrlni_d_q", "vfcvtl_s_h", "vmaddwod_h_bu_b", "vssrlrni_du_q", "vhaddw_du_wu", "__builtin_lsx_vftintrnel_l_s", "vssrln_h_w", "vrotri_h", "vrotr_b", "vreplve_b", "vpcnt_h", "vfmadd_s", "vssrlni_b_h", "__builtin_lsx_vfcmp_seq_s", "__builtin_lsx_vsrln_b_h", "vbsrl_v", "vneg_h", "vinsgr2vr_h", "__builtin_lsx_vftintrneh_l_s", "vexth_h_b", "__builtin_lsx_vfcmp_slt_s", "vmskltz_h", "vssrarni_w_d", "__builtin_lsx_vmulwev_q_du", "vshuf4i_h", "vdiv_b", "vseqi_w", "__builtin_lsx_vssran_h_w", "__builtin_lsx_vmulwod_q_du_d", "vssrlni_w_d", "vaddwod_h_bu", "__builtin_lsx_vsrlrni_h_w", "vavgr_hu", "__builtin_lsx_vavg_bu", "vfrstpi_h", "__builtin_lsx_vstelm_w", "vsat_hu", "__builtin_lsx_vmsub_b", "vfcmp_sult_d", "vclz_h", "__builtin_lsx_vssran_b_h", "vftint_w_d", "vfcmp_sun_s", "vftintrm_w_d", "vmuh_b", "vfmina_d", "vssrani_bu_h", "vsra_d", "vmaddwev_q_du_d", "vinsgr2vr_w", "vfcmp_ceq_d", "vssran_bu_h", "vftintrz_lu_d", "__builtin_lsx_vdiv_wu", "vfcvt_h_s", "vfcmp_sueq_d", "__builtin_lsx_vbitsel_v", "vftintrp_w_s", "vbitseli_b", "vsrlr_h", "vhaddw_qu_du", "vdiv_w", "vftinth_l_s", "vffintl_d_w", "vmin_w", "vorn_v", "vavg_bu", "vfcmp_cor_s", "vmsub_d", "vfadd_s", "__builtin_lsx_vbitset_b", "__builtin_lsx_vmulwev_h_bu", "vfmax_d", "__builtin_lsx_vssrarn_hu_w", "vaddwev_q_d", "vstx", "vmaddwod_d_wu", "__builtin_lsx_vfcmp_cueq_s", "vmax_h", "__builtin_lsx_vfcmp_sune_s", "vbitset_w", "vsrar_w", "vfcmp_cun_d", "vssrani_b_h", "__builtin_lsx_vssub_d", "vssrlrni_w_d", "__builtin_lsx_vssrlrn_w_d", "vsrlr_w", "__builtin_lsx_vfrstp_h", "__builtin_lsx_vreplve_b", "__builtin_lsx_vadda_b", "__builtin_lsx_vhaddw_w_h", "vffint_d_lu", "vmulwod_d_wu", "vsub_w", "vavgr_du", "vilvh_d", "vavg_du", "__builtin_lsx_vsrlr_b", "vsrai_w", "__builtin_lsx_vfadd_s", "__builtin_lsx_vssrani_w_d", "vssran_hu_w", "__builtin_lsx_vslt_bu", "vpickve2gr_h", "vandn_v", "vmod_b", "__builtin_lsx_vfmadd_s", "vfrintrz_s", "__builtin_lsx_vssrani_hu_w", "vmaxi_wu", "vflogb_s", "vmaddwev_d_w", "__builtin_lsx_vmaddwod_h_bu", "vfcmp_cult_d", "vssrarni_d_q", "vmin_hu", "vrotri_d", "vabsd_b", "vmulwod_d_w", "vsrlr_d", "__builtin_lsx_vinsgr2vr_h", "vfrstpi_b", "__builtin_lsx_vssrlni_bu_h", "__builtin_lsx_vsrarni_h_w", "__builtin_lsx_vsrlni_h_w", "vreplvei_h", "vmaxi_hu", "vdiv_bu", "vaddi_wu", "__builtin_lsx_vaddwod_w_h", "vsran_b_h", "__builtin_lsx_vfcmp_sult_d", "vsrari_h", "vmod_w", "vmul_b", "vpickve2gr_wu", "__builtin_lsx_vmulwod_q_du", "vsrlni_b_h", "bz_d", "__builtin_lsx_vfcmp_cun_s", "vmulwod_q_d", "vsllwil_hu_bu", "__builtin_lsx_vsubwod_h_b", "vsubwev_w_h", "vssrani_w_d", "vfcmp_seq_d", "vsle_wu", "vbitrevi_d", "vffint_s_wu", "vaddwev_w_hu_h", "vmod_wu", "__builtin_lsx_vmulwod_w_hu", "__builtin_lsx_vsrlrn_w_d", "vfrecip_s", "vssrlrn_wu_d", "__builtin_lsx_vssub_w", "vabsd_w", "vabsd_wu", "__builtin_lsx_vinsgr2vr_d", "vadd_b", "vsubwod_w_h", "vavgr_bu", "vneg_w", "vsrlrni_h_w", "__builtin_lsx_vmod_hu", "vmulwod_w_h", "vmaddwod_d_w", "__builtin_lsx_vfcmp_cor_d", "__builtin_lsx_vsubwod_q_du", "vmulwev_d_wu", "vftintrne_w_s", "vssrlni_hu_w", "vmin_bu", "vssrlrn_w_d", "__builtin_lsx_vmadd_d", "vhsubw_qu_du", "vfcmp_cun_s", "vsrai_h", "vsrl_d", "vbitset_h", "vmsub_w", "vmulwev_w_hu", "__builtin_lsx_vfcmp_sne_s", "vmuh_wu", "__builtin_lsx_vinsgr2vr_b", "vseqi_h", "__builtin_lsx_vmulwod_h_bu_b", "__builtin_lsx_vssrani_h_w", "__builtin_lsx_vabsd_bu", "vssran_b_h", "__builtin_lsx_vaddwev_d_wu_w", "__builtin_lsx_vbitclr_w", "vssrln_hu_w", "__builtin_lsx_vilvl_d", "vaddwod_q_du", "vfcmp_sor_s", "vbitclr_w", "vffint_d_l", "vsrarni_b_h", "__builtin_lsx_vsrlni_d_q", "__builtin_lsx_vsubwev_q_d", "__builtin_lsx_vfcmp_sueq_s", "__builtin_lsx_vabsd_d", "vfmina_s", "vadda_b", "__builtin_lsx_vpickod_d", "vpickve2gr_b", "__builtin_lsx_vssrlrn_wu_d", "vfcmp_cune_s", "vhsubw_q_d", "__builtin_lsx_vsrln_h_w", "__builtin_lsx_vmulwod_h_b", "vseq_h", "vbitset_d", "__builtin_lsx_vfcmp_cune_d", "vsrlrn_b_h", "vssrlrn_bu_h", "__builtin_lsx_vsubwev_w_hu", "__attribute__", "vsrarn_b_h", "vfcmp_sueq_s", "vhaddw_w_h", "vadd_h", "vfrint_d", "vfcvth_s_h", "vsrari_b", "__builtin_lsx_vdiv_hu", "__builtin_lsx_vmaddwod_q_du", "vmaddwod_h_bu", "vbitrev_h", "vssrlrn_hu_w", "vssrarni_h_w", "__builtin_lsx_vhsubw_h_b", "vssrlrni_wu_d", "vssrlrni_b_h", "vmini_d", "vfcmp_saf_s", "vdiv_d", "vsubwev_d_wu", "__builtin_lsx_vaddwod_h_bu", "vldi", "__builtin_lsx_vsubwev_d_w", "vmaddwod_q_du", "__builtin_lsx_vmax_wu", "vssrlni_bu_h", "vsrai_b", "__builtin_lsx_vmaddwod_w_hu", "vseq_d", "__builtin_lsx_vsrani_d_q"]}, {"filename": "clang/test/CodeGen/LoongArch/lasx/builtin-alias-error.c", "functions": ["xvsat_du", "xvslli_b", "xvmaxi_h", "xvmini_w", "xvslei_h", "xvstelm_b_idx", "xvslti_w", "xvpermi_w", "xvseqi_d", "xvrepl128vei_b", "xvssrarni_w_d", "xvxori_b", "xvmaxi_wu", "xvbitrevi_h", "xvbitrevi_b", "xvaddi_wu", "xvmaxi_du", "xvmini_h", "xvsrlrni_b_h", "xvsllwil_d_w", "xvbitrevi_d", "xvssrarni_h_w", "xvseqi_h", "xvssrani_bu_h", "xvssrlrni_b_h", "xvssrani_hu_w", "xvshuf4i_w", "xvori_b", "xvsrari_b", "xvsrari_d", "xvmini_bu", "xvmaxi_w", "xvbsll_v", "xvstelm_h", "xvbitrevi_w", "xvmini_hu", "xvsrli_h", "xvsrai_b", "xvslei_hu", "xvslei_du", "xvbitseti_b", "xvssrlni_bu_h", "xvmini_b", "xvpermi_q", "xvsrarni_d_q", "xvslli_d", "xvsllwil_h_b", "xvstelm_d", "xvrotri_d", "xvbitseti_h", "xvpickve2gr_w", "xvbitseti_w", "xvsrai_w", "xvssrlni_w_d", "xvsubi_wu", "xvslti_bu", "xvextrins_w", "xvldrepl_b", "xvrotri_b", "xvfrstpi_h", "xvpickve2gr_wu", "xvssrlrni_bu_h", "xvsat_wu", "xvsrarni_h_w", "xvpermi_d", "xvssrani_du_q", "xvssrani_w_d", "xvld", "xvsrani_d_q", "xvssrarni_d_q", "xvssrlni_hu_w", "xvseqi_b", "xvslli_w", "xvsubi_du", "xvslei_wu", "xvrotri_w", "xvssrarni_du_q", "xvmini_wu", "xvslti_du", "xvextrins_b", "xvssrlni_du_q", "xvldrepl_h", "xvsubi_hu", "xvsrlri_d", "xvandi_b", "xvsllwil_du_wu", "xvslei_b", "xvldi", "xvbsrl_v", "xvstelm_w", "xvsrai_d", "xvslei_d", "xvsrani_b_h", "xvsrai_h", "xvsrlni_h_w", "xvsrlrni_d_q", "xvssrlrni_wu_d", "xvslti_wu", "xvsrlri_h", "xvaddi_bu", "xvsat_bu", "xvfrstpi_b", "xvsrani_h_w", "xvshuf4i_b", "xvssrarni_hu_w", "xvpickve_w_f", "xvsllwil_hu_bu", "xvssrlrni_h_w", "xvinsve0_d", "xvssrlni_d_q", "xvpickve_d_f", "xvsrlri_w", "xvnori_b", "xvssrlni_wu_d", "xvssrlrni_du_q", "xvsrani_w_d", "xvssrani_d_q", "xvldrepl_w", "xvslti_d", "xvslti_b", "xvmini_du", "xvsrari_h", "xvslli_h", "xvbitseli_b", "xvinsve0_w", "xvsrlrni_w_d", "xvshuf4i_d", "xvsllwil_w_h", "xvssrani_h_w", "xvrepli_d", "xvinsgr2vr_w", "xvsrlrni_h_w", "xvst", "xvpickve_d", "xvrotri_h", "xvbitclri_b", "xvaddi_du", "xvssrlrni_w_d", "xvsrli_b", "xvslei_bu", "xvssrarni_wu_d", "xvrepli_w", "xvpickve2gr_d", "xvstelm_h_idx", "xvsat_w", "xvssrarni_b_h", "xvsat_b", "xvmaxi_d", "xvbitclri_h", "xvpickve2gr_du", "xvsrlni_b_h", "xvsat_hu", "xvpickve_w", "xvssrarni_bu_h", "xvslti_h", "xvstelm_d_idx", "xvslei_w", "xvseqi_w", "xvmini_d", "xvsubi_bu", "xvsrli_w", "xvssrlrni_d_q", "xvbitseti_d", "xvaddi_hu", "xvssrlrni_hu_w", "xvslti_hu", "xvshuf4i_h", "xvsrarni_w_d", "xvstelm_w_idx", "xvrepl128vei_w", "xvssrlni_b_h", "xvstelm_b", "xvrepl128vei_d", "xvsllwil_wu_hu", "xvrepl128vei_h", "xvsat_d", "xvsat_h", "xvinsgr2vr_d", "xvextrins_h", "xvsrlni_w_d", "xvssrani_b_h", "xvrepli_h", "xvrepli_b", "xvmaxi_hu", "xvsrlri_b", "xvmaxi_bu", "xvsrli_d", "xvsrarni_b_h", "xvldrepl_d", "xvbitclri_d", "xvsrari_w", "xvssrani_wu_d", "xvbitclri_w", "xvextrins_d", "xvsrlni_d_q", "xvssrlni_h_w", "xvmaxi_b"]}, {"filename": "clang/test/CodeGen/LoongArch/lasx/builtin-alias.c", "functions": ["xvsat_du", "xvmax_h", "xvfadd_d", "xvbitset_h", "xvftintrneh_l_s", "xvpickod_d", "xvaddwod_d_wu", "xvslti_w", "xvmulwod_q_du_d", "xvxor_v", "xvhsubw_hu_bu", "xvrepl128vei_b", "xvsubwev_w_h", "xvxori_b", "xvmaddwev_d_wu_w", "xvhaddw_w_h", "xvfrintrz_s", "xvaddi_wu", "xvmini_h", "vext2xv_d_w", "xvssub_wu", "xvssrarn_wu_d", "xvilvh_d", "xvshuf4i_w", "xvadd_w", "xvreplve_b", "xvavg_wu", "xvssran_b_h", "xvssran_h_w", "xvmod_hu", "xvsrari_d", "xvshuf_h", "xvmaxi_w", "xvsadd_du", "xvmaddwev_q_d", "xvfcmp_ceq_d", "xvsubwod_h_bu", "xvfrintrm_d", "xvpackod_b", "xvsrli_h", "xvilvh_h", "xvfcmp_cun_d", "xvsrlr_d", "xvslei_du", "xvssrlni_bu_h", "xvmin_b", "xvpermi_q", "xvftintrz_l_d", "xvaddwev_h_b", "xvmulwod_h_b", "xvsllwil_h_b", "xvmulwod_w_hu", "xvbitseti_h", "xvfcmp_sule_s", "xvpcnt_w", "xvextrins_w", "xvdiv_b", "xvavgr_b", "xvrotri_b", "xvfcmp_saf_d", "xvmadd_h", "xvssrlrni_bu_h", "xvfadd_s", "xvaddwev_w_hu_h", "xvbitrev_w", "xvbitclr_w", "xvavgr_w", "xvsrani_d_q", "xvmin_bu", "xvhaddw_h_b", "xvfdiv_d", "xvsadd_d", "xvfcmp_caf_d", "xvfcmp_cle_s", "xvslt_bu", "xvmadd_w", "xvmaddwev_h_b", "xvssrarni_du_q", "xvfmadd_s", "xvmin_hu", "xvsrl_h", "xvabsd_h", "xvstx", "xvssran_hu_w", "xvstelm_w", "xvsrai_d", "xvsrani_b_h", "xvmaddwev_w_hu", "xvslt_h", "xvaddi_bu", "xvssrarni_hu_w", "xvaddwod_q_du_d", "xbz_h", "xvaddwev_w_hu", "xvinsve0_d", "xvssrlni_d_q", "vext2xv_du_bu", "xvsrlri_w", "xvmulwev_d_wu", "xvabsd_du", "xvssrlrni_du_q", "xvreplve0_b", "xvreplve0_h", "xvmsub_b", "xvfnmadd_d", "xvfrintrne_s", "xvldrepl_w", "xvdiv_hu", "xvclz_h", "xvslt_d", "xvaddwev_h_bu_b", "xvfnmsub_d", "xvssrln_bu_h", "xvsrlrni_w_d", "xvffintl_d_w", "xbz_b", "xvssrarn_hu_w", "xvssrani_h_w", "xvrepli_d", "xvst", "xvpickve_d", "xvfcmp_ceq_s", "xvssub_hu", "xvfcmp_cule_d", "xvfmaxa_s", "xvbitclri_b", "xvaddi_du", "xvssub_b", "vext2xv_w_b", "xvneg_b", "xvffint_d_lu", "xvadd_d", "xvssrarni_b_h", "xvilvl_b", "xvssub_du", "xvreplve_d", "xvsigncov_d", "xvpickod_b", "xvpackev_b", "xvneg_h", "xvpickve2gr_du", "xvssrarn_h_w", "xvsat_hu", "xvsubwod_q_d", "xvexth_d_w", "xvfrintrp_s", "xvseqi_w", "xvshuf_b", "xvfmsub_d", "xvftintrp_w_s", "xvmini_d", "xvreplgr2vr_b", "xvmulwev_w_hu_h", "xvhsubw_du_wu", "xvseq_h", "xvsubwod_h_b", "xvslti_hu", "xvmod_bu", "xvsub_h", "xvavgr_h", "xvssrlni_b_h", "xvmod_h", "xvaddwev_h_bu", "xvaddwod_h_bu", "xvfcmp_cune_s", "xvsrlni_w_d", "xvmaxi_hu", "xvsrlri_b", "xvmaxi_bu", "xvslt_hu", "xvmulwod_h_bu", "xvsubwod_w_h", "xvmax_du", "xvfrstp_b", "xvmuh_hu", "xvaddwev_q_d", "xvmaddwev_h_bu", "xvssrlni_h_w", "xvmaxi_b", "xvpackod_d", "xvmini_w", "xvfrsqrt_s", "xvsadd_bu", "xvfcmp_cne_s", "xvseqi_d", "xvsra_d", "xvssrarni_w_d", "xvfcmp_sueq_s", "xvftint_wu_s", "xvfcmp_sune_d", "xvmulwev_w_h", "xvpcnt_d", "xvbitrevi_h", "xvbitrevi_b", "xvdiv_bu", "xvsrlrni_b_h", "xvsrlrn_b_h", "xvfcmp_sne_s", "xvfcmp_seq_d", "xvmulwod_q_d", "xvshuf_w", "xvssrlrni_b_h", "xvssrarn_bu_h", "xvmul_d", "xvori_b", "xvftintrm_l_d", "xvmini_bu", "xvsubwev_d_wu", "xvfcmp_sne_d", "xvsadd_wu", "xvandn_v", "xvmuh_du", "xvfrintrm_s", "xvmaddwod_q_du_d", "xvmul_b", "xvaddwod_h_b", "xvbitseti_b", "xvreplve_w", "xbnz_w", "xvsle_b", "xvslli_d", "xvmulwod_w_hu_h", "xvhsubw_qu_du", "xvstelm_d", "xvmax_d", "xvfrint_d", "xvpickve2gr_w", "xvadda_h", "xbz_d", "xvsubi_wu", "xvmaddwod_h_bu_b", "xvssran_wu_d", "xvfrstpi_h", "xvmaddwod_w_hu_h", "xvaddwod_w_hu_h", "xvfrint_s", "xvssrlrn_b_h", "xvfmin_s", "xvreplgr2vr_d", "xvavg_h", "xvld", "xvssrlrn_w_d", "xvseqi_b", "xvfclass_d", "xvavgr_d", "xvsubwod_w_hu", "xvslli_w", "xvsubi_du", "xvmini_wu", "xvsrar_h", "xvsrln_w_d", "xvsrlr_b", "xvldrepl_h", "xvmaddwod_d_wu_w", "xvfcvtl_s_h", "xvpickod_w", "xvdiv_d", "xvsllwil_du_wu", "xvslei_b", "xvftintrz_w_s", "xvldx", "xvneg_w", "xvslti_wu", "xvmuh_h", "xvfrstpi_b", "xvfcmp_slt_s", "xvpickve_w_f", "xvmaddwev_q_du", "xvmaddwev_d_w", "xvfcmp_sle_d", "xvmaddwev_h_bu_b", "xvsubwod_d_w", "xvfmadd_d", "xvssrlni_wu_d", "xvsle_du", "xvftint_w_s", "xvsrani_w_d", "xvhaddw_wu_hu", "xvffint_s_w", "xvmulwod_w_h", "xvclo_w", "xvmuh_wu", "xvssrlrn_hu_w", "xvffint_d_l", "xvfcmp_sule_d", "xvslli_h", "xvbitseli_b", "xvilvl_d", "xvinsgr2vr_w", "xvsrar_w", "xvssrlrni_w_d", "xvssrarni_wu_d", "xvsll_b", "xvmulwev_h_bu", "xvpcnt_b", "xvssub_bu", "xvclz_d", "xvfmul_s", "xvrotr_h", "xvsat_b", "xvilvl_w", "xvorn_v", "xvfcvt_h_s", "xvftintrne_w_d", "xvsub_q", "xvmin_du", "xvabsd_hu", "xvilvh_w", "xvfcvt_s_d", "xvpickve_w", "xvftint_l_d", "xvbitclr_b", "xvadda_b", "xvmulwev_q_du_d", "xvslei_w", "xvsubi_bu", "xvsle_d", "xvsrli_w", "xvaddi_hu", "xvslt_wu", "xvfrintrp_d", "xvabsd_w", "xvfmina_d", "xvssrln_w_d", "xvaddwod_q_d", "xvmin_w", "xvmulwev_h_bu_b", "xvmaddwod_d_w", "xvslt_b", "xvshuf4i_h", "xvclo_d", "xvftintrz_lu_d", "xvexth_q_d", "xvsrl_d", "xvssub_h", "xvrepl128vei_d", "vext2xv_wu_hu", "xvrepli_h", "xvfdiv_s", "xvextrins_h", "xvsadd_w", "xvssrani_b_h", "xvsrl_b", "xvfsqrt_d", "xvfsqrt_s", "xvrepli_b", "xvmax_bu", "xvsll_w", "xvextl_qu_du", "xvmulwev_h_b", "xvmul_h", "xvsrarni_b_h", "xvfcmp_caf_s", "xvbitclri_d", "xvaddwev_w_h", "xvssrarn_w_d", "xvssrani_wu_d", "xvbitclr_d", "xvsran_w_d", "xvextrins_d", "xvsrl_w", "xvfcmp_clt_s", "xvmaddwod_d_wu", "xvslli_b", "xvmin_wu", "xvhaddw_d_w", "xvftintrne_l_d", "xvfcmp_slt_d", "xvsubwev_d_w", "xvhaddw_qu_du", "xvssrln_h_w", "xvpermi_w", "xvsubwev_h_bu", "xvrotr_d", "xvadda_d", "xvpickev_w", "xvclz_w", "xvsub_b", "vext2xv_d_b", "xvsubwod_q_du", "xvhaddw_q_d", "xvsrarn_h_w", "xvbitrevi_d", "xvmaddwod_h_bu", "xvssrarni_h_w", "xvfsub_s", "xvseqi_h", "xvmaddwev_d_wu", "xvmod_b", "xvfcmp_cle_d", "xvfsub_d", "xvmulwev_w_hu", "xvaddwev_d_wu_w", "xvftinth_l_s", "xvssrani_hu_w", "xvdiv_w", "xvsrari_b", "xvabsd_b", "xvsigncov_h", "xvabsd_d", "xvssrln_hu_w", "xvbitrevi_w", "xvmax_hu", "xvslei_hu", "xvpackev_h", "xvslt_w", "xvfcmp_cueq_d", "xvfnmsub_s", "xvfrecip_d", "xvmulwod_d_w", "xvsrarn_w_d", "xvilvl_h", "xvsadd_hu", "xvdiv_wu", "xvrotri_d", "xvbitseti_w", "xvsrai_w", "xbz_v", "xvsll_h", "xvfclass_s", "xvftint_w_d", "xvfcmp_sle_s", "xvfnmadd_s", "xvsat_wu", "xvsrarni_h_w", "xvmax_w", "xvpermi_d", "xvssrln_b_h", "xvmulwev_d_w", "xvssrani_du_q", "xvssrani_w_d", "xvssrarni_d_q", "xvffinth_d_w", "xvsle_wu", "xvadd_h", "xvsrarn_b_h", "xvhsubw_q_d", "xvssrlrn_wu_d", "xvexth_h_b", "xvmsub_h", "xvssran_w_d", "xvsubwod_d_wu", "xvssrlni_hu_w", "xvmuh_w", "xvdiv_h", "xvmulwod_q_du", "xvmulwod_h_bu_b", "xvftintrp_w_d", "xvmulwev_q_d", "xvslei_wu", "xvslt_du", "xvmsub_d", "xvsle_hu", "xvsra_b", "xvneg_d", "xvextrins_b", "xvreplve0_d", "xvavg_bu", "xvssrlni_du_q", "xvmul_w", "xvaddwev_d_wu", "xvmaddwod_h_b", "xvsubi_hu", "xvsadd_b", "vext2xv_d_h", "xvhaddw_du_wu", "xvldi", "xvslei_d", "xvsrlni_h_w", "xbnz_v", "xvmskltz_h", "xvssrlrni_wu_d", "xvsrani_h_w", "xvmaddwod_w_hu", "xvsrlr_h", "xvfcmp_cne_d", "xvavg_hu", "xvsigncov_b", "xvhsubw_h_b", "xvsigncov_w", "xvbitrev_d", "xvfcvth_d_s", "xvmskgez_b", "xvssrani_d_q", "xvadd_b", "xvslti_d", "xvbitsel_v", "vext2xv_du_hu", "xvslti_b", "xvaddwev_q_du_d", "xvsrari_h", "xvaddwod_h_bu_b", "xvshuf4i_d", "xvsllwil_w_h", "xvhaddw_hu_bu", "xvsra_w", "xvshuf_d", "xvsrlrni_h_w", "xvsran_h_w", "xvftintrne_w_s", "xvaddwod_w_h", "xvftintrz_wu_s", "xvmulwev_d_wu_w", "xvsrli_b", "xvmaddwod_q_du", "xvrepli_w", "xvclo_h", "xbnz_b", "xvpickve2gr_d", "xvmulwod_d_wu_w", "xvmulwev_q_du", "xvfrecip_s", "xvnor_v", "xvsat_w", "xvsll_d", "xvsrar_b", "xvmaxi_d", "xvfcvtl_d_s", "xvftintrnel_l_s", "xvsrlni_b_h", "xvmin_d", "xvfcmp_cult_s", "xvsrlr_w", "xvreplve0_w", "xvadd_q", "xvsub_d", "xvffint_s_wu", "xvmod_w", "xvmadd_b", "xvavgr_wu", "xvftintrm_w_d", "xbz_w", "xvrepl128vei_w", "xvsat_d", "xvftintrzh_l_s", "xvfrsqrt_d", "xvfmina_s", "xvaddwod_d_wu_w", "xbnz_d", "xvexth_w_h", "xvftintrzl_l_s", "xvdiv_du", "xvfmax_s", "xvftintrph_l_s", "xvsran_b_h", "xvsrari_w", "xvssrarn_b_h", "xvssrln_wu_d", "xvsra_h", "xvsadd_h", "xvsrlni_d_q", "vext2xv_wu_bu", "xvfcmp_seq_s", "xvmaxi_h", "xvslei_h", "vext2xv_hu_bu", "xvffint_s_l", "xvpickod_h", "xvextl_q_d", "xvfcmp_cult_d", "xvftintrm_w_s", "xvreplve_h", "xvmaxi_wu", "xvmaxi_du", "xvseq_w", "xvfrintrne_d", "xvreplve0_q", "vext2xv_du_wu", "xvmaddwod_q_d", "xvsllwil_d_w", "xvfcmp_clt_d", "xvfrintrz_d", "xvrotr_w", "xvssrani_bu_h", "xvfcmp_sor_d", "xvor_v", "xvpackev_d", "xvmsub_w", "xvmax_wu", "xvand_v", "xvhsubw_wu_hu", "xvftint_lu_d", "xvsubwev_h_b", "xvbsll_v", "xvabsd_bu", "xvftintrp_l_d", "xvrotr_b", "xvstelm_h", "xvssub_w", "xvssrlrn_bu_h", "xvaddwev_q_du", "xvmini_hu", "xvseq_d", "xvsrai_b", "xvbitrev_h", "xvmini_b", "xvmskltz_w", "xvsubwev_w_hu", "xvsrarni_d_q", "xvsrlrn_h_w", "xvclz_b", "xvavg_d", "xvbitset_b", "xvmulwod_d_wu", "xvfcmp_cor_s", "xvbitset_w", "xvssrlni_w_d", "xvavgr_bu", "xvslti_bu", "xvsrar_d", "xvmuh_b", "xvpickev_d", "xvreplgr2vr_h", "xvldrepl_b", "xvpickve2gr_wu", "xvmsknz_b", "xvbitrev_b", "xvmskltz_d", "xvmaddwev_w_h", "xvavg_w", "xvsle_w", "xvfmin_d", "xvftintrpl_l_s", "xvftintrz_w_d", "xvmod_du", "xvmin_h", "xvaddwod_w_hu", "xvrotri_w", "xvsubwev_q_du", "xvslti_du", "xvadda_w", "xvpcnt_h", "xvsle_h", "xvexth_qu_du", "xvaddwod_d_w", "xvmskltz_b", "xvfcmp_cun_s", "vext2xv_w_h", "xvsrlri_d", "xvbitclr_h", "xvandi_b", "xvsrlrn_w_d", "xvftintl_l_s", "xvmuh_d", "xvbsrl_v", "xvftintrmh_l_s", "xvfcmp_cule_s", "xvsrai_h", "xvmaddwev_w_hu_h", "xvsrlrni_d_q", "xvbitset_d", "xvavg_b", "xvavgr_du", "xvsrlri_h", "xvsat_bu", "xvshuf4i_b", "xvfmul_d", "xvmod_d", "xvsllwil_hu_bu", "xvseq_b", "xvssrlrni_h_w", "xvexth_hu_bu", "xvpickve_d_f", "xvnori_b", "xvhsubw_w_h", "xvavgr_hu", "xvsrln_h_w", "xvfcmp_sueq_d", "xvfcmp_sor_s", "xvclo_b", "xvpackod_w", "xvmaddwod_w_h", "xvfcmp_saf_s", "vext2xv_h_b", "xvsrln_b_h", "xvmini_du", "xvfrstp_h", "xvilvh_b", "xvfcmp_sult_s", "xvinsve0_w", "xvssub_d", "xvfcmp_cune_d", "xvreplgr2vr_w", "xvsle_bu", "xvrotri_h", "xvslei_bu", "xvmod_wu", "xvpickev_h", "xvfmax_d", "xvfmsub_s", "xvfcmp_sune_s", "xvfcmp_cueq_s", "xvfcvth_s_h", "xvssrlrn_h_w", "xvmaddwev_q_du_d", "xvbitclri_h", "xvpickev_b", "xvfcmp_sun_s", "xvssrarni_bu_h", "xvslti_h", "xvfcmp_sult_d", "xvfmaxa_d", "xvssran_bu_h", "xvpackod_h", "xvfcmp_cor_d", "xvexth_du_wu", "xvssrlrni_d_q", "xvbitseti_d", "xvsub_w", "xvmax_b", "xvssrlrni_hu_w", "xbnz_h", "xvsubwev_q_d", "xvsrarni_w_d", "xvpackev_w", "xvsllwil_wu_hu", "xvstelm_b", "xvrepl128vei_h", "xvabsd_wu", "xvinsgr2vr_d", "xvsat_h", "xvperm_w", "xvmadd_d", "xvhsubw_d_w", "xvflogb_d", "xvaddwev_d_w", "xvftintrml_l_s", "xvsrli_d", "xvfcmp_sun_d", "xvldrepl_d", "xvflogb_s", "xvmuh_bu", "xvbitclri_w", "xvexth_wu_hu", "xvaddwod_q_du", "xvavg_du"]}, {"filename": "clang/test/CodeGen/LoongArch/lasx/builtin-error.c", "functions": ["xvsat_du", "xvslli_b", "xvmaxi_h", "xvmini_w", "xvslei_h", "xvstelm_b_idx", "xvslti_w", "xvpermi_w", "xvseqi_d", "xvrepl128vei_b", "xvssrarni_w_d", "xvxori_b", "xvmaxi_wu", "xvbitrevi_h", "xvbitrevi_b", "xvaddi_wu", "xvmaxi_du", "xvmini_h", "xvsrlrni_b_h", "xvsllwil_d_w", "xvbitrevi_d", "xvssrarni_h_w", "xvseqi_h", "xvssrani_bu_h", "xvssrlrni_b_h", "xvssrani_hu_w", "xvshuf4i_w", "xvori_b", "xvsrari_b", "xvsrari_d", "xvmini_bu", "xvmaxi_w", "xvbsll_v", "xvstelm_h", "xvbitrevi_w", "xvmini_hu", "xvsrli_h", "xvsrai_b", "xvslei_hu", "xvslei_du", "xvbitseti_b", "xvssrlni_bu_h", "xvmini_b", "xvpermi_q", "xvsrarni_d_q", "xvslli_d", "xvsllwil_h_b", "xvstelm_d", "xvrotri_d", "xvbitseti_h", "xvpickve2gr_w", "xvbitseti_w", "xvsrai_w", "xvssrlni_w_d", "xvsubi_wu", "xvslti_bu", "xvextrins_w", "xvldrepl_b", "xvrotri_b", "xvfrstpi_h", "xvpickve2gr_wu", "xvssrlrni_bu_h", "xvsat_wu", "xvsrarni_h_w", "xvpermi_d", "xvssrani_du_q", "xvssrani_w_d", "xvld", "xvsrani_d_q", "xvssrarni_d_q", "xvssrlni_hu_w", "xvseqi_b", "xvslli_w", "xvsubi_du", "xvslei_wu", "xvrotri_w", "xvssrarni_du_q", "xvmini_wu", "xvslti_du", "xvextrins_b", "xvssrlni_du_q", "xvldrepl_h", "xvsubi_hu", "xvsrlri_d", "xvandi_b", "xvsllwil_du_wu", "xvslei_b", "xvldi", "xvbsrl_v", "xvstelm_w", "xvsrai_d", "xvslei_d", "xvsrani_b_h", "xvsrai_h", "xvsrlni_h_w", "xvsrlrni_d_q", "xvssrlrni_wu_d", "xvslti_wu", "xvsrlri_h", "xvaddi_bu", "xvsat_bu", "xvfrstpi_b", "xvsrani_h_w", "xvshuf4i_b", "xvssrarni_hu_w", "xvpickve_w_f", "xvsllwil_hu_bu", "xvssrlrni_h_w", "xvinsve0_d", "xvssrlni_d_q", "xvpickve_d_f", "xvsrlri_w", "xvnori_b", "xvssrlni_wu_d", "xvssrlrni_du_q", "xvsrani_w_d", "xvssrani_d_q", "xvldrepl_w", "xvslti_d", "xvslti_b", "xvmini_du", "xvsrari_h", "xvslli_h", "xvbitseli_b", "xvinsve0_w", "xvsrlrni_w_d", "xvshuf4i_d", "xvsllwil_w_h", "xvssrani_h_w", "xvrepli_d", "xvinsgr2vr_w", "xvsrlrni_h_w", "xvst", "xvpickve_d", "xvrotri_h", "xvbitclri_b", "xvaddi_du", "xvssrlrni_w_d", "xvsrli_b", "xvslei_bu", "xvssrarni_wu_d", "xvrepli_w", "xvpickve2gr_d", "xvstelm_h_idx", "xvsat_w", "xvssrarni_b_h", "xvsat_b", "xvmaxi_d", "xvbitclri_h", "xvpickve2gr_du", "xvsrlni_b_h", "xvsat_hu", "xvpickve_w", "xvssrarni_bu_h", "xvslti_h", "xvstelm_d_idx", "xvslei_w", "xvseqi_w", "xvmini_d", "xvsubi_bu", "xvsrli_w", "xvssrlrni_d_q", "xvbitseti_d", "xvaddi_hu", "xvssrlrni_hu_w", "xvslti_hu", "xvshuf4i_h", "xvsrarni_w_d", "xvstelm_w_idx", "xvrepl128vei_w", "xvssrlni_b_h", "xvstelm_b", "xvrepl128vei_d", "xvsllwil_wu_hu", "xvrepl128vei_h", "__attribute__", "xvsat_h", "xvsat_d", "xvextrins_h", "xvinsgr2vr_d", "xvsrlni_w_d", "xvssrani_b_h", "xvrepli_h", "xvrepli_b", "xvmaxi_hu", "xvsrlri_b", "xvmaxi_bu", "xvsrli_d", "xvsrarni_b_h", "xvldrepl_d", "xvbitclri_d", "xvsrari_w", "xvssrani_wu_d", "xvbitclri_w", "xvextrins_d", "xvsrlni_d_q", "xvssrlni_h_w", "xvmaxi_b"]}, {"filename": "clang/test/CodeGen/LoongArch/lasx/builtin.c", "functions": ["xvsat_du", "xvmax_h", "xvfadd_d", "xvbitset_h", "xvftintrneh_l_s", "xvpickod_d", "xvaddwod_d_wu", "xvslti_w", "xvmulwod_q_du_d", "xvxor_v", "xvhsubw_hu_bu", "xvrepl128vei_b", "xvsubwev_w_h", "xvxori_b", "xvmaddwev_d_wu_w", "xvhaddw_w_h", "xvfrintrz_s", "xvaddi_wu", "xvmini_h", "vext2xv_d_w", "xvssub_wu", "xvssrarn_wu_d", "xvilvh_d", "xvshuf4i_w", "xvadd_w", "xvreplve_b", "xvavg_wu", "xvssran_b_h", "xvssran_h_w", "xvmod_hu", "xvsrari_d", "xvshuf_h", "xvmaxi_w", "xvsadd_du", "xvmaddwev_q_d", "xvfcmp_ceq_d", "xvsubwod_h_bu", "xvfrintrm_d", "xvpackod_b", "xvsrli_h", "xvilvh_h", "xvfcmp_cun_d", "xvsrlr_d", "xvslei_du", "xvssrlni_bu_h", "xvmin_b", "xvpermi_q", "xvftintrz_l_d", "xvaddwev_h_b", "xvmulwod_h_b", "xvsllwil_h_b", "xvmulwod_w_hu", "xvbitseti_h", "xvfcmp_sule_s", "xvpcnt_w", "xvextrins_w", "xvdiv_b", "xvavgr_b", "xvrotri_b", "xvfcmp_saf_d", "xvmadd_h", "xvssrlrni_bu_h", "xvfadd_s", "xvaddwev_w_hu_h", "xvbitrev_w", "xvbitclr_w", "xvavgr_w", "xvsrani_d_q", "xvmin_bu", "xvhaddw_h_b", "xvfdiv_d", "xvsadd_d", "xvfcmp_caf_d", "xvfcmp_cle_s", "xvslt_bu", "xvmadd_w", "xvmaddwev_h_b", "xvssrarni_du_q", "xvfmadd_s", "xvmin_hu", "xvsrl_h", "xvabsd_h", "xvstx", "xvssran_hu_w", "xvstelm_w", "xvsrai_d", "xvsrani_b_h", "xvmaddwev_w_hu", "xvslt_h", "xvaddi_bu", "xvssrarni_hu_w", "xvaddwod_q_du_d", "xbz_h", "xvaddwev_w_hu", "xvinsve0_d", "xvssrlni_d_q", "vext2xv_du_bu", "xvsrlri_w", "xvmulwev_d_wu", "xvabsd_du", "xvssrlrni_du_q", "xvreplve0_b", "xvreplve0_h", "xvmsub_b", "xvfnmadd_d", "xvfrintrne_s", "xvldrepl_w", "xvdiv_hu", "xvclz_h", "xvslt_d", "xvaddwev_h_bu_b", "xvfnmsub_d", "xvssrln_bu_h", "xvsrlrni_w_d", "xvffintl_d_w", "xbz_b", "xvssrarn_hu_w", "xvssrani_h_w", "xvrepli_d", "xvst", "xvpickve_d", "xvfcmp_ceq_s", "xvssub_hu", "xvfcmp_cule_d", "xvfmaxa_s", "xvbitclri_b", "xvaddi_du", "xvssub_b", "vext2xv_w_b", "xvneg_b", "xvffint_d_lu", "xvadd_d", "xvssrarni_b_h", "xvilvl_b", "xvssub_du", "xvreplve_d", "xvsigncov_d", "xvpickod_b", "xvpackev_b", "xvneg_h", "xvpickve2gr_du", "xvssrarn_h_w", "xvsat_hu", "xvsubwod_q_d", "xvexth_d_w", "xvfrintrp_s", "xvseqi_w", "xvshuf_b", "xvfmsub_d", "xvftintrp_w_s", "xvmini_d", "xvreplgr2vr_b", "xvmulwev_w_hu_h", "xvhsubw_du_wu", "xvseq_h", "xvsubwod_h_b", "xvslti_hu", "xvmod_bu", "xvsub_h", "xvavgr_h", "xvssrlni_b_h", "xvmod_h", "xvaddwev_h_bu", "xvaddwod_h_bu", "xvfcmp_cune_s", "xvsrlni_w_d", "xvmaxi_hu", "xvsrlri_b", "xvmaxi_bu", "xvslt_hu", "xvmulwod_h_bu", "xvsubwod_w_h", "xvmax_du", "xvfrstp_b", "xvmuh_hu", "xvaddwev_q_d", "xvmaddwev_h_bu", "xvssrlni_h_w", "xvmaxi_b", "xvpackod_d", "xvmini_w", "xvfrsqrt_s", "xvsadd_bu", "xvfcmp_cne_s", "xvseqi_d", "xvsra_d", "xvssrarni_w_d", "xvfcmp_sueq_s", "xvftint_wu_s", "xvfcmp_sune_d", "xvmulwev_w_h", "xvpcnt_d", "xvbitrevi_h", "xvbitrevi_b", "xvdiv_bu", "xvsrlrni_b_h", "xvsrlrn_b_h", "xvfcmp_sne_s", "xvfcmp_seq_d", "xvmulwod_q_d", "xvshuf_w", "xvssrlrni_b_h", "xvssrarn_bu_h", "xvmul_d", "xvori_b", "xvftintrm_l_d", "xvmini_bu", "xvsubwev_d_wu", "xvfcmp_sne_d", "xvsadd_wu", "xvandn_v", "xvmuh_du", "xvfrintrm_s", "xvmaddwod_q_du_d", "xvmul_b", "xvaddwod_h_b", "xvbitseti_b", "xvreplve_w", "xbnz_w", "xvsle_b", "xvslli_d", "xvmulwod_w_hu_h", "xvhsubw_qu_du", "xvstelm_d", "xvmax_d", "xvfrint_d", "xvpickve2gr_w", "xvadda_h", "xbz_d", "xvsubi_wu", "xvmaddwod_h_bu_b", "xvssran_wu_d", "xvfrstpi_h", "xvmaddwod_w_hu_h", "xvaddwod_w_hu_h", "xvfrint_s", "xvssrlrn_b_h", "xvfmin_s", "xvreplgr2vr_d", "xvavg_h", "xvld", "xvssrlrn_w_d", "xvseqi_b", "xvfclass_d", "xvavgr_d", "xvsubwod_w_hu", "xvslli_w", "xvsubi_du", "xvmini_wu", "xvsrar_h", "xvsrln_w_d", "xvsrlr_b", "xvldrepl_h", "xvmaddwod_d_wu_w", "xvfcvtl_s_h", "xvpickod_w", "xvdiv_d", "xvsllwil_du_wu", "xvslei_b", "xvftintrz_w_s", "xvldx", "xvneg_w", "xvslti_wu", "xvmuh_h", "xvfrstpi_b", "xvfcmp_slt_s", "xvpickve_w_f", "xvmaddwev_q_du", "xvmaddwev_d_w", "xvfcmp_sle_d", "xvmaddwev_h_bu_b", "xvsubwod_d_w", "xvfmadd_d", "xvssrlni_wu_d", "xvsle_du", "xvftint_w_s", "xvsrani_w_d", "xvhaddw_wu_hu", "xvffint_s_w", "xvmulwod_w_h", "xvclo_w", "xvmuh_wu", "xvssrlrn_hu_w", "xvffint_d_l", "xvfcmp_sule_d", "xvslli_h", "xvbitseli_b", "xvilvl_d", "xvinsgr2vr_w", "xvsrar_w", "xvssrlrni_w_d", "xvssrarni_wu_d", "xvsll_b", "xvmulwev_h_bu", "xvpcnt_b", "xvssub_bu", "xvclz_d", "xvfmul_s", "xvrotr_h", "xvsat_b", "xvilvl_w", "xvorn_v", "xvfcvt_h_s", "xvftintrne_w_d", "xvsub_q", "xvmin_du", "xvabsd_hu", "xvilvh_w", "xvfcvt_s_d", "xvpickve_w", "xvftint_l_d", "xvbitclr_b", "xvadda_b", "xvmulwev_q_du_d", "xvslei_w", "xvsubi_bu", "xvsle_d", "xvsrli_w", "xvaddi_hu", "xvslt_wu", "xvfrintrp_d", "xvabsd_w", "xvfmina_d", "xvssrln_w_d", "xvaddwod_q_d", "xvmin_w", "xvmulwev_h_bu_b", "xvmaddwod_d_w", "xvslt_b", "xvshuf4i_h", "xvclo_d", "xvftintrz_lu_d", "xvexth_q_d", "xvsrl_d", "xvssub_h", "xvrepl128vei_d", "vext2xv_wu_hu", "xvrepli_h", "xvfdiv_s", "xvextrins_h", "xvsadd_w", "xvssrani_b_h", "xvsrl_b", "xvfsqrt_d", "xvfsqrt_s", "xvrepli_b", "xvmax_bu", "xvsll_w", "xvextl_qu_du", "xvmulwev_h_b", "xvmul_h", "xvsrarni_b_h", "xvfcmp_caf_s", "xvbitclri_d", "xvaddwev_w_h", "xvssrarn_w_d", "xvssrani_wu_d", "xvbitclr_d", "xvsran_w_d", "xvextrins_d", "xvsrl_w", "xvfcmp_clt_s", "xvmaddwod_d_wu", "xvslli_b", "xvmin_wu", "xvhaddw_d_w", "xvftintrne_l_d", "xvfcmp_slt_d", "xvsubwev_d_w", "xvhaddw_qu_du", "xvssrln_h_w", "xvpermi_w", "xvsubwev_h_bu", "xvrotr_d", "xvadda_d", "xvpickev_w", "xvclz_w", "xvsub_b", "vext2xv_d_b", "xvsubwod_q_du", "xvhaddw_q_d", "xvsrarn_h_w", "xvbitrevi_d", "xvmaddwod_h_bu", "xvssrarni_h_w", "xvfsub_s", "xvseqi_h", "xvmaddwev_d_wu", "xvmod_b", "xvfcmp_cle_d", "xvfsub_d", "xvmulwev_w_hu", "xvaddwev_d_wu_w", "xvftinth_l_s", "xvssrani_hu_w", "xvdiv_w", "xvsrari_b", "xvabsd_b", "xvsigncov_h", "xvabsd_d", "xvssrln_hu_w", "xvbitrevi_w", "xvmax_hu", "xvslei_hu", "xvpackev_h", "xvslt_w", "xvfcmp_cueq_d", "xvfnmsub_s", "xvfrecip_d", "xvmulwod_d_w", "xvsrarn_w_d", "xvilvl_h", "xvsadd_hu", "xvdiv_wu", "xvrotri_d", "xvbitseti_w", "xvsrai_w", "xbz_v", "xvsll_h", "xvfclass_s", "xvftint_w_d", "xvfcmp_sle_s", "xvfnmadd_s", "xvsat_wu", "xvsrarni_h_w", "xvmax_w", "xvpermi_d", "xvssrln_b_h", "xvmulwev_d_w", "xvssrani_du_q", "xvssrani_w_d", "xvssrarni_d_q", "xvffinth_d_w", "xvsle_wu", "xvadd_h", "xvsrarn_b_h", "xvhsubw_q_d", "xvssrlrn_wu_d", "xvexth_h_b", "xvmsub_h", "xvssran_w_d", "xvsubwod_d_wu", "xvssrlni_hu_w", "xvmuh_w", "xvdiv_h", "xvmulwod_q_du", "xvmulwod_h_bu_b", "xvftintrp_w_d", "xvmulwev_q_d", "xvslei_wu", "xvslt_du", "xvmsub_d", "xvsle_hu", "xvsra_b", "xvneg_d", "xvextrins_b", "xvreplve0_d", "xvavg_bu", "xvssrlni_du_q", "xvmul_w", "xvaddwev_d_wu", "xvmaddwod_h_b", "xvsubi_hu", "xvsadd_b", "vext2xv_d_h", "xvhaddw_du_wu", "xvldi", "xvslei_d", "xvsrlni_h_w", "xbnz_v", "xvmskltz_h", "xvssrlrni_wu_d", "xvsrani_h_w", "xvmaddwod_w_hu", "xvsrlr_h", "xvfcmp_cne_d", "xvavg_hu", "xvsigncov_b", "xvhsubw_h_b", "xvsigncov_w", "xvbitrev_d", "xvfcvth_d_s", "xvmskgez_b", "xvssrani_d_q", "xvadd_b", "xvslti_d", "xvbitsel_v", "vext2xv_du_hu", "xvslti_b", "xvaddwev_q_du_d", "xvsrari_h", "xvaddwod_h_bu_b", "xvshuf4i_d", "xvsllwil_w_h", "xvhaddw_hu_bu", "xvsra_w", "xvshuf_d", "xvsrlrni_h_w", "xvsran_h_w", "xvftintrne_w_s", "xvaddwod_w_h", "xvftintrz_wu_s", "xvmulwev_d_wu_w", "xvsrli_b", "xvmaddwod_q_du", "xvrepli_w", "xvclo_h", "xbnz_b", "xvpickve2gr_d", "xvmulwod_d_wu_w", "xvmulwev_q_du", "xvfrecip_s", "xvnor_v", "xvsat_w", "xvsll_d", "xvsrar_b", "xvmaxi_d", "xvfcvtl_d_s", "xvftintrnel_l_s", "xvsrlni_b_h", "xvmin_d", "xvfcmp_cult_s", "xvsrlr_w", "xvreplve0_w", "xvadd_q", "xvsub_d", "xvffint_s_wu", "xvmod_w", "xvmadd_b", "xvavgr_wu", "xvftintrm_w_d", "xbz_w", "xvrepl128vei_w", "xvsat_d", "xvftintrzh_l_s", "xvfrsqrt_d", "xvfmina_s", "xvaddwod_d_wu_w", "xbnz_d", "xvexth_w_h", "xvftintrzl_l_s", "xvdiv_du", "xvfmax_s", "xvftintrph_l_s", "xvsran_b_h", "xvsrari_w", "xvssrarn_b_h", "xvssrln_wu_d", "xvsra_h", "xvsadd_h", "xvsrlni_d_q", "vext2xv_wu_bu", "xvfcmp_seq_s", "xvmaxi_h", "xvslei_h", "vext2xv_hu_bu", "xvffint_s_l", "xvpickod_h", "xvextl_q_d", "xvfcmp_cult_d", "xvftintrm_w_s", "xvreplve_h", "xvmaxi_wu", "xvmaxi_du", "xvseq_w", "xvfrintrne_d", "xvreplve0_q", "vext2xv_du_wu", "xvmaddwod_q_d", "xvsllwil_d_w", "xvfcmp_clt_d", "xvfrintrz_d", "xvrotr_w", "xvssrani_bu_h", "xvfcmp_sor_d", "xvor_v", "xvpackev_d", "xvmsub_w", "xvmax_wu", "xvand_v", "xvhsubw_wu_hu", "xvftint_lu_d", "xvsubwev_h_b", "xvbsll_v", "xvabsd_bu", "xvftintrp_l_d", "xvrotr_b", "xvstelm_h", "xvssub_w", "xvssrlrn_bu_h", "xvaddwev_q_du", "xvmini_hu", "xvseq_d", "xvsrai_b", "xvbitrev_h", "xvmini_b", "xvmskltz_w", "xvsubwev_w_hu", "xvsrarni_d_q", "xvsrlrn_h_w", "xvclz_b", "xvavg_d", "xvbitset_b", "xvmulwod_d_wu", "xvfcmp_cor_s", "xvbitset_w", "xvssrlni_w_d", "xvavgr_bu", "xvslti_bu", "xvsrar_d", "xvmuh_b", "xvpickev_d", "xvreplgr2vr_h", "xvldrepl_b", "xvpickve2gr_wu", "xvmsknz_b", "xvbitrev_b", "xvmskltz_d", "xvmaddwev_w_h", "xvavg_w", "xvsle_w", "xvfmin_d", "xvftintrpl_l_s", "xvftintrz_w_d", "xvmod_du", "xvmin_h", "xvaddwod_w_hu", "xvrotri_w", "xvsubwev_q_du", "xvslti_du", "xvadda_w", "xvpcnt_h", "xvsle_h", "xvexth_qu_du", "xvaddwod_d_w", "xvmskltz_b", "xvfcmp_cun_s", "vext2xv_w_h", "xvsrlri_d", "xvbitclr_h", "xvandi_b", "xvsrlrn_w_d", "xvftintl_l_s", "xvmuh_d", "xvbsrl_v", "xvftintrmh_l_s", "xvfcmp_cule_s", "xvsrai_h", "xvmaddwev_w_hu_h", "xvsrlrni_d_q", "xvbitset_d", "xvavg_b", "xvavgr_du", "xvsrlri_h", "xvsat_bu", "xvshuf4i_b", "xvfmul_d", "xvmod_d", "xvsllwil_hu_bu", "xvseq_b", "xvssrlrni_h_w", "xvexth_hu_bu", "xvpickve_d_f", "xvnori_b", "xvhsubw_w_h", "xvavgr_hu", "xvsrln_h_w", "xvfcmp_sueq_d", "xvfcmp_sor_s", "xvclo_b", "xvpackod_w", "xvmaddwod_w_h", "xvfcmp_saf_s", "vext2xv_h_b", "xvsrln_b_h", "xvmini_du", "xvfrstp_h", "xvilvh_b", "xvfcmp_sult_s", "xvinsve0_w", "xvssub_d", "xvfcmp_cune_d", "xvreplgr2vr_w", "xvsle_bu", "xvrotri_h", "xvslei_bu", "xvmod_wu", "xvpickev_h", "xvfmax_d", "xvfmsub_s", "xvfcmp_sune_s", "xvfcmp_cueq_s", "xvfcvth_s_h", "xvssrlrn_h_w", "xvmaddwev_q_du_d", "xvbitclri_h", "xvpickev_b", "xvfcmp_sun_s", "xvssrarni_bu_h", "xvslti_h", "xvfcmp_sult_d", "xvfmaxa_d", "xvssran_bu_h", "xvpackod_h", "xvfcmp_cor_d", "xvexth_du_wu", "xvssrlrni_d_q", "xvbitseti_d", "xvsub_w", "xvmax_b", "xvssrlrni_hu_w", "xbnz_h", "xvsubwev_q_d", "xvsrarni_w_d", "xvpackev_w", "xvsllwil_wu_hu", "xvstelm_b", "xvrepl128vei_h", "xvabsd_wu", "__attribute__", "xvsat_h", "xvinsgr2vr_d", "xvperm_w", "xvmadd_d", "xvhsubw_d_w", "xvflogb_d", "xvaddwev_d_w", "xvftintrml_l_s", "xvsrli_d", "xvfcmp_sun_d", "xvldrepl_d", "xvflogb_s", "xvmuh_bu", "xvbitclri_w", "xvexth_wu_hu", "xvaddwod_q_du", "xvavg_du"]}]}
{"pr_number": 70543, "url": "https://github.com/llvm/llvm-project/pull/70543", "title": "Perf/lexer faster slow get char and size", "body": "", "feature_layers": ["ast", "lexer"], "feature_directives": [], "files_changed": [{"filename": "clang/lib/Lex/Lexer.cpp", "functions": ["getCharAndSizeSlowNoWarn", "getCharAndSizeSlow"]}]}
{"pr_number": 70653, "url": "https://github.com/llvm/llvm-project/pull/70653", "title": "[mlir][linalg] Enable CollapseLinalgDimensions to collapse ops with C\u2026", "body": "\u2026anonicalized Identity maps\r\n\r\nSupporting collapsion of linalg ops which have\r\ncanonicalized identity maps matched for their\r\nOpOperands.\r\n\r\nCanonnicalized Identity is an identity affine map\r\nwhich include zero constants corresponded to the\r\nvalues of `1` of the Operand's shape.\r\n\r\na common use case for this support would be the\r\nusage of CollapseLinalgDimensions after Tosa-To-Linalg ,\r\nsince the later generates linalg.generic ops with canonicalized\r\nidentity maps (and the rewrite pattern would fail matching, \r\nsince it supports only projected permutes indexing maps).", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Linalg/Transforms/ElementwiseOpFusion.cpp", "functions": ["isDimSequencePreserved", "getCollapsedOpIndexingMap"]}]}
{"pr_number": 66079, "url": "https://github.com/llvm/llvm-project/pull/66079", "title": "[GlobalISel] Add `GITypeOf` special type", "body": "NOTE: This is part of a stack. See #66377 for the follow-up commit which adds type inference to drop GITypeOf in most instances.\r\n\r\nAllows creating a register/immediate that uses the same type as a matched operand.\r\n\r\nCombined with #66077 this adds more flexibility to rewrite certain combines, e.g.\r\n```\r\ndef mul_by_neg_one: GICombineRule <\r\n  (defs root:$dst),\r\n  (match (G_MUL $dst, $x, -1)),\r\n  (apply (G_SUB $dst, (GITypeOf<\"$x\"> 0), $x))\r\n>;\r\n```", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/utils/TableGen/GlobalISelCombinerEmitter.cpp", "functions": ["ImmTy", "getType", "bool", "getLLTCodeGenFromRecord", "diagnoseAllSpecialTypes", "str", "isTypeOf", "setType", "getRawOpName", "isLLT", "check", "getLLTCodeGen", "checkSemantics", "Ty", "isSpecial", "getTypeOfOpName", "isValidType", "Name", "getLLTCodeGenOrTempType", "LLTCodeGen"]}]}
{"pr_number": 70437, "url": "https://github.com/llvm/llvm-project/pull/70437", "title": "[clang][dataflow][NFC] Move `parseAll()` to TestingSupport and rename `parseFormulas()`", "body": "I'm working on a patch that will use this function from a different test.\n", "feature_layers": ["parse"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/unittests/Analysis/FlowSensitive/SolverTest.cpp", "functions": ["parseAll"]}]}
{"pr_number": 69604, "url": "https://github.com/llvm/llvm-project/pull/69604", "title": "[mlir][ArmSME] Support lowering masked vector.outerproduct ops to SME", "body": "This patch adds support for lowering masked outer products to SME. This is done in two stages. First, vector.outerproducts (both masked and non-masked) are rewritten to arm_sme.outerproducts. The arm_sme.outerproduct op is close to vector.outerproduct, but supports masking on the operands rather than the result. It also limits the cases it handles to things that could be (directly) lowered to SME.\r\n\r\nThis currently requires that the source of the mask is a vector.create_mask op. E.g.:\r\n\r\n```mlir\r\n%mask = vector.create_mask %dimA, %dimB : vector<[4]x[4]xi1>\r\n%result = vector.mask %mask {\r\n             vector.outerproduct %vecA, %vecB\r\n              : vector<[4]xf32>, vector<[4]xf32>\r\n          } : vector<[4]x[4]xi1> -> vector<[4]x[4]xf32>\r\n```\r\nIs rewritten to:\r\n```\r\n%maskA = vector.create_mask %dimA : vector<[4]xi1>\r\n%maskB = vector.create_mask %dimB : vector<[4]xi1>\r\n%result = arm_sme.outerproduct %vecA, %vecB masks(%maskA, %maskB)\r\n              : vector<[4]xf32>, vector<[4]xf32>\r\n```\r\n(The same rewrite works for non-masked vector.outerproducts too)\r\n\r\nThe arm_sme.outerproduct can then be directly lowered to SME intrinsics.", "feature_layers": ["ir"], "feature_directives": ["for", "requires", "masked"], "files_changed": [{"filename": "mlir/lib/Conversion/VectorToArmSME/VectorToArmSME.cpp", "functions": ["failure"]}, {"filename": "mlir/lib/Dialect/ArmSME/Transforms/LegalizeForLLVMExport.cpp", "functions": ["failure"]}]}
{"pr_number": 70326, "url": "https://github.com/llvm/llvm-project/pull/70326", "title": "[MLIR][Linalg] Introduce SpecializeOp", "body": "Introduce an operation to specialize linalg.generics, for example, detecting a linalg.generic that is semantically equivalent to a linalg.copy and replacing the former with the latter. After code generation, it is helpful to lower named operations to vendor-optimized libraries.", "feature_layers": ["sema", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Linalg/TransformOps/LinalgTransformOps.cpp", "functions": ["emitDefaultSilenceableFailure"]}, {"filename": "mlir/lib/Dialect/Linalg/Transforms/Specialize.cpp", "functions": ["failure"]}]}
{"pr_number": 65728, "url": "https://github.com/llvm/llvm-project/pull/65728", "title": "[RISCV] Combine trunc (sra sext (x), zext (y)) to sra (x, smin (y, scalarsizeinbits(y) - 1))", "body": "For RVV, If we want to perform an i8 or i16 element-wise vector arithmetic right shift in the upper C/C++ program,  the value to be shifted would be first sign extended to i32, and the shift amount would also be zero_extended to i32 to perform the vsra.vv instruction, and followed by a truncate to get the final calculation result, such pattern will later expanded to a series of \"vsetvli\" and \"vnsrl\" instructions later, this is because the RVV spec only support 2 * SEW -> SEW truncate. But for vector, the shift amount can also be determined by smin (Y, ScalarSizeInBits(Y) - 1)). Also, for the vsra instruction, we only care about the low lg2(SEW) bits as the shift amount.\r\n\r\n- Alive2: https://alive2.llvm.org/ce/z/u3-Zdr\r\n- C++ Test cases : https://gcc.godbolt.org/z/q1qE7fbha", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVISelLowering.cpp", "functions": ["SDValue"]}]}
{"pr_number": 66463, "url": "https://github.com/llvm/llvm-project/pull/66463", "title": "[analyzer] Simplify SVal for simple NonLoc->Loc casts", "body": "NonLoc symbolic SVal to Loc casts are not supported except for nonloc::ConcreteInt.\r\n\r\nThis change simplifies the source SVals so that the more casts can go through nonloc::ConcreteInt->loc::ConcreteInt path. For example:\r\n\r\n```c\r\n  void test_simplified_before_cast_add(long long t1) {\r\n    long long t2 = t1 + 3;\r\n    if (!t2) {\r\n      int *p = (int *) t2;\r\n      clang_analyzer_eval(p == 0); // expected-warning{{TRUE}}\r\n    }\r\n  }\r\n```\r\nIf simplified, `t2` is 0, resulting `p` is nullptr, otherwise `p` is unknown.\r\n\r\nFixes #62232", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/Analysis/symbol-simplification-nonloc-loc.cpp", "functions": ["test_simplified_before_cast_mul", "test_simplified_before_cast_add", "clang_analyzer_eval", "test_simplified_before_cast_sub"]}]}
{"pr_number": 70694, "url": "https://github.com/llvm/llvm-project/pull/70694", "title": "[mlir][MemRefToLLVM] Fix crashes with unconvertable memory spaces", "body": "Fixes #70160\r\n\r\nThe issue is resolved by:\r\n1. Changing the call to address space conversion to use the correct return type, preventing the code from moving past the if and into the crashing optional dereference.\r\n2. Adding handling to the AllocLikeOp rewriter for the case where the underlying buffer allocation fails.", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Conversion/MemRefToLLVM/AllocLikeConversion.cpp", "functions": ["Value"]}]}
{"pr_number": 70342, "url": "https://github.com/llvm/llvm-project/pull/70342", "title": "[RISCV] Begin moving post-isel vector peepholes to a MF pass", "body": "We currently have three postprocess peephole optimisations for vector pseudos:\r\n\r\n1) Masked pseudo with all ones mask -> unmasked pseudo\r\n2) Merge vmerge pseudo into operand pseudo's mask\r\n3) vmerge pseudo with all ones mask -> vmv.v.v pseudo\r\n\r\nThis patch aims to move these peepholes out of SelectionDAG and into a separate RISCVFoldMasks MachineFunction pass.\r\n\r\nThere are a few motivations for doing this:\r\n\r\n* The current SelectionDAG implementation operates on MachineSDNodes, which are essentially MachineInstrs but require a bunch of logic to reason about chain and glue operands. The RISCVII::has*Op helper functions also don't exactly line up with the SDNode operands. Mutating these pseudos and their operands in place becomes a good bit easier at the MachineInstr level. For example, we would no longer need to check for cycles in the DAG during performCombineVMergeAndVOps.\r\n\r\n* Although it's further down the line, moving this code out of SelectionDAG allows it to be reused by GlobalISel later on.\r\n\r\n* In performCombineVMergeAndVOps, it may be possible to commute the operands to enable folding in more cases (see test/CodeGen/RISCV/rvv/vmadd-vp.ll). There is existing machinery to commute operands in TII::commuteInstruction, but it's implemented on MachineInstrs.\r\n\r\nThe pass runs straight after ISel, before any of the other machine SSA optimization passes run. This is so that dead-mi-elimination can mop up any vmsets that are no longer used (but if preferred we could try and erase them from inside RISCVFoldMasks itself). This also means that these peepholes are no longer run at codegen -O0, so this patch isn't strictly NFC.\r\n\r\nOnly the performVMergeToVMv peephole is refactored in this patch, the remaining two would be implemented later. And as noted by @preames, it should be possible to move doPeepholeSExtW out of SelectionDAG as well.", "feature_layers": ["codegen", "ir"], "feature_directives": ["for", "masked"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVFoldMasks.cpp", "functions": ["isVMerge"]}, {"filename": "llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp", "functions": ["DL"]}]}
{"pr_number": 68091, "url": "https://github.com/llvm/llvm-project/pull/68091", "title": "[clang][driver] Fix an issue where clang does not correctly resolve the system header if invoked via symlink (on MacOS)", "body": "## Add \\<executable\\>/../include/c++/v1 to include path\r\n\r\nOn macOS, when clang is invoked via a symlink, since the InstalledDir is\r\nwhere the link is located, the C++ headers are not identified and the\r\ndefault system headers are used.\r\n\r\nThis fix adds a second check using the folder where the executable is\r\nlocated.\r\n\r\nThis patch fixes #66704.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "clang/tools/driver/driver.cpp", "functions": ["InstalledPath"]}]}
{"pr_number": 70366, "url": "https://github.com/llvm/llvm-project/pull/70366", "title": "[CGExprConstant] stop calling into ConstExprEmitter for Reference type destinations", "body": "Fixes a bug introduced by\r\ncommit b54294e2c959 (\"[clang][ConstantEmitter] have tryEmitPrivate[ForVarInit] try ConstExprEmitter fast-path first\")\r\n\r\nIn the added test case, the QualType is a LValueReferenceType.\r\n\r\n    LValueReferenceType 0x558412998d90 'const char (&)[41]'\r\n    `-ParenType 0x558412998d30 'const char[41]' sugar\r\n      `-ConstantArrayType 0x558412998cf0 'const char[41]' 41\r\n        `-QualType 0x55841294c271 'const char' const\r\n          `-BuiltinType 0x55841294c270 'char'\r\n\r\nFixes: #69979", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CodeGenCXX/const-init-cxx11.cpp", "functions": ["char"]}]}
{"pr_number": 70690, "url": "https://github.com/llvm/llvm-project/pull/70690", "title": "[flang] Add fastmath attributes to complex arithmetic", "body": "Propagate fast math flags through complex number lowering (when lowering fir.*c directly to llvm floating point operations).\r\n\r\nThe lowering path through the MLIR complex dialect is unchanged.\r\n\r\nThis leads to a small improvement in spec2017 fotonik3d_r.", "feature_layers": ["ir", "ast"], "feature_directives": [], "files_changed": [{"filename": "flang/lib/Optimizer/CodeGen/CodeGen.cpp", "functions": ["getLLVMFMFAttr"]}]}
{"pr_number": 65512, "url": "https://github.com/llvm/llvm-project/pull/65512", "title": "[LTO] A static relocation model can override the PIC level wrt treating external address as directly accessible", "body": "As described in issue [#64999](https://github.com/llvm/llvm-project/issues/64999), commit [e018cbf7208](https://github.com/llvm/llvm-project/commit/e018cbf7208b3d34f18997ddee84c66cee32fb1b) caused the symbol __stack_chk_guard to not become dso_local when PIC is enabled in a module. However, during LTO we can force a static relocation model, which overrides the PIC level. In this case __stack_chk_guard should become dso_local.\r\nFor this purpose we're adding a boolean to the interface of getDirectAccessExternalData() to indicate the relocation model.\r\n\r\nFixes https://github.com/llvm/llvm-project/issues/64999", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/IR/Module.cpp", "functions": ["getPICLevel"]}]}
{"pr_number": 67594, "url": "https://github.com/llvm/llvm-project/pull/67594", "title": "[SCCP] [Transform] Adding ICMP folding for zext and sext in SCCPSolver", "body": "This PR fixes #55013 : the max intrinsics is not generated for this simple loop case : https://godbolt.org/z/hxz1xhMPh. This is caused by a ICMP not being folded into a select, thus not generating the max intrinsics. \r\n\r\nSince LLVM 14, SCCP pass got smarter by folding sext into zext for positive ranges : https://reviews.llvm.org/D81756. After this change, InstCombine was sometimes unable to fold icmp correctly as both of the arguments pointed to mismatched zext/sext. To fix this, @rotateright implemented this fix : https://reviews.llvm.org/D124419 that tries to resolve the mismatch by knowing if the argument of a zext is positive (in which case, it is like a sext) by using ValueTracking. However, ValueTracking seems to be not smart enough for this case and cannot accurately know that the value is positive or not. This PR implements the folding in SCCP directly, where we have the knowledge that the value are positive or not.\r\n\r\nThis PR also contains test cases for sext/zext folding with SCCP as well as a x86 regression tests for the max/min case. ", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CodeGen/X86/min_max.c", "functions": ["vecreduce_smin_v2i16", "vecreduce_smax_v2i16"]}]}
{"pr_number": 68860, "url": "https://github.com/llvm/llvm-project/pull/68860", "title": "[BasicBlockSections] Apply path cloning with -basic-block-sections.", "body": "https://github.com/llvm/llvm-project/commit/28b912687900bc0a67cd61c374fce296b09963c4 introduced the path cloning format in the basic-block-sections profile.\r\n\r\nThis PR validates and applies path clonings. \r\nA path cloning is valid if all of these conditions hold:\r\n  1. All bb ids in the path are mapped to existing blocks.\r\n  2. Each two consecutive bb ids in the path have a successor relationship in the CFG.\r\n  3. The path does not include a block with indirect branches, except possibly as the last block.\r\n \r\nApplying a path cloning involves cloning all blocks in the path (except the first one) and setting up their branches.\r\nOnce all clonings are applied, the cluster information is used to guide block layout in the modified function.", "feature_layers": ["ir", "ast"], "feature_directives": ["for", "sections"], "files_changed": [{"filename": "llvm/lib/CodeGen/BasicBlockPathCloning.cpp", "functions": ["getPassName"]}, {"filename": "llvm/lib/CodeGen/BasicBlockSections.cpp", "functions": ["hasInstrProfHashMismatch"]}, {"filename": "llvm/lib/CodeGen/BasicBlockSectionsProfileReader.cpp", "functions": ["getPathAndClusterInfoForFunction", "getClusterInfoForFunction"]}, {"filename": "llvm/lib/CodeGen/MIRParser/MIParser.cpp", "functions": ["error"]}]}
{"pr_number": 70246, "url": "https://github.com/llvm/llvm-project/pull/70246", "title": "[flang] Account for shadowed symbols when skimming executable part", "body": "Name resolution takes a quick pass over the executable part of a (sub)program in search of symbols that appear to be called as procedures, so that those names don't get mistakenly converted into objects when finishing up specification part processing.  This pass doesn't currently cope with symbol shadowing by nested declarations in executable constructs.  This patch ensures that nested declarations for symbols that could be used in contexts that might have been parsed as function references properly shadow symbols of the same name in outer scopes.", "feature_layers": ["parse"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Semantics/resolve-names.cpp", "functions": ["NoteExecutablePartCall", "PushScope", "Pre", "Post", "PopScope", "Hide"]}]}
{"pr_number": 70511, "url": "https://github.com/llvm/llvm-project/pull/70511", "title": "[flang] Fix mod file generation of derived type initializers...", "body": "... when the derived type used in the structure constructor(s) is from another module and not use-associated into the current module.\r\n\r\nThis came up in a test with a derived type component default initializer of \"c_null_ptr\", which is replaced with the expression \"__builtin_c_ptr(address=0_8)\"; the derived type name \"__builtin_c_ptr\" is not available in the current scope, and the module file would fail semantic analysis when USE'd.\r\n\r\nThe best solution that I found was to extend module file generation to detect this case and handle it by inserting the right USE association to the ultimate derived type symbol, possibly with renaming to a compiler-created name in the case of a conflict.\r\n\r\nTo implement this transformation, it was necessary to fix the utility evaluate::CollectSymbols() to include the derived type symbol from a structure constructor.  This involved extending the expression traversal framework to visit the derived type spec of a structure constructor. Extending CollectSymbols() caused a lowering test to fail mysteriously, so I tracked down the code in PFTBuilder that didn't expect to see a DerivedTypeDetails symbol and dealt with it there.", "feature_layers": ["sema"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Evaluate/formatting.cpp", "functions": ["DerivedTypeSpecAsFortran"]}, {"filename": "flang/lib/Semantics/mod-file.cpp", "functions": ["DEREF", "CollectSymbols"]}]}
{"pr_number": 69654, "url": "https://github.com/llvm/llvm-project/pull/69654", "title": "[ARMISelDAGToDAG] use MO_FrameIndex to represent FrameIndex rather than MO_Register for INLINEASM", "body": "Many other targets use stack slot indexes to represent memory locations.\nThis patch normalizes ARM to also use these kind of MachineOperands so\nthat register selection can find which stack slot is necessary to fold\nmemory operands when \"rm\" is used.\n\nA nice side effect of this change is that we're less likely to exhaust\nregisters for inline asm with many clobbers.\n\nLink: https://github.com/llvm/llvm-project/issues/20571#issuecomment-1771336576\n", "feature_layers": [], "feature_directives": ["for", "target"], "files_changed": [{"filename": "llvm/lib/Target/ARM/ARMAsmPrinter.cpp", "functions": ["F"]}, {"filename": "llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp", "functions": ["F"]}]}
{"pr_number": 70508, "url": "https://github.com/llvm/llvm-project/pull/70508", "title": "[NFC] Extract LoopConstrainer from IRCE to reuse it outside the pass", "body": "", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp", "functions": ["cloneLoop", "B", "addToParentLoopIfNeeded", "run", "Expander", "F", "DisableAllLoopOptsOnLoop"]}, {"filename": "llvm/lib/Transforms/Utils/LoopConstrainer.cpp", "functions": ["B", "Expander", "F", "DisableAllLoopOptsOnLoop"]}]}
{"pr_number": 66924, "url": "https://github.com/llvm/llvm-project/pull/66924", "title": "ISel: introduce vector ISD::LRINT, ISD::LLRINT; custom RISCV lowering", "body": "The issue #55208 noticed that std::rint is vectorized by the SLPVectorizer, but a very similar function, std::lrint, is not. std::lrint corresponds to ISD::LRINT in the SelectionDAG, and std::llrint is a familiar cousin corresponding to ISD::LLRINT. Now, neither ISD::LRINT nor ISD::LLRINT have a corresponding vector variant, and the LangRef makes this clear in the documentation of llvm.lrint.* and llvm.llrint.*.\r\n\r\nThis patch extends the LangRef to include vector variants of llvm.lrint.* and llvm.llrint.*, and lays the necessary ground-work of scalarizing it for all targets. However, this patch would be devoid of motivation unless we show the utility of these new vector variants. Hence, the RISCV target has been chosen to implement a custom lowering to the vfcvt.x.f.v instruction. The patch also includes a CostModel for RISCV, and a trivial follow-up can potentially enable the SLPVectorizer to vectorize std::lrint and std::llrint, fixing #55208.\r\n\r\nThe patch includes tests, obviously for the RISCV target, but also for the X86, AArch64, and PowerPC targets to justify the addition of the vector variants to the LangRef.", "feature_layers": [], "feature_directives": ["for", "target"], "files_changed": [{"filename": "llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp", "functions": ["visitXRINT", "SDValue"]}, {"filename": "llvm/lib/Target/RISCV/RISCVISelLowering.cpp", "functions": ["convertFromScalableVector", "DL", "lowerVectorXRINT"]}]}
{"pr_number": 70699, "url": "https://github.com/llvm/llvm-project/pull/70699", "title": "[flang] Accept directive sentinels in macro-replaced source better", "body": "At present, the prescanner emits an error if a source line or compiler directive, after macro replacement or not, contains a token with a non-Fortran character.  In the particular case of the '!' character, the code that checks for bad character will accept the '!' if it appears after a ';', since the '!' might begin a compiler directive.\r\n\r\nThis current implementation fails when a compiler directive appears after some other character that might (by means of further source processing not visible to the prescanner) be replaced with a ';' or newline.\r\n\r\nExtend the bad character check for '!' to actually check for a compiler directive sentinel instead.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Parser/prescan.cpp", "functions": ["IsCompilerDirectiveSentinel"]}]}
{"pr_number": 70750, "url": "https://github.com/llvm/llvm-project/pull/70750", "title": "[mlir][sparse] add helper class to implement common rewriter to re/demap sparse tensors.", "body": "", "feature_layers": ["parse", "ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/Transforms/SparseReinterpretMap.cpp", "functions": ["success", "reMappedOuts", "failure", "matchOp", "adaptor", "deMappedIns"]}]}
{"pr_number": 68506, "url": "https://github.com/llvm/llvm-project/pull/68506", "title": "[clang] __is_trivially_equality_comparable for types containing lambdas", "body": "Lambdas (closure types) are trivially equality-comparable iff they are\r\nnon-capturing, because non-capturing lambdas are convertible to function\r\npointers: if (lam1 == lam2) compiles, then lam1 and lam2 must have\r\nthe same type, and be always-equal, and be empty.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/SemaCXX/type-traits.cpp", "functions": ["GetNonCapturingLambda", "decltype"]}]}
{"pr_number": 70836, "url": "https://github.com/llvm/llvm-project/pull/70836", "title": "[IndVars] Use IRBuilder in eliminateTrunc [nfc-ish]", "body": "Mostly a cleanup so that we don't need to manually emit instructions, and can eagerly constant fold where relevant.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/Transforms/Utils/SimplifyIndVar.cpp", "functions": ["Builder"]}]}
{"pr_number": 70683, "url": "https://github.com/llvm/llvm-project/pull/70683", "title": "[OpenMP] Add optimization to remove the RPC client", "body": "Summary:\nPart of the work done in the `libc` project is to provide host services\nfor things like `printf` or `malloc`, or generally any syscall-like\nbehaviour. This scheme works by emitting an externally visible global\ncalled `__llvm_libc_rpc_client` that the host runtime can pick up to get\na handle to the global memory associated with the client. We use the\npresence of this symbol to indicate whether or not we need to run an RPC\nserver. Normally, this symbol is only present if something requiring an\nRPC server was linked in, such as `printf`. However, if this call to\n`printf` was subsequently optimizated out, the symbol would remain and\ncannot be removed (rightfully so) because of its linkage. This patch\nadds a special-case optimization to remove this symbol so we can\nindicate that an RPC server is no longer needed.\n\nThis patch puts this logic in `OpenMPOpt` as the most readily available\nplace for it. In the future, we should think how to move this somewhere\nmore generic. Furthermore, we use a hard-coded runtime name (which isn't\nuncommon given all the other magic symbol names). But it might be nice\nto abstract that part away.\n", "feature_layers": ["runtime", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/IPO/OpenMPOpt.cpp", "functions": ["removeRuntimeSymbols"]}]}
{"pr_number": 70724, "url": "https://github.com/llvm/llvm-project/pull/70724", "title": "[mlir][bytecode] Implements back deployment capability for MLIR dialects", "body": "When emitting bytecode, clients can specify a target dialect version to emit in `BytecodeWriterConfig`. This exposes a target dialect version to the DialectBytecodeWriter, which can be queried by name and used to back-deploy attributes, types, and properties.", "feature_layers": ["ir"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "mlir/lib/Bytecode/Writer/BytecodeWriter.cpp", "functions": ["failure"]}, {"filename": "mlir/lib/Bytecode/Writer/IRNumbering.cpp", "functions": ["state", "writer", "failure"]}, {"filename": "mlir/test/lib/IR/TestBytecodeRoundtrip.cpp", "functions": ["getArgument", "runTest6", "success", "registerTestBytecodeRoundtripPasses", "failure", "parseConfig", "registerTestBytecodeCallbackPasses", "initialize"]}, {"filename": "mlir/tools/mlir-opt/mlir-opt.cpp", "functions": ["registerTestBytecodeCallbackPasses", "registerTestBytecodeRoundtripPasses"]}]}
{"pr_number": 70863, "url": "https://github.com/llvm/llvm-project/pull/70863", "title": " [mlir][sparse] first proof-of-concept non-permutation rewriter", "body": "Rather than extending sparsifier codegen with higher order non-permutations, we follow the path of rewriting linalg generic ops into higher order operations. That way, code generation will simply work out of the box. This is a very first proof-of-concept rewriting of that idea.", "feature_layers": ["parse", "codegen", "ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/Transforms/SparseReinterpretMap.cpp", "functions": ["failure", "success"]}]}
{"pr_number": 69669, "url": "https://github.com/llvm/llvm-project/pull/69669", "title": "[libc++] Encode additional ODR-affecting properties in the ABI tag", "body": "As explained in `__config`, we have an ABI tag that we use to ensure that we don't run into ODR issues when mixing different versions of libc++ in multiple TUs. However, the reasoning behind that extends not only to different versions of libc++, but also to different configurations of the same version of libc++. In fact, we've been aware of this for a while but never really bothered to make the change because ODR issues are often thought to be benign.\r\n\r\nWell, it turns out that I just spent over an hour banging my head against an issue that boils down to our lack of encoding of some ODR properties in the ABI tag, so here's the patch we should have done a long time ago.\r\n\r\nFor now, the ODR properties we encode in the ABI tag are:\r\n- library version\r\n- exceptions vs no-exceptions\r\n- hardening mode\r\n\r\nThose are all things that we support different values for on a per-TU basis and they definitely affect ODR in a meaningful way. We can add more properties later as we see fit.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "libcxx/test/libcxx/odr_signature.exceptions.sh.cpp", "functions": ["tu2", "main", "tu1", "f"]}, {"filename": "libcxx/test/libcxx/odr_signature.hardening.sh.cpp", "functions": ["tu4", "main", "tu1", "f", "tu2", "tu3"]}]}
{"pr_number": 70700, "url": "https://github.com/llvm/llvm-project/pull/70700", "title": "Metadata: Optimize metadata queries", "body": " Optimize metadata query code:\r\n- Avoid `DenseMap::operator[]` in situations where it is known that the key exists in the map. Instead use `DenseMap::at()`/ `DenseMap::find()->second`. This avoids code-bloat and bad inlining decisions for the unused insertion/growing code in `operator[]`.\r\n- Directly query the map in `Instruction::getMetadataImpl` instead of using `Value::getMetadata` to avoid a redundant `hasMetadata()` check.\r\n- Move the `KindID == LLVMContext::MD_dbg` case to `Instruction::getMetadata` and check it first assuming that it can be constant folded after inlining in many situations.\r\n\r\nThe motivation for this change is a regression triggered by e3cf80c5c1fe55efd8216575ccadea0ab087e79c which could attributed to the compiler inlining the insertion part of `DenseMap::operator[]` in more cases while unbeknownst to a  compiler (without PGO) that code is never used in this context. This change improves performance and eliminates difference before and after that change in my measurements.", "feature_layers": ["sema", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/IR/Metadata.cpp", "functions": ["getValueMetadata", "getMetadataImpl"]}]}
{"pr_number": 70617, "url": "https://github.com/llvm/llvm-project/pull/70617", "title": "[mlir][Interfaces] Add `SubsetOpInterface` and `SubsetExtractionOpInterface`", "body": "There is currently an op interface for subset insertion ops (`SubsetInsertionOpInterface`), but not for subset extraction ops. This commit adds `SubsetExtractionOpInterface` to `mlir/Interfaces`, as well as a common dependent op interface: `SubsetOpInterface`.\r\n\r\n- `SubsetOpInterface` is for ops that operate on tensor subsets. It provides interface methods to check if two subset ops operate on equivalent or disjoint subsets. Ops that implement this interface must implement either `SubsetExtractionOpInterface` or `SubsetInsertionOpInterface`.\r\n- `SubsetExtractionOpInterface` is for ops that extract from a tensor at a subset. E.g., `tensor.extract_slice`, `tensor.gather`, `vector.transfer_read`. Current implemented only on `tensor.extract_slice`.\r\n- `SubsetInsertionOpInterface` is for ops that insert into a destination tensor at a subset. E.g., `tensor.insert_slice`, `tensor.parallel_insert_slice`, `tensor.scatter`, `vector.transfer_write`. Currently only implemented on `tensor.insert_slice`, `tensor.parallel_insert_slice`.\r\n\r\nOther changes:\r\n- Rename `SubsetInsertionOpInterface.td` to `SubsetOpInterface.td`.\r\n- Add helper functions to `ValueBoundsOpInterface.cpp` for checking whether two slices are disjoint.\r\n\r\nThe new interfaces will be utilized by a new \"loop-invariant subset hoisting\"\r\ntransformation. (This new transform is roughly\r\nwhat `Linalg/Transforms/SubsetHoisting.cpp` is doing, but in a generic\r\nand interface-driven way.)\r\n", "feature_layers": ["ir"], "feature_directives": ["parallel", "for"], "files_changed": [{"filename": "mlir/lib/Dialect/Linalg/Transforms/SubsetInsertionOpInterfaceImpl.cpp", "functions": ["equivalenceFn"]}, {"filename": "mlir/lib/Dialect/Tensor/Transforms/SubsetInsertionOpInterfaceImpl.cpp", "functions": ["getContainerOperand", "operateOnDisjointSubsets", "operateOnEquivalentSubsets"]}, {"filename": "mlir/lib/Interfaces/SubsetOpInterface.cpp", "functions": ["success"]}, {"filename": "mlir/lib/Interfaces/ValueBoundsOpInterface.cpp", "functions": ["failure", "computeConstantBound", "b"]}]}
{"pr_number": 70063, "url": "https://github.com/llvm/llvm-project/pull/70063", "title": "[mlir][tosa] fix a crash when sliceOp has invalid attribute (#68486)", "body": "add a verifier for tosa::sliceOp", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Tosa/IR/TosaOps.cpp", "functions": ["success"]}]}
{"pr_number": 70619, "url": "https://github.com/llvm/llvm-project/pull/70619", "title": "[mlir][Transforms] Add loop-invariant subset hoisting (LISH) transformation", "body": "Add a loop-invariant subset hoisting pass to `mlir/Interfaces`. This pass hoist loop-invariant tensor subsets (subset extraction and subset insertion ops) from loop-like ops. Extraction ops are moved before the loop. Insertion ops are moved after the loop. The loop body operates on newly added region iter_args (one per extraction-insertion pair).\r\n\r\nThis new pass will be improved in subsequent commits (to support more cases/ops) and will eventually replace `Linalg/Transforms/SubsetHoisting.cpp`. In contrast to the existing Linalg subset hoisting, the new pass is op interface-based (`SubsetOpInterface` and `LoopLikeOpInterface`).\r\n\r\n", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Transforms/LoopInvariantCodeMotion.cpp", "functions": ["runOnOperation"]}, {"filename": "mlir/lib/Transforms/Utils/LoopInvariantCodeMotionUtils.cpp", "functions": ["getHoistableSubsetOps", "insertInsertionOp", "insertExtractionOp", "rewriter", "isEquivalent", "allDisjoint", "insert"]}]}
{"pr_number": 70623, "url": "https://github.com/llvm/llvm-project/pull/70623", "title": "[mlir][Transforms] LISH: Improve bypass analysis for loop-like ops", "body": "Improve the bypass analysis for loop-like ops. Until now, loop-like ops were treated like any other non-subset ops: they prevent hoisting of any sort because the analysis does not know which parts of a tensor init operand are accessed by the loop-like op. With this change, the analysis can look into loop-like ops and analyze which subset they are operating on.\r\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Transforms/Utils/LoopInvariantCodeMotionUtils.cpp", "functions": ["failure", "success", "insert", "rewriter"]}]}
{"pr_number": 70628, "url": "https://github.com/llvm/llvm-project/pull/70628", "title": "[mlir][Interfaces] LISH: Add helpers for hyperrectangular subsets", "body": "The majority of subset ops operate on hyperrectangular subsets. This commit adds a new optional interface method (`getAccessedHyperrectangularSlice`) that can be implemented by such subset ops. If implemented, the other `operatesOn...` interface methods of the `SubsetOpInterface` do not have to be implemented anymore.\r\n\r\nThe comparison logic for hyperrectangular subsets (is disjoint/equivalent) is implemented with `ValueBoundsOpInterface`. This makes the subset hoisting more powerful: simple cases where two different SSA values always have the same runtime value can now be supported.\r\n ", "feature_layers": ["runtime", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Tensor/Transforms/SubsetInsertionOpInterfaceImpl.cpp", "functions": ["HyperrectangularSlice", "getContainerOperand", "operateOnDisjointSubsets", "operateOnEquivalentSubsets"]}, {"filename": "mlir/lib/Interfaces/SubsetOpInterface.cpp", "functions": ["succeeded"]}, {"filename": "mlir/lib/Interfaces/ValueBoundsOpInterface.cpp", "functions": ["mixedOffsets", "failure", "HyperrectangularSlice", "b"]}]}
{"pr_number": 70629, "url": "https://github.com/llvm/llvm-project/pull/70629", "title": "[mlir][vector] LISH: Implement `SubsetOpInterface` for transfer_read/write", "body": "- Implement `SubsetOpInterface`, `SubsetExtractionOpInterface`, `SubsetInsertionOpInterface` for `vector.transfer_read` and `vector.transfer_write`.\r\n- Move all tensor subset hoisting test cases from `Linalg` to `loop-invariant-subset-hoisting.mlir`. (Removing 1 duplicate test case.)\r\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Vector/Transforms/SubsetOpInterfaceImpl.cpp", "functions": ["HyperrectangularSlice", "b", "Value"]}]}
{"pr_number": 70351, "url": "https://github.com/llvm/llvm-project/pull/70351", "title": "[lldb/Target] Delay image loading after corefile process creation", "body": "This patch is a follow-up to db223b7f01f7. Similarly to it, it changes the timing of binary image loading for the ProcessMachCore plugin.\r\n\r\nThis issue came up after getting reports of scripting resources that would fail to execute because they relied on data provided by the corefile process (i.e. for reading memory). However, rior to this change, the scripting resource loading would happen as part of the binary image loading, which in turns happened before the process finished being created.\r\n\r\nThis patch address that issue by delaying the binary image loading phase until we receive the corefile process stop event event, ensuring that the process is fully formed.", "feature_layers": [], "feature_directives": ["for", "target"], "files_changed": [{"filename": "lldb/test/API/functionalities/script-resource-loading/main.cpp", "functions": ["foo", "main"]}]}
{"pr_number": 70806, "url": "https://github.com/llvm/llvm-project/pull/70806", "title": "[llvm-c] Improve TargetMachine bindings", "body": "This PR exposes four APIs for `TargetMachine`:\r\n```\r\n/** Enable fast-path instruction selection. */\r\nvoid LLVMSetTargetMachineFastISel(LLVMTargetMachineRef T, LLVMBool Enable);\r\n\r\n/** Enable global instruction selection. */\r\nvoid LLVMSetTargetMachineGlobalISel(LLVMTargetMachineRef T, LLVMBool Enable);\r\n\r\n/** Set abort behaviour when global instruction selection fails to lower/select\r\n * an instruction. */\r\nvoid LLVMSetTargetMachineGlobalISelAbort(LLVMTargetMachineRef T,\r\n                                         LLVMGlobalISelAbortMode Mode);\r\n\r\n/** Enable the MachineOutliner pass. */\r\nvoid LLVMSetTargetMachineMachineOutliner(LLVMTargetMachineRef T,\r\n                                         LLVMBool Enable);\r\n```\r\n\r\nFixes #70666.\r\n", "feature_layers": ["ast"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "llvm/bindings/ocaml/target/target_ocaml.c", "functions": ["llvm_targetmachine_set_machine_outliner", "llvm_targetmachine_set_global_isel", "llvm_targetmachine_set_fast_isel", "llvm_targetmachine_set_global_isel_abort"]}, {"filename": "llvm/lib/Target/TargetMachineC.cpp", "functions": ["LLVMSetTargetMachineFastISel", "LLVMSetTargetMachineGlobalISel"]}]}
{"pr_number": 70355, "url": "https://github.com/llvm/llvm-project/pull/70355", "title": "[Clang][RISCV] Add vcreate intrinsics for RVV non-tuple types", "body": "riscv-non-isa/rvv-intrinsic-doc#288", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CodeGen/RISCV/rvv-intrinsics-autogenerated/non-policy/non-overloaded/vcreate.c", "functions": ["__riscv_vcreate_v_u32m2_u32m4", "test_vcreate_v_i16m1x8", "test_vcreate_v_f32m2x4", "test_vcreate_v_f16m1x8", "test_vcreate_v_i8mf8x7", "test_vcreate_v_u64m1x4", "__riscv_vcreate_v_i8m4_i8m8", "test_vcreate_v_i64m1x6", "test_vcreate_v_f16mf4x4", "test_vcreate_v_u64m1x6", "test_vcreate_v_u32mf2x5", "test_vcreate_v_u16mf4x7", "test_vcreate_v_i64m1_i64m2", "test_vcreate_v_i32mf2x4", "__riscv_vcreate_v_u8m1_u8m4", "test_vcreate_v_u16m4_u16m8", "test_vcreate_v_u8mf4x7", "test_vcreate_v_f64m1x5", "test_vcreate_v_i8mf2x4", "test_vcreate_v_i8mf8x5", "test_vcreate_v_i16m1_i16m2", "test_vcreate_v_i16m1x3", "test_vcreate_v_u8m1x3", "test_vcreate_v_i32mf2x3", "__riscv_vcreate_v_i32m1_i32m8", "test_vcreate_v_f32mf2x6", "test_vcreate_v_i16mf4x5", "__riscv_vcreate_v_i8m1_i8m8", "test_vcreate_v_i8m1_i8m2", "test_vcreate_v_u8mf4x8", "__riscv_vcreate_v_i64m1_i64m4", "test_vcreate_v_f32m1x8", "test_vcreate_v_u32m1x6", "test_vcreate_v_i32mf2x8", "test_vcreate_v_i16mf4x3", "test_vcreate_v_u8mf4x3", "test_vcreate_v_u8mf4x5", "test_vcreate_v_f32m1x6", "test_vcreate_v_f64m1x8", "test_vcreate_v_i8mf4x3", "test_vcreate_v_f16m4_f16m8", "test_vcreate_v_i8mf2x6", "test_vcreate_v_i64m1x3", "test_vcreate_v_f32m1x3", "test_vcreate_v_i64m1x8", "test_vcreate_v_u8mf2x8", "test_vcreate_v_f32m1_f32m2", "test_vcreate_v_i64m1x7", "__riscv_vcreate_v_i16m4_i16m8", "test_vcreate_v_u8m2x4", "__riscv_vcreate_v_u64m2_u64m4", "test_vcreate_v_i8mf4x4", "test_vcreate_v_i16m2x4", "__riscv_vcreate_v_i8m1_i8m4", "test_vcreate_v_f16m2_f16m4", "test_vcreate_v_i8mf8x6", "test_vcreate_v_i32m1x4", "test_vcreate_v_u64m1_u64m2", "test_vcreate_v_i16mf4x4", "__riscv_vcreate_v_f16m1_f16m2", "test_vcreate_v_i8m2_i8m4", "test_vcreate_v_f16mf4x6", "test_vcreate_v_i16m2x3", "test_vcreate_v_u16mf2x4", "test_vcreate_v_f16mf2x3", "test_vcreate_v_i32m1x6", "test_vcreate_v_i8mf2x7", "__riscv_vcreate_v_f16m1_f16m8", "__riscv_vcreate_v_f64m1_f64m4", "test_vcreate_v_u8mf8x5", "test_vcreate_v_f64m4_f64m8", "__riscv_vcreate_v_u8m2_u8m8", "test_vcreate_v_u8mf8x8", "test_vcreate_v_u16m1x7", "__riscv_vcreate_v_i32m4_i32m8", "test_vcreate_v_f16m1x3", "test_vcreate_v_i32mf2x6", "test_vcreate_v_f64m2x4", "__riscv_vcreate_v_u32m1_u32m2", "__riscv_vcreate_v_i8m2_i8m8", "test_vcreate_v_i32m1_i32m2", "test_vcreate_v_i64m4_i64m8", "__riscv_vcreate_v_i16m2_i16m8", "test_vcreate_v_i16m1x4", "test_vcreate_v_u8mf2x7", "__riscv_vcreate_v_f32m1_f32m4", "test_vcreate_v_u32m4_u32m8", "test_vcreate_v_f32mf2x5", "test_vcreate_v_i64m2x4", "__riscv_vcreate_v_f64m1_f64m8", "test_vcreate_v_f16mf4x7", "__riscv_vcreate_v_u16m1_u16m8", "test_vcreate_v_u32mf2x7", "test_vcreate_v_u32m1_u32m2", "test_vcreate_v_i64m1x4", "test_vcreate_v_i8m1x6", "test_vcreate_v_i8m4_i8m8", "test_vcreate_v_f64m1x7", "test_vcreate_v_u8m1x7", "test_vcreate_v_u32m1x4", "test_vcreate_v_u32m1x8", "test_vcreate_v_f16m1x5", "test_vcreate_v_u16mf2x5", "__riscv_vcreate_v_i16m1_i16m4", "test_vcreate_v_i16mf2x7", "test_vcreate_v_f16m1_f16m2", "__riscv_vcreate_v_f64m2_f64m8", "test_vcreate_v_u8m1x6", "test_vcreate_v_u8m2_u8m4", "test_vcreate_v_u8m1x5", "test_vcreate_v_f16mf4x5", "test_vcreate_v_f16mf2x7", "test_vcreate_v_f64m1_f64m2", "test_vcreate_v_i16m4_i16m8", "test_vcreate_v_i64m2_i64m4", "test_vcreate_v_u8m1_u8m2", "test_vcreate_v_f16m1x6", "test_vcreate_v_i8mf4x8", "__riscv_vcreate_v_f16m2_f16m8", "test_vcreate_v_u8mf8x3", "test_vcreate_v_u8m1x8", "test_vcreate_v_i8mf4x5", "__riscv_vcreate_v_u16m2_u16m8", "__riscv_vcreate_v_u32m1_u32m8", "test_vcreate_v_f32mf2x8", "test_vcreate_v_f16mf2x8", "test_vcreate_v_u16mf2x3", "test_vcreate_v_u16mf4x8", "test_vcreate_v_u32m1x3", "__riscv_vcreate_v_u16m2_u16m4", "test_vcreate_v_f16m2x3", "test_vcreate_v_i8m2x4", "__riscv_vcreate_v_f32m1_f32m8", "test_vcreate_v_f32m1x5", "test_vcreate_v_i8mf2x8", "__riscv_vcreate_v_i16m2_i16m4", "test_vcreate_v_f32mf2x7", "test_vcreate_v_f16mf4x3", "test_vcreate_v_i8m1x8", "test_vcreate_v_u8mf4x4", "test_vcreate_v_i8mf2x5", "test_vcreate_v_i32m2x4", "test_vcreate_v_u8mf2x6", "test_vcreate_v_u8m2x3", "test_vcreate_v_i16m1x6", "test_vcreate_v_u32m2_u32m4", "test_vcreate_v_u32mf2x4", "test_vcreate_v_f32m1x4", "test_vcreate_v_i64m1x5", "test_vcreate_v_u64m1x3", "test_vcreate_v_i16mf2x5", "test_vcreate_v_f32m2x3", "test_vcreate_v_f32mf2x3", "test_vcreate_v_i32m2x3", "test_vcreate_v_u32m2x4", "__riscv_vcreate_v_i64m2_i64m8", "test_vcreate_v_i16mf2x6", "test_vcreate_v_u16m1x3", "test_vcreate_v_u64m1x8", "test_vcreate_v_f16m2x4", "__riscv_vcreate_v_f64m4_f64m8", "test_vcreate_v_i32mf2x5", "test_vcreate_v_f32m1x7", "__riscv_vcreate_v_u8m4_u8m8", "test_vcreate_v_u16m2x3", "test_vcreate_v_i8m1x5", "__riscv_vcreate_v_f16m1_f16m4", "__riscv_vcreate_v_i8m1_i8m2", "__riscv_vcreate_v_i16m1_i16m8", "test_vcreate_v_f16m1x7", "test_vcreate_v_f64m1x3", "test_vcreate_v_u32mf2x6", "test_vcreate_v_i32m1x8", "test_vcreate_v_u16mf2x6", "test_vcreate_v_i16mf4x7", "__riscv_vcreate_v_u16m4_u16m8", "test_vcreate_v_u16m1x5", "test_vcreate_v_f64m1x4", "test_vcreate_v_i8mf8x4", "test_vcreate_v_u8mf4x6", "test_vcreate_v_u8m1x4", "test_vcreate_v_f32m2_f32m4", "__riscv_vcreate_v_i64m1_i64m8", "test_vcreate_v_u8mf2x4", "__riscv_vcreate_v_f16m4_f16m8", "__riscv_vcreate_v_u64m2_u64m8", "test_vcreate_v_f16mf2x6", "test_vcreate_v_i16mf4x8", "__riscv_vcreate_v_u16m1_u16m2", "test_vcreate_v_i16m1x5", "__riscv_vcreate_v_i64m1_i64m2", "__riscv_vcreate_v_i8m2_i8m4", "test_vcreate_v_u16m1_u16m2", "test_vcreate_v_f64m1x6", "__riscv_vcreate_v_u16m1_u16m4", "test_vcreate_v_u16mf2x7", "__riscv_vcreate_v_f64m1_f64m2", "test_vcreate_v_f16mf4x8", "__riscv_vcreate_v_u32m2_u32m8", "test_vcreate_v_i8mf4x7", "test_vcreate_v_u64m2x4", "__riscv_vcreate_v_u8m1_u8m8", "test_vcreate_v_i8mf8x3", "test_vcreate_v_u16m2x4", "test_vcreate_v_u64m1x5", "test_vcreate_v_f64m2x3", "test_vcreate_v_i16mf4x6", "test_vcreate_v_u8mf8x4", "test_vcreate_v_i8mf4x6", "test_vcreate_v_u16m2_u16m4", "test_vcreate_v_i32m2_i32m4", "__riscv_vcreate_v_u32m4_u32m8", "test_vcreate_v_i32mf2x7", "__riscv_vcreate_v_f32m4_f32m8", "__riscv_vcreate_v_u64m1_u64m2", "test_vcreate_v_i8mf2x3", "__riscv_vcreate_v_i32m2_i32m4", "__riscv_vcreate_v_f64m2_f64m4", "test_vcreate_v_u16mf4x5", "test_vcreate_v_u64m2x3", "__riscv_vcreate_v_u64m4_u64m8", "test_vcreate_v_u16mf4x3", "__riscv_vcreate_v_u8m2_u8m4", "test_vcreate_v_u64m1x7", "test_vcreate_v_u16mf2x8", "test_vcreate_v_u32m1x7", "__riscv_vcreate_v_i64m2_i64m4", "test_vcreate_v_u8mf2x3", "__riscv_vcreate_v_f16m2_f16m4", "test_vcreate_v_f64m2_f64m4", "test_vcreate_v_i8mf8x8", "test_vcreate_v_i32m1x7", "__riscv_vcreate_v_i16m1_i16m2", "test_vcreate_v_u8m4_u8m8", "test_vcreate_v_u16m1x8", "test_vcreate_v_i64m2x3", "__riscv_vcreate_v_f32m1_f32m2", "test_vcreate_v_u16mf4x4", "__riscv_vcreate_v_f32m2_f32m8", "test_vcreate_v_u16mf4x6", "test_vcreate_v_i16m2_i16m4", "__riscv_vcreate_v_f32m2_f32m4", "test_vcreate_v_i16mf2x4", "test_vcreate_v_u8mf8x7", "test_vcreate_v_f32mf2x4", "test_vcreate_v_u16m1x6", "test_vcreate_v_i32m4_i32m8", "test_vcreate_v_f32m4_f32m8", "test_vcreate_v_i16mf2x8", "test_vcreate_v_u32mf2x8", "test_vcreate_v_u64m4_u64m8", "__riscv_vcreate_v_i64m4_i64m8", "test_vcreate_v_i16mf2x3", "__riscv_vcreate_v_u64m1_u64m4", "__riscv_vcreate_v_i32m1_i32m4", "test_vcreate_v_u8mf8x6", "__riscv_vcreate_v_u8m1_u8m2", "test_vcreate_v_i32m1x3", "__riscv_vcreate_v_u64m1_u64m8", "__riscv_vcreate_v_u32m1_u32m4", "test_vcreate_v_i8m1x7", "__riscv_vcreate_v_i32m1_i32m2", "test_vcreate_v_i32m1x5", "test_vcreate_v_f16m1x4", "test_vcreate_v_u32m2x3", "test_vcreate_v_u64m2_u64m4", "__riscv_vcreate_v_i32m2_i32m8", "test_vcreate_v_f16mf2x5", "test_vcreate_v_u16m1x4", "test_vcreate_v_i16m1x7", "test_vcreate_v_u32mf2x3", "test_vcreate_v_u8mf2x5", "test_vcreate_v_u32m1x5", "test_vcreate_v_f16mf2x4", "test_vcreate_v_i8m1x4"]}]}
{"pr_number": 70354, "url": "https://github.com/llvm/llvm-project/pull/70354", "title": "[Clang][RISCV] Add vundefine intrinsics for tuple types", "body": "riscv-non-isa/rvv-intrinsic-doc#288", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CodeGen/RISCV/rvv-intrinsics-autogenerated/non-policy/non-overloaded/vundefined.c", "functions": ["test_vundefined_i16mf2x3", "__riscv_vundefined_u16m8", "test_vundefined_i64m1x5", "__riscv_vundefined_u32mf2x5", "test_vundefined_u64m4", "test_vundefined_f32m1x2", "test_vundefined_i16m4", "test_vundefined_i8mf8x2", "test_vundefined_i32m1x8", "test_vundefined_u64m1x5", "test_vundefined_i64m1x4", "test_vundefined_u64m2x4", "__riscv_vundefined_u8m4", "test_vundefined_u8m8", "test_vundefined_i32m1x5", "__riscv_vundefined_f16mf4x5", "__riscv_vundefined_f32mf2x2", "test_vundefined_u8mf2x4", "test_vundefined_i8mf4x2", "__riscv_vundefined_u16mf2x5", "test_vundefined_f16mf2x4", "test_vundefined_u16mf4x8", "__riscv_vundefined_f64m1x7", "test_vundefined_u16mf2x4", "test_vundefined_f32m2x4", "test_vundefined_i32mf2x4", "__riscv_vundefined_i16mf2x7", "__riscv_vundefined_u16mf2x3", "test_vundefined_i8m1x8", "test_vundefined_u16m2x2", "test_vundefined_u64m8", "__riscv_vundefined_i16mf2x4", "test_vundefined_u8m2x3", "test_vundefined_i16mf4x7", "test_vundefined_i16m1x7", "test_vundefined_u32mf2x7", "test_vundefined_i8mf2x8", "__riscv_vundefined_i16mf4x7", "__riscv_vundefined_f64m2", "test_vundefined_u32mf2x8", "test_vundefined_i8m1x3", "__riscv_vundefined_f32m4", "test_vundefined_i16mf2x2", "test_vundefined_i16m4x2", "test_vundefined_f32mf2x8", "__riscv_vundefined_f32m1", "test_vundefined_u8mf4x5", "test_vundefined_f16m4x2", "__riscv_vundefined_i32mf2x5", "__riscv_vundefined_f16mf4", "test_vundefined_u16m8", "test_vundefined_u8m1x5", "test_vundefined_i8mf8x3", "test_vundefined_f64m1x2", "__riscv_vundefined_i16m4", "test_vundefined_i64m1x6", "__riscv_vundefined_f16mf2x6", "test_vundefined_f64m1x8", "test_vundefined_u16m2", "__riscv_vundefined_u64m4", "__riscv_vundefined_i64m4", "test_vundefined_f32m1x6", "test_vundefined_i8mf4x6", "__riscv_vundefined_f16mf2x5", "__riscv_vundefined_f32m1x7", "__riscv_vundefined_u16mf4x2", "test_vundefined_i32m1x2", "test_vundefined_u16m1", "test_vundefined_u16mf2x2", "test_vundefined_i8mf4x4", "test_vundefined_f32mf2", "test_vundefined_u32mf2x3", "__riscv_vundefined_u64m8", "test_vundefined_u32m1x7", "test_vundefined_f16m1x2", "test_vundefined_f16m1x5", "__riscv_vundefined_i16mf2x2", "__riscv_vundefined_u32mf2", "__riscv_vundefined_u16mf2x7", "test_vundefined_u8mf2x2", "test_vundefined_u32m4x2", "__riscv_vundefined_f16mf2x2", "__riscv_vundefined_u64m2", "test_vundefined_i64m1", "__riscv_vundefined_u16mf4x3", "test_vundefined_u16m1x2", "__riscv_vundefined_f64m4x2", "__riscv_vundefined_f16mf4x4", "test_vundefined_i8m1", "test_vundefined_f64m2x4", "__riscv_vundefined_i64m2", "test_vundefined_u32mf2", "__riscv_vundefined_u32mf2x6", "__riscv_vundefined_u16mf4x6", "__riscv_vundefined_f16m1x8", "test_vundefined_i8m1x2", "__riscv_vundefined_u16mf4", "__riscv_vundefined_f16mf2x8", "test_vundefined_f32m2x2", "test_vundefined_f64m1x4", "test_vundefined_i32m8", "test_vundefined_f16m2x4", "__riscv_vundefined_u32m8", "test_vundefined_i8m2x4", "__riscv_vundefined_i16mf2x6", "test_vundefined_i8mf4", "test_vundefined_i64m2x3", "test_vundefined_i32mf2x2", "__riscv_vundefined_f16mf4x2", "__riscv_vundefined_f32mf2x3", "test_vundefined_u32mf2x5", "test_vundefined_i64m2", "test_vundefined_u64m1x6", "test_vundefined_i64m1x7", "test_vundefined_i16mf4", "__riscv_vundefined_f16m2x3", "test_vundefined_i32m2x3", "test_vundefined_i16mf2x8", "test_vundefined_f32m8", "test_vundefined_i8m4", "test_vundefined_u8mf4x6", "__riscv_vundefined_f32m4x2", "__riscv_vundefined_i32mf2x4", "__riscv_vundefined_i32mf2x7", "__riscv_vundefined_f16m4", "__riscv_vundefined_i16mf2x5", "test_vundefined_u8m1x7", "test_vundefined_u16m1x6", "__riscv_vundefined_i32m4", "test_vundefined_f16mf4x2", "test_vundefined_u16m1x5", "test_vundefined_f32m1x7", "__riscv_vundefined_u32m4", "__riscv_vundefined_f16mf2x4", "test_vundefined_i8mf4x8", "test_vundefined_i8mf2", "__riscv_vundefined_u8m8", "test_vundefined_i8m8", "test_vundefined_i64m4x2", "__riscv_vundefined_i16mf4x5", "test_vundefined_f32m1x8", "__riscv_vundefined_i8m4", "test_vundefined_i64m1x3", "test_vundefined_i8m1x5", "test_vundefined_i16m2x3", "test_vundefined_i8mf2x3", "__riscv_vundefined_f32m8", "test_vundefined_f16mf4x3", "__riscv_vundefined_f64m1", "__riscv_vundefined_i8m8", "__riscv_vundefined_u16mf2x8", "test_vundefined_f16mf4x6", "test_vundefined_f16m2x3", "test_vundefined_u8mf2x6", "__riscv_vundefined_u8m1", "test_vundefined_f16m1x7", "__riscv_vundefined_f32mf2x7", "test_vundefined_f16mf2x5", "__riscv_vundefined_f16mf2x3", "__riscv_vundefined_f64m1x2", "test_vundefined_u16mf4x3", "test_vundefined_f16m1", "test_vundefined_f32mf2x7", "test_vundefined_f64m1x3", "test_vundefined_i32mf2x6", "test_vundefined_u32mf2x2", "__riscv_vundefined_f64m1x3", "test_vundefined_i8mf2x2", "test_vundefined_u32m2x4", "test_vundefined_u8mf4x3", "__riscv_vundefined_u8mf4", "__riscv_vundefined_i32m2", "test_vundefined_f32m1x5", "test_vundefined_u8mf2x7", "__riscv_vundefined_f64m1x4", "__riscv_vundefined_i16mf4", "test_vundefined_i8mf4x5", "test_vundefined_u64m2x3", "__riscv_vundefined_u32mf2x8", "__riscv_vundefined_i16m2", "__riscv_vundefined_i64m1", "__riscv_vundefined_f64m1x5", "test_vundefined_u8mf2x3", "test_vundefined_i16m1x5", "__riscv_vundefined_u32mf2x4", "test_vundefined_i8m2", "test_vundefined_i8mf2x4", "test_vundefined_f32m1", "__riscv_vundefined_f16m2x4", "test_vundefined_f64m2x2", "test_vundefined_f16m2", "__riscv_vundefined_u32mf2x3", "test_vundefined_u8m4x2", "test_vundefined_i32mf2x3", "test_vundefined_u32m1x4", "test_vundefined_u8mf8x4", "test_vundefined_u16m4x2", "test_vundefined_i16mf2x5", "test_vundefined_i16m1x2", "__riscv_vundefined_f16m1", "test_vundefined_u8m1x8", "__riscv_vundefined_f32m1x4", "__riscv_vundefined_f16mf4x8", "__riscv_vundefined_i8mf2", "__riscv_vundefined_u8mf8", "test_vundefined_f32mf2x5", "test_vundefined_f16m1x3", "test_vundefined_f16mf2x7", "test_vundefined_f16mf4x4", "test_vundefined_u32m2x2", "test_vundefined_i8m2x2", "test_vundefined_u16m1x4", "test_vundefined_i32mf2x7", "test_vundefined_i8m1x7", "test_vundefined_u8mf4x7", "test_vundefined_u32mf2x6", "test_vundefined_i32m4x2", "test_vundefined_f32m1x3", "test_vundefined_u8m4", "test_vundefined_f64m4", "test_vundefined_f32m1x4", "test_vundefined_u16mf2x6", "__riscv_vundefined_f32m2x4", "test_vundefined_f16mf2x3", "__riscv_vundefined_f32m2x3", "test_vundefined_f16mf4x7", "test_vundefined_f64m8", "__riscv_vundefined_f16mf2", "__riscv_vundefined_i8m2", "__riscv_vundefined_f64m1x6", "__riscv_vundefined_u64m1", "test_vundefined_u16mf4x7", "test_vundefined_u16m2x4", "__riscv_vundefined_f32mf2x5", "__riscv_vundefined_u32m2", "__riscv_vundefined_f32mf2x6", "__riscv_vundefined_u16mf2", "test_vundefined_i16m2x4", "__riscv_vundefined_i16mf2x8", "test_vundefined_i32m2x2", "test_vundefined_u16mf2x8", "test_vundefined_i8m1x6", "test_vundefined_u32m1x3", "__riscv_vundefined_f16m1x4", "__riscv_vundefined_u16mf4x5", "__riscv_vundefined_i32mf2x8", "__riscv_vundefined_i16mf2x3", "__riscv_vundefined_f16mf4x3", "test_vundefined_u8mf2x8", "__riscv_vundefined_i32mf2x6", "test_vundefined_u16mf4x5", "__riscv_vundefined_f64m8", "test_vundefined_f32mf2x2", "test_vundefined_u8mf8x6", "test_vundefined_u64m1x3", "test_vundefined_f16mf4x8", "test_vundefined_u16mf4x6", "test_vundefined_u8m2x4", "__riscv_vundefined_f64m2x2", "test_vundefined_u8mf8x5", "__riscv_vundefined_f64m4", "test_vundefined_f32mf2x4", "test_vundefined_i16mf2x4", "test_vundefined_i16m8", "test_vundefined_u8m2", "test_vundefined_i32m1x3", "__riscv_vundefined_f16m1x5", "__riscv_vundefined_f16mf2x7", "__riscv_vundefined_f16m1x7", "__riscv_vundefined_u32mf2x2", "test_vundefined_i8mf8", "__riscv_vundefined_u32m1", "test_vundefined_i16m2", "test_vundefined_i16mf4x2", "test_vundefined_i32mf2", "test_vundefined_u8mf8x8", "test_vundefined_i8mf4x7", "test_vundefined_u64m2x2", "__riscv_vundefined_u16m1", "test_vundefined_u16m1x7", "test_vundefined_u8m1x4", "test_vundefined_u64m1x7", "__riscv_vundefined_f32m2x2", "test_vundefined_u16mf4", "__riscv_vundefined_f32m1x6", "test_vundefined_f64m4x2", "test_vundefined_u32m1x5", "test_vundefined_u32m1x2", "__riscv_vundefined_u16m2", "test_vundefined_i16mf4x4", "__riscv_vundefined_f64m2x4", "test_vundefined_i8mf2x7", "test_vundefined_f16mf4", "test_vundefined_f16m1x6", "__riscv_vundefined_i32mf2", "test_vundefined_u16m2x3", "test_vundefined_i8mf8x6", "__riscv_vundefined_u16mf2x2", "test_vundefined_u8mf4x8", "test_vundefined_u8mf8x2", "__riscv_vundefined_f16m4x2", "test_vundefined_i32m1x4", "test_vundefined_u8mf4x4", "__riscv_vundefined_i8m1", "test_vundefined_i8mf8x7", "__riscv_vundefined_f32mf2", "__riscv_vundefined_f16m1x3", "test_vundefined_f16mf2", "test_vundefined_i64m1x8", "__riscv_vundefined_i16mf4x2", "test_vundefined_i16m1x6", "test_vundefined_i16mf4x3", "test_vundefined_u64m2", "test_vundefined_f64m1x6", "__riscv_vundefined_i16mf4x6", "test_vundefined_u8m1x2", "__riscv_vundefined_f32m1x3", "test_vundefined_i16mf2x7", "test_vundefined_f64m1", "test_vundefined_u32m2", "test_vundefined_i16m1x3", "__riscv_vundefined_u16mf2x4", "__riscv_vundefined_f16m1x6", "__riscv_vundefined_i16m1", "test_vundefined_u32m4", "test_vundefined_u8mf8", "test_vundefined_f16mf2x2", "test_vundefined_i8mf2x6", "test_vundefined_i64m8", "__riscv_vundefined_f32mf2x4", "test_vundefined_f16m8", "__riscv_vundefined_u16mf2x6", "test_vundefined_u8mf2", "__riscv_vundefined_f16mf4x6", "test_vundefined_i8mf2x5", "__riscv_vundefined_i16mf4x3", "test_vundefined_u16mf2x5", "test_vundefined_i8m4x2", "test_vundefined_f16mf2x8", "test_vundefined_f64m1x7", "test_vundefined_i8m1x4", "__riscv_vundefined_u16mf4x4", "test_vundefined_i8m2x3", "test_vundefined_u64m1", "__riscv_vundefined_f64m1x8", "test_vundefined_u16mf4x2", "test_vundefined_u64m1x4", "test_vundefined_f32m4x2", "test_vundefined_i32m1x6", "__riscv_vundefined_u16mf4x8", "test_vundefined_i32m1x7", "test_vundefined_f16m1x4", "__riscv_vundefined_u32mf2x7", "test_vundefined_u16m1x3", "test_vundefined_i32mf2x5", "test_vundefined_f64m1x5", "test_vundefined_i16m1", "__riscv_vundefined_i8mf4", "test_vundefined_i16m1x8", "test_vundefined_u64m4x2", "__riscv_vundefined_f16m2x2", "test_vundefined_u8m1x3", "test_vundefined_i8mf8x5", "test_vundefined_u8mf8x3", "test_vundefined_u16m1x8", "test_vundefined_i32m1", "test_vundefined_f32m2x3", "__riscv_vundefined_f32m1x8", "test_vundefined_u16mf2x7", "test_vundefined_i32m2", "__riscv_vundefined_i16mf4x8", "test_vundefined_u8m1", "test_vundefined_i64m1x2", "test_vundefined_i8mf8x4", "__riscv_vundefined_i16m8", "__riscv_vundefined_u16mf4x7", "__riscv_vundefined_i32m1", "test_vundefined_i16mf4x8", "test_vundefined_u64m1x8", "test_vundefined_f16m2x2", "test_vundefined_u16mf4x4", "test_vundefined_u8mf4x2", "test_vundefined_u16m4", "test_vundefined_u64m1x2", "test_vundefined_f32mf2x6", "test_vundefined_i16m2x2", "test_vundefined_u8mf2x5", "test_vundefined_u32m1", "__riscv_vundefined_f32m2", "test_vundefined_i16m1x4", "__riscv_vundefined_i8mf8", "test_vundefined_f64m2", "__riscv_vundefined_f32m1x2", "test_vundefined_u32m1x8", "__riscv_vundefined_f32mf2x8", "test_vundefined_i32m4", "__riscv_vundefined_f16m2", "test_vundefined_f16mf4x5", "test_vundefined_f32mf2x3", "test_vundefined_u32m2x3", "__riscv_vundefined_f32m1x5", "test_vundefined_i16mf4x6", "test_vundefined_i32m2x4", "test_vundefined_f16m4", "test_vundefined_u32mf2x4", "__riscv_vundefined_f64m2x3", "__riscv_vundefined_i16mf2", "__riscv_vundefined_u16m4", "test_vundefined_i16mf2x6", "test_vundefined_i32mf2x8", "__riscv_vundefined_i16mf4x4", "test_vundefined_i8mf4x3", "test_vundefined_u8m2x2", "__riscv_vundefined_i32m8", "test_vundefined_i16mf4x5", "__riscv_vundefined_i32mf2x2", "test_vundefined_u16mf2", "test_vundefined_u8mf8x7", "test_vundefined_f16m1x8", "__riscv_vundefined_i32mf2x3", "test_vundefined_u32m1x6", "test_vundefined_f16mf2x6", "test_vundefined_u32m8", "test_vundefined_i8mf8x8", "__riscv_vundefined_f16mf4x7", "__riscv_vundefined_f16m8", "test_vundefined_u8m1x6", "test_vundefined_f64m2x3", "test_vundefined_u16mf2x3", "test_vundefined_f32m4", "__riscv_vundefined_u8m2", "test_vundefined_i64m2x4", "__riscv_vundefined_i64m8", "test_vundefined_u8mf4", "__riscv_vundefined_f16m1x2", "test_vundefined_i64m2x2", "__riscv_vundefined_u8mf2", "test_vundefined_i64m4", "test_vundefined_i16mf2", "test_vundefined_f32m2"]}]}
{"pr_number": 70773, "url": "https://github.com/llvm/llvm-project/pull/70773", "title": "[mlir][bufferization] Fix ownership computation of unknown ops", "body": "No ownership is assumed for memref results of ops that implement none of the relevant interfaces and have no memref operands. This fixes #68948.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Bufferization/Transforms/OwnershipBasedBufferDeallocation.cpp", "functions": ["builder"]}]}
{"pr_number": 68774, "url": "https://github.com/llvm/llvm-project/pull/68774", "title": "[clang][ASTImporter] Fix crash when template class static member imported to other translation unit.", "body": "Fixes: #68769", "feature_layers": ["ast"], "feature_directives": [], "files_changed": [{"filename": "clang/unittests/AST/ASTImporterTest.cpp", "functions": ["foo"]}]}
{"pr_number": 70186, "url": "https://github.com/llvm/llvm-project/pull/70186", "title": "Disable memtag sanitization for global fnptrs going into .ctors", "body": "Looks like there's code out there that, instead of using\n'__attribute__((constructor(x)))' to add constructor functions, they\njust declare a global function pointer and use\n'__attribute__((section('.ctors')))' instead.\n\nProblem is, with memtag-globals, we pad the global function pointer to\nbe 16 bytes large. This of course means we have an 8-byte real function\npointer, then 8 bytes of zero padding, and this trips up the loader when\nit processes this section.\n\nFixes #69939\n", "feature_layers": [], "feature_directives": ["for", "declare"], "files_changed": [{"filename": "clang/test/CodeGen/memtag-globals-asm.cpp", "functions": ["void"]}]}
{"pr_number": 69584, "url": "https://github.com/llvm/llvm-project/pull/69584", "title": "[MLIR][NVGPU] Remove Memref Rank vs. Coordinates `tma.async.load`", "body": "Previously, a verifier to check for mismatches between memref rank and number of coordinates was introduced. I noticed that it is very strict. Let's take following IR snippet where the verifier complains about mismatches (2 coordinates (%c1,%c2) != memref rank 3).\r\n\r\n```\r\nnvgpu.tma.async.load %0[%c1, %c2], %1 to %2 : ... -> memref<1x64x128xf16, ..., 3>\r\n```\r\n\r\nThis PR relax the verifier.\n\nThe test #69913 needs this PR. ", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/NVGPU/IR/NVGPUDialect.cpp", "functions": ["size_t", "emitError", "getCoordinates"]}]}
{"pr_number": 69935, "url": "https://github.com/llvm/llvm-project/pull/69935", "title": "[mlir][nvgpu] Remove strict verifiers on `warpgroup.generate.descriptor`", "body": "This PR relaxes some rules in the verifier. I found this to be overly restrictive. It's certainly possible to work around these rules, for example one way is to generate additional subview and etc., but this just bloats the IR.\n\nThe test #69913 needs this PR. ", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/NVGPU/IR/NVGPUDialect.cpp", "functions": ["emitError"]}]}
{"pr_number": 70134, "url": "https://github.com/llvm/llvm-project/pull/70134", "title": "[llvm][AArch64][Assembly]: Add FP8FMA  assembly and disassembly.", "body": "This patch adds the feature flag FP8FMA and the assembly/disassembly\r\nfor the following instructions of NEON and SVE2:\r\n  * NEON: \r\n    - FMLALBlane\r\n    - FMLALTlane\r\n    - FMLALLBBlane\r\n    - FMLALLBTlane\r\n    - FMLALLTBlane\r\n    - FMLALLTTlane\r\n    - FMLALB\r\n    - FMLALT\r\n    - FMLALLB\r\n    - FMLALLBT\r\n    - FMLALLTB\r\n    - FMLALLTT\r\n  * SVE2:\r\n    - FMLALB_ZZZI\r\n    - FMLALT_ZZZI\r\n    - FMLALB_ZZZ \r\n    - FMLALT_ZZZ \r\n    - FMLALLBB_ZZZI \r\n    - FMLALLBT_ZZZI \r\n    - FMLALLTB_ZZZI \r\n    - FMLALLTT_ZZZI \r\n    - FMLALLBB_ZZZ \r\n    - FMLALLBT_ZZZ \r\n    - FMLALLTB_ZZZ \r\n    - FMLALLTT_ZZZ\r\n\r\nThat is according to this documentation:\r\nhttps://developer.arm.com/documentation/ddi0602/2023-09", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp", "functions": ["addVectorReg0to7Operands", "isNeonVectorReg0to7"]}, {"filename": "llvm/lib/Target/AArch64/Disassembler/AArch64Disassembler.cpp", "functions": ["DecodeFPR128RegisterClass"]}]}
{"pr_number": 70924, "url": "https://github.com/llvm/llvm-project/pull/70924", "title": "[mlir][SCF] Add folding for IndexSwitchOp", "body": "", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/SCF/IR/SCF.cpp", "functions": ["failure", "getDefaultRegion", "success"]}]}
{"pr_number": 70548, "url": "https://github.com/llvm/llvm-project/pull/70548", "title": "[Clang] Defer the instantiation of explicit-specifier until constraint checking completes", "body": "Modifications:\r\n\r\n- Skip the instantiation of the explicit-specifier during Decl substitution if we are deducing template arguments and the explicit-specifier is value dependent.\r\n\r\n- Instantiate the explicit-specifier after the constraint checking completes.\r\n\r\n- Make `instantiateExplicitSpecifier` a member function in order to instantiate the explicit-specifier in different stages.\r\n\r\n\r\nThis PR doesn\u2019t defer the instantiation of the explicit specifier for deduction guides, because I\u2019m not familiar with deduction guides yet. I\u2019ll dig into it after this PR.\r\n\r\nAccording to my local test, GCC 13 tuple works with this PR.\r\n\r\nFixes #59827.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/SemaCXX/cxx2a-explicit-bool-deferred.cpp", "functions": ["explicit", "t", "t2", "do_not_instantiate"]}, {"filename": "clang/lib/Sema/SemaTemplateDeduction.cpp", "functions": ["Trap"]}]}
{"pr_number": 68413, "url": "https://github.com/llvm/llvm-project/pull/68413", "title": "[libc++] Fix complexity guarantee in ranges::clamp", "body": "This patch prevents us from calling the projection more than 3 times in std::clamp, as required by the Standard.\r\n\r\nFixes #64717", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "libcxx/test/std/algorithms/alg.sorting/alg.clamp/ranges.clamp.pass.cpp", "functions": ["lvalue_proj", "prvalue_proj", "operator"]}]}
{"pr_number": 70424, "url": "https://github.com/llvm/llvm-project/pull/70424", "title": "[libc++] <experimental/simd> Add default constructor for class simd/simd_mask", "body": "", "feature_layers": [], "feature_directives": ["for", "simd"], "files_changed": [{"filename": "libcxx/test/std/experimental/simd/simd.class/simd_ctor_default.pass.cpp", "functions": ["main", "operator"]}, {"filename": "libcxx/test/std/experimental/simd/simd.mask.class/simd_mask_ctor_default.pass.cpp", "functions": ["main", "operator"]}]}
{"pr_number": 70942, "url": "https://github.com/llvm/llvm-project/pull/70942", "title": "[mlir][Vector] Add initial support for inlining in the presence of vector ops", "body": "", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Vector/IR/VectorOps.cpp", "functions": ["isLegalToInline"]}]}
{"pr_number": 70742, "url": "https://github.com/llvm/llvm-project/pull/70742", "title": "[LLDB] On AArch64, reconfigure register context first", "body": "On an SVE/SME the register context configuration may change after the inferior process has executed.  This was handled via https://reviews.llvm.org/D159504 but it is reconfiguring and clearing the register context after we've parsed any expedited reigster values from the stop reply packet.  That results in lldb having to read each register value one at a time while at that stop location, which will be a performance problem on non-local debug setups.\r\n\r\nThe configuration & clearing needs to happen first.  Also, update the names of the local variables for a little clarity.", "feature_layers": ["parse", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "lldb/source/Plugins/Process/gdb-remote/ProcessGDBRemote.cpp", "functions": ["reg_ctx_sp", "gdb_reg_ctx_sp"]}]}
{"pr_number": 66906, "url": "https://github.com/llvm/llvm-project/pull/66906", "title": "[mlir][TOSA] Fix shape inference when operand was inferred", "body": "https://github.com/llvm/llvm-project/commit/057fc8e7d8a3593f98930b8b91f80b9dd9b5fd4a Introduces a bug in the `TosaInferShapesPass` when an operand type was already inferred. https://github.com/llvm/llvm-project/blob/f7bfa583b7a5ff0e9954d2810006b7a71123be88/mlir/include/mlir/Interfaces/InferTypeOpInterface.td#L248 interprets the `ValueShapeRange` as a normal `ValueRange` and looses the information of the inference. \r\n\r\nThis PR changes the logic of the shape inference a bit. Instead of saving the type information in a `DenseMap` and updating the types after the whole analysis for a region, it now updates the types directly in each iteration. That way the operands always have the inferred type.", "feature_layers": ["sema", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Tosa/Transforms/TosaInferShapes.cpp", "functions": ["propagateShapesToTosaWhile", "range", "propagateShapesToTosaIf"]}]}
{"pr_number": 65989, "url": "https://github.com/llvm/llvm-project/pull/65989", "title": "[SPIRV] Add -spirv option to DXC driver", "body": "Add an option to target SPIR-V to the clang-dxc driver, which sets the target triple's architecture to logical SPIR-V. This does not yet address the need for a Vulkan target environment in the triple, tracked in Issue #70051.\r\n\r\nDepends on #70330", "feature_layers": ["ir"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "clang/lib/Driver/Driver.cpp", "functions": ["T"]}]}
{"pr_number": 70357, "url": "https://github.com/llvm/llvm-project/pull/70357", "title": "[RISCV] Add experimental support for making i32 a legal type on RV64 in SelectionDAG.", "body": "This will select i32 operations directly to W instructions without custom nodes. Hopefully this can allow us to be less dependent on hasAllNBitUsers to recover i32 operations in RISCVISelDAGToDAG.cpp.\r\n\r\nThis support is enabled with a command line option that is off by default.\r\n\r\nGenerated code is still very not optimal.\r\n\r\nI've duplicated many test cases for this, but its not complete. I think that enabling this runs all existing lit tests without crashing.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVISelLowering.cpp", "functions": ["if"]}]}
{"pr_number": 70752, "url": "https://github.com/llvm/llvm-project/pull/70752", "title": "[OpenMP][FIX] Allocate per launch memory for GPU team reductions", "body": "We used to perform team reduction on global memory allocated in the\r\nruntime and by clang. This was racy as multiple instances of a kernel,\r\nor different kernels with team reductions, would use the same locations.\r\nSince we now have the kernel launch environment, we can allocate dynamic\r\nmemory per-launch, allowing us to move all the state into a non-racy\r\nplace.\r\n\r\nFixes: https://github.com/llvm/llvm-project/issues/70249", "feature_layers": ["runtime", "ir"], "feature_directives": ["for", "allocate"], "files_changed": [{"filename": "openmp/libomptarget/test/offloading/parallel_target_teams_reduction.cpp", "functions": ["avec", "main"]}]}
{"pr_number": 70954, "url": "https://github.com/llvm/llvm-project/pull/70954", "title": "[openacc] Update acc.loop to expose data operands", "body": "The compute and data constructs implement getNumDataOperands and getDataOperand. The acc.loop operation similarly has multiple data operands - thus it makes sense to expose them the same way.\r\n\r\nFor loop, only private and reduction operands are exposed this way. Technically, acc.loop also holds cache operands - but these are hints not a data attribute.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/OpenACC/IR/OpenACC.cpp", "functions": ["getReductionOperands", "getOperand"]}]}
{"pr_number": 70178, "url": "https://github.com/llvm/llvm-project/pull/70178", "title": "[AArch64,ELF] Restrict MOVZ/MOVK to non-PIC large code model", "body": "There is no PIC support for -mcmodel=large\n(https://github.com/ARM-software/abi-aa/blob/main/sysvabi64/sysvabi64.rst)\nand Clang recently rejects -mcmodel= with PIC (#70262).\n\nThe current backend code assumes that the large code model is non-PIC.\nThis patch adds `!getTargetMachine().isPositionIndependent()` conditions\nto clarify that the support is non-PIC only. In addition, add some tests\nas change detectors in case PIC large code model is supported in the\nfuture.\n\nIf other front-ends/JITs use the large code model with PIC, they will\nget small code model code sequence, instead of potentially-incorrect\nMOVZ/MOVK sequence, which is only suitable for non-PIC. The sequence\nwill cause text relocations using ELF linkers.\n\n(The small code model code sequence is usually sufficient as ADRP+ADD or\nADRP+LDR targets [-2**32,2**32), which has a doubled range of x86-64\nR_X86_64_REX_GOTPCRELX/R_X86_64_PC32 [-2**32,2**32).)", "feature_layers": [], "feature_directives": ["for", "target"], "files_changed": [{"filename": "llvm/lib/Target/AArch64/AArch64ISelLowering.cpp", "functions": ["getAddr", "getAddrLarge"]}]}
{"pr_number": 70868, "url": "https://github.com/llvm/llvm-project/pull/70868", "title": "[mlir][sparse] Implement rewriters to reinterpret maps on foreach", "body": "", "feature_layers": ["parse", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/Transforms/SparseReinterpretMap.cpp", "functions": ["dstArgs"]}, {"filename": "mlir/lib/Dialect/SparseTensor/Transforms/SparseTensorRewriting.cpp", "functions": ["success"]}]}
{"pr_number": 70031, "url": "https://github.com/llvm/llvm-project/pull/70031", "title": "[AMDGPU] GCNRegPressure printing pass for testing.", "body": "Take a look at the tests to see the output.\r\n\r\nThis probably should be also enabled for _llc_ tests, I haven't tried it yet.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/GCNRegPressure.cpp", "functions": ["reportMismatch"]}]}
{"pr_number": 66035, "url": "https://github.com/llvm/llvm-project/pull/66035", "title": "Add `target modules dump separate-debug-info`", "body": "Add a new command\r\n```\r\ntarget modules dump separate-debug-info [-j] [<filename> [<filename> [...]]]\r\n```\r\nor\r\n```\r\nimage dump separate-debug-info [-j] [<filename> [<filename> [...]]]\r\n```\r\n(since `image` is an alias for `target modules`).\r\nThis lists the separate debug info files and their current status (loaded or not loaded) for the specified modules. This diff implements this command for mach-O files with OSO and ELF files with dwo.\r\nExample dwo:\r\n```\r\n(lldb) image dump separate-debug-info\r\nSymbol file: /home/toyang/workspace/dwo-scratch/a.out\r\nType: \"dwo\"\r\nDwo ID             Err Dwo Path\r\n------------------ --- -----------------------------------------\r\n0x9a429da5abb6faae     /home/toyang/workspace/scratch-dwo/a-main.dwo\r\n0xbcc129959e76ff33     /home/toyang/workspace/scratch-dwo/a-foo.dwo\r\n\r\n(lldb) image dump separate-debug-info -j\r\n[\r\n  {\r\n    \"separate-debug-info-files\": [\r\n      {\r\n        \"comp_dir\": \"/home/toyang/workspace/dwo-scratch\",\r\n        \"dwo_id\": 11115620165179865774,\r\n        \"dwo_name\": \"a-main.dwo\",\r\n        \"loaded\": true,\r\n        \"resolved_dwo_path\": \"/home/toyang/workspace/dwo-scratch/a-main.dwo\"\r\n      },\r\n      {\r\n        \"comp_dir\": \"/home/toyang/workspace/dwo-scratch\",\r\n        \"dwo_id\": 13601198072221073203,\r\n        \"dwo_name\": \"a-foo.dwo\",\r\n        \"loaded\": true,\r\n        \"resolved_dwo_path\": \"/home/toyang/workspace/dwo-scratch/a-foo.dwo\"\r\n      }\r\n    ],\r\n    \"symfile\": \"/home/toyang/workspace/dwo-scratch/a.out\",\r\n    \"type\": \"dwo\"\r\n  }\r\n]\r\n```\r\nExample dwo with missing dwo:\r\n```\r\n(lldb) image dump separate-debug-info\r\nSymbol file: /home/toyang/workspace/dwo-scratch/a.out\r\nType: \"dwo\"\r\nDwo ID             Err Dwo Path\r\n------------------ --- -----------------------------------------\r\n0x9a429da5abb6faae E   unable to locate .dwo debug file \"/home/toyang/workspace/scratch-dwo/b.out-main.dwo\" for skeleton DIE 0x0000000000000014\r\n0xbcc129959e76ff33 E   unable to locate .dwo debug file \"/home/toyang/workspace/scratch-dwo/b.out-foo.dwo\" for skeleton DIE 0x000000000000003c\r\n\r\n(lldb) image dump separate-debug-info -j\r\n[\r\n  {\r\n    \"separate-debug-info-files\": [\r\n      {\r\n        \"comp_dir\": \"/home/toyang/workspace/dwo-scratch\",\r\n        \"dwo_id\": 11115620165179865774,\r\n        \"dwo_name\": \"a-main.dwo\",\r\n        \"error\": \"unable to locate .dwo debug file \\\"/home/toyang/workspace/dwo-scratch/a-main.dwo\\\" for skeleton DIE 0x0000000000000014\",\r\n        \"loaded\": false\r\n      },\r\n      {\r\n        \"comp_dir\": \"/home/toyang/workspace/dwo-scratch\",\r\n        \"dwo_id\": 13601198072221073203,\r\n        \"dwo_name\": \"a-foo.dwo\",\r\n        \"error\": \"unable to locate .dwo debug file \\\"/home/toyang/workspace/dwo-scratch/a-foo.dwo\\\" for skeleton DIE 0x000000000000003c\",\r\n        \"loaded\": false\r\n      }\r\n    ],\r\n    \"symfile\": \"/home/toyang/workspace/dwo-scratch/a.out\",\r\n    \"type\": \"dwo\"\r\n  }\r\n]\r\n```\r\nExample output with dwp:\r\n```\r\n(lldb) image dump separate-debug-info\r\nSymbol file: /home/toyang/workspace/dwo-scratch/a.out\r\nType: \"dwo\"\r\nDwo ID             Err Dwo Path\r\n------------------ --- -----------------------------------------\r\n0x9a429da5abb6faae     /home/toyang/workspace/dwo-scratch/a.out.dwp(a-main.dwo)\r\n0xbcc129959e76ff33     /home/toyang/workspace/dwo-scratch/a.out.dwp(a-foo.dwo)\r\n(lldb) image dump separate-debug-info -j\r\n[\r\n  {\r\n    \"separate-debug-info-files\": [\r\n      {\r\n        \"comp_dir\": \"/home/toyang/workspace/dwo-scratch\",\r\n        \"dwo_id\": 11115620165179865774,\r\n        \"dwo_name\": \"a-main.dwo\",\r\n        \"loaded\": true,\r\n        \"resolved_dwo_path\": \"/home/toyang/workspace/dwo-scratch/a.out.dwp\"\r\n      },\r\n      {\r\n        \"comp_dir\": \"/home/toyang/workspace/dwo-scratch\",\r\n        \"dwo_id\": 13601198072221073203,\r\n        \"dwo_name\": \"a-foo.dwo\",\r\n        \"loaded\": true,\r\n        \"resolved_dwo_path\": \"/home/toyang/workspace/dwo-scratch/a.out.dwp\"\r\n      }\r\n    ],\r\n    \"symfile\": \"/home/toyang/workspace/dwo-scratch/a.out\",\r\n    \"type\": \"dwo\"\r\n  }\r\n]\r\n```\r\nExample oso on my Mac:\r\n```\r\n(lldb) image dump separate-debug-info\r\nSymbol file: /Users/toyang/workspace/scratch/a.out\r\nType: \"oso\"\r\nMod Time           Err Oso Path\r\n------------------ --- ---------------------\r\n0x0000000064e64868     /Users/toyang/workspace/scratch/foo.a(foo.o)\r\n0x0000000064e64868     /Users/toyang/workspace/scratch/foo.a(main.o)\r\n\r\n(lldb) image dump separate-debug-info -j\r\n[\r\n  {\r\n    \"separate-debug-info-files\": [\r\n      {\r\n        \"loaded\": true,\r\n        \"oso_mod_time\": 1692813416,\r\n        \"oso_path\": \"/Users/toyang/workspace/scratch/foo.a(foo.o)\",\r\n        \"so_file\": \"/Users/toyang/workspace/scratch/foo.cpp\"\r\n      },\r\n      {\r\n        \"loaded\": true,\r\n        \"oso_mod_time\": 1692813416,\r\n        \"oso_path\": \"/Users/toyang/workspace/scratch/foo.a(main.o)\",\r\n        \"so_file\": \"/Users/toyang/workspace/scratch/main.cpp\"\r\n      }\r\n    ],\r\n    \"symfile\": \"/Users/toyang/workspace/scratch/a.out\",\r\n    \"type\": \"oso\"\r\n  }\r\n]\r\n```\r\n\r\nTest Plan:\r\nTested on Mac OS and Linux.\r\n```\r\nlldb-dotest -p TestDumpDwo\r\nlldb-dotest -p TestDumpOso\r\n```", "feature_layers": ["ir"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "lldb/source/Commands/CommandObjectTarget.cpp", "functions": ["GetDefinitions", "OptionParsingStarting", "guard", "DoExecute"]}, {"filename": "lldb/test/API/commands/target/dump-separate-debug-info/dwo/foo.cpp", "functions": ["foo"]}, {"filename": "lldb/test/API/commands/target/dump-separate-debug-info/dwo/main.cpp", "functions": ["main"]}, {"filename": "lldb/test/API/commands/target/dump-separate-debug-info/oso/foo.cpp", "functions": ["foo"]}, {"filename": "lldb/test/API/commands/target/dump-separate-debug-info/oso/main.cpp", "functions": ["main"]}]}
{"pr_number": 66023, "url": "https://github.com/llvm/llvm-project/pull/66023", "title": "[libc] Refactor scanf reader to match printf", "body": "In a previous patch, the printf writer was rewritten to use a single writer class with a buffer and a callback hook. This patch refactors scanf's reader to match conceptually.", "feature_layers": [], "feature_directives": ["single"], "files_changed": [{"filename": "libc/src/stdio/scanf_core/vfscanf_internal.cpp", "functions": ["reader", "file_reader"]}, {"filename": "libc/src/stdio/sscanf.cpp", "functions": ["reader", "string_reader"]}, {"filename": "libc/test/src/stdio/scanf_core/reader_test.cpp", "functions": ["reader", "str_reader"]}]}
{"pr_number": 68134, "url": "https://github.com/llvm/llvm-project/pull/68134", "title": "[clang-tidy][libc] Fix namespace check with macro", "body": "The name of the namespace for LLVM's libc is now provided by a macro.\nThe ImplementationNamespaceCheck was updated to handle this, but the\nCalleeNamespaceCheck was missed. This patch updates the\nCalleeNamespaceCheck to handle the macro.\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang-tools-extra/test/clang-tidy/checkers/llvmlibc/callee-namespace.cpp", "functions": ["right_name_no_macro_func", "wrong_name_macro_func"]}]}
{"pr_number": 70997, "url": "https://github.com/llvm/llvm-project/pull/70997", "title": "[flang] Support fir.boxchar in getTypeAsString", "body": "", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "flang/lib/Optimizer/Dialect/FIRType.cpp", "functions": ["if"]}]}
{"pr_number": 70993, "url": "https://github.com/llvm/llvm-project/pull/70993", "title": "[mlir][sparse] Implement rewriters to reinterpret maps on alloc_tenso\u2026", "body": "\u2026r operation", "feature_layers": ["parse", "ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/Transforms/SparseReinterpretMap.cpp", "functions": ["failure", "success"]}]}
{"pr_number": 70293, "url": "https://github.com/llvm/llvm-project/pull/70293", "title": "[mlir] Add support for vector.store sub-byte emulation.", "body": "", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Vector/Transforms/VectorEmulateNarrowType.cpp", "functions": ["failure", "success"]}]}
{"pr_number": 70889, "url": "https://github.com/llvm/llvm-project/pull/70889", "title": "[mlir][spirv][cf] Check destination block argument types", "body": "Do not match on illegal destination blocks. Also apply some minor cleanups.\r\n\r\nTODO: We should add region/block argument type conversions to properly address this.\r\n\r\nIssue: https://github.com/llvm/llvm-project/issues/70813", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Conversion/ControlFlowToSPIRV/ControlFlowToSPIRV.cpp", "functions": ["failure", "success"]}]}
{"pr_number": 67166, "url": "https://github.com/llvm/llvm-project/pull/67166", "title": "[InstCombine] Add combines/simplifications for `llvm.ptrmask`", "body": "- [InstSimplify] Add tests for simplify `llvm.ptrmask`; NFC\r\n- [InstSimplify] Add some basic simplifications for `llvm.ptrmask`\r\n- [InstCombine] Add tests for combining `llvm.ptrmask`; NFC\r\n- [InstCombine] Deduce `align` and `nonnull` return attributes for `llvm.ptrmask`\r\n- [InstCombine] Implement `SimplifyDemandedBits` for `llvm.ptrmask`\r\n- [InstCombine] Preserve return attributes when merging `llvm.ptrmask`\r\n- [InstCombine] Merge consecutive `llvm.ptrmask` with different mask types if a mask is constant.\r\n- [InstCombine] Fold `(ptrtoint (ptrmask p0, m0))` -> `(and (ptrtoint p0), m0)`\r\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp", "functions": ["Known"]}, {"filename": "llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp", "functions": ["DemandedMask", "getBitWidth", "Known", "SimplifyDemandedInstructionBits"]}]}
{"pr_number": 70909, "url": "https://github.com/llvm/llvm-project/pull/70909", "title": "[MLIR][MemRefToLLVM] Remove typed pointer support", "body": "This commit removes the support for lowering MemRefToLLVM to LLVM dialect with typed pointers. Typed pointers have been deprecated for a while now and it's planned to soon remove them from the LLVM dialect.\r\n\r\nRelated PSA: https://discourse.llvm.org/t/psa-removal-of-typed-pointers-from-the-llvm-dialect/74502\r\n\r\nNote: There were some patterns that used typed pointers, but changing to opaque pointers didn't break any tests. I'm not sure if the test coverage of this conversion is sufficient.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Conversion/LLVMCommon/MemRefBuilder.cpp", "functions": ["getElementPtrType"]}]}
{"pr_number": 68406, "url": "https://github.com/llvm/llvm-project/pull/68406", "title": "[LLVM-C] Add LLVMCreateTargetMachineWithABI", "body": "The ABI parameter is used by a number of common backends, including ARM, MIPS, PPC, and RISCV. Exposing it via the C API makes it possible for users of those backends to configure the ABI without custom bindings.", "feature_layers": [], "feature_directives": ["for", "target"], "files_changed": [{"filename": "llvm/lib/Target/TargetMachineC.cpp", "functions": ["LLVMCreateTargetMachineOptions", "unwrap", "wrap", "LLVMDisposeTargetMachineOptions"]}]}
{"pr_number": 71028, "url": "https://github.com/llvm/llvm-project/pull/71028", "title": "[MLIR][SCFToOpenMP] Remove typed pointer support", "body": "This commit removes the support for lowering SCF to OpenMP dialect with typed pointers. Typed pointers have been deprecated for a while now and it's planned to soon remove them from the LLVM dialect.\r\n\r\nRelated PSA: https://discourse.llvm.org/t/psa-removal-of-typed-pointers-from-the-llvm-dialect/74502", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Conversion/SCFToOpenMP/SCFToOpenMP.cpp", "functions": ["addAtomicRMW", "applyPatterns"]}]}
{"pr_number": 70540, "url": "https://github.com/llvm/llvm-project/pull/70540", "title": "[clang][analyzer] Restrict 'fopen' & 'tmpfile' modeling to POSIX versions in StreamChecker", "body": "'tmpfile' has only one form that it has no argument.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/Analysis/stream-non-posix-function.c", "functions": ["test_tmpfile_non_posix", "test_fopen_non_posix"]}]}
{"pr_number": 70814, "url": "https://github.com/llvm/llvm-project/pull/70814", "title": "[mlir][ArmSME] Propagate pad and mask in vector.transfer_read lowering", "body": "This extends the lowering of vector.transfer_read -> arm_sme.tile_load lowering to propagate pad and mask.\r\n\r\nThe restriction on the transfer_read being a transposition is also removed, identity maps are lowered to normal horizontal loads.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Conversion/VectorToArmSME/VectorToArmSME.cpp", "functions": ["if"]}]}
{"pr_number": 70914, "url": "https://github.com/llvm/llvm-project/pull/70914", "title": "[lldb][AArch64] Simplify handing of scalable registers using vg and svg", "body": "This removes explicit invalidation of vg and svg that was done in `GDBRemoteRegisterContext::AArch64Reconfigure`. This was in fact covering up a bug elsehwere.\r\n\r\nRegister information says that a write to vg also invalidates svg (it does not unless you are in streaming mode, but we decided to keep it simple and say it always does).\r\n\r\nThis invalidation was not being applied until *after* AArch64Reconfigure was called. This meant that without those manual invalidates this happened:\r\n* vg is written\r\n* svg is not invalidated\r\n* Reconfigure uses the written vg value\r\n* Reconfigure uses the *old* svg value\r\n\r\nI have moved the AArch64Reconfigure call to after we've processed the invalidations caused by the register write, so we no longer need the manual invalidates in AArch64Reconfigure.\r\n\r\nIn addition I have changed the order in which expedited registers as parsed. These registers come with a stop notification and include, amongst others, vg and svg.\r\n\r\nSo now we:\r\n* Parse them and update register values (including vg and svg)\r\n* AArch64Reconfigure, which uses those values, and invalidates every register, because offsets may have changed.\r\n* Parse the expedited registers again, knowing that none of the values will have changed due to the scaling.\r\n\r\nThis means we use the expedited registers during the reconfigure, but the invalidate does not mean we throw all of them away.\r\n\r\nThe cost is we parse them twice client side, but this is cheap compared to a network packet, and is limited to AArch64 targets only.\r\n\r\nOn a system with SVE and SME, these are the packets sent for a step:\r\n```\r\n(lldb) b-remote.async>  < 803> read packet:\r\n$T05thread:p1f80.1f80;name:main.o;threads:1f80;thread-pcs:000000000040056c<...>a1:0800000000000000;d9:0400000000000000;reason:trace;#fc\r\nintern-state     <  21> send packet: $xfffffffff200,200#5e\r\nintern-state     < 516> read packet:\r\n$e4f2ffffffff000000<...>#71\r\nintern-state     <  15> send packet: $Z0,400568,4#4d\r\nintern-state     <   6> read packet: $OK#9a\r\ndbg.evt-handler  <  16> send packet: $jThreadsInfo#c1\r\ndbg.evt-handler  < 224> read packet:\r\n$[{\"name\":\"main.o\",\"reason\":\"trace\",\"registers\":{\"161\":\"0800000000000000\",<...>}],\"signal\":5,\"tid\":8064}]]#73\r\n```\r\n\r\nYou can see there are no extra register reads which means we're using the expedited registers.\r\n\r\nFor a write to vg:\r\n```\r\n(lldb) register write vg 4\r\nlldb             <  37> send packet:\r\n$Pa1=0400000000000000;thread:1f80;#4a\r\nlldb             <   6> read packet: $OK#9a\r\nlldb             <  20> send packet: $pa1;thread:1f80;#29\r\nlldb             <  20> read packet: $0400000000000000#04\r\nlldb             <  20> send packet: $pd9;thread:1f80;#34\r\nlldb             <  20> read packet: $0400000000000000#04\r\n```\r\n\r\nThere is the initial P write, and lldb correctly assumes that SVG is invalidated by this also so we read back the new vg and svg values afterwards.", "feature_layers": ["parse"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "lldb/source/Plugins/Process/gdb-remote/ProcessGDBRemote.cpp", "functions": ["DataBufferHeap", "gdb_reg_ctx_sp", "reg_value_extractor"]}]}
{"pr_number": 70957, "url": "https://github.com/llvm/llvm-project/pull/70957", "title": "[mlir][Bufferization] Add support for controlled bufferization of alloc_tensor", "body": "This revision adds support to `transform.structured.bufferize_to_allocation` to bufferize `bufferization.alloc_tensor()` ops.\r\n    \r\nThis is useful as a means path to control the bufferization of `tensor.empty` ops that have bene previously `bufferization.empty_tensor_to_alloc_tensor`'ed.\r\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Linalg/Transforms/ConvertToDestinationStyle.cpp", "functions": ["g", "bufferizeToAllocation"]}]}
{"pr_number": 70975, "url": "https://github.com/llvm/llvm-project/pull/70975", "title": "Revert \"Revert \"[APINotes] Upstream APINotesOptions\"\"", "body": "This re-lands https://github.com/llvm/llvm-project/pull/70827 while preventing the assertion failure that occurred when generating `ASTNodeAPI.json` on non-Apple platforms.", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Frontend/CompilerInvocation.cpp", "functions": ["ensureOwned"]}]}
{"pr_number": 71055, "url": "https://github.com/llvm/llvm-project/pull/71055", "title": "LegalizeIntegerTypes: implement PromoteIntRes for xrint", "body": "Recently, 98c90a1 (ISel: introduce vector ISD::LRINT, ISD::LLRINT; custom RISCV lowering) introduced vector variants of llvm.lrint, llvm.llrint, and bundled several tests along with the code change. However, it forgot to test lrint and llrint on fixed vectors on RISC-V, and it turns out that that fixed-vectors-lrint.ll requires PromoteIntRes_XRINT to be implemented. Implement it, and add tests for fixed-vector lrint, llrint.", "feature_layers": ["ir"], "feature_directives": ["for", "requires"], "files_changed": [{"filename": "llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp", "functions": ["dl"]}]}
{"pr_number": 70792, "url": "https://github.com/llvm/llvm-project/pull/70792", "title": "[analyzer] Fix uninitialized base class with initializer list when ctor is not declared in the base class (#70464)", "body": "When ctor is not declared in the base class, initializing the base class with the initializer list will not trigger a proper assignment of the base region, as a CXXConstructExpr doing that is not available in the AST.\r\n\r\nThis patch checks whether the init expr is an InitListExpr under a base initializer, and adds a binding if so.", "feature_layers": ["ast"], "feature_directives": ["declare"], "files_changed": [{"filename": "clang/test/Analysis/issue-70464.cpp", "functions": ["entry", "clang_analyzer_dump"]}]}
{"pr_number": 70989, "url": "https://github.com/llvm/llvm-project/pull/70989", "title": "[mlir][sparse] simplify some header code", "body": "This is a first revision in a small series of changes that removes duplications between direct encoding methods and sparse tensor type wrapper methods (in favor of the latter abstraction, since it provides more safety). The goal is to simply end up with \"just\" SparseTensorType", "feature_layers": ["parse", "ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/Transforms/CodegenUtils.cpp", "functions": ["resShape"]}, {"filename": "mlir/lib/Dialect/SparseTensor/Transforms/SparseTensorConversion.cpp", "functions": ["constantIndex"]}]}
{"pr_number": 70978, "url": "https://github.com/llvm/llvm-project/pull/70978", "title": "[clang] Separate bit-field padding diagnostics into -Wpadded-bitfield", "body": "The `-Wpadded` diagnostics are usually very noisy and generally not helpful. However, reporting padding that was introduced in bit-fields is rather helpful. For example, yesterday in SerenityOS's discord we had very unpleasant experience of debugging Windows portability issue, and its root cause was that under `x86_64-pc-windows-msvc` a padding was introduced for one of the bit-fields.\r\n\r\nSo, this PR separates bit-field-related padding diagnostics into a new `-Wpadded-bitfield`. The diagnostic group is also enabled by `-Wpadded` for compatibility reasons.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CodeGenCXX/warn-padded-bitfields.cpp", "functions": ["__attribute__", "f"]}]}
{"pr_number": 71049, "url": "https://github.com/llvm/llvm-project/pull/71049", "title": "[clang][NFC] Refactor `clang::Linkage`", "body": "This patch introduces a new enumerator `Invalid = 0`, shifting other enumerators by +1. Contrary to how it might sound, this actually affirms status quo of how this enum is stored in `clang::Decl`:\r\n```\r\n  /// If 0, we have not computed the linkage of this declaration.\r\n  /// Otherwise, it is the linkage + 1.\r\n  mutable unsigned CacheValidAndLinkage : 3;\r\n```\r\nThis patch makes debuggers to not be mistaken about enumerator stored in this bit-field. It also converts `clang::Linkage` to a scoped enum.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "clang-tools-extra/clang-doc/Serialize.cpp", "functions": ["if"]}, {"filename": "clang/lib/AST/Decl.cpp", "functions": ["getFormalLinkage", "LinkageInfo"]}, {"filename": "clang/lib/AST/Type.cpp", "functions": ["CachedProperties"]}, {"filename": "clang/lib/Sema/SemaDecl.cpp", "functions": ["if"]}, {"filename": "clang/tools/libclang/CXIndexDataConsumer.cpp", "functions": ["ProtInfo", "handleObjCContainer"]}]}
{"pr_number": 71085, "url": "https://github.com/llvm/llvm-project/pull/71085", "title": "[mlir][sparse] Cleanup sparse_tensor::LvlOp's folder", "body": "Reuse the util function instead.", "feature_layers": ["parse", "ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/IR/SparseTensorDialect.cpp", "functions": ["getIndexAttr"]}]}
{"pr_number": 70972, "url": "https://github.com/llvm/llvm-project/pull/70972", "title": "[mlir][tosa] Add verifier for tosa.tile, fix shape inference crash", "body": "This patch adds an verifier to `tosa.tile` which checks input/output ranks and the length of the `multiples` array. The patch also fixes a crash in the shape inference when an invalid `multiples` array is supplied.\r\n\r\nFix https://github.com/llvm/llvm-project/issues/70415", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Tosa/IR/TosaOps.cpp", "functions": ["failure", "emitOpError", "success"]}]}
{"pr_number": 69095, "url": "https://github.com/llvm/llvm-project/pull/69095", "title": "[Driver][DragonFly] Fixes for linker path and command-line option handling", "body": "- Add in some other linker command line options that the other BSD's handle\r\n- Make use of AddFilePathLibArgs()\r\n- Handle OpenMP", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Driver/ToolChains/DragonFly.cpp", "functions": ["Dir"]}]}
{"pr_number": 71092, "url": "https://github.com/llvm/llvm-project/pull/71092", "title": "[libc] Allow hermetic timing if the `clock` function is built", "body": "Summary:\nThis patch fixes some code duplication on the GPU. The GPU build wanted\nto enable timing for hermetic tests so it built some special case\nhandling into the test suite. Now that `clock` is supported on the\ntarget we can simply link against the external interface. Because we\ninclude `clock.h` for the CLOCKS_PER_SEC macro we remap the C entrypoint\nto the internal one if it ends up called. This should allow hermetic\ntests to run with timing if it is supported.\n", "feature_layers": [], "feature_directives": ["for", "target"], "files_changed": [{"filename": "libc/test/UnitTest/LibcTest.cpp", "functions": ["clock"]}]}
{"pr_number": 71066, "url": "https://github.com/llvm/llvm-project/pull/71066", "title": "Revert \"[CaptureTracking] Ignore ephemeral values when determining po\u2026", "body": "Unfortunately the commit (D123162) introduced a mis-compile (https://github.com/llvm/llvm-project/issues/70547), which wasn't fixed by the alternative fix (c0de28b92e98acbeb73)\r\n\r\nI think as long as the call considered as ephemeral is not removed, we need to be conservative. To address the correctness issue quickly, I think we should revert the patch (as this patch does, it doens't revert cleanly)\r\n\r\nThis reverts commit 17fdaccccfad9b143e4aadbcdda7f645de127153.\r\n\r\nFixes https://github.com/llvm/llvm-project/issues/70547", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Analysis/CaptureTracking.cpp", "functions": ["CB", "EphValues", "SCT", "ReturnCaptures", "DT", "SimpleCaptureTracker"]}, {"filename": "llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp", "functions": ["F", "State"]}]}
{"pr_number": 70382, "url": "https://github.com/llvm/llvm-project/pull/70382", "title": "[RISCV] Implement cross basic block VXRM write insertion.", "body": "This adds a new pass to insert VXRM writes for vector instructions. With the goal of avoiding redundant writes.\r\n\r\nThe pass does 2 dataflow algorithms. The first is a forward data flow to calculate where a VXRM value is available. The second is a backwards dataflow to determine where a VXRM value is anticipated.\r\n\r\nFinally, we use the results of these two dataflows to insert VXRM writes where a value is anticipated, but not available.\r\n\r\nThe pass does not split critical edges so we aren't always able to eliminate all redundancy.\r\n\r\nThe pass will only insert vxrm writes on paths that always require it.", "feature_layers": ["ir"], "feature_directives": ["for", "critical"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp", "functions": ["printMBBReference"]}]}
{"pr_number": 71114, "url": "https://github.com/llvm/llvm-project/pull/71114", "title": "[mlir][sparse] support sparse constant to BSR conversion.", "body": "support direct convert from a constant tensor defined by SparseArrayElements to BSR", "feature_layers": ["parse", "ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/IR/SparseTensorDialect.cpp", "functions": ["emitError"]}]}
{"pr_number": 71125, "url": "https://github.com/llvm/llvm-project/pull/71125", "title": "[mlir][sparse] remove (some) deprecated dim/lvl methods", "body": "This removes the most obvious ones. The others are still TBD.", "feature_layers": ["parse", "ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/IR/SparseTensorDialect.cpp", "functions": ["toOrigDim", "toStoredDim"]}]}
{"pr_number": 71022, "url": "https://github.com/llvm/llvm-project/pull/71022", "title": "CodeGen: Port ExpandLargeDivRem to new pass manager", "body": "", "feature_layers": ["codegen"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/CodeGen/ExpandLargeDivRem.cpp", "functions": ["runImpl"]}]}
{"pr_number": 66860, "url": "https://github.com/llvm/llvm-project/pull/66860", "title": "[RISCV] Fix wrong implication for zvknhb.", "body": "", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/Sema/zvk-invalid-zvknha.c", "functions": ["test_zvk_features"]}]}
{"pr_number": 70893, "url": "https://github.com/llvm/llvm-project/pull/70893", "title": "[CodeGen][MIR] Support parsing of scalable vectors in MIR", "body": "This patch builds on the support for vectors by adding ability to parse scalable vectors in MIR.", "feature_layers": ["parse", "codegen", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/CodeGen/MIRParser/MIParser.cpp", "functions": ["error"]}]}
{"pr_number": 69473, "url": "https://github.com/llvm/llvm-project/pull/69473", "title": "[clang-format] Skip PP directives when determining brace kind", "body": "Pull request #65409 changed the brace kind heuristic to not treat a preprocessor if directive as a in statement, however, this caused some regressions.\r\n\r\nIf the contents of a brace don't immediately determine the brace kind, the heuristic will look at the characters immediately before and after the closing brace to determine the brace type.\r\n\r\nUnfortunately, if the closing brace was preceded by a preprocessor directive, for example `#endif`, the preceding token was `endif`, seen as just an identifier, so the braces were understood as a braced list.\r\n\r\nThis patch fixes this behaviour by skipping all preprocessor directives when calculating brace types. Comments were already being skipped, so now preprocessor lines are skipped alongside comments.\r\n\r\nFixes https://github.com/llvm/llvm-project/issues/68404", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Format/UnwrappedLineParser.cpp", "functions": ["MacroState"]}]}
{"pr_number": 69072, "url": "https://github.com/llvm/llvm-project/pull/69072", "title": "[clang][repl] fix `new` on Mac M1", "body": "On Mac M1, if you load something that transitively loads `#include <new>`, it will fail because \r\n\r\n```\r\nIn file included from <<< inputs >>>:1:\r\nIn file included from input_line_22:1:\r\nIn file included from /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX12.3.sdk/usr/include/c++/v1/memory:671:\r\nIn file included from /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX12.3.sdk/usr/include/c++/v1/__functional_base:23:\r\n/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX12.3.sdk/usr/include/c++/v1/new:214:70: error: 'internal_linkage' attribute does not appear on the first declaration\r\n  214 | _LIBCPP_NODISCARD_AFTER_CXX17 inline _LIBCPP_INLINE_VISIBILITY void* operator new  (std::size_t, void* __p) _NOEXCEPT {return __p;}\r\n      |                                                                      ^\r\ninput_line_0:3:11: note: previous declaration is here\r\n    3 |     void* operator new(__SIZE_TYPE__, void* __p) noexcept;\r\n      |           ^\r\nAssertion failed: (Ptr && \"dereferencing end() iterator\"), function operator*, file DeclBase.h, line 1315.\r\n```\r\n\r\nThis is because `MacOSX12.3.sdk/usr/include/c++/v1/__config` sets `_LIBCPP_INLINE_VISIBILITY` to be `__attribute__((__visibility__(\"hidden\"))) __attribute__((internal_linkage))`, which makes the `new` in `<new>` incompatible with the hardcoded decl `void* operator new(__SIZE_TYPE__, void* __p) noexcept;` in `clang/lib/Interpreter/Interpreter::Runtimes`. I believe the correct thing to do is replace that decl with `#include <new>` (as I've done here).", "feature_layers": ["runtime", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Interpreter/Interpreter.cpp", "functions": ["new", "__clang_Interpreter_SetValueCopyArr"]}, {"filename": "clang/unittests/Interpreter/InterpreterTest.cpp", "functions": ["cantFail"]}]}
{"pr_number": 71073, "url": "https://github.com/llvm/llvm-project/pull/71073", "title": "[analyzer][NFC] Add a test case to PR-70792 for Issue-59493", "body": "Following PR #70792 for issue #70464 \r\nAdd a test case for issue #59493 ", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/Analysis/issue-70464.cpp", "functions": ["entry1", "entry2"]}]}
{"pr_number": 70934, "url": "https://github.com/llvm/llvm-project/pull/70934", "title": "[lldb][AArch64] Read SME2's ZT0 register from Linux core files", "body": "The ZT0 register is always 64 bytes in size so it is a lot easier to handle than ZA which is scalable. In addition, reading an inactive ZT0 via ptrace returns all 0s, unlike ZA which returns no register data.\r\n\r\nThis means that a corefile from a process where ZA and ZT0 were inactive still contains an NT_ARM_ZT note and we can simply say that if it's there, then we should be able to read from it.\r\n\r\nAlong the way I removed a redundant check on the size of the ZA note. If that note's size is < the ZA header size, we do not have SME, and therefore could not have SME2 either.\r\n\r\nI have added ZT0 to the existing SME core files tests. This means that you need an SME2 system to generate them (Arm's FVP at this point). I think this is a fair tradeoff given that this is all running in simulation anyway and seperate ZT0 tests would be 99% identical copies of the ZA only tests.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "lldb/test/API/linux/aarch64/sme_core_file/main.c", "functions": ["volatile", "set_zt0_register"]}]}
{"pr_number": 71169, "url": "https://github.com/llvm/llvm-project/pull/71169", "title": "[MLIR][LLVM] Remove typed pointer conversion utils", "body": "This commit removes the no longer required type pointer helpers from the LLVM dialect conversion utils. Typed pointers have been deprecated for a while now and it's planned to soon remove them from the LLVM dialect.\r\n\r\nRelated PSA: https://discourse.llvm.org/t/psa-removal-of-typed-pointers-from-the-llvm-dialect/74502\r\n\r\nThese should be the last non-LLVM dialect usages of typed pointers. The next steps will be to cleanup the target conversion (already WIP), and then going ahead and removing typed pointers from the dialect.", "feature_layers": ["ir", "ast"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "mlir/lib/Conversion/LLVMCommon/Pattern.cpp", "functions": ["getTypeConverter"]}, {"filename": "mlir/lib/Conversion/LLVMCommon/TypeConverter.cpp", "functions": ["getPointerType", "conversion"]}, {"filename": "mlir/lib/Dialect/LLVMIR/IR/FunctionCallUtils.cpp", "functions": ["getVoidPtr", "getCharPtr"]}]}
{"pr_number": 69287, "url": "https://github.com/llvm/llvm-project/pull/69287", "title": "[NFC] [Serializer] Pack information in serializer", "body": "Previously, the boolean values will occupy spaces that can contain integers. It wastes the spaces especially if the boolean values are serialized consecutively. The patch tries to pack such consecutive boolean values (and enum values) so that we can save more spaces and so the times.\r\n\r\nBefore the patch, we need 4.478s (in my machine) to build the std module (https://libcxx.llvm.org/Modules.html) with 28712 bytes for size of the BMI. After the patch, the time becomes to 4.374s and the size becomes to 27388 bytes for the size of the BMI.\r\n\r\nThis is intended to be a NFC patch.\r\n\r\nThis patch doesn't optimize all such cases. We can do it later after we have consensus on this.", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Serialization/ASTReaderDecl.cpp", "functions": ["ParmVarDeclBits", "RecordDeclBits", "EnumDeclBits", "LambdaBits", "NamespaceDeclBits", "TagDeclBits", "CaptureBits", "VarDeclBits", "FunctionDeclBits", "DeclBits"]}]}
{"pr_number": 71143, "url": "https://github.com/llvm/llvm-project/pull/71143", "title": "[LLDB][easy] Fix a bug in DummySyntheticFrontEnd", "body": "DummySyntheticFrontEnd is implementing correctly CalculateNumChildren but not MightHaveChildren, where instead of delegating its action, it was returning true.\nThis fixes that simple bug.\n", "feature_layers": ["frontend"], "feature_directives": [], "files_changed": [{"filename": "lldb/source/Core/ValueObjectSyntheticFilter.cpp", "functions": ["MightHaveChildren"]}]}
{"pr_number": 69258, "url": "https://github.com/llvm/llvm-project/pull/69258", "title": "[orc][mach-o] Fix mixing objc and swift code in a single JITDylib", "body": "The system linker merges __objc_imageinfo flags values to select a compatible set of flags using the minimum swift version and only erroring on incompatible ABIs. Match that behaviour in the orc macho platform. One wrinkle is that the JIT can add new objects after the dylib is running code. In that case we only check for known incompatible flags and ignore the swift version. It's too late to change the flags at that point and swift version is unlikely to change runtime behaviour in practice.", "feature_layers": ["runtime"], "feature_directives": ["for", "single"], "files_changed": [{"filename": "llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp", "functions": ["Old", "ObjCImageInfoFlags", "rawFlags", "if", "formatv", "New", "Lock"]}]}
{"pr_number": 70970, "url": "https://github.com/llvm/llvm-project/pull/70970", "title": "[LLVM][AArch64] Add ASM constraints for reduced GPR register ranges.", "body": "[LLVM][AArch64] Add ASM constraints for reduced GPR register ranges.\r\n    \r\nThe patch adds the follow ASM constraints:\r\n  Uci => w8-w11/x8-x11\r\n  Ucj => w12-w15/x12-x15\r\n    \r\nThese constraints are required for SME load/store instructions\r\nwhere a reduced set of GPRs are used to specify ZA array vectors.\r\n    \r\nNOTE: GCC has agreed to use the same constraint syntax.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CodeGen/aarch64-inline-asm.c", "functions": ["test_reduced_gpr_constraints"]}, {"filename": "llvm/lib/Target/AArch64/AArch64ISelLowering.cpp", "functions": ["if"]}]}
{"pr_number": 71111, "url": "https://github.com/llvm/llvm-project/pull/71111", "title": "[RISCV] CSE by swapping conditional branches", "body": "DAGCombiner, as well as InstCombine, tend to canonicalize GE/LE into GT/LT, namely:\r\n```\r\nX >= C --> X > (C - 1)\r\n```\r\nWhich sometime generates off-by-one constants that could have been CSE'd with surrounding constants.\r\nInstead of changing such canonicalization, this patch tries to swap those branch conditions post-isel, in the hope of resurfacing more constant CSE opportunities. More specifically, it performs the following optimization:\r\n\r\nFor two constants C0 and C1 from\r\n```\r\nli Y, C0\r\nli Z, C1\r\n```\r\nTo remove redundnat `li Y, C0`,\r\n 1. if C1 = C0 + 1 we can turn: \r\n    (a) blt Y, X -> bge X, Z\r\n    (b) bge Y, X -> blt X, Z\r\n 2. if C1 = C0 - 1 we can turn: \r\n    (a) blt X, Y -> bge Z, X\r\n    (b) bge X, Y -> blt Z, X\r\n\r\nThis optimization will be done by PeepholeOptimizer through RISCVInstrInfo::optimizeCondBranch.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVInstrInfo.cpp", "functions": ["Register"]}]}
{"pr_number": 70973, "url": "https://github.com/llvm/llvm-project/pull/70973", "title": "[Clang] Preserve coroutine parameter referenced state", "body": "This PR is proposing a fix for https://github.com/llvm/llvm-project/issues/65971.\r\n\r\nPreviously, given a coroutine like this\r\n```\r\ntask foo(int a) {\r\n  co_return;\r\n}\r\n```\r\nParameter `a` is never used. However, because C++ coroutines move constructs the variable to a heap allocated coroutine activation frame, we considered all parameters referenced. When diagnosing unused parameters, we cannot distinguish if the variable reference was due to coroutine parameter moves. \r\n\r\nCompiler Explorer shows that GCC warns against this case correctly, but clang does not: https://godbolt.org/z/Wo7dfqeaf\r\n\r\nThis patch addresses this issue by preserving the original `ParmVarDecl`'s `Referenced` state.", "feature_layers": [], "feature_directives": ["task", "for", "allocate"], "files_changed": [{"filename": "clang/test/SemaCXX/warn-unused-parameters-coroutine.cpp", "functions": ["final_suspend", "unhandled_exception", "foo", "bar", "await_suspend", "initial_suspend", "return_void", "await_ready", "get_return_object", "await_resume", "create_closure"]}]}
{"pr_number": 70738, "url": "https://github.com/llvm/llvm-project/pull/70738", "title": "[InlineAsm] Steal a bit to denote a register is foldable", "body": "When using the inline asm constraint string \"rm\" (or \"g\"), we generally\r\nwould like the compiler to choose \"r\", but it is permitted to choose \"m\"\r\nif there's register pressure. This is distinct from \"r\" in which the\r\nregister is not permitted to be spilled to the stack.\r\n\r\nThe decision of which to use must be made at some point.  Currently, the\r\ninstruction selection frameworks (ISELs) make the choice, and the\r\nregister allocators had better be able to handle the result.\r\n\r\nSteal a bit from Storage when using registers operands to disambiguate\r\nbetween the two cases.  Add helpers/getters/setters, and print in MIR\r\nwhen such a register is spillable.\r\n\r\nThe getter will later be used by the register allocation frameworks (and\r\nasserted by the ISELs) while the setters will be used by the instruction\r\nselection frameworks.\r\n\r\nLink: https://github.com/llvm/llvm-project/issues/20571", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/CodeGen/MachineInstr.cpp", "functions": ["F"]}]}
{"pr_number": 71106, "url": "https://github.com/llvm/llvm-project/pull/71106", "title": "[InstrProf] Do not block functions from PGOUse", "body": "The `skipPGO()` function was added in https://reviews.llvm.org/D137184. Unfortunately, it also blocked functions from being annotated (PGOUse), which I believe will cause confusion to users if a function has a profile but it is not PGO'd.\r\n\r\nThe docs for `noprofile` and `skipprofile` only claim to block instrumentation, not PGO optimization: https://llvm.org/docs/LangRef.html", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp", "functions": ["skipPGOUse", "skipPGO", "skipPGOGen"]}]}
{"pr_number": 70392, "url": "https://github.com/llvm/llvm-project/pull/70392", "title": "[lldb] Make use of Scripted{Python,}Interface for ScriptedThreadPlan", "body": "This patch makes ScriptedThreadPlan conforming to the ScriptedInterface\r\n& ScriptedPythonInterface facilities by introducing 2\r\nScriptedThreadPlanInterface & ScriptedThreadPlanPythonInterface classes.\r\n\r\nThis allows us to get rid of every ScriptedThreadPlan-specific SWIG\r\nmethod and re-use the same affordances as other scripting offordances,\r\nlike Scripted{Process,Thread,Platform} & OperatingSystem.\r\n\r\nTo do so, this adds new transformer methods for `ThreadPlan`, `Stream` &\r\n`Event`, to allow the bijection between C++ objects and their python\r\ncounterparts.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "lldb/source/Plugins/ScriptInterpreter/Python/Interfaces/ScriptedThreadPlanPythonInterface.cpp", "functions": ["ScriptedThreadPlanInterface"]}, {"filename": "lldb/source/Plugins/ScriptInterpreter/Python/ScriptInterpreterPython.cpp", "functions": ["StructuredPythonObject"]}]}
{"pr_number": 70990, "url": "https://github.com/llvm/llvm-project/pull/70990", "title": "[indvars] Support known positive extends in getExtendedOperandRecurrence", "body": "IndVars has the existing notion of a narrow definition which is known to positive and thus both sign and zero extension kinds are actually the same operations.  There's existing logic for forming a SCEV based on the extension kind and the no-wrap flags.  This change extends that logic to form the opposite extension kind for a positive def if doing so is allowed by the flags.  Note that we already do something analogous for the getWideRecurrence case as well.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Utils/SimplifyIndVar.cpp", "functions": ["if"]}]}
{"pr_number": 71160, "url": "https://github.com/llvm/llvm-project/pull/71160", "title": "[clang][NFC] Refactor `TagTypeKind`", "body": "This patch converts TagTypeKind into scoped enum. Among other benefits, this allows us to forward-declare it where necessary.\r\n\r\nI plan to land this patch as soon as pre-commit CI passes, probably not waiting for Windows bot.", "feature_layers": [], "feature_directives": ["for", "declare"], "files_changed": [{"filename": "clang/lib/AST/Decl.cpp", "functions": ["TagDecl"]}, {"filename": "clang/lib/AST/DeclTemplate.cpp", "functions": ["CXXRecordDecl"]}, {"filename": "clang/lib/Index/USRGeneration.cpp", "functions": ["llvm_unreachable"]}, {"filename": "clang/lib/Sema/SemaDeclCXX.cpp", "functions": ["new"]}, {"filename": "clang/lib/Sema/SemaType.cpp", "functions": ["llvm_unreachable"]}]}
{"pr_number": 71165, "url": "https://github.com/llvm/llvm-project/pull/71165", "title": "Refactor ModuleToObject to offer more flexibility to subclass (NFC)", "body": "Some specific implementation of the offload may want more customization, and\neven avoid using LLVM in-tree to dispatch the ISA translation to a custom\nsolution. This refactoring makes it possible for such implementation to work\nwithout even configuring the target backend in LLVM.\n", "feature_layers": [], "feature_directives": ["for", "target"], "files_changed": [{"filename": "clang/lib/AST/Decl.cpp", "functions": ["TagDecl"]}, {"filename": "clang/lib/AST/DeclTemplate.cpp", "functions": ["CXXRecordDecl"]}, {"filename": "clang/lib/Index/USRGeneration.cpp", "functions": ["llvm_unreachable"]}, {"filename": "clang/lib/Sema/SemaDeclCXX.cpp", "functions": ["new"]}, {"filename": "clang/lib/Sema/SemaType.cpp", "functions": ["llvm_unreachable"]}, {"filename": "clang/lib/Serialization/ASTReaderDecl.cpp", "functions": ["ParmVarDeclBits", "RecordDeclBits", "EnumDeclBits", "LambdaBits", "NamespaceDeclBits", "TagDeclBits", "CaptureBits", "VarDeclBits", "FunctionDeclBits", "DeclBits"]}, {"filename": "clang/test/CodeGen/aarch64-inline-asm.c", "functions": ["test_reduced_gpr_constraints"]}, {"filename": "clang/test/CodeGen/aarch64-sve-intrinsics/acle_sve_reinterpret-bfloat.c", "functions": ["test_svreinterpret_bf16_s32", "test_svreinterpret_bf16_u32", "test_svreinterpret_f16_bf16", "test_svreinterpret_s32_bf16", "test_svreinterpret_bf16_s64", "test_svreinterpret_bf16_u64", "test_svreinterpret_bf16_f64", "test_svreinterpret_bf16_bf16", "test_svreinterpret_u16_bf16", "test_svreinterpret_u64_bf16", "test_svreinterpret_bf16_s8", "test_svreinterpret_f64_bf16", "test_svreinterpret_bf16_f32", "test_svreinterpret_bf16_s16", "test_svreinterpret_bf16_f16", "test_svreinterpret_bf16_u8", "test_svreinterpret_f32_bf16", "SVE_ACLE_FUNC", "test_svreinterpret_s8_bf16", "test_svreinterpret_s64_bf16", "test_svreinterpret_bf16_u16", "test_svreinterpret_s16_bf16", "test_svreinterpret_u32_bf16", "test_svreinterpret_u8_bf16"]}, {"filename": "clang/test/CodeGen/aarch64-sve-intrinsics/acle_sve_reinterpret.c", "functions": ["test_svreinterpret_s32_s16", "test_svreinterpret_u16_f16", "test_svreinterpret_u16_s32", "test_svreinterpret_u8_f64", "test_svreinterpret_f16_u8", "test_svreinterpret_u32_u8", "test_svreinterpret_u8_u8", "test_svreinterpret_s32_f32", "test_svreinterpret_s8_s32", "test_svreinterpret_f32_f16", "test_svreinterpret_f16_s8", "test_svreinterpret_s16_u16", "test_svreinterpret_f16_f32", "test_svreinterpret_f64_s8", "test_svreinterpret_s16_f32", "test_svreinterpret_s32_u16", "test_svreinterpret_s32_s32", "test_svreinterpret_u32_f16", "test_svreinterpret_s16_f16", "test_svreinterpret_f32_s16", "test_svreinterpret_f16_s16", "test_svreinterpret_s32_u8", "SVE_ACLE_FUNC", "test_svreinterpret_s8_f32", "test_svreinterpret_f32_u32", "test_svreinterpret_s64_u64", "test_svreinterpret_f64_s64", "test_svreinterpret_u64_s32", "test_svreinterpret_s32_s8", "test_svreinterpret_u64_u32", "test_svreinterpret_s64_s16", "test_svreinterpret_u16_s16", "test_svreinterpret_s16_s64", "test_svreinterpret_u8_s16", "test_svreinterpret_f32_u64", "test_svreinterpret_s64_f16", "test_svreinterpret_s32_s64", "test_svreinterpret_s32_u64", "test_svreinterpret_s8_s16", "test_svreinterpret_u16_s8", "test_svreinterpret_f64_u16", "test_svreinterpret_f32_s8", "test_svreinterpret_u64_u64", "test_svreinterpret_s64_u32", "test_svreinterpret_u32_u32", "test_svreinterpret_f32_s64", "test_svreinterpret_u16_u16", "test_svreinterpret_u16_u8", "test_svreinterpret_u64_s16", "test_svreinterpret_f32_u8", "test_svreinterpret_s16_u64", "test_svreinterpret_u32_s64", "test_svreinterpret_u8_f16", "test_svreinterpret_u8_f32", "test_svreinterpret_u64_u8", "test_svreinterpret_s8_u64", "test_svreinterpret_f64_f64", "test_svreinterpret_u8_u32", "test_svreinterpret_f64_f32", "test_svreinterpret_u16_u64", "test_svreinterpret_s8_s8", "test_svreinterpret_u32_u64", "test_svreinterpret_f16_u64", "test_svreinterpret_u32_f64", "test_svreinterpret_u64_s64", "test_svreinterpret_s8_u32", "test_svreinterpret_f32_u16", "test_svreinterpret_f16_f16", "test_svreinterpret_s32_f64", "test_svreinterpret_s64_u16", "test_svreinterpret_s8_f16", "test_svreinterpret_u64_f16", "test_svreinterpret_u8_s8", "test_svreinterpret_s64_f32", "test_svreinterpret_u8_u64", "test_svreinterpret_s16_u8", "test_svreinterpret_u16_f64", "test_svreinterpret_u32_s16", "test_svreinterpret_u64_f32", "test_svreinterpret_u32_s8", "test_svreinterpret_f32_f32", "test_svreinterpret_s16_f64", "test_svreinterpret_f16_s64", "test_svreinterpret_s8_s64", "test_svreinterpret_u64_f64", "test_svreinterpret_u16_s64", "test_svreinterpret_f64_u64", "test_svreinterpret_u16_u32", "test_svreinterpret_f16_u16", "test_svreinterpret_s8_u8", "test_svreinterpret_u32_f32", "test_svreinterpret_u64_s8", "test_svreinterpret_f16_u32", "test_svreinterpret_u32_s32", "test_svreinterpret_f16_s32", "test_svreinterpret_s64_s8", "test_svreinterpret_u32_u16", "test_svreinterpret_s16_s32", "test_svreinterpret_u16_f32", "test_svreinterpret_s64_u8", "test_svreinterpret_f32_s32", "test_svreinterpret_f64_f16", "test_svreinterpret_s64_f64", "test_svreinterpret_u8_u16", "test_svreinterpret_s64_s64", "test_svreinterpret_s32_u32", "test_svreinterpret_u8_s64", "test_svreinterpret_s16_u32", "test_svreinterpret_s16_s8", "test_svreinterpret_u64_u16", "test_svreinterpret_f64_s32", "test_svreinterpret_u8_s32", "test_svreinterpret_f64_u32", "test_svreinterpret_s32_f16", "test_svreinterpret_f16_f64", "test_svreinterpret_f64_s16", "test_svreinterpret_s8_u16", "test_svreinterpret_f32_f64", "test_svreinterpret_s16_s16", "test_svreinterpret_f64_u8", "test_svreinterpret_s8_f64", "test_svreinterpret_s64_s32"]}, {"filename": "clang/utils/TableGen/SveEmitter.cpp", "functions": ["applyTypespec", "TS", "Float", "FromV", "ToV"]}, {"filename": "llvm/lib/CodeGen/MachineInstr.cpp", "functions": ["F"]}, {"filename": "llvm/lib/DWARFLinker/DWARFLinker.cpp", "functions": ["guessToolchainBaseDir"]}, {"filename": "llvm/lib/DWARFLinkerParallel/DWARFLinkerCompileUnit.cpp", "functions": ["guessToolchainBaseDir"]}, {"filename": "llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp", "functions": ["Old", "ObjCImageInfoFlags", "rawFlags", "if", "formatv", "New", "Lock"]}, {"filename": "llvm/lib/IR/ConstantFold.cpp", "functions": ["llvm_unreachable", "areGlobalsPotentiallyEqual", "evaluateICmpRelation", "if", "evaluateFCmpRelation"]}, {"filename": "llvm/lib/Support/RISCVISAInfo.cpp", "functions": ["if"]}, {"filename": "llvm/lib/Target/AArch64/AArch64ISelLowering.cpp", "functions": ["if", "parsePredicateConstraint"]}, {"filename": "llvm/lib/Target/RISCV/RISCVInstrInfo.cpp", "functions": ["Register", "II", "isLoadImm"]}, {"filename": "llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp", "functions": ["skipPGOUse", "skipPGO", "skipPGOGen"]}, {"filename": "llvm/lib/Transforms/Utils/SimplifyIndVar.cpp", "functions": ["if"]}, {"filename": "llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp", "functions": ["SubMask", "RegMask", "ShufflesRes", "ExtractMask", "VecMask"]}, {"filename": "llvm/utils/TableGen/CallingConvEmitter.cpp", "functions": ["StringRef"]}, {"filename": "mlir/lib/Conversion/LLVMCommon/Pattern.cpp", "functions": ["getTypeConverter"]}, {"filename": "mlir/lib/Conversion/LLVMCommon/TypeConverter.cpp", "functions": ["getPointerType", "conversion"]}, {"filename": "mlir/lib/Dialect/LLVMIR/IR/FunctionCallUtils.cpp", "functions": ["getVoidPtr", "getCharPtr"]}, {"filename": "openmp/libomptarget/DeviceRTL/src/Reduction.cpp", "functions": ["__kmpc_nvptx_end_reduce_nowait", "__kmpc_nvptx_end_reduce"]}]}
{"pr_number": 71215, "url": "https://github.com/llvm/llvm-project/pull/71215", "title": "[test][HWASAN] Force interceptors tests for memcmp and bcmp call interceptor", "body": "", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "compiler-rt/test/hwasan/TestCases/bcmp.cpp", "functions": ["bcmp"]}, {"filename": "compiler-rt/test/hwasan/TestCases/memcmp.cpp", "functions": ["memcmp"]}]}
{"pr_number": 71198, "url": "https://github.com/llvm/llvm-project/pull/71198", "title": "LegalizeVectorTypes: fix bug in widening of vec result in xrint", "body": "Fix a bug introduced in 98c90a1 (ISel: introduce vector ISD::LRINT, ISD::LLRINT; custom RISCV lowering), where ISD::LRINT and ISD::LLRINT used WidenVecRes_Unary to widen the vector result. This leads to incorrect CodeGen for RISC-V fixed-vectors of length 3, and a crash in SelectionDAG when we try to lower llvm.lrint.vxi32.vxf64 on i686. Fix the bug by implementing a correct WidenVecRes_XRINT.\r\n\r\nFixes #71187.", "feature_layers": ["codegen"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp", "functions": ["dl"]}]}
{"pr_number": 71231, "url": "https://github.com/llvm/llvm-project/pull/71231", "title": "[mlir][sparse] reformat SparseTensorCodegen file", "body": "", "feature_layers": ["parse", "codegen", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/Transforms/SparseTensorCodegen.cpp", "functions": ["genCast", "stt", "getReassociationForFlattening"]}]}
{"pr_number": 70841, "url": "https://github.com/llvm/llvm-project/pull/70841", "title": "[Clang] Emit type metadata on vtables when IRPGO instrumentation option is on.", "body": "The motivating use case is to have type metadata on vtables if IRPGO instrumentation is on (without the requirement of `-fwhole-program-vtables` or `-flto`).\r\n\r\nA related rfc is in https://discourse.llvm.org/t/rfc-dynamic-type-profiling-and-optimizations-in-llvm/74600", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "clang/test/Driver/type-metadata.cpp", "functions": ["g", "foo", "dh1", "df1", "af", "df3", "f", "h", "dg1", "df2"]}]}
{"pr_number": 70986, "url": "https://github.com/llvm/llvm-project/pull/70986", "title": "[OpenMP] Guard Virtual Memory Management API and Types", "body": "", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "openmp/libomptarget/plugins-nextgen/cuda/src/rtl.cpp", "functions": ["supportVAManagement"]}]}
{"pr_number": 69665, "url": "https://github.com/llvm/llvm-project/pull/69665", "title": "[MLIR][Mesh] Add sharding propagation pass", "body": "- add `ShardingInterface` and the methods' default implementation\r\n- add `ShardingInterface` implementation for element-wise and matmul ops in TOSA dialect\r\n- add sharding propagation pass\r\n- add Mesh_IteratorType enum\r\n\r\nSmall changes in non-mesh folder:\r\n- add `getMultiDimMapWithTargets` method in AffineMap.h", "feature_layers": ["ir"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "mlir/lib/Dialect/Mesh/Interfaces/ShardingInterface.cpp", "functions": ["failure", "success"]}, {"filename": "mlir/lib/Dialect/Mesh/Transforms/ShardingPropagation.cpp", "functions": ["getOperationsVector", "signalPassFailure", "getReversedOperationsVector"]}, {"filename": "mlir/lib/Dialect/Tosa/IR/ShardingInterfaceImpl.cpp", "functions": ["registerElemwiseOne", "getIndexingMaps", "registerElemwiseAll", "getLoopIteratorTypes", "types"]}, {"filename": "mlir/lib/IR/Builders.cpp", "functions": ["getArrayAttr", "getDenseI32ArrayAttr"]}]}
{"pr_number": 68235, "url": "https://github.com/llvm/llvm-project/pull/68235", "title": "Port Swift's merge function pass to llvm: merging functions that differ in constants", "body": "See RFC for details: https://discourse.llvm.org/t/rfc-for-moving-swift-s-merge-function-pass-to-llvm/73778\r\n\r\nWe will need to refactor extension to FunctionComparator/FunctionHash to StructuralHash. This patch adds a new pass which is ported from Swift, and will need to discuss on how to migrate Swift\u2019s pass over after we land this in llvm.\r\n\r\nCreate this PR to get some early review on the patch.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/IPO/MergeFunctionsIgnoringConst.cpp", "functions": ["triple", "canParameterizeCallOperand", "isCalleeOperand", "FnTree", "F"]}]}
{"pr_number": 71261, "url": "https://github.com/llvm/llvm-project/pull/71261", "title": "[MLIR][Mesh] Add sharding propagation pass", "body": "Add a pass that propagates sharding information throughout the graph.\r\nAfter this pass, each of the operations' operands and results is\r\nannotated with a mesh.shard operation.\r\n\r\nThe pass is driven by a newly added ShardingInterface, and an implementation\r\nfor element-wise and matmul ops in the TOSA dialect is provided.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Mesh/Interfaces/ShardingInterface.cpp", "functions": ["success", "guard", "splitAxes", "failure", "isReductionLoop", "stringifyEnum", "seenIds"]}, {"filename": "mlir/lib/Dialect/Mesh/Transforms/ShardingPropagation.cpp", "functions": ["runOnOperation", "success", "signalPassFailure", "visitOp", "builder", "failure"]}, {"filename": "mlir/lib/Dialect/Tosa/IR/ShardingInterfaceImpl.cpp", "functions": ["registerElemwiseOne", "getIndexingMaps", "registerElemwiseAll", "getLoopIteratorTypes", "types"]}]}
{"pr_number": 71062, "url": "https://github.com/llvm/llvm-project/pull/71062", "title": "[DebugInfo] Use human-friendly printing for DWARF column attributes", "body": "This prints DWARF attributes that describes source columns as base 10 integers for easier comprehension (via `llvm-dwarfdump` and similar tools) and matches the behaviour for source line attributes.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/DebugInfo/DWARF/DWARFDie.cpp", "functions": ["if"]}]}
{"pr_number": 69884, "url": "https://github.com/llvm/llvm-project/pull/69884", "title": "[InstCombine] Improve eq/ne by parts to handle ult/ugt equality pattern", "body": "- [InstCombine] Add tests for new eq/ne patterns combining eq/ne by parts; NFC\n- [InstCombine] Improve eq/ne by parts to handle `ult/ugt` equality pattern.\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp", "functions": ["matchIntPart"]}]}
{"pr_number": 70630, "url": "https://github.com/llvm/llvm-project/pull/70630", "title": "[mlir][transform] LISH: Add transform op", "body": "Add a transform op for loop-invariant subset hoisting. Delete the old transform op from the Linalg dialect.\r\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Transform/LoopExtension/LoopExtension.cpp", "functions": ["init"]}, {"filename": "mlir/lib/Transforms/LoopInvariantCodeMotion.cpp", "functions": ["rewriter"]}, {"filename": "mlir/lib/Transforms/Utils/LoopInvariantCodeMotionUtils.cpp", "functions": ["rewriter"]}]}
{"pr_number": 71010, "url": "https://github.com/llvm/llvm-project/pull/71010", "title": "[mlir][memref] Remove redundant `memref.tensor_store` op", "body": "`bufferization.materialize_in_destination` should be used instead. Both ops bufferize to a memcpy. This change also conceptually cleans up the memref dialect a bit: the memref dialect no longer contains ops that operate on tensor values.\r\n", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/Bufferization/IR/BufferizationOps.cpp", "functions": ["failure"]}, {"filename": "mlir/lib/Dialect/MemRef/Transforms/BufferizableOpInterfaceImpl.cpp", "functions": ["failure", "success"]}]}
{"pr_number": 70897, "url": "https://github.com/llvm/llvm-project/pull/70897", "title": "[mlir] Turn `memref/tensor.dim` reification into canonicalization pattern", "body": "Instead of having a dedicated pass to fold `memref/tensor.dim` of ops that implement `ReifyRankedShapedTypeOpInterface`, turn the respective patterns into canonicalization patterns. This allows us to delete canonicalization patterns that do the same for specific ops. (Some of these canonicalization patterns do not have proper error checking; e.g., they crash when the dimension index is out-of-bounds.)\r\n\r\nThis change also decouples the tensor/memref transforms build units a bit: there is now one fewer dependency on `tensor.dim` in `MemRef/Transforms/ResolveShapedTypeResultDims.cpp`. The canonicalization pattern is now part of `mlir/Interfaces/InferTypeOpInterface.h`.\r\n\r\nAlso add a new `transform.tensor.resolve_ranked_shaped_type_result_dims` transform op. (`transform.memref.resolve_ranked_shaped_type_result_dims` no longer applies to `tensor.dim` ops.)", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Bufferization/IR/BufferizationOps.cpp", "functions": ["failure", "success"]}, {"filename": "mlir/lib/Dialect/MemRef/Transforms/ResolveShapedTypeResultDims.cpp", "functions": ["runOnOperation", "success", "signalPassFailure", "patterns", "failure", "initialize"]}, {"filename": "mlir/lib/Dialect/Tensor/IR/TensorOps.cpp", "functions": ["failure", "success"]}]}
{"pr_number": 71288, "url": "https://github.com/llvm/llvm-project/pull/71288", "title": "[mlir][spirv][cf] legalize block arguments when convert cf to spirv", "body": "When converting branches, legalize target block arguments first.\r\n\r\nFixes llvm#70813", "feature_layers": ["ir"], "feature_directives": ["target"], "files_changed": [{"filename": "mlir/lib/Conversion/ControlFlowToSPIRV/ControlFlowToSPIRV.cpp", "functions": ["failure", "success"]}]}
{"pr_number": 70799, "url": "https://github.com/llvm/llvm-project/pull/70799", "title": "[StackProtector] Do not emit the stack protector on GPU architectures", "body": "Summary:\nThis patch changes the code generation to not emit the stack protector\nmetadata on unsupported architectures. The issue was caused by system\ntoolchains emitting stack protector option by default which would lead\nto errors when compiling for the GPU. I elected to change the code\ngeneration as we may want to update this in the future so we should keep\nthe `clang` Driver code common. Although the user can use some\ncombination of `-Xarch-device -fno-stack-protector` to override this, it\nis very irritating to do when we shouldn't emit this incompatible IR\nanyway.\n\nFixes: https://github.com/llvm/llvm-project/issues/65911\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/CodeGen/CodeGenModule.cpp", "functions": ["if"]}]}
{"pr_number": 71105, "url": "https://github.com/llvm/llvm-project/pull/71105", "title": "[GISel] Remove BitVector from RegBank. Use tablegen CoverageData tables directly. NFC", "body": "RegBanks are allocated as global variables. The use of BitVector causes a static global constructor to be used. The BitVector is initialized from a table of bits that is created by tablegen. We can keep a pointer to that data and use it as the bit vector instead.\r\n\r\nThis does require a little bit of manual indexing and reimplementation of BitVector::count.", "feature_layers": ["ir"], "feature_directives": ["allocate"], "files_changed": [{"filename": "llvm/lib/CodeGen/RegisterBank.cpp", "functions": ["ID"]}]}
{"pr_number": 71192, "url": "https://github.com/llvm/llvm-project/pull/71192", "title": "[libc++] Improve tests for std::find_if and std::find_if_not", "body": "These tests are salvaged from https://reviews.llvm.org/D112152 which I decided not to pursue anymore.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "libcxx/test/std/algorithms/alg.nonmodifying/alg.find/find_if.pass.cpp", "functions": ["main", "operator", "eq", "test_iter", "test", "c", "test_constexpr", "EqualTo"]}, {"filename": "libcxx/test/std/algorithms/alg.nonmodifying/alg.find/find_if_not.pass.cpp", "functions": ["DifferentFrom", "ne", "main", "operator", "test_iter", "test", "c", "test_constexpr"]}]}
{"pr_number": 69949, "url": "https://github.com/llvm/llvm-project/pull/69949", "title": "[mlir][spirv] Implement gpu::TargetAttrInterface", "body": "Create SPIRV Target Attribute to enable GPU compilation pipeline. The Target Attribute is modeled after the existing spriv.target_env Plan is to use this new attribute to enable GPU compilation pipeline for OpenCL kernels only.\r\nThe changes do not impact Vulkan shaders using milr-vulkan-runner. New GPU Dialect transform pass spirv-attach-target is implemented for attaching attribute from CLI.\r\ngpu-module-to-binary pass now works with GPU module that has SPIRV module with OpenCL kernel functions inside.", "feature_layers": ["ir"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "mlir/lib/Dialect/GPU/Transforms/SPIRVAttachTarget.cpp", "functions": ["runOnOperation", "matcher", "signalPassFailure", "builder", "getDependentDialects", "caps", "exts"]}, {"filename": "mlir/lib/Target/SPIRV/Target.cpp", "functions": ["builder"]}]}
{"pr_number": 69941, "url": "https://github.com/llvm/llvm-project/pull/69941", "title": "[mlir] Prepare convert-gpu-to-spirv for OpenCL support", "body": "This includes a couple of changes to pass behavior for OpenCL kernels. Vulkan shaders are not impacted by the changes.\r\n\r\n1. SPIRV module is placed inside GPU module. This change is required for gpu-module-to-binary to work correctly as it expects kernel function to be inside the GPU module.\r\n2. A dummy func.func with same kernel name as gpu.func is created. GPU compilation pipeline defers lowering of gpu launch kernel op. Since spirv.func is not directly tied to gpu launch kernel, a dummy func.func is required to avoid legalization issues.\r\n3. Use correct mapping when mapping MemRef memory space to SPIR-V storage class for OpenCL kernels.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Conversion/GPUToSPIRV/GPUToSPIRVPass.cpp", "functions": ["signalPassFailure", "targetEnv"]}]}
{"pr_number": 70983, "url": "https://github.com/llvm/llvm-project/pull/70983", "title": "[OpenMP] Simplify parallel reductions", "body": "A lot of the code was from a time when we had multiple parallel levels. The new runtime is much simpler, the code can be simplified a lot which should speed up reductions too.", "feature_layers": ["runtime"], "feature_directives": ["parallel"], "files_changed": [{"filename": "openmp/libomptarget/DeviceRTL/src/Reduction.cpp", "functions": ["if", "nvptx_parallel_reduce_nowait", "gpu_irregular_simd_reduce"]}, {"filename": "openmp/libomptarget/test/offloading/generic_reduction.c", "functions": ["main"]}]}
{"pr_number": 69432, "url": "https://github.com/llvm/llvm-project/pull/69432", "title": "[Clang][Sema] Skip RecordDecl when checking scope of declarations", "body": "In non C++ mode, struct definitions does not create a scope for declaration.\r\n\r\nFixes #41302\r\n\r\nFixes #44080", "feature_layers": ["sema"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/Sema/nested-redef.c", "functions": ["f4"]}]}
{"pr_number": 70405, "url": "https://github.com/llvm/llvm-project/pull/70405", "title": "[VP][RISCV] Add llvm.experimental.vp.reverse.", "body": "This is similar to vector.reverse, but only reverses the first EVL elements.\r\n\r\nI extracted this code from our downstream. Some of it may have come from https://repo.hca.bsc.es/gitlab/rferrer/llvm-epi/ originally.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp", "functions": ["DL"]}, {"filename": "llvm/lib/Target/RISCV/RISCVISelLowering.cpp", "functions": ["llvm_unreachable"]}]}
{"pr_number": 68310, "url": "https://github.com/llvm/llvm-project/pull/68310", "title": "[ConstantRange] Handle `Intrinsic::ctpop`", "body": "This patch adds support for `Intrinsic::ctpop` in ConstantRange. It calculates the range in O(1) with the LCP-based method.\r\n\r\nMigrated from https://reviews.llvm.org/D153505.\r\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/IR/ConstantRange.cpp", "functions": ["getUnsignedPopCountRange"]}]}
{"pr_number": 70674, "url": "https://github.com/llvm/llvm-project/pull/70674", "title": "[clang][DebugInfo][NFC] Add createConstantValueExpression helper", "body": "This patch factors out the code to create a DIExpression from an APValue into a separate helper function.\r\n\r\nThis will be useful in a follow-up patch where we re-use this logic elsewhere.\r\n\r\nPre-requisite for https://github.com/llvm/llvm-project/pull/70639", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/CodeGen/CGDebugInfo.cpp", "functions": ["if"]}]}
{"pr_number": 71004, "url": "https://github.com/llvm/llvm-project/pull/71004", "title": "[lldb][DWARFASTParserClang] Fetch constant value from variable defintion if available", "body": "https://github.com/llvm/llvm-project/pull/70639 proposes moving the `DW_AT_const_value` on inline static members from the declaration DIE to the definition DIE. This patch makes sure the LLDB's expression evaluator can continue to support static initialisers even if the declaration doesn't have a `DW_AT_const_value` anymore.\r\n\r\nPreviously the expression evaluator would find the constant for a VarDecl from its declaration `DW_TAG_member` DIE. In cases where the initialiser was specified out-of-class, LLDB could find it during symbol resolution.\r\n\r\nHowever, neither of those will work for constants, since we don't have a constant attribute on the declaration anymore and we don't have constants in the symbol table.\r\n\r\n**Testing**\r\n\r\n* If https://github.com/llvm/llvm-project/pull/70639 were to land without this patch then most of the `TestConstStaticIntegralMember.py` would start failing", "feature_layers": ["parse", "ast", "parser"], "feature_directives": ["for"], "files_changed": [{"filename": "lldb/test/API/lang/cpp/const_static_integral_member/main.cpp", "functions": ["func", "bar"]}]}
{"pr_number": 67000, "url": "https://github.com/llvm/llvm-project/pull/67000", "title": "[OpenMP][OMPIRBuilder] Add support to omp target parallel", "body": "Added support for LLVM IR code generation which is used for handling omp target parallel code. The call for __kmpc_parallel_51 is generated and the parallel region is outlined to separate function.\r\n\r\nThe proper setup of kmpc_target_init mode is not included in the commit. It is assumed that the SPMD mode for target initialization is properly set by other codegen functions.\r\n\r\nThis PR depends on: https://github.com/llvm/llvm-project/pull/66998 ", "feature_layers": ["codegen", "ir", "ompirbuilder"], "feature_directives": ["parallel", "for", "target"], "files_changed": [{"filename": "llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp", "functions": ["MDB", "ExitIP"]}, {"filename": "llvm/unittests/Frontend/OpenMPIRBuilderTest.cpp", "functions": ["AllocaIP", "OMPBuilder", "Builder", "Loc"]}]}
{"pr_number": 67917, "url": "https://github.com/llvm/llvm-project/pull/67917", "title": "[ConstantRange] Handle `Intrinsic::cttz`", "body": "This patch adds support for `Intrinsic::cttz` in ConstantRange. It calculates the range in O(1) with the LCP-based method.\r\n\r\nMigrated from https://reviews.llvm.org/D153505.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/IR/ConstantRange.cpp", "functions": ["getUnsignedCountTrailingZerosRange", "getNonEmpty"]}, {"filename": "llvm/unittests/IR/ConstantRangeTest.cpp", "functions": ["APInt"]}]}
{"pr_number": 68186, "url": "https://github.com/llvm/llvm-project/pull/68186", "title": "[AMDGPU] ISel for @llvm.amdgcn.cs.chain intrinsic", "body": "The @llvm.amdgcn.cs.chain intrinsic is essentially a call. The call parameters are bundled up into 2 intrinsic arguments, one for those that should go in the SGPRs (the 3rd intrinsic argument), and one for those that should go in the VGPRs (the 4th intrinsic argument). Both will often be some kind of aggregate.\r\n\r\nBoth instruction selection frameworks have some internal representation for intrinsics (G_INTRINSIC[_WITH_SIDE_EFFECTS] for GlobalISel, ISD::INTRINSIC_[VOID|WITH_CHAIN] for DAGISel), but we can't use those because aggregates are dissolved very early on during ISel and we'd lose the inreg information. Therefore, this patch shortcircuits both the IRTranslator and SelectionDAGBuilder to lower this intrinsic as a call from the very start. It tries to use the existing infrastructure as much as possible, by calling into the code for lowering tail calls.\r\n\r\nThis has already gone through a few rounds of review in Phab:\r\n\r\nDifferential Revision: https://reviews.llvm.org/D153761", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp", "functions": ["translateCallBase"]}, {"filename": "llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp", "functions": ["CLI"]}, {"filename": "llvm/lib/Target/AMDGPU/AMDGPUCallLowering.cpp", "functions": ["lowerChainCall"]}, {"filename": "llvm/lib/Target/AMDGPU/SIISelLowering.cpp", "functions": ["lowerUnhandledCall"]}, {"filename": "llvm/lib/Target/AMDGPU/SILateBranchLowering.cpp", "functions": ["expandChainCall"]}]}
{"pr_number": 70950, "url": "https://github.com/llvm/llvm-project/pull/70950", "title": "[lldb][AArch64] Move register info reconfigure into architecture plugin", "body": "This removes AArch64 specific code from the GDB* classes.\r\n\r\nTo do this I've added 2 new methods to Architecture:\r\n* RegisterWriteCausesReconfigure to check if what you are about to do\r\n  will trash the register info.\r\n* ReconfigureRegisterInfo to do the reconfiguring. This tells you if\r\n  anything changed so that we only invalidate registers when needed.\r\n\r\nSo that ProcessGDBRemote can call ReconfigureRegisterInfo in SetThreadStopInfo,\r\nI've added forwarding calls to GDBRemoteRegisterContext and the base class\r\nRegisterContext.\r\n\r\n(which removes a slightly sketchy static cast as well)\r\n\r\nRegisterContext defaults to doing nothing for both the methods\r\nso anything other than GDBRemoteRegisterContext will do nothing.", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "lldb/source/Plugins/Architecture/AArch64/ArchitectureAArch64.cpp", "functions": ["if"]}, {"filename": "lldb/source/Plugins/Process/gdb-remote/GDBRemoteRegisterContext.cpp", "functions": ["if", "exe_ctx"]}]}
{"pr_number": 70837, "url": "https://github.com/llvm/llvm-project/pull/70837", "title": "[analyzer] Fix assertion failure in `CXXInstanceCall::getCXXThisVal`", "body": "Workaround the case when the `this` pointer is actually a `NonLoc`, by returning `Unknown` instead.\r\nThe solution isn't ideal, as `this` should be really a `Loc`, but due to how casts work, I feel this is our easiest and best option.\r\n\r\nAs this patch presents, I'm evaluating a cast to transform the `NonLoc`.\r\nHowever, given that `evalCast()` can't be cast from `NonLoc` to a pointer type thingy (`Loc`), we end up with `Unknown`.\r\nIt is because `EvalCastVisitor::VisitNonLocSymbolVal()` only evaluates casts that happen from NonLoc to NonLocs.\r\n\r\nWhen I tried to actually implement that case, I figured:\r\n1) Create a `SymbolicRegion` from that `nonloc::SymbolVal`; but `SymbolRegion` ctor expects a pointer type for the symbol.\r\n2) Okay, just have a `SymbolCast`, getting us the pointer type; but `SymbolRegion` expects `SymbolData` symbols, not generic `SymExpr`s, as stated:\r\n\r\n> // Because pointer arithmetic is represented by ElementRegion layers,\r\n> // the base symbol here should not contain any arithmetic.\r\n\r\n3) We can't use `ElementRegion`s to perform this cast because to have an `ElementRegion`, you already have to have a `SubRegion` that you want to cast, but the point is that we don't have that.\r\n\r\nAt this point, I gave up, and just left a FIXME instead, while still returning `Unknown` on that path.\r\nIMO this is still better than having a crash.\r\n\r\nFixes #69922", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/Analysis/builtin_bitcast.cpp", "functions": ["gh_69922"]}, {"filename": "clang/lib/StaticAnalyzer/Core/CallEvent.cpp", "functions": ["UnknownVal"]}]}
{"pr_number": 69915, "url": "https://github.com/llvm/llvm-project/pull/69915", "title": "[clang][Interp] Fix IntAP(s) to IntAP(s) casts", "body": "", "feature_layers": ["ast"], "feature_directives": [], "files_changed": [{"filename": "clang/test/AST/Interp/intap.cpp", "functions": ["_BitInt"]}]}
{"pr_number": 68714, "url": "https://github.com/llvm/llvm-project/pull/68714", "title": "Improve selection of conditional branch on amdgcn.ballot!=0 condition in SelectionDAG.", "body": "I'm going to introduce changes in address sanitizer instrumentation checks for AMDGPU target and it will make use of the following pattern:\r\n```\r\nbool cnd = ...\r\nif (amdgcn.ballot(cnd) != 0) {\r\n  ...\r\n}\r\n```\r\nwhich means \"execute _then_ if any lane has satisfied the _cnd_ condition\". Note that this is uniform condition since _amdgcn.ballot_ is uniform intrinsic.\r\n\r\nThis patch improves code generation for this pattern in SelectionDAG. GlobalISel change should be added later. It introduces special _AMDGPUISD::BRCONDZ_ node that is created in the DAG combiner and maps directly either to _S_CBRANCH_VCC(Z|NZ)_ or _S_CBRANCH_SCC(0|1)_ if _cnd_ is itself uniform.\r\n\r\nP.S. This pull request contains two commits, first one just adds tests so I recommend to take a look at the second commit https://github.com/llvm/llvm-project/commit/13ebb871f82fd4dfa9eff7ecae6c0d60d6ebab16 to see the code difference it makes in tests.", "feature_layers": ["ir"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/SIISelLowering.cpp", "functions": ["isBoolSGPR"]}, {"filename": "llvm/lib/Target/AMDGPU/AMDGPUISelDAGToDAG.cpp", "functions": ["isBoolSGPR", "combineBallotPattern"]}]}
{"pr_number": 71050, "url": "https://github.com/llvm/llvm-project/pull/71050", "title": "[mlir] support scalable vectors in python bindings", "body": "The scalable dimension functionality was added to the vector type after the bindings for it were defined, without the bindings being ever updated. Fix that.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Bindings/Python/IRTypes.cpp", "functions": ["PyVectorType", "scalableDimFlags", "MLIRError", "errors"]}, {"filename": "mlir/lib/CAPI/IR/BuiltinTypes.cpp", "functions": ["unwrap", "mlirVectorTypeIsScalable", "mlirVectorTypeIsDimScalable"]}]}
{"pr_number": 70879, "url": "https://github.com/llvm/llvm-project/pull/70879", "title": "Fix line table lookups in line tables with multiple lines with the sa\u2026", "body": "Fix line table lookups in line tables with multiple lines with the same address.\r\n\r\nCompilers emit line tables that have multiple line table entries with the same address. When doing lookups, we always need to use the last line entry if a lookup address matches the address of one or more line entries. This is because the size of an address range for a line uses the next line entry to figure out how big the current line entry is. If the next line entry has the same address, that means the current line entry has a size of zero, so no bytes correspond to the line entry.\r\n\r\nThis patch ensures that lookups will always pick the last matching line entry when the lookup address matches more than one line entry.", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/unittests/DebugInfo/GSYM/GSYMTest.cpp", "functions": ["OutStrm", "OS", "FW", "DT"]}]}
{"pr_number": 71225, "url": "https://github.com/llvm/llvm-project/pull/71225", "title": "[BOLT][DWARF] Refactor address ranges processing", "body": "Create BinaryFunction::translateInputToOutputRange() and use it for updating DWARF debug ranges and location lists while de-duplicating the existing code. Additionally, move DWARF-specific code out of BinaryFunction and add print functions to facilitate debugging.\r\n\r\nNote that this change is deliberately kept \"bug-level\" compatible with the existing solution to keep it NFCI and make it easier to track any possible regressions in the future updates to the ranges-handling code.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "bolt/lib/Core/BinaryFunction.cpp", "functions": ["DebugAddressRange"]}, {"filename": "bolt/lib/Rewrite/DWARFRewriter.cpp", "functions": ["DebugAddressRange"]}]}
{"pr_number": 71380, "url": "https://github.com/llvm/llvm-project/pull/71380", "title": "[mlir][MemRef] Add subview folding pattern for vector.maskedload", "body": "This is required  for fixing https://github.com/openxla/iree/issues/15031", "feature_layers": ["ir"], "feature_directives": ["for", "masked"], "files_changed": [{"filename": "mlir/lib/Dialect/MemRef/Transforms/FoldMemRefAliasOps.cpp", "functions": ["getMemRefOperand"]}]}
{"pr_number": 70876, "url": "https://github.com/llvm/llvm-project/pull/70876", "title": "Modify llvm-gsymutil to ignore invalid file indexes.", "body": "DWARF produced by LTO and BOLT can sometimes be broken where file indexes are beyond the end of the line table's file list in the prologue. This patch allows llvm-gsymutil to convert this DWARF without crashing, and emits errors when:\r\n- line table contains entries with an invalid file index (line entry will be removed)\r\n- inline functions that have invalid DW_AT_call_file file indexes\r\n- when there are no line table entries for a function and we fall back to making a single line table entry from the functions DW_AT_decl_file/DW_AT_decl_line attributes, we make sure the DW_AT_decl_file attribute is valid before emitting it.", "feature_layers": [], "feature_directives": ["for", "single"], "files_changed": [{"filename": "llvm/lib/DebugInfo/GSYM/DwarfTransformer.cpp", "functions": ["DWARFToGSYMFileIndex"]}, {"filename": "llvm/unittests/DebugInfo/GSYM/GSYMTest.cpp", "functions": ["OutStrm", "OS", "FW", "DT"]}]}
{"pr_number": 68131, "url": "https://github.com/llvm/llvm-project/pull/68131", "title": "[LLVM][DWARF] Add support for monolithic types in .debug_names", "body": "Added support for Type Units in monolithic DWARF in .debug_names.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp", "functions": ["getUniqueTags", "ID", "getTagFromAbbreviationTag", "if", "emitTUList", "populateAbbrevsMap", "CompUnitCount"]}, {"filename": "llvm/lib/DebugInfo/DWARF/DWARFAcceleratorTable.cpp", "functions": ["AbbrevScope"]}]}
{"pr_number": 69708, "url": "https://github.com/llvm/llvm-project/pull/69708", "title": "[mlir][vector][spirv] Lower vector.transfer_read and vector.transfer_write to SPIR-V", "body": "Add patterns to lower vector.transfer_read to spirv.load and vector.transfer_write to spirv.store.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Conversion/VectorToSPIRV/VectorToSPIRV.cpp", "functions": ["failure", "success"]}]}
{"pr_number": 65670, "url": "https://github.com/llvm/llvm-project/pull/65670", "title": "[OpenMPOpt] Fix incorrect end-of-kernel barrier removal", "body": "Barrier removal in OpenMPOpt normally removes barriers by proving that they are redundant with barriers preceding them. However, it can't do this with the \"pseudo-barrier\" at the end of kernels because that can't be removed. Instead, it removes the barriers preceding the end of the kernel which that end-of-kernel barrier is redundant with. However, these barriers aren't always redundant with the end-of-kernel barrier when loops are involved, and removing them can lead to incorrect results in compiled code.\r\n\r\nThis change fixes this by requiring that these pre-end-of-kernel barriers also have the kernel end as a unique successor before removing them. It also changes the initialization of `ExitED` for kernels since the kernel end is not an aligned barrier.", "feature_layers": ["ir"], "feature_directives": ["for", "barrier"], "files_changed": [{"filename": "llvm/lib/Transforms/IPO/OpenMPOpt.cpp", "functions": ["hasFunctionEndAsUniqueSuccessor"]}]}
{"pr_number": 71441, "url": "https://github.com/llvm/llvm-project/pull/71441", "title": "Refactor traverse function with clearer function names", "body": "The `traverse` function has been updated for better readability and maintainability. The function now has clearer function names.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/ASTMatchers/ASTMatchFinder.cpp", "functions": ["continueTraversal", "baseTraverse", "traverse"]}]}
{"pr_number": 70255, "url": "https://github.com/llvm/llvm-project/pull/70255", "title": "[PowerPC] Add an alias for -mregnames so that full register names used in assembly.", "body": "This option already exists on GCC and so it is being added to LLVM so that we use the same option as them.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CodeGen/PowerPC/ppc-full-reg-names.c", "functions": ["VecNames", "IntNames", "FPNames"]}]}
{"pr_number": 71188, "url": "https://github.com/llvm/llvm-project/pull/71188", "title": "[libc][math] Implement powf function correctly rounded to all rounding modes.", "body": "We compute `pow(x, y)` using the formula\r\n```\r\n  pow(x, y) = x^y = 2^(y * log2(x))\r\n```\r\nWe follow similar steps as in `log2f(x)` and `exp2f(x)`, by breaking down into `hi + mid + lo` parts, in which `hi` parts are computed using the exponent field directly, `mid` parts will use look-up tables, and `lo` parts are approximated by polynomials.\r\n\r\nWe add some speedup for common use-cases:\r\n```\r\n  pow(2, y) = exp2(y)\r\n  pow(10, y) = exp10(y)\r\n  pow(x, 2) = x * x\r\n  pow(x, 1/2) = sqrt(x)\r\n  pow(x, -1/2) = rsqrt(x) - to be added\r\n```\r\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "libc/src/math/generic/powf.cpp", "functions": ["exp10f", "exp2f"]}, {"filename": "libc/test/src/math/powf_test.cpp", "functions": ["__r"]}, {"filename": "libc/test/src/math/smoke/powf_test.cpp", "functions": ["__r"]}, {"filename": "libc/utils/MPFRWrapper/MPFRUtils.cpp", "functions": ["pow", "result"]}, {"filename": "libc/src/math/generic/exp10f.cpp", "functions": ["xbits"]}, {"filename": "libc/src/math/generic/exp2f.cpp", "functions": ["FPBits", "xbits"]}]}
{"pr_number": 71242, "url": "https://github.com/llvm/llvm-project/pull/71242", "title": "[flang][openacc] Support variable in equivalence in declare directive", "body": "A variable in equivalence share the storage units with one or more objects. When lowered to FIR, the global created for the equivalence has the name of one of the object. The variable also has an offset in the storage unit.\r\nThis patch takes all of this into account for variable part of equivalence used in a declare directive. ", "feature_layers": ["ir"], "feature_directives": ["for", "declare"], "files_changed": [{"filename": "flang/lib/Lower/OpenACC.cpp", "functions": ["constexpr"]}]}
{"pr_number": 71444, "url": "https://github.com/llvm/llvm-project/pull/71444", "title": "[flang][openacc] Issue an error when TBP are used in data clause", "body": "Putting a type-bound procedure in a data clause was crashing the lowering. Issue a proper semantic error in this case. ", "feature_layers": ["sema"], "feature_directives": [], "files_changed": [{"filename": "flang/lib/Semantics/resolve-directives.cpp", "functions": ["AllowOnlyVariable"]}]}
{"pr_number": 71467, "url": "https://github.com/llvm/llvm-project/pull/71467", "title": "[mlir][Tensor] Fold destination-style ops into `tensor.unpack` operat\u2026", "body": "\u2026ion.\r\n\r\nThe destination operand of the `tensor.unpack` operation is only needed to carry shape information. So if the producer of the destination operand implements the `DestinationStyleOpInterface`, then fold it into the `tensor.unpack` operation by replacing the destination operand with the destination for the source.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Tensor/IR/TensorOps.cpp", "functions": ["failure", "success"]}]}
{"pr_number": 71151, "url": "https://github.com/llvm/llvm-project/pull/71151", "title": "[lldb] Convert LocateSymbolFile into a plugin", "body": "This commit contains the initial scaffolding to convert the functionality currently implemented in LocateSymbolFile to a plugin architecture. The plugin approach allows us to easily add new ways to find plugins.\r\n\r\nThe current implementation abuses the host OS to use the DebugSymbols framework on macOS. With the plugin approach, we retain all the benefits (including the ability to compile it out) with a much cleaner level of abstraction.\r\n\r\nTo limit the scope of this patch, I've only converted LocateExecutableObjectFile. The goal is to do the same for the remaining LocateSymbolFile functions and eventually remove the file. To make reviewing easier, that will done as follow-up patches.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "lldb/source/Core/PluginManager.cpp", "functions": ["GetSymbolLocatorInstances"]}, {"filename": "lldb/source/Plugins/SymbolLocator/DebugSymbols/SymbolLocatorDebugSymbols.cpp", "functions": ["file_spec", "dsym_filespec", "bundle", "bundle_exe_file_spec", "CFDictionaryRef", "SymbolLocatorDebugSymbols", "exec_filespec", "uuid_cfstr", "CFURLRef"]}, {"filename": "lldb/source/Plugins/SymbolLocator/Default/SymbolLocatorDefault.cpp", "functions": ["SymbolLocatorDefault"]}]}
{"pr_number": 70980, "url": "https://github.com/llvm/llvm-project/pull/70980", "title": "[InstCombine] Avoid Allocating Arrays Too Large For the Target", "body": "The current logic in `simplifyAllocaArraySize` may result in an array too large for a target. For example, `%1 = alloca i32, i32 -1` may result in an array type of `[4294967295 x i32]`. Such an array can cause a crash in the code generator when the 32 bit mode is in effect, because the array's size is larger than what a 32 bit pointer can index. This PR teaches `instcombine` to avoid creating an over-sized array. ", "feature_layers": [], "feature_directives": ["for", "target"], "files_changed": [{"filename": "llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp", "functions": ["It"]}]}
{"pr_number": 71461, "url": "https://github.com/llvm/llvm-project/pull/71461", "title": "[mlir][sparse] implement loose-compressed/2:4 on direct IR codegen path", "body": "Fills in the missing cases for direct IR codegen.\r\nNote that non-permutation handling is still TBD.", "feature_layers": ["parse", "codegen", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/Transforms/SparseTensorCodegen.cpp", "functions": ["desc"]}]}
{"pr_number": 71466, "url": "https://github.com/llvm/llvm-project/pull/71466", "title": "[mlir][vector] Add leading unit dim folding patterns for masked transfers", "body": "This handles `vector.transfer_read`, `vector.transfer_write`, and `vector.constant_mask`. The unit dims are only relevant for masks created by `create_mask` and `constant_mask` if the mask size for the unit dim is non-one, in which case all subsequent sizes must also be zero. From the perspective of the vector transfers, however, these unit dims can just be dropped directly.", "feature_layers": ["ir"], "feature_directives": ["for", "masked"], "files_changed": [{"filename": "mlir/lib/Dialect/Vector/Transforms/VectorDropLeadUnitDim.cpp", "functions": ["failure", "success", "newDimSizes"]}]}
{"pr_number": 70171, "url": "https://github.com/llvm/llvm-project/pull/70171", "title": "[Clang] Add codegen option to add passbuilder callback functions", "body": "Adding passbuilder callbacks presently can be done one of two ways:\r\n* a shared library plugin\r\n* modifying the extensions list (and thus extensions.def)\r\n\r\nThis prevents the use of such functionality for static builds on build systems that cannot be modified, as well as prevents such functionality from being usable when using llvm/clang as a library.\r\n\r\nThis creates a third mechanism for adding these callbacks, an explicit list of said callbacks in the CodegenOptions. It's otherwise identical to the plugin approach, except now instead of the list of plugins each being queried for the callback function, this just runs the callback function. This enables use of a clang plugin which can statically add the llvm plugin, without forcing a dsoload for the llvm plugin.", "feature_layers": ["codegen", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/examples/LLVMPrintFunctionNames/LLVMPrintFunctionNames.cpp", "functions": ["run", "isRequired", "PrintCallback", "getActionType"]}, {"filename": "clang/test/Frontend/llvmplugins.c", "functions": ["x"]}]}
{"pr_number": 71040, "url": "https://github.com/llvm/llvm-project/pull/71040", "title": "[IR] Remove zext and sext constant expressions", "body": "Remove support for zext and sext constant expressions. All places creating them have been removed beforehand, so this just removes the APIs and uses of these constant expressions in tests.\r\n\r\nThere is some additional cleanup that can be done on top of this, e.g. we can remove the ZExtInst vs ZExtOperator footgun.\r\n\r\nThis is part of https://discourse.llvm.org/t/rfc-remove-most-constant-expressions/63179.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/bindings/ocaml/llvm/llvm_ocaml.c", "functions": ["to_val", "llvm_const_zext", "llvm_const_zext_or_bitcast", "llvm_const_sext", "llvm_const_intcast", "llvm_const_sext_or_bitcast"]}, {"filename": "llvm/lib/AsmParser/LLParser.cpp", "functions": ["error"]}, {"filename": "llvm/lib/IR/ConstantFold.cpp", "functions": ["ExtractConstantBytes", "PossiblySetBits"]}, {"filename": "llvm/lib/IR/Constants.cpp", "functions": ["getZExt", "getCast", "getSExt", "getBitCast", "getTrunc", "getFoldedCast"]}, {"filename": "llvm/lib/IR/Core.cpp", "functions": ["LLVMConstZExt", "LLVMConstSExt", "wrap"]}]}
{"pr_number": 71319, "url": "https://github.com/llvm/llvm-project/pull/71319", "title": "[MLIR] Add support for calling conventions to LLVM::CallOp and LLVM::InvokeOp", "body": "Despite the fact that the LLVM dialect\u2019s `FuncOp` already supports calling conventions, there was yet no support for them in the ops that actually perform function calls, which led to incorrect LLVM IR being generated if one actually tried setting a `FuncOp`\u2019s calling convention to anything other than `ccc`.\r\n\r\nThis commit adds support for calling conventions to `LLVM::CallOp` and `LLVM::InvokeOp` and makes sure that calling conventions are parsed, printed, and lowered appropriately.", "feature_layers": ["parse", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/LLVMIR/IR/LLVMDialect.cpp", "functions": ["stringify", "stringifyCConv", "getMaxEnumVal"]}]}
{"pr_number": 69378, "url": "https://github.com/llvm/llvm-project/pull/69378", "title": "[libc++] Make sure ranges algorithms and views handle boolean-testable correctly", "body": "Before this patch, we would fail to implicitly convert the result of\r\npredicates to bool, which means we'd potentially perform a copy or move\r\nconstruction of the boolean-testable, which isn't allowed. The same\r\nholds true for comparing iterators against sentinels, which is allowed\r\nto return a boolean-testable type.\r\n\r\nWe already had tests aiming to ensure correct handling of these types,\r\nbut they failed to provide appropriate coverage in several cases due to\r\nguaranteed RVO. This patch fixes the tests, adds tests for missing\r\nalgorithms and views, and fixes the actual problems in the code.\r\n\r\nFixes #69074", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "libcxx/test/std/algorithms/ranges_robust_against_nonbool.compile.pass.cpp", "functions": ["f"]}, {"filename": "libcxx/test/std/algorithms/ranges_robust_against_nonbool_predicates.pass.cpp", "functions": ["test_all", "test", "main", "test_mid"]}, {"filename": "libcxx/test/std/ranges/range.adaptors/robust_against_nonbool.compile.pass.cpp", "functions": ["f", "use"]}, {"filename": "libcxx/test/std/utilities/memory/specialized.algorithms/ranges_robust_against_nonbool.compile.pass.cpp", "functions": ["f"]}]}
{"pr_number": 71408, "url": "https://github.com/llvm/llvm-project/pull/71408", "title": "[IR] Remove FP cast constant expressions", "body": "Remove support for the fptrunc, fpext, fptoui, fptosi, uitofp and sitofp constant expressions. All places cerating them have been removed beforehand, so this just removes the APIs and uses of these constant expressions in tests.\r\n\r\nWith this, the only remaining FP operation that still has constant expression support is fcmp.\r\n\r\nThis is part of https://discourse.llvm.org/t/rfc-remove-most-constant-expressions/63179.", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/bindings/ocaml/llvm/llvm_ocaml.c", "functions": ["to_val", "llvm_const_uitofp", "llvm_const_fptosi", "llvm_const_fptrunc", "llvm_const_fpext", "llvm_const_fpcast", "llvm_const_sitofp", "llvm_const_fptoui"]}, {"filename": "llvm/lib/AsmParser/LLParser.cpp", "functions": ["error"]}, {"filename": "llvm/lib/IR/Constants.cpp", "functions": ["getFPToSI", "getSIToFP", "getFPToUI", "getUIToFP", "getCast", "getFPTrunc", "getFoldedCast", "getFPExtend"]}, {"filename": "llvm/lib/IR/Core.cpp", "functions": ["LLVMConstUIToFP", "LLVMConstFPTrunc", "LLVMConstFPToSI", "LLVMConstFPToUI", "wrap", "LLVMConstFPCast", "LLVMConstSIToFP", "LLVMConstFPExt"]}]}
{"pr_number": 71384, "url": "https://github.com/llvm/llvm-project/pull/71384", "title": "[clang][dataflow] Fix assert-fail when calling assignment operator with by-value parameter.", "body": "The code assumed that the source parameter of an assignment operator is always\npassed by reference, but it is legal for it to be passed by value.\n\nThis patch includes a test that assert-fails without the fix.\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/unittests/Analysis/FlowSensitive/TransferTest.cpp", "functions": ["target"]}]}
{"pr_number": 71381, "url": "https://github.com/llvm/llvm-project/pull/71381", "title": "[GlobalOpt] Cache whether CC is changeable", "body": "The hasAddressTaken() call in hasOnlyColdCalls() has quadratic complexity if there are many cold calls to a function: We're going to visit each call of the function, and then for each of them iterate all the users of the function.\r\n\r\nWe've recently encountered a case where GlobalOpt spends more than an hour in these hasAddressTaken() checks when full LTO is used.\r\n\r\nAvoid this by moving the hasAddressTaken() check into hasChangeableCC() and caching its result, so it is only computed once per function.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/IPO/GlobalOpt.cpp", "functions": ["hasChangeableCC", "hasChangeableCCImpl"]}]}
{"pr_number": 70304, "url": "https://github.com/llvm/llvm-project/pull/70304", "title": "[AArch64] Sink vscale calls into loops for better isel", "body": "For more recent sve capable CPUs it is beneficial to use the inc* instruction\r\nto increment a value by vscale (potentially shifted or multiplied) even in\r\nshort loops.\r\n\r\nThis patch tells codegenprepare to sink appropriate vscale calls into\r\nblocks where they are used so that isel can match them.\r\n", "feature_layers": ["codegen"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AArch64/AArch64ISelLowering.cpp", "functions": ["shouldSinkVScale"]}]}
{"pr_number": 70056, "url": "https://github.com/llvm/llvm-project/pull/70056", "title": "[analyzer] Improve diagnostics from ArrayBoundCheckerV2", "body": "Previously alpha.security.ArrayBoundV2 produced very spartan bug reports; this commit ensures that the relevant (and known) details are reported to the user.\r\n\r\nThe logic for detecting bugs is not changed, after this commit the checker will report the same set of issues, but with better messages.\r\n\r\nTo test the details of the message generation this commit adds a new test file 'out-of-bounds-diagnostics.c'. Three of the testcases are added with FIXME notes because they reveal shortcomings of the existing modeling and bounds checking code. I will try to fix them in separate follow-up commits.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/StaticAnalyzer/Checkers/ArrayBoundCheckerV2.cpp", "functions": ["getTaintMsg", "getPrecedesMsg", "getShortMsg", "formatv", "getRegionName", "Out", "getConcreteValue"]}, {"filename": "clang/test/Analysis/out-of-bounds-diagnostics.c", "functions": ["scalarOverflow", "convertedArray2", "oneElementArrayOverflow", "taintedIndex", "arrayInStructPtr", "__typeof", "arrayOverflow", "scanf", "intFromString", "allocaRegion", "arrayInStruct", "arrayUnderflow", "convertedArray", "unknownIndex", "intFromStringDivisible"]}]}
{"pr_number": 65638, "url": "https://github.com/llvm/llvm-project/pull/65638", "title": "[clang] Improve `_Alignas` on a `struct` declaration diagnostic", "body": "Fixes https://github.com/llvm/llvm-project/issues/58637. \r\n\r\nAdds `isAlignas()` method on `AttributeCommonInfo` which accounts for\r\nC++ `alignas` as well as C11 `_Alignas`.\r\n\r\nThe method is used to improve diagnostic in C when `_Alignas` is used in\r\nC at the wrong location.  This corrects the previously suggested move\r\nof `_Alignas` past the declaration specifier, now warns attribute\r\n`_Alignas` is ignored.\r\n\r\nBased on https://reviews.llvm.org/D141177. ", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Sema/SemaDecl.cpp", "functions": ["if", "GetDiagnosticTypeSpecifierID"]}]}
{"pr_number": 65268, "url": "https://github.com/llvm/llvm-project/pull/65268", "title": "[time-trace] Add a new time trace scope variable named \"ParseDeclarationOrFunctionDefinition\".", "body": "When profiling code using `-ftime-trace` with the default `time-trace-granularity` value (500 microseconds), in some code there is a large empty timeline in the flame chart profiling view (using Chrome Tracing view).  If you pass `-ftime-trace-granularity=0` in order to show all time traces, the empty timeline consists of a large number of small time scopes named `EvaluateAsConstExpr`.  This change adds an enclosing time trace scope for the function `Parser::ParseDeclarationOrFunctionDefinition` to record the time spent parsing  the function's declaration or definition.", "feature_layers": ["parse", "parser"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/Driver/check-time-trace-ParseDeclarationOrFunctionDefinition.cpp", "functions": ["bar", "foo"]}, {"filename": "clang/lib/Parse/Parser.cpp", "functions": ["TimeScope"]}]}
{"pr_number": 70848, "url": "https://github.com/llvm/llvm-project/pull/70848", "title": "[clang][dataflow] Simplify flow conditions displayed in HTMLLogger.", "body": "This can make the flow condition significantly easier to interpret; see below\nfor an example.\n\nI had hoped that adding the simplification as a preprocessing step before the\nSAT solver (in `DataflowAnalysisContext::querySolver()`) would also speed up SAT\nsolving and maybe even eliminate SAT solver timeouts, but in my testing, this\nactually turns out to be a pessimization. It appears that these simplifications\nare easy enough for the SAT solver to perform itself.\n\nNevertheless, the improvement in debugging alone makes this a worthwhile change.\n\nExample of flow condition output with these changes:\n\n```\nFlow condition token: V37\nConstraints:\n(V16 = (((V15 & (V19 = V12)) & V22) & V25))\n(V15 = ((V12 & ((V14 = V9) | (V14 = V4))) & (V13 = V14)))\nTrue atoms: (V0, V1, V2, V5, V6, V7, V29, V30, V32, V34, V35, V37)\nFalse atoms: (V3, V8, V17)\nEquivalent atoms:\n(V11, V15)\n\nFlow condition constraints before simplification:\nV37\n((!V3 & !V8) & !V17)\n(V37 = V34)\n(V34 = (V29 & (V35 = V30)))\n(V29 = (((V16 | V2) & V32) & (V30 = V32)))\n(V16 = (((V15 & (V19 = V12)) & V22) & V25))\n(V15 = V11)\n(V11 = ((((V7 | V2) & V12) & ((V7 & (V14 = V9)) | (V2 & (V14 = V4)))) & (V13 = V14)))\n(V2 = V1)\n(V1 = V0)\nV0\n(V7 = V6)\n(V6 = V5)\n(V5 = V2)\n```\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/unittests/Analysis/FlowSensitive/SimplifyConstraintsTest.cpp", "functions": ["OS", "Constraints", "parse"]}]}
{"pr_number": 71322, "url": "https://github.com/llvm/llvm-project/pull/71322", "title": "[clang][NFC] Refactor `CXXNewExpr::InitializationStyle`", "body": "This patch converts `CXXNewExpr::InitializationStyle` into a scoped enum at namespace scope. It also affirms the status quo by adding a new enumerator to represent implicit initializer.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "clang/lib/Sema/SemaExprCXX.cpp", "functions": ["if"]}]}
{"pr_number": 71516, "url": "https://github.com/llvm/llvm-project/pull/71516", "title": "[mlir][gpu] Introduce `gpu.dynamic.shared.memory` Op", "body": "While the `gpu.launch` Op allows setting the size via the `dynamic_shared_memory_size` argument, accessing the dynamic shared memory is very convoluted. This PR implements the proposed Op, `gpu.dynamic.shared.memory` that aims to simplify the utilization of dynamic shared memory.\r\n\r\nRFC: https://discourse.llvm.org/t/rfc-simplifying-dynamic-shared-memory-access-in-gpu/\r\n\r\n**Proposal from RFC**\r\nThis PR `gpu.dynamic.shared.memory` Op to use dynamic shared memory feature efficiently. It is is a powerful feature that enables the allocation of shared memory at runtime with the kernel launch on the host. Afterwards, the memory can be accessed directly from the device. I believe similar story exists for AMDGPU.\r\n\r\n**New Op Features**\r\n\r\n- No more 0-Sized Global Symbol Generation: The lowering will hide 1st and 3rd steps.\r\n- Simplified Shared Memory Access: No need for reinterpret_cast or subview. The offset argument will be sufficient.\r\n- Compile-time Bound Check: The Op verifier checks dynamic_shared_memory_size < offset if they are compile-time constants.\r\n- Runtime-time Bound Check (TODO): We can add `{dynamicBoundCheck}` attribute that checks dynamic_shared_memory_size < offset on the runtime. This is optional and definitely adds overhead, but it can be beneficial for debugging.\r\n\r\n**Current way Using Dynamic Shared Memory with MLIR**\r\n\r\nLet me illustrate the challenges of using dynamic shared memory in MLIR with an example below. The process involves several steps:\r\n- memref.global 0-sized array NVPTX expects\r\n- dynamic_shared_memory_size Set the size of dynamic shared memory\r\n- memref.get_global Access the global symbol\r\n- reinterpret_cast and subview Many OPs for pointer arithmetic\r\n\r\n```\r\n// Step 1. Create 0-sized global symbol. Manually set the alignment\r\nmemref.global \"private\" @dynamicShmem  : memref<0xf16, 3> { alignment = 16 }\r\nfunc.func @main() {\r\n  // Step 2. Allocate shared memory\r\n  gpu.launch blocks(...) threads(...)\r\n    dynamic_shared_memory_size %c10000 {\r\n    // Step 3. Access the global object\r\n    %shmem = memref.get_global @dynamicShmem : memref<0xf16, 3>\r\n    // Step 4. A sequence of `memref.reinterpret_cast` and `memref.subview` operations.\r\n    %4 = memref.reinterpret_cast %shmem to offset: [0], sizes: [14, 64, 128],  strides: [8192,128,1] : memref<0xf16, 3> to memref<14x64x128xf16,3>\r\n    %5 = memref.subview %4[7, 0, 0][7, 64, 128][1,1,1] : memref<14x64x128xf16,3> to memref<7x64x128xf16, strided<[8192, 128, 1], offset: 57344>, 3>\r\n    %6 = memref.subview %5[2, 0, 0][1, 64, 128][1,1,1] : memref<7x64x128xf16, strided<[8192, 128, 1], offset: 57344>, 3> to memref<64x128xf16, strided<[128, 1], offset: 73728>, 3>\r\n    %7 = memref.subview %6[0, 0][64, 64][1,1]  : memref<64x128xf16, strided<[128, 1], offset: 73728>, 3> to memref<64x64xf16, strided<[128, 1], offset: 73728>, 3>\r\n    %8 = memref.subview %6[32, 0][64, 64][1,1] : memref<64x128xf16, strided<[128, 1], offset: 73728>, 3> to memref<64x64xf16, strided<[128, 1], offset: 77824>, 3>\r\n    // Step.5 Use\r\n    \"test.use.shared.memory\"(%7) : (memref<64x64xf16, strided<[128, 1], offset: 73728>, 3>) -> (index)\r\n    \"test.use.shared.memory\"(%8) : (memref<64x64xf16, strided<[128, 1], offset: 77824>, 3>) -> (index)\r\n    gpu.terminator\r\n  }\r\n```\r\n\r\nLet\u2019s write the program above with that:\r\n\r\n```\r\nfunc.func @main() {\r\n    gpu.launch blocks(...) threads(...) dynamic_shared_memory_size %c10000 {\r\n    \t%i = arith.constant 18 : index\r\n        // Step 1: Obtain shared memory directly\r\n        %7 = gpu.dynamic.shared.memory [%i,0,0] : memref<64x64xf16, 3>\r\n        %i2 = arith.addi %i, %c1\r\n        %8 = gpu.dynamic.shared.memory [%i2,0,0] : memref<64x64xf16, 3>\r\n\r\n        // Step 2: Utilize the shared memory\r\n        \"test.use.shared.memory\"(%7) : (memref<64x64xf16, 3>) -> (index)\r\n        \"test.use.shared.memory\"(%8) : (memref<64x64xf16, 3>) -> (index)\r\n    }\r\n}\r\n```", "feature_layers": ["runtime", "ir", "ast"], "feature_directives": ["for", "allocate"], "files_changed": [{"filename": "mlir/lib/Conversion/GPUCommon/GPUOpsLowering.cpp", "functions": ["success", "guard"]}, {"filename": "mlir/lib/Dialect/GPU/IR/GPUDialect.cpp", "functions": ["emitOpError", "success", "failure", "if", "isWorkgroupMemoryAddressSpace", "stringifyEnum"]}]}
{"pr_number": 71513, "url": "https://github.com/llvm/llvm-project/pull/71513", "title": "[RISCV][Clang][TargetParser] Support getting feature unaligned-scalar-mem from mcpu.", "body": "This patch reference ac1ffd3caca12c254e0b8c847aa8ce8e51b6cfbf to suppot a soft coding way to identify whether a cpu has a feature `unaligned-scalar-mem` by `RISCVProcessors.td`.\r\nThis patch does not provide test case since there is no risc-v cpu support `unaligned-scalar-mem` in llvm upstream now.", "feature_layers": ["parse", "parser"], "feature_directives": ["target"], "files_changed": [{"filename": "llvm/lib/TargetParser/RISCVTargetParser.cpp", "functions": ["hasFastUnalignedAccess"]}]}
{"pr_number": 71462, "url": "https://github.com/llvm/llvm-project/pull/71462", "title": "[OpenMP][Offload] Automatically map indirect function pointers", "body": "We already have all the information to automatically map function pointers that have been declared as `indirect` declare target by the user. This is just enabling and testing the functionality by looking through the one level of indirection.", "feature_layers": ["ir"], "feature_directives": ["for", "target", "declare"], "files_changed": [{"filename": "openmp/libomptarget/src/omptarget.cpp", "functions": ["AsyncInfo"]}, {"filename": "openmp/libomptarget/test/offloading/indirect_fp_mapping.c", "functions": ["int", "square", "main"]}]}
{"pr_number": 69644, "url": "https://github.com/llvm/llvm-project/pull/69644", "title": "[mlir][python] value casting", "body": "This PR adds \"value casting\", i.e., a mechanism to wrap `ir.Value` in a proxy class that overloads dunders such as `__add__`, `__sub__`, and `__mul__` for fun and great profit. \r\n\r\nThis is thematically similar to https://github.com/llvm/llvm-project/commit/bfb1ba752655bf09b35c486f6cc9817dbedfb1bb and https://github.com/llvm/llvm-project/commit/9566ee280607d91fa2e5eca730a6765ac84dfd0f. The example in the test demonstrates the value of the feature (no pun intended):\r\n\r\n```python\r\n    @register_value_caster(F16Type.static_typeid)\r\n    @register_value_caster(F32Type.static_typeid)\r\n    @register_value_caster(F64Type.static_typeid)\r\n    @register_value_caster(IntegerType.static_typeid)\r\n    class ArithValue(Value):\r\n        __add__ = partialmethod(_binary_op, op=\"add\")\r\n        __sub__ = partialmethod(_binary_op, op=\"sub\")\r\n        __mul__ = partialmethod(_binary_op, op=\"mul\")\r\n\r\n    a = arith.constant(value=FloatAttr.get(f16_t, 42.42))\r\n    b = a + a\r\n    # CHECK: ArithValue(%0 = arith.addf %cst, %cst : f16)\r\n    print(b)\r\n\r\n    a = arith.constant(value=FloatAttr.get(f32_t, 42.42))\r\n    b = a - a\r\n    # CHECK: ArithValue(%1 = arith.subf %cst_0, %cst_0 : f32)\r\n    print(b)\r\n\r\n    a = arith.constant(value=FloatAttr.get(f64_t, 42.42))\r\n    b = a * a\r\n    # CHECK: ArithValue(%2 = arith.mulf %cst_1, %cst_1 : f64)\r\n    print(b)\r\n```\r\n\r\n**EDIT**: this now goes through the bindings and thus supports automatic casting of `OpResult` (including as an element of `OpResultList`), `BlockArgument` (including as an element of `BlockArgumentList`), as well as `Value`.", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/tools/mlir-tblgen/OpPythonBindingGen.cpp", "functions": ["_get_op_result_or_op_results", "_maybe_cast"]}, {"filename": "mlir/lib/Bindings/Python/IRCore.cpp", "functions": ["getItem"]}, {"filename": "mlir/test/python/lib/PythonTestModule.cpp", "functions": ["mlirValueIsNull"]}]}
{"pr_number": 71431, "url": "https://github.com/llvm/llvm-project/pull/71431", "title": "Modify llvm-gsymutil to ignore invalid file indexes", "body": "DWARF produced by LTO and BOLT can sometimes be broken where file indexes are beyond the end of the line table's file list in the prologue. This patch allows llvm-gsymutil to convert this DWARF without crashing, and emits errors when:\r\n\r\nline table contains entries with an invalid file index (line entry will be removed) inline functions that have invalid DW_AT_call_file file indexes when there are no line table entries for a function and we fall back to making a single line table entry from the functions DW_AT_decl_file/DW_AT_decl_line attributes, we make sure the DW_AT_decl_file attribute is valid before emitting it.", "feature_layers": [], "feature_directives": ["for", "single"], "files_changed": [{"filename": "llvm/lib/DebugInfo/GSYM/DwarfTransformer.cpp", "functions": ["DWARFToGSYMFileIndex"]}, {"filename": "llvm/unittests/DebugInfo/GSYM/GSYMTest.cpp", "functions": ["OutStrm", "OS", "FW", "DT"]}]}
{"pr_number": 69372, "url": "https://github.com/llvm/llvm-project/pull/69372", "title": "[TSAN] Add __tsan_check_no_mutexes_held helper", "body": "This adds a new helper that can be called from application code to ensure that no mutexes are held on specific code paths. This is useful for multiple scenarios, including ensuring no locks are held:\r\n\r\n- at thread exit\r\n- in peformance-critical code\r\n- when a coroutine is suspended (can cause deadlocks)\r\n\r\nSee this discourse thread for more discussion:\r\nhttps://discourse.llvm.org/t/add-threadsanitizer-check-to-prevent-coroutine-suspending-while-holding-a-lock-potential-deadlock/74051", "feature_layers": [], "feature_directives": ["for", "critical"], "files_changed": [{"filename": "compiler-rt/lib/tsan/rtl/tsan_interface_ann.cpp", "functions": ["ReportMutexCannotBeLocked", "rep", "ReportMutexHeldWrongContext"]}, {"filename": "compiler-rt/lib/tsan/rtl/tsan_report.cpp", "functions": ["PrintMutex"]}, {"filename": "compiler-rt/test/tsan/mutex_cannot_be_locked.cpp", "functions": ["main"]}, {"filename": "compiler-rt/test/tsan/mutex_cannot_be_locked_success.cpp", "functions": ["main"]}, {"filename": "compiler-rt/test/tsan/mutex_held_wrong_context.cpp", "functions": ["Func1", "main", "Func2"]}]}
{"pr_number": 71477, "url": "https://github.com/llvm/llvm-project/pull/71477", "title": "[lldb] BreakpointResolver{*}::CreateFromStructuredData should return shared pointers", "body": "BreakpointResolver::CreateFromStructuredData returns a BreakpointResolverSP, but all of the subclasses return raw pointers. Instead of creating a raw pointer and shoving it into a shared pointer, it seems reasonable to just create the shared pointer directly.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "lldb/source/Breakpoint/BreakpointResolver.cpp", "functions": ["BreakpointResolverSP"]}, {"filename": "lldb/source/Breakpoint/BreakpointResolverAddress.cpp", "functions": ["BreakpointResolverAddress"]}, {"filename": "lldb/source/Breakpoint/BreakpointResolverFileRegex.cpp", "functions": ["BreakpointResolverFileRegex"]}, {"filename": "lldb/source/Breakpoint/BreakpointResolverName.cpp", "functions": ["BreakpointResolverName"]}]}
{"pr_number": 70881, "url": "https://github.com/llvm/llvm-project/pull/70881", "title": "[CodeGen][MachineVerifier] Use TypeSize instead of unsigned for getRe\u2026", "body": "\u2026gSizeInBits\r\n\r\nThis patch changes getRegSizeInBits to return a TypeSize instead of an unsigned in the case that a virtual register has a scalable LLT. In the case that register is physical, a Fixed TypeSize is returned.\r\n\r\nThe MachineVerifier pass is updated to allow copies between fixed and scalable operands as long as the Src size will fit into the Dest size.\r\n\r\nThis is a precommit which will be stacked on by a change to GISel to generate COPYs with a scalable destination but a fixed size source.\r\n\r\nThis patch is stacked on https://github.com/llvm/llvm-project/pull/70893 for the ability to use scalable vector types in MIR tests.", "feature_layers": ["codegen", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/CodeGen/TargetRegisterInfo.cpp", "functions": ["getRegSizeInBits"]}]}
{"pr_number": 65516, "url": "https://github.com/llvm/llvm-project/pull/65516", "title": "[llvm][dwarf][rfc][donotcommit] Enable print of ranges addresses from .debug_info.dwo", "body": "Summary:\r\nFor split dwarf some of the sections remain in the main binary. For DWARF4 it's\r\n.debug_ranges, .debug_addr. For DWARF5 it's .debug_addr. When using\r\nllvm-dwarfdump on .dwo/.dwp files this results in not being able to see what ranges\r\nand addresses for DW_AT_low_pc are used in DIEs, and output having \"Error: \" in it.\r\n\r\nI added a new option --main-binary=<binary> that will create a link in\r\nDWARFContext between DWO context and main binary. This allows tool to display\r\naddresses for DW_AT_ranges and DW_AT_low_pc.\r\n\r\nExample (DWARF5):\r\n\r\nDW_TAG_inlined_subroutine\r\n        DW_AT_abstract_origin (0x00000b21 \"flush_RL\")\r\n        DW_AT_ranges  (indexed (0x0) rangelist = 0x00000054\r\n          [0x0000000000403fe2, 0x0000000000403ff3)\r\n          [0x0000000000403ff6, 0x0000000000403ffe))\r\n\r\nDW_TAG_subprogram\r\n        DW_AT_low_pc  (0x0000000000403940)\r\n\r\n\r\nOriginal phab review: https://reviews.llvm.org/D159374", "feature_layers": [], "feature_directives": ["for", "sections", "flush"], "files_changed": [{"filename": "llvm/lib/DebugInfo/DWARF/DWARFUnit.cpp", "functions": ["RangesData"]}]}
{"pr_number": 71482, "url": "https://github.com/llvm/llvm-project/pull/71482", "title": "[mlir][vector] Add support for distributing masked writes", "body": "Because the mask applies to the un-permuted write vector, we can simply distribute the mask identically to the vector, if present.", "feature_layers": ["ir"], "feature_directives": ["for", "distribute", "masked"], "files_changed": [{"filename": "mlir/lib/Dialect/Vector/Transforms/VectorDistribute.cpp", "functions": ["failure"]}]}
{"pr_number": 68986, "url": "https://github.com/llvm/llvm-project/pull/68986", "title": "[DebugMetadata][DwarfDebug] Clone uniqued function-local types after metadata loading", "body": "- [DebugMetadata][DwarfDebug] Support function-local types in lexical block scopes (4/7)\r\n- Clone function-local types after metadata loading.\r\n\r\nThis is a follow-up for https://reviews.llvm.org/D144006, fixing a crash reported in Chromium (https://reviews.llvm.org/D144006#4651955).\r\n\r\nThe first commit is added for convenience, as it has already been accepted.\r\nThe issue is that when DIType nodes are loaded, they get deduplicated as ODR-uniqued. When two modules get merged by LTO, DISubprogram nodes for the same function from different modules are not uniqued, since they are marked as distinct, whereas their retained types are, which can violate the ownership relationship between DISubprogram and its function-local retained type.\r\nIt is fixed by copying a function-local type referenced by one DISubprogram through retainedNodes and referencing another in its scope field. The scope of the copy gets changed correspondingly.\r\n\r\nThis is meant to be committed along with https://reviews.llvm.org/D144006.\r\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Bitcode/Reader/MetadataLoader.cpp", "functions": ["MDs", "if", "cloneLocalTypes"]}, {"filename": "llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp", "functions": ["getLocalContextDIE", "getOrCreateContextDIE", "getLexicalBlockDIE"]}, {"filename": "llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp", "functions": ["if"]}]}
{"pr_number": 71588, "url": "https://github.com/llvm/llvm-project/pull/71588", "title": "[clang][DepScan] Make OptimizeArgs a bit mask enum and enable by default", "body": "Make it easier to control which optimizations are enabled by making\r\nOptimizeArgs a bit masked enum. There's currently only one such\r\noptimization, but more will be added in followup commits.", "feature_layers": [], "feature_directives": ["masked"], "files_changed": [{"filename": "clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp", "functions": ["Format"]}]}
{"pr_number": 71611, "url": "https://github.com/llvm/llvm-project/pull/71611", "title": "[mlir][sparse][gpu] cleanup GPUDataTransferStrategy", "body": "Rationale:\r\nThe flag seemed to do very little different between zero cost and pinned dma. In addition, the register host is not truly the right zero cost flag. So we are simplifying the set up for now, until we have a better definition for what to test.\r\n\r\nhttps://github.com/llvm/llvm-project/issues/64316", "feature_layers": ["parse", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/Transforms/SparseGPUCodegen.cpp", "functions": ["rewriteSpGEMM", "rewriteSDDMM", "rewrite2To4SpMM", "OpRewritePattern", "rewriteSpMM", "rewriteSpMV"]}]}
{"pr_number": 71480, "url": "https://github.com/llvm/llvm-project/pull/71480", "title": "[Clang][OpenMP] fixed crash due to invalid binary expression in checking atomic semantics", "body": "This PR fixes https://github.com/llvm/llvm-project/issues/69069 . \r\n", "feature_layers": ["sema"], "feature_directives": ["atomic"], "files_changed": [{"filename": "clang/test/SemaOpenMP/atomic-capture-const-no-crash.c", "functions": ["test"]}]}
{"pr_number": 71616, "url": "https://github.com/llvm/llvm-project/pull/71616", "title": "[OpenMP ]Added more libomptarget reduction tests", "body": "Based on https://github.com/llvm/llvm-project/pull/70766 I think it would be good to have a few more offloading reduction tests, so we do not accidentally break minimum and maximum reductions another time.", "feature_layers": [], "feature_directives": ["target"], "files_changed": [{"filename": "openmp/libomptarget/test/offloading/parallel_target_teams_reduction_max.cpp", "functions": ["test_max_val_reduction", "test_max_idx_reduction", "a", "test_max_reduction"]}, {"filename": "openmp/libomptarget/test/offloading/parallel_target_teams_reduction_min.cpp", "functions": ["test_min_reduction", "a", "test_min_val_reduction", "test_min_idx_reduction"]}]}
{"pr_number": 71488, "url": "https://github.com/llvm/llvm-project/pull/71488", "title": "[SEH] Fix assertin when return scalar value from __try block.", "body": "Current compler assert with `!SI->isAtomic() && !SI->isVolatile()' failed\r\n\r\nThis due to following rule:\r\nFirst, no exception can move in or out of _try region., i.e., no \"potential faulty instruction can be moved across _try boundary. Second, the order of exceptions for instructions 'directly' under a _try must be preserved (not applied to those in callees). Finally, global states (local/global/heap variables) that can be read outside of _try region must be updated in memory (not just in register) before the subsequent exception occurs.\r\n\r\nAll memory instructions inside a _try are considered as 'volatile' to assure 2nd and 3rd rules for C-code above. This is a little sub-optimized. But it's acceptable as the amount of code directly under _try is very small. However during findDominatingStoreToReturnValue: those are not allowed.\r\n\r\nTo fix just skip the assertion when current function has seh try.", "feature_layers": ["ir"], "feature_directives": ["for", "atomic"], "files_changed": [{"filename": "clang/test/CodeGen/windows-seh-EHa-TryInFinally.cpp", "functions": ["bar"]}]}
{"pr_number": 71468, "url": "https://github.com/llvm/llvm-project/pull/71468", "title": "[mlir][Tensor] Fold destination-style ops into `tensor.unpack` operation.", "body": "The destination operand of the `tensor.unpack` operation is only needed to carry shape information. So if the producer of the destination operand implements the `DestinationStyleOpInterface`, then fold it into the `tensor.unpack` operation by replacing the destination operand with the destination for the source.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Tensor/IR/TensorOps.cpp", "functions": ["failure", "success"]}]}
{"pr_number": 71568, "url": "https://github.com/llvm/llvm-project/pull/71568", "title": "[TSAN] Add __tsan_check_no_mutexes_held helper", "body": "This adds a new helper that can be called from application code to ensure that no mutexes are held on specific code paths. This is useful for multiple scenarios, including ensuring no locks are held:\r\n\r\n- at thread exit\r\n- in peformance-critical code\r\n- when a coroutine is suspended (can cause deadlocks)\r\n\r\nSee this discourse thread for more discussion:\r\nhttps://discourse.llvm.org/t/add-threadsanitizer-check-to-prevent-coroutine-suspending-while-holding-a-lock-potential-deadlock/74051\r\n\r\nThis resubmits and fixes #69372 (was reverted because of build breakage).\r\nThis also includes the followup change #71471 (to fix a land race).", "feature_layers": [], "feature_directives": ["for", "critical"], "files_changed": [{"filename": "compiler-rt/lib/tsan/rtl/tsan_interface_ann.cpp", "functions": ["rep", "__tsan_check_no_mutexes_held", "l", "ReportMutexHeldWrongContext"]}, {"filename": "compiler-rt/test/tsan/mutex_held_wrong_context.cpp", "functions": ["main"]}]}
{"pr_number": 66377, "url": "https://github.com/llvm/llvm-project/pull/66377", "title": "[TableGen][GlobalISel] Add rule-wide type inference", "body": "NOTE: This is part of a stack. Please only review the last commit, see #66079 for the previous commit(s).\r\n\r\nThe inference is trivial and leverages the MCOI OperandTypes encoded in\r\nCodeGenInstructions to infer types across patterns in a CombineRule. It's\r\nthus very limited and only supports CodeGenInstructions (but that's the main\r\nuse case so it's fine).\r\n\r\nWe only try to infer untyped operands in apply patterns when they're temp\r\nreg defs, or immediates. Inference always outputs a `TypeOf<$x>` where $x is\r\na named operand from a match pattern.\r\n\r\nThis allows us to drop the `GITypeOf` in #66079 without errors.", "feature_layers": ["codegen", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/utils/TableGen/GlobalISelCombinerEmitter.cpp", "functions": ["toString", "doSetsIntersect", "setVectorUnion"]}]}
{"pr_number": 71278, "url": "https://github.com/llvm/llvm-project/pull/71278", "title": "[BOLT][AArch64] Don't change layout in PatchEntries", "body": "Due to LongJmp pass that is executed before PatchEntries we can't ignore\r\nthe function here since it would change pre-calculated output layout.\r\nThe test reloc-26 relied on the wrong behavior, rewritten to unittest.\r\nThis is also attemp to fix #70771", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "bolt/unittests/Core/BinaryContext.cpp", "functions": ["OS", "Vect"]}]}
{"pr_number": 71104, "url": "https://github.com/llvm/llvm-project/pull/71104", "title": "[BOLT][AArch64] Handle IFUNCS properly", "body": "Currently we were testing only the binaries compiled with O0, which\nresults in indirect call to the IFUNC trampoline and the trampoline has\nassociated IFUNC symbol with it. Compile with O3 results in direct\ncalling the IFUNC trampoline and no symbols are associated with it, the\nIFUNC symbol address becomes the same as IFUNC resolver address. Since\nno symbol was associated the BF was not created before PLT analyze and\nbe the algorithm we're going to analyze target relocation. As we're\nexpecting the JUMP relocation we're also expecting the associated symbol\nwith it to be presented. But for IFUNC relocation the IRELATIVE\nrelocation is used and no symbol is associated with it, the addend value\nis pointing on the target symbol, so we need to find BF using it and use\nit's symbol in this situation. Currently this is checked only for\nAArch64 platform, so I've limited it in code to use this logic only for\nthis platform, although I wouldn't be surprised if other platforms needs\nto activate this logic too.\n", "feature_layers": ["ir"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "bolt/test/AArch64/ifunc.c", "functions": ["foo", "_start"]}]}
{"pr_number": 70915, "url": "https://github.com/llvm/llvm-project/pull/70915", "title": "[mlir][ArmSME] Add support for lowering masked tile_load ops", "body": "This patch extends ArmSMEToSCF to support lowering of masked tile_load\r\nops. Only masks created by 'vector.create_mask' are currently supported.\r\n\r\nThere are two lowerings, one for pad of constant zero and another for\r\nnon-zero pad. For the following example:\r\n```\r\n  %pad = arith.constant 0 : i32\r\n  %num_rows = arith.constant 2 : index\r\n  %num_cols = arith.constant 4 : index\r\n  %mask = vector.create_mask %num_rows, %num_cols : <[4]x[4]xi1>\r\n  %tile = arm_sme.tile_load %src[%c0, %c0], %pad, %mask : memref<?x?xi32>,\r\n                                                          vector<[4]x[4]xi32>\r\n```\r\nThe former (constant non-zero pad) is lowered as follows:\r\n---------------------------------------------------------\r\n```\r\n  %tile = arm_sme.zero : vector<[4]x[4]xi32>\r\n  %num_cols = vector.create_mask %c4 : vector<[4]xi1>\r\n  scf.for %slice_idx = %c0 to %num_rows step %c1\r\n    %tile_update = arm_sme.load_tile_slice\r\n      %src[%slice_idx], %num_cols, %tile, %tile_slice_idx :\r\n      memref<?x?xi32>, vector<[1]xi32>, vector<[4]x[4]xi32>\r\n```\r\nThe tile is zeroed the satisfy the padding and only active rows are\r\nloaded.\r\n\r\nThe latter (non-zero pad) is lowered as follows:\r\n------------------------------------------------\r\n```\r\n  scf.for %slice_idx = %c0 to %num_tile_slices step %c1 {\r\n    %row_is_active = arith.cmpi ult %slice_idx, %num_rows : index\r\n    %mask = // sext row_is_active then and with num_cols\r\n    %slice = vector.maskedload %src[%slice_idx, %c0], %mask, %pad_1d :\r\n        memref<?x?xf32>, vector<[4]xi1>, vector<[4]xf32> into vector<[4]xf32>\r\n    arm_sme.move_vector_to_tile_slice %slice, %tile, %slice_idx\r\n      : vector<[4]xi32> into vector<[4]x[4]xi32>\r\n```\r\nThe scalar pad is broadcast to a 1-D vector and a regular\r\n'vector.masked_load' (will be lowered to SVE, not SME) loads each slice\r\nfor active rows, with padding specified as a passthru. For non-active\r\nrows the slice is the 1-D pad. The resulting slice is inserted into the\r\ntile with 'arm_sme.move_vector_to_tile_slice'.", "feature_layers": ["ir", "ast"], "feature_directives": ["for", "masked"], "files_changed": [{"filename": "mlir/lib/Conversion/ArmSMEToSCF/ArmSMEToSCF.cpp", "functions": ["g", "success"]}]}
{"pr_number": 70300, "url": "https://github.com/llvm/llvm-project/pull/70300", "title": "[lldb][AArch64][Linux] Add field information for the CPSR register", "body": "The contents of which are mostly SPSR_EL1 as shown in the Arm manual, with a few adjustments for things Linux says userspace shouldn't concern itself with.\r\n\r\n```\r\n(lldb) register read cpsr\r\n    cpsr = 0x80001000\r\n         = (N = 1, Z = 0, C = 0, V = 0, SS = 0, IL = 0, ...\r\n```\r\n\r\nSome fields are always present, some depend on extensions. I've checked for those extensions using HWCAP and HWCAP2.\r\n\r\nTo provide this for core files and live processes I've added a new class LinuxArm64RegisterFlags. This is a container for all the registers we'll want to have fields and handles detecting fields and updating register info.\r\n\r\nThis is used by the native process as follows:\r\n* There is a global LinuxArm64RegisterFlags object.\r\n* The first thread takes a mutex on it, and updates the fields.\r\n* Subsequent threads see that detection is already done, and skip it.\r\n* All threads then update their own copy of the register information with pointers to the field information contained in the global object.\r\n\r\nThis means that even though every thread will have the same fields, we only detect them once and have one copy of the information.\r\n\r\nCore files instead have a LinuxArm64RegisterFlags as a member, because each core file could have different saved capabilities. The logic from there is the same but we get HWACP values from the corefile note.\r\n\r\nThis handler class is Linux specific right now, but it can easily be made more generic if needed. For example by using LLVM's FeatureBitset instead of HWCAPs.\r\n\r\nUpdating register info is done with string comparison, which isn't ideal. For CPSR, we do know the register number ahead of time but we do not for other registers in dynamic register sets. So in the interest of consistency, I'm going to use string comparison for all registers including cpsr.\r\n\r\nI've added tests with a core file and live process. Only checking for fields that are always present to account for CPU variance.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "lldb/source/Plugins/Process/Linux/NativeRegisterContextLinux_arm64.cpp", "functions": ["lock"]}, {"filename": "lldb/source/Plugins/Process/elf-core/RegisterContextPOSIXCore_arm64.cpp", "functions": ["aux_vec"]}, {"filename": "lldb/source/Target/RegisterFlags.cpp", "functions": ["m_id"]}]}
{"pr_number": 69725, "url": "https://github.com/llvm/llvm-project/pull/69725", "title": "[Clang][SME2] Add multi-vector add/sub builtins", "body": "Adds the following SME2 builtins:\r\n - sv(add|sub)\r\n - sv(add|sub)_za32/za64,\r\n - sv(add|sub)_write_za32/za64\r\n\r\nOther changes in this patch:\r\n - CGBuiltin.cpp: The GetAArch64SMEProcessedOperands function is created\r\n    to avoid duplicating existing code from EmitAArch64SVEBuiltinExpr.\r\n - arm_sve.td: The add/sub SME2 builtins which do not operate on ZA have\r\n    been added to arm_sve.td, matching the corrosponding LLVM IR intrinsic\r\n    names which start with @llvm.aarch64.sve for this reason.\r\n - SveEmitter.cpp: Adds the createCoreHeaderIntrinsics function to remove\r\n    duplicated code in createHeader & createSMEHeader. Uses a new enum\r\n    (ACLEKind) to choose either \"__builtin_sme_\" or \"__builtin_sve_\" when\r\n    emitting the intrinsics.\r\n\r\nSee https://github.com/ARM-software/acle/pull/217/files", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CodeGen/aarch64-sme2-intrinsics/acle_sme2_add.c", "functions": ["test_svadd_vector_single4_s8", "test_svadd_vector_single2_u64", "test_svadd_vector_single2_s32", "test_svadd_vector_single4_u32", "test_svadd_vector_single4_u16", "test_svadd_vector_single2_s16", "test_svadd_vector_single4_s32", "test_svadd_vector_single2_u32", "test_svadd_vector_single2_u8", "test_svadd_vector_single2_s64", "test_svadd_vector_single4_u8", "test_svadd_vector_single4_s16", "test_svadd_vector_single4_s64", "test_svadd_vector_single2_s8", "test_svadd_vector_single4_u64", "SVE_ACLE_FUNC", "test_svadd_vector_single2_u16"]}, {"filename": "clang/test/CodeGen/aarch64-sme2-intrinsics/acle_sme2_sub.c", "functions": ["test_svsub_write_single4_u64", "test_svsub_write_single4_u32", "test_svsub_write_multi2_s32", "test_svsub_write_single2_s32", "test_svsub_write_single2_u64", "test_svsub_write_single4_s64", "test_svsub_za32_vg1x4_f32", "test_svsub_write_single4_s32", "test_svsub_za32_vg1x4_u32", "test_svsub_za64_vg1x4_u64", "test_svsub_za64_vg1x4_f64", "test_svsub_write_single2_s64", "test_svsub_za32_vg1x2_u32", "test_svsub_za64_vg1x2_f64", "test_svsub_write_multi2_s64", "test_svsub_za32_vg1x2_f32", "test_svsub_za32_vg1x2_s32", "test_svsub_write_multi4_s64", "test_svsub_za32_vg1x4_s32", "test_svsub_za64_vg1x2_s64", "test_svsub_za64_vg1x2_u64", "test_svsub_za64_vg1x4_s64", "test_svsub_write_multi4_s32", "test_svsub_write_multi4_u32", "test_svsub_write_multi2_u64", "test_svsub_write_single2_u32", "test_svsub_write_multi2_u32", "test_svsub_write_multi4_u64"]}, {"filename": "clang/utils/TableGen/SveEmitter.cpp", "functions": ["createCoreHeaderIntrinsics", "ToTuple"]}, {"filename": "clang/test/CodeGen/aarch64-sme2-intrinsics/acle_sme2_vector_add.c", "functions": ["test_svadd_vector_single4_s8", "test_svadd_vector_single2_u64", "test_svadd_vector_single2_s32", "test_svadd_vector_single4_u32", "test_svadd_vector_single4_u16", "test_svadd_vector_single2_s16", "test_svadd_vector_single4_s32", "test_svadd_vector_single2_u32", "test_svadd_vector_single2_u8", "test_svadd_vector_single2_s64", "test_svadd_vector_single4_u8", "test_svadd_vector_single4_s16", "test_svadd_vector_single4_s64", "test_svadd_vector_single2_s8", "test_svadd_vector_single4_u64", "SVE_ACLE_FUNC", "test_svadd_vector_single2_u16"]}]}
{"pr_number": 71257, "url": "https://github.com/llvm/llvm-project/pull/71257", "title": "InstCombine: fix transformation of bitwiseAnd to fabs", "body": "Since 5c0da5839de1 instcombine transform pattern masking the MSB with a call to fabs.\r\n\r\nWhile this might be correct in C, it is not in OpenCL. Math operations are allowed to flush denormalized numbers to zero in OpenCL. Thus what should be just masking the MSB starts to change much more data.\r\n\r\nThis is an issue in libclc as those implementations are using this pattern and rely on the fact that only the MSB is masked. Using fabs instead breaks conformance on platforms where fabs flushes denormalized numbers to zero.\r\n\r\nInstead look for the complete pattern:\r\n```\r\nbitcast float to int\r\nbitwiseand\r\nbitcast int to float\r\n=>\r\nfabs\r\n```\r\n\r\nFix #69464", "feature_layers": ["ast"], "feature_directives": ["for", "flush", "masked"], "files_changed": [{"filename": "llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp", "functions": ["BitCastInst"]}]}
{"pr_number": 70923, "url": "https://github.com/llvm/llvm-project/pull/70923", "title": "[MLIR][NVGPU] Improve and Cleanup verifier of TMA OPs", "body": "This PR improves and cleans-up verifiers of TmaCreateDescriptor and TmaAsyncLoad Ops and unifies them.\r\n\r\nThe PR verifiers followings that didn't before:\r\n- address space\r\n- rank match between descriptor and memref\r\n- element type match between descriptor and memref\r\n- shape type match between descriptor and memref", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/NVGPU/IR/NVGPUDialect.cpp", "functions": ["emitError"]}]}
{"pr_number": 65593, "url": "https://github.com/llvm/llvm-project/pull/65593", "title": "[AArch64][SME]Update intrinsic interface for ldr/str", "body": "The new ACLE PR#225[1] now combines the slice parameters for some builtins. This patch is the #3 of 3 patches to update the interface.\r\n\r\n[1]https://github.com/ARM-software/acle/pull/225/files", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CodeGen/aarch64-sme-intrinsics/acle_sme_ldr.c", "functions": ["test_svldr_za"]}, {"filename": "clang/test/CodeGen/aarch64-sme-intrinsics/acle_sme_str.c", "functions": ["test_svstr_za"]}]}
{"pr_number": 68032, "url": "https://github.com/llvm/llvm-project/pull/68032", "title": "[ConstraintElim] Support arbitrary incoming values for inductions", "body": "Support arbitray incoming values for AddRecs by getting the loop predecessor and checking if its SCEV matches the AddRec start.\r\n\r\nThis is done after the existing check, which can help to catch cases where the expression gets simplified by SCEV to either an IR constant or existing value which can be used instead.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Scalar/ConstraintElimination.cpp", "functions": ["if"]}]}
{"pr_number": 71668, "url": "https://github.com/llvm/llvm-project/pull/71668", "title": "[SystemZ] Add backchain target-feature", "body": "GCC supports building individual functions with backchain using the __attribute__((target(\"backchain\"))) syntax, and Clang should too.\r\n\r\nClang translates this into the \"target-features\"=\"+backchain\" attribute, and the -mbackchain command-line option into the \"backchain\" attribute. The backend currently checks only the latter; furthermore, the backchain target feature is not defined.\r\n\r\nHandle backchain like soft-float. Define a target feature, convert function attribute into it in getSubtargetImpl(), and check for target feature instead of function attribute everywhere. Add an end-to-end test to the Clang testsuite.", "feature_layers": [], "feature_directives": ["for", "target"], "files_changed": [{"filename": "clang/test/CodeGen/SystemZ/mbackchain-4.c", "functions": ["__builtin_return_address"]}]}
{"pr_number": 71585, "url": "https://github.com/llvm/llvm-project/pull/71585", "title": "[InstSimplify] Check call for FMF instead of CtxI", "body": "This code was incorrectly checking that the CtxI has required FMF, but\r\nthe context instruction need not always be the instrinsic call.\r\n\r\nCheck that the intrinsic call has the required FMF.\r\n\r\nFixes PR71548.\r\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Analysis/InstructionSimplify.cpp", "functions": ["simplifyUnaryIntrinsic", "simplifyBinaryIntrinsic"]}]}
{"pr_number": 69946, "url": "https://github.com/llvm/llvm-project/pull/69946", "title": "[OpenMP] Add skewed iteration distribution on hybrid systems", "body": "This commit adds skewed distribution of iterations in `nonmonotonic:dynamic` schedule (static steal) for hybrid systems when thread affinity is assigned. Currently, it distributes the iterations at 60:40 ratio. Consider this loop with dynamic schedule type,\r\n`for (int i = 0; i < 100; ++i)`. In a hybrid system with 20 hardware threads (16 CORE and 4 ATOM core), 88 iterations will be assigned to performance cores and 12 iterations will be assigned to efficient cores. Each thread with CORE core will process 5 iterations + extras and with ATOM core will process 3 iterations.\r\n\r\nOriginal Phabricator Patch: https://reviews.llvm.org/D152955", "feature_layers": [], "feature_directives": ["for", "distribute"], "files_changed": [{"filename": "openmp/runtime/src/kmp_affinity.cpp", "functions": ["__kmp_get_first_osid_with_ecore"]}, {"filename": "openmp/runtime/src/kmp_dispatch.cpp", "functions": ["__kmp_round_2decimal_val", "__kmp_get_float_val"]}]}
{"pr_number": 71260, "url": "https://github.com/llvm/llvm-project/pull/71260", "title": "[lldb] Check for abstract methods implementation in Scripted Plugin Objects", "body": "This patch enforces that every scripted object implements all the necessary abstract methods.\r\n\r\nEvery scripted affordance language interface can implement a list of abstract methods name that checked when the object is instanciated.\r\n\r\nSince some scripting affordances implementations can be derived from template base classes, we can't check the object dictionary since it will contain the definition of the base class, so instead, this checks the scripting class dictionary.\r\n\r\nPreviously, for the various python interfaces, we used `ABC.abstractmethod` decorators but this is too language specific and doesn't work for scripting affordances that are not derived from template base classes (i.e OperatingSystem, ScriptedThreadPlan, ...), so this patch provides generic/language-agnostic checks for every scripted affordance.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.cpp", "functions": ["key_object"]}]}
{"pr_number": 69769, "url": "https://github.com/llvm/llvm-project/pull/69769", "title": "Introduce DIExpressionOptimizer", "body": "DIExpressionOptimizer is a lightweight class that can be used to optimize DIExpressions that can get very large, by involving some simple constant folding and removing appends of unnecessary operations.\r\n\r\nFor example:\r\n\r\nIf we have a `DIExpression: {dwarf::DW_OP_LLVM_arg, 0, dwarf::DW_OP_constu, 2, dwarf::DW_OP_plus}` and want to append `{dwarf::DW_OP_constu, 3, dwarf::DW_OP_plus}`\r\n\r\nInstead of having the final `DIExpression be {dwarf::DW_OP_LLVM_arg, 0, dwarf::DW_OP_constu, 2, dwarf::DW_OP_plus, dwarf::DW_OP_constu, 3, dwarf::DW_OP_plus}. `\r\n\r\nIt will be reduced to `{dwarf::DW_OP_LLVM_arg, 0, dwarf::DW_OP_constu, 5, dwarf::DW_OP_plus}`\r\n\r\nThere is an implementation for `DW_OP_mul` and `DW_OP_plus_uconst` as well\r\n\r\nIt also just flat out does not append `{DW_OP_constu, 1, DW_OP_mul}, {DW_OP_constu, 1, DW_OP_div}, {DW_OP_constu, 0, DW_OP_plus}, {DW_OP_constu, 0, DW_OP_minus}, {DW_OP_constu, 0, DW_OP_shl}, {DW_OP_constu, 0, DW_OP_shr}`\r\n\r\nHopefully this can be improved upon by the larger community to add more optimizations in the future.\r\n\r\nThis patch is part of a stacked diff, I was not sure how to do this any better because github squashes multiple commits in one PR, but the PR this depends on is:\r\n\r\nhttps://github.com/llvm/llvm-project/pull/69768", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/IR/DebugInfoMetadata.cpp", "functions": ["Cursor"]}]}
{"pr_number": 70639, "url": "https://github.com/llvm/llvm-project/pull/70639", "title": "[clang][DebugInfo] Emit global variable definitions for static data members with constant initializers", "body": "When an LLDB user asks for the value of a static data member, LLDB starts by\r\nsearching the Names accelerator table for the corresponding variable definition\r\nDIE. For static data members with out-of-class definitions that works fine,\r\nbecause those get represented as global variables with a location and making them\r\neligible to be added to the Names table. However, in-class definitions won\u2019t get\r\nindexed because we usually don't emit global variables for them. So in DWARF\r\nwe end up with a single `DW_TAG_member` that usually holds the constant initializer.\r\nBut we don't get a corresponding CU-level `DW_TAG_variable` like we do for\r\nout-of-class definitions.\r\n\r\nTo make it more convenient for debuggers to get to the value of inline static data members,\r\nthis patch makes sure we emit definitions for static variables with constant initializers\r\nthe same way we do for other static variables. This also aligns Clang closer to GCC, which\r\nproduces CU-level definitions for inline statics and also emits these into `.debug_pubnames`.\r\n\r\nThe implementation keeps track of newly created static data members. Then in\r\n`CGDebugInfo::finalize`, we emit a global `DW_TAG_variable` with a `DW_AT_const_value` for\r\nany of those declarations that didn't end up with a definition in the `DeclCache`.\r\n\r\nThe newly emitted `DW_TAG_variable` will look as follows:\r\n```\r\n0x0000007b:   DW_TAG_structure_type\r\n                DW_AT_calling_convention        (DW_CC_pass_by_value)\r\n                DW_AT_name      (\"Foo\")\r\n                ...\r\n\r\n0x0000008d:     DW_TAG_member\r\n                  DW_AT_name    (\"i\")\r\n                  DW_AT_type    (0x00000062 \"const int\")\r\n                  DW_AT_external        (true)\r\n                  DW_AT_declaration     (true)\r\n                  DW_AT_const_value     (4)\r\n\r\nNewly added\r\nvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv\r\n\r\n0x0000009a:   DW_TAG_variable\r\n                DW_AT_specification     (0x0000008d \"i\")\r\n                DW_AT_const_value       (4)\r\n                DW_AT_linkage_name      (\"_ZN2t2IiE1iIfEE\")\r\n```", "feature_layers": [], "feature_directives": ["for", "single"], "files_changed": [{"filename": "clang/test/CodeGenCXX/debug-info-static-inline-member.cpp", "functions": ["func", "main"]}]}
{"pr_number": 71014, "url": "https://github.com/llvm/llvm-project/pull/71014", "title": "[Coroutines] Introduce [[clang::coro_only_destroy_when_complete]]", "body": "Close https://github.com/llvm/llvm-project/issues/56980.\r\n\r\nThis patch tries to introduce a light-weight optimization attribute for coroutines which are guaranteed to only be destroyed after it reached the final suspend.\r\n\r\nThe rationale behind the patch is simple. See the example:\r\n\r\n```C++\r\nA foo() {\r\n  dtor d;\r\n  co_await something();\r\n  dtor d1;\r\n  co_await something();\r\n  dtor d2;\r\n  co_return 43;\r\n}\r\n```\r\n\r\nGenerally the generated .destroy function may be:\r\n\r\n```C++\r\nvoid foo.destroy(foo.Frame *frame) {\r\n  switch(frame->suspend_index()) {\r\n    case 1:\r\n      frame->d.~dtor();\r\n      break;\r\n    case 2:\r\n      frame->d.~dtor();\r\n      frame->d1.~dtor();\r\n      break;\r\n    case 3:\r\n      frame->d.~dtor();\r\n      frame->d1.~dtor();\r\n      frame->d2.~dtor();\r\n      break;\r\n    default: // coroutine completed or haven't started\r\n      break;\r\n  }\r\n\r\n  frame->promise.~promise_type();\r\n  delete frame;\r\n}\r\n```\r\n\r\nSince the compiler need to be ready for all the cases that the coroutine may be destroyed in a valid state.\r\n\r\nHowever, from the user's perspective, we can understand that certain coroutine types may only be destroyed after it reached to the final suspend point. And we need a method to teach the compiler about this. Then this is the patch. After the compiler recognized that the coroutines can only be destroyed after complete, it can optimize the above example to:\r\n\r\n```C++\r\nvoid foo.destroy(foo.Frame *frame) {\r\n  frame->promise.~promise_type();\r\n  delete frame;\r\n}\r\n```\r\n\r\nI spent a lot of time experimenting and experiencing this in the downstream. The numbers are really good. In a real-world coroutine-heavy workload, the size of the build dir (including .o files) reduces 14%. And the size of final libraries (excluding the .o files) reduces 8% in Debug mode and 1% in Release mode.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CodeGenCoroutines/coro-only-destroy-when-complete.cpp", "functions": ["await_resume", "unhandled_exception", "foo", "return_value", "await_suspend", "something", "initial_suspend", "await_ready", "get_return_object", "final_suspend"]}]}
{"pr_number": 71770, "url": "https://github.com/llvm/llvm-project/pull/71770", "title": "[RISCV][NFC] Pass MCSubtargetInfo instead of FeatureBitset in RISCVMatInt", "body": "The use of `hasFeature` is more descriptive and the callers of\r\n`RISCVMatInt` have no need to call `getFeatureBits()` any more.", "feature_layers": [], "feature_directives": ["target"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp", "functions": ["generateInstSeq"]}]}
{"pr_number": 70364, "url": "https://github.com/llvm/llvm-project/pull/70364", "title": "[JITLink][AArch32] Add support for ELF::R_ARM_THM_MOV{W_PREL_NC,T_PREL}", "body": "Support for ELF::R_ARM_THM_MOVW_PREL_NC and ELF::R_ARM_THM_MOVT_PREL\r\nis added. Move instructions with PC-relative immediates can be handled in Thumb mode with this addition.\r\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/ExecutionEngine/JITLink/aarch32.cpp", "functions": ["makeUnexpectedOpcodeError"]}]}
{"pr_number": 69636, "url": "https://github.com/llvm/llvm-project/pull/69636", "title": "[JITLink][AArch32] Unittest for error paths of readAddend and applyFixup functionality", "body": "This commit is part of an effort to increase coverage of AArch32 backend.\r\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/unittests/ExecutionEngine/JITLink/AArch32Tests.cpp", "functions": ["R_Arm", "E", "B1Addr", "InvalidEdge", "R_Thumb"]}, {"filename": "llvm/unittests/ExecutionEngine/JITLink/AArch32ErrorTests.cpp", "functions": ["B3DummyAddr", "MutableArmContent", "E", "B2DummyAddr"]}]}
{"pr_number": 71465, "url": "https://github.com/llvm/llvm-project/pull/71465", "title": "[lldb/Interpreter] Make Scripted*Interface base class abstract", "body": "This patch makes the various Scripted Interface base class abstract by making the `CreatePluginObject` method pure virtual.\r\n\r\nThis means that we cannot construct a Scripted Interface base class instance, so this patch also updates the various `ScriptedInterpreter::CreateScripted*Interface` methods to return a `nullptr` instead.`\r\n\r\nThis patch also removes the `ScriptedPlatformInterface` member from the `ScriptInterpreter` class since it the interpreter can be owned by the `ScriptedPlatform` instance itself, like we do for `ScriptedProcess` objects.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "lldb/source/Interpreter/ScriptInterpreter.cpp", "functions": ["m_debugger"]}]}
{"pr_number": 71754, "url": "https://github.com/llvm/llvm-project/pull/71754", "title": "[MLIR][Affine] Generalize/fix mdg init for region-holding ops with known control flow", "body": "Generalize/fix mdg init for region-holding ops with well-defined control\nflow. Use the memory effect interface to determine when to create a\nnode. While on this, remove the special treatment there for call ops.\n\nThis allows fusion of affine nests even in the presence of scf region\nops elsewhere in the Block. Previously, even a single scf.for/if/while\nop in a block would have made fusion bail out on all affine fusion that\nwas possible. Addressed.\n", "feature_layers": ["ir"], "feature_directives": ["for", "single"], "files_changed": [{"filename": "mlir/lib/Dialect/Affine/Analysis/Utils.cpp", "functions": ["node"]}]}
{"pr_number": 71610, "url": "https://github.com/llvm/llvm-project/pull/71610", "title": "[mlir][vector] Add pattern to distribute masked reads", "body": "Because the distribution is based on types, supporting general masked reads requires first materializing the permutation map in IR to align the elements of the mask with the elements read by the transfer op. For now just support cases with the trivial permutation map.", "feature_layers": ["ir"], "feature_directives": ["for", "distribute", "requires", "masked"], "files_changed": [{"filename": "mlir/lib/Dialect/Vector/Transforms/VectorDistribute.cpp", "functions": ["failure"]}]}
{"pr_number": 71487, "url": "https://github.com/llvm/llvm-project/pull/71487", "title": "Make DWARFUnitVector threadsafe.", "body": "The DWARFUnitVector class lives inside of the DWARFContextState. Prior to this fix a non const reference was being handed out to clients. When fetching the DWO units, there used to be a \"bool Lazy\" parameter that could be passed that would allow the DWARFUnitVector to parse individual units on the fly. There were two major issues with this approach:\r\n- not thread safe and causes crashes\r\n- the accessor would check if DWARFUnitVector was empty and if not empty it would return a partially filled in DWARFUnitVector if it was constructed with \"Lazy = true\"\r\n\r\nThis patch fixes the issues by always fully parsing the DWARFUnitVector when it is requested and only hands out a \"const DWARFUnitVector &\". This allows the thread safety mechanism built into the DWARFContext class to work corrrectly, and avoids the issue where if someone construct DWARFUnitVector with \"Lazy = true\", and then calls an API that partially fills in the DWARFUnitVector with individual entries, and then someone accesses the DWARFUnitVector, they would get a partial and incomplete listing of the DWARF units for the DWOs.", "feature_layers": ["parse"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/DebugInfo/DWARF/DWARFUnit.cpp", "functions": ["Data", "if"]}]}
{"pr_number": 71728, "url": "https://github.com/llvm/llvm-project/pull/71728", "title": "[RISCVInsertVSETVLI] Allow PRE with non-immediate AVLs", "body": "Extend our PRE logic to cover non-immediate AVL values.  This covers large constant AVLs (which must be materialized in registers), and may help some code written explicitly with intrinsics.\r\n\r\nLooking at the existing code, I can't entirely figure out why I thought we needed VL == AVL to perform the PRE.  My best guess is that I was worried about the VLMAX < VL < 2 * VLMAX case, but the spec explicitly says that vsetvli must be determinist on any particular AVL value.\r\n\r\nThat case was, possibly by accident, covering another legality precondition.  Specifically, by only returning true for immediate and VLMAX AVL values, we didn't encounter the case where the AVL was a register and that register wasn't available in the predecessor (e.g. if AVL is a load in the MBB block itself).", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp", "functions": ["willVLBeAVL"]}]}
{"pr_number": 71625, "url": "https://github.com/llvm/llvm-project/pull/71625", "title": "[mlir][vector] Fix cases with multiple yielded transfer_read ops", "body": "This fixes two bugs:\r\n1) When deciding whether a transfer read could be propagated out of\r\n   a warp op, it looked for the first yield operand that was produced by\r\n   a transfer read. If this transfer read wasn't ready to be\r\n   distributed, the pattern would not re-check for any other transfer\r\n   reads that could have been propagated.\r\n2) When dropping dead warp results, we do so by updating the warp op\r\n   signature and splicing in the old region. This does not add the ops\r\n   in the body of the warp op back to the pattern applicator's worklist,\r\n   and thus those operations won't be DCE'd. This is a problem for\r\n   patterns like the one for transfer reads that will still see the dead\r\n   operation as a user.", "feature_layers": ["ir"], "feature_directives": ["for", "distribute"], "files_changed": [{"filename": "mlir/lib/Dialect/Vector/Transforms/VectorDistribute.cpp", "functions": ["failure"]}]}
{"pr_number": 71566, "url": "https://github.com/llvm/llvm-project/pull/71566", "title": "[NFC][InstrProf]Refactor readPGOFuncNameStrings", "body": "Refactor this function to take a callback for each decoded string, and change it to a static function in cpp. Move its (sole) caller from header to cpp.\r\n- This is a split of patch https://github.com/llvm/llvm-project/pull/66825; to minimize the diff created in a big PR.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/ProfileData/InstrProf.cpp", "functions": ["readPGOFuncNameStrings"]}]}
{"pr_number": 71598, "url": "https://github.com/llvm/llvm-project/pull/71598", "title": "Revert 112e49b38150b8bfdef01434309d1b05204193e4 due to a miscompile", "body": "- Revert \"[DAGCombiner] Transform `(icmp eq/ne (and X,C0),(shift X,C1))` to use rotate or to getter constants.\" - causes a miscompile, see https://github.com/llvm/llvm-project/commit/112e49b38150b8bfdef01434309d1b05204193e4#commitcomment-131943923\n- Revert \"[X86] Fix gcc warning about mix of enumeral and non-enumeral types. NFC\", which fixes a compiler warning in the commit above\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp", "functions": ["SDValue", "DL"]}]}
{"pr_number": 67164, "url": "https://github.com/llvm/llvm-project/pull/67164", "title": "[OpenMP][Flang] Add \"IsolatedFromAbove\" trait to omp.target", "body": "### This patch adds the PFT lowering changes required for adding the IsolatedFromAbove trait to omp.target.\r\n\r\nKey Changes:\r\n\r\n- Add IsolatedFromAbove trait to target op in MLIR.\r\n- Main reason for this change is to prevent CSE and other similar optimisations from crossing region boundaries for target operations. The link below has the discourse discussion surrounding this issue.\r\n- Move implicit operand capturing to the PFT lowering stage.\r\n- Implicit operands are first added as implicitly captured map_operands with their map_types set accordingly to indicate this. Later, all map_operands including implicit ones are added as block arguments.\r\n- Remove `implicit` attribute from the `MapInfoOp`. This information is already captured by the `map_type`.\r\n- The custom printer and parser for the map_types have been updated to show the `implicit` and `literal` map_types.\r\n- Update related tests.\r\n- This fixes #63555.\r\n- This fixes #70488.\r\n\r\nRelated discussion: https://discourse.llvm.org/t/rfc-prevent-cse-from-removing-expressions-inside-some-non-isolatedfromabove-operation-regions/73150\r\n", "feature_layers": ["parse", "ir", "parser"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "mlir/lib/Dialect/OpenMP/IR/OpenMPDialect.cpp", "functions": ["failure", "success"]}]}
{"pr_number": 71863, "url": "https://github.com/llvm/llvm-project/pull/71863", "title": "[OpenMP] Fix record-replay allocation order for kernel environment", "body": "", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "openmp/libomptarget/plugins-nextgen/common/PluginInterface/PluginInterface.cpp", "functions": ["saveKernelInput"]}]}
{"pr_number": 71489, "url": "https://github.com/llvm/llvm-project/pull/71489", "title": "[InstCombine] Fix buggy transform in foldNestedSelects; PR 71330", "body": "- [InstCombine] Add reduced test for PR 71330; NFC\n- [InstCombine] Fix buggy transform in `foldNestedSelects`; PR 71330\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp", "functions": ["match"]}]}
{"pr_number": 71575, "url": "https://github.com/llvm/llvm-project/pull/71575", "title": "[mlir][gpu] Eliminate redundant gpu.barrier ops", "body": "Adds a canonicalizer for gpu.barrier that gets rid of duplicates.", "feature_layers": ["ir"], "feature_directives": ["for", "barrier"], "files_changed": [{"filename": "mlir/lib/Dialect/GPU/IR/GPUDialect.cpp", "functions": ["failure", "success"]}]}
{"pr_number": 71615, "url": "https://github.com/llvm/llvm-project/pull/71615", "title": "[mlir][sparse][gpu] cleanup GPUDataTransferStrategy", "body": "The flag seems to be doing practically the same thing for zero cost and pinned dma. In addition, the register host is not truly the right zero cost mechanism according to Thomas. So we are simplifying the setup for now, until we have a better definition for what to implement and test.\r\n    \r\nhttps://github.com/llvm/llvm-project/issues/64316\r\n", "feature_layers": ["parse", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/Transforms/SparseGPUCodegen.cpp", "functions": ["rewriteSpGEMM", "rewriteSDDMM", "rewrite2To4SpMM", "OpRewritePattern", "rewriteSpMM", "rewriteSpMV"]}]}
{"pr_number": 70898, "url": "https://github.com/llvm/llvm-project/pull/70898", "title": "[YAMLParser] Unfold multi-line scalar values", "body": "Long scalar values can be split into multiple lines to improve readability. The rules are described in Section 6.5. \"Line Folding\", https://yaml.org/spec/1.2.2/#65-line-folding. In addition, for flow scalar styles, the Spec states that \"All leading and trailing white space characters on each line are excluded from the content\", https://yaml.org/spec/1.2.2/#73-flow-scalar-styles.\r\n\r\nThe patch implements these unfolding rules for double-quoted, single-quoted, and plain scalars.\r\n\r\nDepends on #71774 and #71775 ", "feature_layers": ["parse", "parser"], "feature_directives": ["for", "single"], "files_changed": [{"filename": "llvm/lib/Support/YAMLParser.cpp", "functions": ["StringRef", "unescapeDoubleQuoted", "getPlainValue", "getSingleQuotedValue", "Valid", "parseScalarValue", "getDoubleQuotedValue"]}, {"filename": "llvm/unittests/Support/YAMLParserTest.cpp", "functions": ["Stream", "expectCanParseScalar"]}]}
{"pr_number": 70498, "url": "https://github.com/llvm/llvm-project/pull/70498", "title": "[mlir][bytecode] Fix D155919 and enable backward-compatibility and back-deployment between version 5 and version 6 of the bytecode encoding", "body": "Before D155919, when a dialect was leveraging properties to store attributes with `usePropertiesForAttributes`, the operand segment sizes attribute was emitted in the property section in sorted order together with all the other attributes of an op. After D155919, version 5 of the bytecode was emitting and parsing operand segment sizes after all the properties of an op, breaking backward compatibility and back deployment. This patch fixes the emission ordering and allows to parse bytecode files emitted before (D155919) with version 5 of MLIR bytecode. The patch also enables to emit correctly version 5 of MLIR bytecode.", "feature_layers": ["parse", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/tools/mlir-tblgen/OpDefinitionsGen.cpp", "functions": ["fmtCtxt", "tgfmt", "getOperandSegmentSizesLegacyIndex", "getResultSegmentSizesLegacyIndex"]}]}
{"pr_number": 70369, "url": "https://github.com/llvm/llvm-project/pull/70369", "title": "[CUDA][HIP] Make template implicitly host device", "body": "Added option -foffload-implicit-host-device-templates which is off by default.\r\n\r\nWhen the option is on, template functions and specializations without\r\nhost/device attributes have implicit host device attributes.\r\n\r\nThey can be overridden by device template functions with the same signagure.\r\nThey are emitted on device side only if they are used on device side.\r\n\r\nThis feature is added as an extension.\r\n`__has_extension(cuda_implicit_host_device_templates)` can be used to\r\ncheck whether it is enabled.\r\n\r\nThis is to facilitate using standard C++ headers for device.\r\n\r\nFixes: https://github.com/llvm/llvm-project/issues/69956\r\n\r\nFixes: SWDEV-428314\r\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/CodeGen/CodeGenModule.cpp", "functions": ["hasImplicitAttr"]}]}
{"pr_number": 70624, "url": "https://github.com/llvm/llvm-project/pull/70624", "title": "[RISCV][GISel] Add support for G_FCMP with F and D extensions.", "body": "We only have instructions for OEQ, OLT, and OGT. We need to convert other comparison codes into those.\r\n\r\nI think we'll likely want to split this up in the future to support optimizations. Maybe do some of it in the legalizer or in a new post legalizer lowering pass. So this patch is just enough to get something working without adding 11 additional patterns to tablegen for each type.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp", "functions": ["getFCmpOpcode", "selectFPCompare"]}, {"filename": "llvm/lib/Target/RISCV/GISel/RISCVLegalizerInfo.cpp", "functions": ["typeIs"]}]}
{"pr_number": 71181, "url": "https://github.com/llvm/llvm-project/pull/71181", "title": "[mlir][ArmSME] Lower transfer_write + transpose to vertical store", "body": "This patch extends the lowering of vector.transfer_write in\r\nVectorToArmSME to support in-flight transpose via SME vertical store.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Conversion/VectorToArmSME/VectorToArmSME.cpp", "functions": ["if"]}]}
{"pr_number": 69148, "url": "https://github.com/llvm/llvm-project/pull/69148", "title": "[mlir][ArmSME] Add masking support to memory ops", "body": "This patch series adds masking support to the ArmSME memory ops, as well as lowerings from Vector `transfer_read` and `vector.transfer_write`. The `transfer_read` to ArmSME is more complete than `transfer_write`, for the latter the VectorToArmSME lowering still needs fleshing out to support in-flight transpose via vertical load and integration tests need to be added.\r\n\r\nThis support is part of a wider effort to lower linalg.matmul to SME. There's a lot of changes here so I don't expect this to be reviewed as a whole, hence why I've created this as a draft PR. I plan to create separate PRs for each commit.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Conversion/VectorToArmSME/VectorToArmSME.cpp", "functions": ["if"]}, {"filename": "mlir/lib/Conversion/ArmSMEToSCF/ArmSMEToSCF.cpp", "functions": ["g", "success"]}]}
{"pr_number": 67330, "url": "https://github.com/llvm/llvm-project/pull/67330", "title": "[flang][OpenMP] Fix common block missing symbol crash", "body": "Fixes #65034 by skipping copy of host-association information if the concerned symbol is missing from the inner construct", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Lower/Bridge.cpp", "functions": ["isPresentShallowLookup", "bool"]}]}
{"pr_number": 70636, "url": "https://github.com/llvm/llvm-project/pull/70636", "title": "[mlir][linalg][NFC] Remove linalg subset hoisting", "body": "Remove `SubsetHoisting.cpp` and migrate all remaining uses to the newly added loop-invariant subset hoisting transform in `mlir/Transforms`.\r\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Linalg/Transforms/Hoisting.cpp", "functions": ["rewriter"]}, {"filename": "mlir/lib/Dialect/Linalg/Transforms/SubsetHoisting.cpp", "functions": ["failure", "users"]}]}
{"pr_number": 69481, "url": "https://github.com/llvm/llvm-project/pull/69481", "title": "[clangd] Add tweak for turning an unscoped into a scoped enum", "body": "", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang-tools-extra/clangd/refactor/tweaks/ScopifyEnum.cpp", "functions": ["getOffsetFromPosition", "prepare", "getPosition", "PrefixToInsert", "title", "apply", "getContentForFile", "addReplacement", "scopifyEnumValue", "scopifyEnumValues", "kind", "IsAlreadyScoped", "addClassKeywordToDeclarations"]}, {"filename": "clang-tools-extra/clangd/unittests/tweaks/ScopifyEnumTests.cpp", "functions": ["func"]}]}
{"pr_number": 71186, "url": "https://github.com/llvm/llvm-project/pull/71186", "title": "[AMDGPU] Fix GCNUpwardRPTracker. (WIP)", "body": "This is an early-preview, this patch is going to fix:\r\n\r\n1. Maximum register pressure calculation at the instruction level. \r\nPreviously max RP included both def and use of registers of an instruction. Now maximum RP includes _uses_ and _early-clobber defs_.\r\n\r\n2. Uses were incorrectly tracked and this resulted in a mismatch of live-in set reported by LiveIntervals and tracked live reg set when the beginning of the block is reached.\r\n\r\nInterface has changed, moveMaxPressure becomes deprecated and  getMaxPressure, resetMaxPressure functions are added. reset function seem now more consistent.\r\n\r\nGCNUpwardRPTracker interface may seem a bit strange but I would like to clarify what I had in mind when created it.\r\n\r\nThe idea was to have a tracker that can work on non-implemented tentative schedules, that is:\r\n1. Instruction order is maintained externally, like in array.\r\n2. LiveIntervals and dead/kill flags aren't updated on a tentative schedule.\r\n\r\nFor this reason it has no functions to advance to next instruction, it should not use dead/kill flags. It only uses LiveIntervals information to track usage of a register with subregs and to calculate starting live register set. The idea is that _lane bitmask of a reg's use_ should be the same for any schedule.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/GCNRegPressure.cpp", "functions": ["getLiveLaneMask"]}]}
{"pr_number": 67364, "url": "https://github.com/llvm/llvm-project/pull/67364", "title": "[RISCV][SDAG] Prefer ShortForwardBranch to lower sdiv by pow2", "body": "This patch lowers `sdiv x, +/-2**k` to `add + select + shift` when the short forward branch optimization is enabled. The latter inst seq performs faster than the seq generated by target-independent DAGCombiner. This algorithm is described in ***Hacker's Delight***.\r\n\r\nThis patch also removes duplicate logic in the X86 and AArch64 backend. But we cannot do this for the PowerPC backend since it generates a special instruction `addze`.\r\n", "feature_layers": ["ast"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp", "functions": ["DL"]}, {"filename": "llvm/lib/Target/AArch64/AArch64ISelLowering.cpp", "functions": ["DL"]}, {"filename": "llvm/lib/Target/RISCV/RISCVISelLowering.cpp", "functions": ["SDValue"]}, {"filename": "llvm/lib/Target/X86/X86ISelLowering.cpp", "functions": ["DL"]}]}
{"pr_number": 71868, "url": "https://github.com/llvm/llvm-project/pull/71868", "title": "[mlir][vector] Root the transfer write distribution pattern on the warp op", "body": "Currently when there is a mix of transfer read ops and transfer write ops that need to be distributed, because the pattern for write distribution is rooted on the transfer write, it is hard to guarantee that the write gets distributed after the read when the two aren't directly connected by SSA. This is likely still relatively unsafe when there are undistributable ops, but structurally these patterns are a bit difficult to work with. For now pattern benefits give fairly good guarantees for happy paths.", "feature_layers": ["ir"], "feature_directives": ["for", "distribute"], "files_changed": [{"filename": "mlir/lib/Dialect/Vector/Transforms/VectorDistribute.cpp", "functions": ["failure"]}, {"filename": "mlir/test/lib/Dialect/Vector/TestVectorTransforms.cpp", "functions": ["patterns"]}]}
{"pr_number": 71799, "url": "https://github.com/llvm/llvm-project/pull/71799", "title": "[AMDGPU] Fix operand definitions for atomic scalar memory instructions.", "body": "CPol and CPol_GLC1 operand classes have identical predicates, which means AsmParser cannot differentiate between the RTN and non-RTN variants of the instructions. When it currently selects the wrong instruction, a hack in cvtSMEMAtomic() corrects the op-code. Using the new predicated-value operands makes this hack and the whole conversion function not needed.\r\n\r\nOther uses of CPol_GLC1 operands are to be addressed separately.\r\n\r\nResolves about half of the remaining ~1000 pairs of ambiguous instructions.\r\n\r\nPart of <https://github.com/llvm/llvm-project/issues/69256>.", "feature_layers": ["parse", "ir", "parser"], "feature_directives": ["for", "atomic"], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp", "functions": ["getPredicate", "cvtSMEMAtomic"]}]}
{"pr_number": 71619, "url": "https://github.com/llvm/llvm-project/pull/71619", "title": "[mlir][vector] Add distribution pattern for vector.create_mask", "body": "This is the last step needed for basic support for distributing masked vector code. The lane id gets delinearized based on the distributed mask shape and then compared against the original mask sizes to compute the bounds for the distributed mask. Note that the distribution of masks is implicit on the shape specified by the warp op. As a result, it is the responsibility of the consumer of the mask to ensure the distributed mask will match its own distribution semantics.", "feature_layers": ["sema", "ir", "ast"], "feature_directives": ["for", "distribute", "masked"], "files_changed": [{"filename": "mlir/lib/Dialect/Vector/Transforms/VectorDistribute.cpp", "functions": ["failure"]}]}
{"pr_number": 71549, "url": "https://github.com/llvm/llvm-project/pull/71549", "title": "[NVPTX] Allow the ctor/dtor lowering pass to emit kernels", "body": "Summary:\nThis pass emits the new \"nvptx$device$init\" and \"nvptx$device$fini\"\nkernels that are callable by the device. This intends to mimic the\nmethod of lowering for AMDGPU where we emit `amdgcn.device.init` and\n`amdgcn.device.fini` respectively. These kernels simply iterate a symbol\ncalled `__init_array_start/stop` and `__fini_array_start/stop`.\nNormally, the linker provides these symbols automatically. In the AMDGPU\ncase we only need call the kernel and we call the ctors / dtors.\nHowever, for NVPTX we require the user initializes these variables to\nthe associated globals that we already emit as a part of this pass.\n\nThe motivation behind this change is to move away from OpenMP's handling\nof ctors / dtors. I would much prefer that the backend / runtime handles\nthis. That allows us to handle ctors / dtors in a language agnostic way,\n\nThis approach requires that the runtime initializes the associated\nglobals. They are marked `weak` so we can emit this per-TU. The kernel\nitself is `weak_odr` as it is copied exactly.\n\nOne downside is that any module containing these kernels elicitis the\n\"stack size cannot be statically determined warning\" every time from\n`nvlink` which is annoying but inconsequential for functionality. It\nwould be nice if there were a way to silence this warning however.\n", "feature_layers": ["runtime", "ir"], "feature_directives": ["for", "requires"], "files_changed": [{"filename": "llvm/lib/Target/NVPTX/NVPTXCtorDtorLowering.cpp", "functions": ["createInitOrFiniCalls", "IRB", "addKernelMetadata"]}]}
{"pr_number": 71688, "url": "https://github.com/llvm/llvm-project/pull/71688", "title": "[Clang][SME2] Add single and multi min and max builtins", "body": "Adds the following SME2 builtins:\r\n\r\n    svmin_single_(s8|s16|s32|s64)_x(2|4)\r\n    svmin_single_(u8|u16|u32|u64)_x(2|4)\r\n    svmin_single_(f16|f32|f64)_x(2|4)\r\n    svmin_(s8|s16|s32|s64)_x(2|4)\r\n    svmin_(u8|u16|u32|u64)_x(2|4)\r\n    svmin_(f16|f32|f64)_x(2|4)\r\n    svmax_single_(s8|s16|s32|s64)_x(2|4)\r\n    svmax_single_(u8|u16|u32|u64)_x(2|4)\r\n    svmax_single_(f16|f32|f64)_x(2|4)\r\n    svmax_(s8|s16|s32|s64)_x(2|4)\r\n    svmax_(u8|u16|u32|u64)_x(2|4)\r\n    svmax_(f16|f32|f64)_x(2|4)\r\n\r\nSee [https://github.com/ARM-software/acle/pull/217](https://github.com/ARM-software/acle/pull/217)\r\n\r\nPatch by: Kerry McLaughlin <kerry.mclaughlin@arm.com>", "feature_layers": [], "feature_directives": ["single"], "files_changed": [{"filename": "clang/test/CodeGen/aarch64-sme2-intrinsics/acle_sme2_max.c", "functions": ["test_svmax_single_u32_x2", "test_svmax_u32_x2", "test_svmax_single_s64_x4", "test_svmax_single_s64_x2", "test_svmax_s32_x2", "test_svmax_u8_x2", "test_svmax_u32_x4", "test_svmax_s32_x4", "test_svmax_u16_x4", "test_svmax_single_s8_x2", "test_svmax_u64_x4", "test_svmax_single_s16_x2", "test_svmax_s64_x4", "test_svmax_single_u16_x2", "test_svmax_single_s16_x4", "test_svmax_single_f32_x4", "test_svmax_s16_x2", "test_svmax_f16_x4", "test_svmax_single_u32_x4", "test_svmax_single_u64_x4", "test_svmax_u16_x2", "test_svmax_s8_x2", "test_svmax_u64_x2", "test_svmax_f32_x2", "test_svmax_f64_x2", "test_svmax_single_u16_x4", "test_svmax_single_s32_x4", "test_svmax_single_u64_x2", "test_svmax_s8_x4", "test_svmax_single_s32_x2", "test_svmax_f32_x4", "test_svmax_single_s8_x4", "test_svmax_single_f64_x2", "test_svmax_single_f16_x2", "test_svmax_single_u8_x2", "test_svmax_single_f16_x4", "test_svmax_single_u8_x4", "test_svmax_s16_x4", "test_svmax_single_f32_x2", "test_svmax_f16_x2", "test_svmax_s64_x2", "test_svmax_single_f64_x4", "test_svmax_u8_x4", "test_svmax_f64_x4"]}, {"filename": "clang/test/CodeGen/aarch64-sme2-intrinsics/acle_sme2_min.c", "functions": ["test_svmin_u32_x4", "test_svmin_single_s32_x4", "test_svmin_u16_x4", "test_svmin_f32_x4", "test_svmin_s64_x4", "test_svmin_single_f64_x2", "test_svmin_single_s64_x2", "test_svmin_s64_x2", "test_svmin_single_f16_x4", "test_svmin_u8_x4", "test_svmin_s8_x2", "test_svmin_s16_x2", "test_svmin_single_s32_x2", "test_svmin_single_u32_x2", "test_svmin_single_s8_x4", "test_svmin_single_s16_x2", "test_svmin_single_u16_x4", "test_svmin_u64_x2", "test_svmin_single_s8_x2", "test_svmin_single_u8_x4", "test_svmin_f64_x2", "test_svmin_single_u8_x2", "test_svmin_f64_x4", "test_svmin_s32_x4", "test_svmin_u32_x2", "test_svmin_single_s16_x4", "test_svmin_f32_x2", "test_svmin_single_u32_x4", "test_svmin_single_f32_x4", "test_svmin_single_f32_x2", "test_svmin_single_s64_x4", "test_svmin_s32_x2", "test_svmin_u64_x4", "test_svmin_u16_x2", "test_svmin_single_u64_x2", "test_svmin_u8_x2", "test_svmin_s8_x4", "test_svmin_single_u16_x2", "test_svmin_single_f16_x2", "test_svmin_single_u64_x4", "test_svmin_s16_x4", "test_svmin_single_f64_x4", "test_svmin_f16_x4", "test_svmin_f16_x2"]}]}
{"pr_number": 71776, "url": "https://github.com/llvm/llvm-project/pull/71776", "title": "[Support]Look up in top-level subcommand as a fallback when looking options for a custom subcommand.", "body": "**Context:**\r\n\r\n- In https://lists.llvm.org/pipermail/llvm-dev/2016-June/101804.html and commit 07670b3e984db32f291373fe12c392959f2aff67, `cl::SubCommand` is introduced.\r\n- Options that don't specify subcommand goes into a special 'top level' subcommand.\r\n\r\n**Motivating Use Case:**\r\n- The motivating use case is to refactor `llvm-profdata` to use `cl::SubCommand` to organize subcommands. See [pr/71328](https://github.com/llvm/llvm-project/pull/71328). A valid use case that's not supported before this patch\r\n\r\n```\r\n  // show-option{1,2} are associated with 'show' subcommand.\r\n  // top-level-option3 is in top-level subcomand (e.g., `profile-isfs` in SampleProfReader.cpp)\r\n  llvm-profdata show --show-option1 --show-option2 --top-level-option3\r\n```\r\n\r\n- Before this patch, option handler look-up will fail with the following error message \"Unknown command line argument --top-level-option3\".\r\n- After this patch, option handler look-up will look up in sub-command options first, and use top-level subcommand as a fallback, so 'top-level-option3' is parsed correctly.", "feature_layers": ["parse", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/unittests/Support/CommandLineTest.cpp", "functions": ["BoolOpt", "EnableOpt", "ThresholdOpt"]}]}
{"pr_number": 69787, "url": "https://github.com/llvm/llvm-project/pull/69787", "title": "[TOSA] Add TosaToMLProgram conversion", "body": "This patch adds a new pass to lower TOSA StatefulOps to corresponding ML Program ops (https://mlir.llvm.org/docs/Dialects/MLProgramOps/). ", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Conversion/TosaToMLProgram/TosaToMLProgram.cpp", "functions": ["success"]}, {"filename": "mlir/lib/Conversion/TosaToMLProgram/TosaToMLProgramPass.cpp", "functions": ["target", "runOnOperation", "patterns"]}]}
{"pr_number": 71731, "url": "https://github.com/llvm/llvm-project/pull/71731", "title": "[libc][math] Add initial support for C23 float128 math functions, starting with copysignf128.", "body": "", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "libc/test/src/__support/FPUtil/fpbits_test.cpp", "functions": ["zero", "one", "num", "negnum", "negzero", "negone"]}]}
{"pr_number": 70779, "url": "https://github.com/llvm/llvm-project/pull/70779", "title": "[LLDB] Ignore actual-needed artificial members in DWARFASTParserClang::ParseSingleMember", "body": "Address the FIXME, this will allow lldb to print all fields of the generated coroutine frame structure.\r\n\r\nFixes #69309.", "feature_layers": ["parse", "ast", "parser"], "feature_directives": ["single"], "files_changed": [{"filename": "lldb/source/Plugins/SymbolFile/DWARF/DWARFASTParserClang.cpp", "functions": ["ShouldIgnoreArtificialField"]}]}
{"pr_number": 71975, "url": "https://github.com/llvm/llvm-project/pull/71975", "title": "Revert \"[Support]Look up in top-level subcommand as a fallback when looking options for a custom subcommand", "body": "\u2026ooking options for a custom subcommand. (#71776)\"\r\n\r\nThis reverts commit b88308b1b4813e55ce8f54ceff6e57736328fb58.\r\n\r\nThe build-bot is unhappy (https://lab.llvm.org/buildbot/#/builders/186/builds/13096), `GroupingAndPrefix` fails after `TopLevelOptInSubcommand` (the newly added test).\r\n\r\nRevert while I look into this (might be related with test sharding but not sure)\r\n\r\n```\r\n\r\n[----------] 3 tests from CommandLineTest\r\n[ RUN      ] CommandLineTest.TokenizeWindowsCommandLine2\r\n[       OK ] CommandLineTest.TokenizeWindowsCommandLine2 (0 ms)\r\n[ RUN      ] CommandLineTest.TopLevelOptInSubcommand\r\n[       OK ] CommandLineTest.TopLevelOptInSubcommand (0 ms)\r\n[ RUN      ] CommandLineTest.GroupingAndPrefix\r\n #0 0x00ba8118 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/home/tcwg-buildbot/worker/clang-armv7-global-isel/stage1/unittests/Support/./SupportTests+0x594118)\r\n #1 0x00ba5914 llvm::sys::RunSignalHandlers() (/home/tcwg-buildbot/worker/clang-armv7-global-isel/stage1/unittests/Support/./SupportTests+0x591914)\r\n #2 0x00ba89c4 SignalHandler(int) (/home/tcwg-buildbot/worker/clang-armv7-global-isel/stage1/unittests/Support/./SupportTests+0x5949c4)\r\n #3 0xf7828530 __default_sa_restorer /build/glibc-9MGTF6/glibc-2.31/signal/../sysdeps/unix/sysv/linux/arm/sigrestorer.S:67:0\r\n #4 0x00af91f0 (anonymous namespace)::CommandLineParser::ResetAllOptionOccurrences() (/home/tcwg-buildbot/worker/clang-armv7-global-isel/stage1/unittests/Support/./SupportTests+0x4e51f0)\r\n #5 0x00af8e1c llvm::cl::ResetCommandLineParser() (/home/tcwg-buildbot/worker/clang-armv7-global-isel/stage1/unittests/Support/./SupportTests+0x4e4e1c)\r\n #6 0x0077cda0 (anonymous namespace)::CommandLineTest_GroupingAndPrefix_Test::TestBody() (/home/tcwg-buildbot/worker/clang-armv7-global-isel/stage1/unittests/Support/./SupportTests+0x168da0)\r\n #7 0x00bc5adc testing::Test::Run() (/home/tcwg-buildbot/worker/clang-armv7-global-isel/stage1/unittests/Support/./SupportTests+0x5b1adc)\r\n #8 0x00bc6cc0 testing::TestInfo::Run() (/home/tcwg-buildbot/worker/clang-armv7-global-isel/stage1/unittests/Support/./SupportTests+0x5b2cc0)\r\n #9 0x00bc7880 testing::TestSuite::Run() (/home/tcwg-buildbot/worker/clang-armv7-global-isel/stage1/unittests/Support/./SupportTests+0x5b3880)\r\n#10 0x00bd7974 testing::internal::UnitTestImpl::RunAllTests() (/home/tcwg-buildbot/worker/clang-armv7-global-isel/stage1/unittests/Support/./SupportTests+0x5c3974)\r\n#11 0x00bd6ebc testing::UnitTest::Run() (/home/tcwg-buildbot/worker/clang-armv7-global-isel/stage1/unittests/Support/./SupportTests+0x5c2ebc)\r\n#12 0x00bb1058 main (/home/tcwg-buildbot/worker/clang-armv7-global-isel/stage1/unittests/Support/./SupportTests+0x59d058)\r\n#13 0xf78185a4 __libc_start_main /build/glibc-9MGTF6/glibc-2.31/csu/libc-start.c:342:3\r\n```", "feature_layers": ["parse", "parser"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/unittests/Support/CommandLineTest.cpp", "functions": ["ThresholdOpt", "TopLevelOpt", "EnableOpt", "SC"]}]}
{"pr_number": 71739, "url": "https://github.com/llvm/llvm-project/pull/71739", "title": " [OpenMP] Rework handling of global ctor/dtors in OpenMP", "body": "Summary:\r\nThis patch reworks how we handle global constructors in OpenMP.\r\nPreviously, we emitted individual kernels that were all registered and\r\ncalled individually. In order to provide more generic support, this\r\npatch moves all handling of this to the target backend and the runtime\r\nplugin. This has the benefit of supporting the GNU extensions for\r\nconstructors an destructors, removing a class of failures related to\r\nshared library destruction order, and allows targets other than OpenMP\r\nto use the same support without needing to change the frontend.\r\n\r\nThis is primarily done by calling kernels that the backend emits to\r\niterate a list of ctor / dtor functions. For x64, this is automatic and\r\nwe get it for free with the standard `dlopen` handling. For AMDGPU, we\r\nemit `amdgcn.device.init` and `amdgcn.device.fini` functions which\r\nhandle everything atuomatically and simply need to be called. For NVPTX,\r\na patch https://github.com/llvm/llvm-project/pull/71549 provides the\r\nkernels to call, but the runtime needs to set up the array manually by\r\npulling out all the known constructor / destructor functions.\r\n\r\nOne concession that this patch requires is the change that for GPU\r\ntargets in OpenMP offloading we will use `llvm.global_dtors` instead of\r\nusing `atexit`. This is because `atexit` is a separate runtime function\r\nthat does not mesh well with the handling we're trying to do here. This\r\nshould be equivalent in all cases except for cases where we would need\r\nto destruct manually such as:\r\n\r\n```\r\nstruct S { ~S() { foo(); } };\r\nvoid foo() {\r\n  static S s;\r\n}\r\n```\r\n\r\nHowever this is broken in many other ways on the GPU, so it is not\r\nregressing any support, simply increasing the scope of what we can\r\nhandle.\r\n\r\nThis changes the handling of ctors / dtors. This patch now outputs a\r\ninformation message regarding the deprecation if the old format is used.\r\nThis will be completely removed in a later release.\r\n\r\nDepends on: https://github.com/llvm/llvm-project/pull/71549", "feature_layers": ["runtime", "ir", "frontend"], "feature_directives": ["for", "target", "requires"], "files_changed": [{"filename": "clang/lib/CodeGen/CGOpenMPRuntime.cpp", "functions": ["CtorCGF", "DtorCGF"]}, {"filename": "openmp/libomptarget/plugins-nextgen/amdgpu/src/rtl.cpp", "functions": ["callGlobalCtorDtorCommon", "Global", "AMDGPUKernel", "AsyncInfoWrapper"]}, {"filename": "openmp/libomptarget/plugins-nextgen/cuda/src/rtl.cpp", "functions": ["CUDAKernel", "Global", "FunctionPtrs", "callGlobalCtorDtorCommon", "AsyncInfoWrapper", "FunctionAddr"]}, {"filename": "openmp/libomptarget/test/libc/global_ctor_dtor.cpp", "functions": ["main"]}]}
{"pr_number": 71879, "url": "https://github.com/llvm/llvm-project/pull/71879", "title": "[asan] Report executable/DSO name for report_globals=2 and odr-violation checking", "body": "For an odr-violation error due to a source file linked into two DSOs, or\none DSO and the main executable, it can be difficult to identify the DSO\nname. Let's print the module name in the error report.\n\n```\necho 'extern long var; int main() { return var; }' > a.cc\necho 'long var;' > b.cc\nclang++ -fpic -fsanitize=address -shared b.cc -o b.so\nclang++ -fsanitize=address a.cc b.cc ./b.so -o a\n```\n\nw/o this patch:\n```\n==1375386==ERROR: AddressSanitizer: odr-violation (0x56067cb06240):\n  [1] size=8 'var' b.cc\n  [2] size=8 'var' b.cc\n...\n```\nw/ this patch:\n```\n==1375386==ERROR: AddressSanitizer: odr-violation (0x56067cb06240):\n  [1] size=8 'var' b.cc in /tmp/c/a\n  [2] size=8 'var' b.cc in ./b.so\n```\n\nIn addition, update the `report_globals=2` message to include the module\nname\n```\n==1451005==Added Global[0x7fcfe59ae040]: beg=0x7fcfe59ae140 size=8/32 name=var source=b.cc module=./b.so dyn_init=0 odr_indicator=0x55754f939260\n```\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "compiler-rt/lib/asan/asan_globals.cpp", "functions": ["PrintGlobalLocation"]}]}
{"pr_number": 70766, "url": "https://github.com/llvm/llvm-project/pull/70766", "title": "[OpenMP] Team reduction work specialization", "body": "Last commit, the others are part of existing PRs.", "feature_layers": ["ast"], "feature_directives": [], "files_changed": [{"filename": "openmp/libomptarget/DeviceRTL/src/Reduction.cpp", "functions": ["SHARED"]}]}
{"pr_number": 66148, "url": "https://github.com/llvm/llvm-project/pull/66148", "title": "[Attributor] New attribute to identify what byte ranges are alive for an allocation", "body": "Changes the size of allocations automatically.\r\nFor now, implements the case when a single range from start of the allocation is alive and the allocation can be reduced.", "feature_layers": [], "feature_directives": ["for", "single"], "files_changed": [{"filename": "llvm/lib/Transforms/IPO/AttributorAttributes.cpp", "functions": ["begin", "trackStatistics", "getAllocatedSize", "AAAllocationInfoImpl", "initialize", "AllocaInst", "getAsStr", "end", "AAAllocationInfo", "updateImpl", "manifest", "changeAllocationSize", "indicatePessimisticFixpoint", "numOffsetBins"]}]}
{"pr_number": 71762, "url": "https://github.com/llvm/llvm-project/pull/71762", "title": "[mlir][gpu] Separate the barrier elimination code from transform ops", "body": "Allows the barrier elimination code to be run from C++ as well. The code\r\nfrom transforms dialect is copied as-is, the pass and populate functions\r\nhave beed added at the end.", "feature_layers": ["ir"], "feature_directives": ["for", "barrier"], "files_changed": [{"filename": "mlir/lib/Dialect/GPU/TransformOps/GPUTransformOps.cpp", "functions": ["isSequentialLoopLike", "propagatesCapture", "getKnownCapturingStatus", "maybeCaptured", "getEffectsBefore", "getEffectsAfter", "mayAlias", "success", "isFunctionArgument", "isKnownNoEffectsOpWithoutInterface", "failure", "isParallelRegionBoundary", "hasSingleExecutionBody", "getBase", "producesDistinctBase"]}, {"filename": "mlir/lib/Dialect/GPU/Transforms/EliminateBarriers.cpp", "functions": ["isSequentialLoopLike", "propagatesCapture", "getKnownCapturingStatus", "maybeCaptured", "getEffectsBefore", "getEffectsAfter", "mayAlias", "success", "runOnOperation", "isFunctionArgument", "signalPassFailure", "isKnownNoEffectsOpWithoutInterface", "patterns", "failure", "isParallelRegionBoundary", "hasSingleExecutionBody", "getBase", "producesDistinctBase"]}]}
{"pr_number": 72031, "url": "https://github.com/llvm/llvm-project/pull/72031", "title": "[mlir][vector] Handle empty `MaskOp` in `LowerVectorMask`, `MaskOpRewritePattern`", "body": "This patch adds handling of an empty `MaskOp` to `MaskOpRewritePattern` and thereby fixes a crash.\r\nIt also pulls the `MaskOp` canonicalization patterns into `LowerVectorMask` so that empty `MaskOp`s are folded away in the Pass.\r\n\r\nFix https://github.com/llvm/llvm-project/issues/71036", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/Vector/Transforms/LowerVectorMask.cpp", "functions": ["failure"]}]}
{"pr_number": 69153, "url": "https://github.com/llvm/llvm-project/pull/69153", "title": "[clangd] Correctly identify the next token after the completion point", "body": "The code was previously using Lexer::findNextToken() which does not handle being passed the completion point as input.\r\n\r\nFixes https://github.com/clangd/clangd/issues/1785", "feature_layers": ["lexer"], "feature_directives": [], "files_changed": [{"filename": "clang-tools-extra/clangd/CodeComplete.cpp", "functions": ["TheLexer"]}, {"filename": "clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp", "functions": ["waldo", "main"]}]}
{"pr_number": 69415, "url": "https://github.com/llvm/llvm-project/pull/69415", "title": "[LLVM][NVPTX]Add BF16 vector instruction and fix lowering rules", "body": "Add support for bf16x2 instructions such as setp, fneg, fabs, etc;\r\nFix the instructions that were not differentiated between sm_80 and sm_90 support, such as fpround etc.\r\nAdd more bf16 test cases to ensure the correct behavior", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp", "functions": ["DL"]}, {"filename": "llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp", "functions": ["SDValue", "PerformSETCCCombine"]}]}
{"pr_number": 69119, "url": "https://github.com/llvm/llvm-project/pull/69119", "title": "[clangd] Use InitLLVM", "body": "This patch is similar to a7acba29c19ac67c77ed282ec9432602ae21268d but for clangd.\r\n\r\nIt allows to pass non-UTF8 encoded command line arguments (e.g. path where compile-commands.json file is located) on Windows.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang-tools-extra/clangd/tool/ClangdMain.cpp", "functions": ["X"]}]}
{"pr_number": 69429, "url": "https://github.com/llvm/llvm-project/pull/69429", "title": "[PHIElimination] Handle subranges in LiveInterval updates", "body": "Add subrange tracking and handling for LiveIntervals during PHI elimination.\r\nThis requires extending MachineBasicBlock::SplitCriticalEdge to also update subrange intervals.", "feature_layers": ["ir"], "feature_directives": ["for", "critical", "requires"], "files_changed": [{"filename": "llvm/lib/CodeGen/PHIElimination.cpp", "functions": ["ToUpdate"]}]}
{"pr_number": 69224, "url": "https://github.com/llvm/llvm-project/pull/69224", "title": "[clang][Sema] Avoid non-empty unexpanded pack assertion for FunctionParmPackExpr", "body": "Closes https://github.com/llvm/llvm-project/issues/61460.\r\n\r\nWe have FunctionParmPackExpr that serves as the unexpanded expression but from which the visitor collects none, which may lead to assertion failure during the template instantiation.", "feature_layers": ["sema"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/SemaCXX/pr61460.cpp", "functions": ["f1"]}]}
{"pr_number": 71969, "url": "https://github.com/llvm/llvm-project/pull/71969", "title": "MapVector: add C++17-style try_emplace and insert_or_assign", "body": "Similar to https://wg21.link/n4279\r\n\r\nFor example, insert_or_assign can be used to simplify\r\nCodeGenModule::AddDeferredUnusedCoverageMapping in\r\nclang/lib/CodeGen/CodeGenModule.cpp\r\n", "feature_layers": ["codegen"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/unittests/ADT/MapVectorTest.cpp", "functions": ["zero", "p", "getHashValue", "getEmptyKey", "isEqual", "two", "getTombstoneKey"]}]}
{"pr_number": 71800, "url": "https://github.com/llvm/llvm-project/pull/71800", "title": "Reland \"[lldb][DWARFASTParserClang] Fetch constant value from variable defintion if available\"", "body": "This patch relands https://github.com/llvm/llvm-project/pull/71004 which was reverted because the clang change it depends on was reverted.\r\n\r\nIn addition to the original patch, this PR includes a change to `SymbolFileDWARF::ParseVariableDIE` to support CU-level variable definitions that don't have locations, but represent a constant value. Previously, when debug-maps were available, we would assume that a variable with \"static lifetime\" (which in this case means \"has a linkage name\") has a valid address, which isn't the case for non-locationed constants. We could omit this additional change if we stopped attaching linkage names to global non-locationed constants.\r\n\r\nOriginal commit message:\r\n\"\"\"\r\nhttps://github.com/llvm/llvm-project/pull/71780 proposes moving the `DW_AT_const_value` on inline static members from the declaration DIE to the definition DIE. This patch makes sure the LLDB's expression evaluator can continue to support static initialisers even if the declaration doesn't have a `DW_AT_const_value` anymore.\r\n\r\nPreviously the expression evaluator would find the constant for a VarDecl from its declaration `DW_TAG_member` DIE. In cases where the initialiser was specified out-of-class, LLDB could find it during symbol resolution.\r\n\r\nHowever, neither of those will work for constants, since we don't have a constant attribute on the declaration anymore and we don't have constants in the symbol table.\r\n\"\"\"\r\n\r\nDepends on:\r\n* https://github.com/llvm/llvm-project/pull/71780", "feature_layers": ["parse", "ast", "parser"], "feature_directives": ["for"], "files_changed": [{"filename": "lldb/test/API/lang/cpp/const_static_integral_member/main.cpp", "functions": ["func", "bar"]}]}
{"pr_number": 71921, "url": "https://github.com/llvm/llvm-project/pull/71921", "title": "[lldb][DWARFASTParserClang] Make MemberAttributes const when parsing member DIEs", "body": "This patch removes the Objective-C accessibility workaround added in https://github.com/llvm/llvm-project/commit/5a477cfd90a8a12510518973fa450ae67372f199 (rdar://8492646). This allows us to make the local `MemberAttributes` variable immutable, which is useful for some other work around this function I was planning on doing.\r\n\r\nWe don't need the workaround anymore since compiler-support for giving debuggers access to private ivars was done couple of years later in https://github.com/llvm/llvm-project/commit/d6cb4a858db0592f6f946fd99a10a9dfcbea6ee9 (rdar://10997647).\r\n\r\n**Testing**\r\n\r\n* Test-suite runs cleanly", "feature_layers": ["parse", "ast", "parser"], "feature_directives": ["for"], "files_changed": [{"filename": "lldb/source/Plugins/SymbolFile/DWARF/DWARFASTParserClang.cpp", "functions": ["attrs"]}]}
{"pr_number": 71909, "url": "https://github.com/llvm/llvm-project/pull/71909", "title": "[X86][MC] Support encoding of EGPR for APX", "body": "#70958 adds registers R16-R31 (EGPR), this patch\r\n1. Introduces a new instruction prefix REX2\r\n2. Supports encoding of EGPR with REX2 for legacy instructions in MAP 0/1\r\n3. Supports encoding of EGPR with EVEX for the existing instructions in EVEX space\r\n\r\nRFC:\r\nhttps://discourse.llvm.org/t/rfc-design-for-apx-feature-egpr-and-ndd-support/73031/4", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/X86/MCTargetDesc/X86MCCodeEmitter.cpp", "functions": ["setV2", "setX", "setXX2", "setM", "W", "setB", "setX2", "setB2", "setBB2", "setR2"]}]}
{"pr_number": 71981, "url": "https://github.com/llvm/llvm-project/pull/71981", "title": "Reland \"[Support]Look up in top-level subcommand as a fallback when looking options for a custom subcommand", "body": "Fixed build bot errors. \r\n\r\n- Use `StackOption<std::string>` type for the top level option. This way, a per test-case option is unregistered when destructor of `StackOption` cleans up state for subsequent test cases.\r\n- Repro the crash with no test sharding `/usr/bin/python3 /path/to/llvm-project/build/./bin/llvm-lit -vv --no-gtest-sharding -j128 /path/to/llvm-project/llvm/test/Unit`.  The crash is gone with the fix (same no-sharding repro)\r\n\r\n**Original commit message:**\r\n**Context:**\r\n\r\n- In https://lists.llvm.org/pipermail/llvm-dev/2016-June/101804.html and commit https://github.com/llvm/llvm-project/commit/07670b3e984db32f291373fe12c392959f2aff67, `cl::SubCommand` is introduced.\r\n- Options that don't specify subcommand goes into a special 'top level' subcommand.\r\n\r\n**Motivating Use Case:**\r\n- The motivating use case is to refactor `llvm-profdata` to use `cl::SubCommand` to organize subcommands. See\r\nhttps://github.com/llvm/llvm-project/pull/71328. A valid use case that's not supported before this patch is shown below\r\n\r\n```\r\n  // show-option{1,2} are associated with 'show' subcommand.\r\n  // top-level-option3 is in top-level subcomand (e.g., `profile-isfs` in SampleProfReader.cpp)\r\n  llvm-profdata show --show-option1 --show-option2 --top-level-option3\r\n```\r\n\r\n- Before this patch, option handler look-up will fail with the following error message \"Unknown command line argument --top-level-option3\".\r\n- After this patch, option handler look-up will look up in sub-command options first, and use top-level subcommand as a fallback, so 'top-level-option3' is parsed correctly.", "feature_layers": ["parse", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/unittests/Support/CommandLineTest.cpp", "functions": ["TopLevelOpt"]}]}
{"pr_number": 70442, "url": "https://github.com/llvm/llvm-project/pull/70442", "title": "[flang] GETPID runtime and lower intrinsic implementation", "body": "Runtime function GetPID calls the function getpid\r\nfrom unistd.h or process.h base on the OS.", "feature_layers": ["runtime"], "feature_directives": [], "files_changed": [{"filename": "flang/runtime/command.cpp", "functions": ["getpid", "RTNAME"]}]}
{"pr_number": 70785, "url": "https://github.com/llvm/llvm-project/pull/70785", "title": "[AArch64][GlobalISel] TableGen Selection for G_VECREDUCE_ADD", "body": "Instruction Selection for G_VECREDUCE_ADD now uses TableGen", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp", "functions": ["if", "selectReduction", "constrainSelectedInstRegOperands"]}]}
{"pr_number": 71924, "url": "https://github.com/llvm/llvm-project/pull/71924", "title": "[mlir][Vector] Don't fully unroll transfer_writes of n-D scalable vectors", "body": "It is not possible to unroll a scalable vector at compile time. This currently prevents transfer_writes from being lowered to arm_sme.tile_writes (downstream).", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Conversion/VectorToSCF/VectorToSCF.cpp", "functions": ["failure"]}]}
{"pr_number": 70646, "url": "https://github.com/llvm/llvm-project/pull/70646", "title": "[clang] Do not clear FP pragma stack when instantiating functions", "body": "When instantiation function, a call to Sema::resetFPOption was used to set the FP options associated with AST node. However this function also cleared FP pragma stack, and it is incorrect. Template instantiation takes place on AST representation and semantic information like the FP pragma stack should not affect it. This was a reason for miscompilation in some cases.\r\n\r\nTo make the Sema interface more consistent, now `resetFPOptions` does not clear FP pragma stack anymore. It is cleared in `FpPragmaStackSaveRAII`, which is used in parsing only.\r\n\r\nThis change must fix https://github.com/llvm/llvm-project/issues/69717 (Problems with float_control pragma stack in Clang 17.x).", "feature_layers": ["sema", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/Sema/PR69717.cpp", "functions": ["multi_i", "multi"]}]}
{"pr_number": 71906, "url": "https://github.com/llvm/llvm-project/pull/71906", "title": "[InstCombine] Infer zext nneg flag directly", "body": "This PR sets the `nneg` flag directly to salvage information and avoid recomputing `isKnownNonNegative`, which was introduced by https://github.com/llvm/llvm-project/pull/71534.\r\n\r\nAlive2: https://alive2.llvm.org/ce/z/voT6HG\r\n\r\nCompile-time impact: https://llvm-compile-time-tracker.com/compare.php?from=bd611264993f64decbce178d460caf1d1cb05f59&to=07958d9959d8af31f599acef96d580cfe786c677&stat=instructions:u", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp", "functions": ["ZExtInst"]}, {"filename": "llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp", "functions": ["IfFold"]}, {"filename": "llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp", "functions": ["ZExtInst"]}]}
{"pr_number": 71171, "url": "https://github.com/llvm/llvm-project/pull/71171", "title": "Recommit changes to global checks", "body": "Recommits the changes from https://reviews.llvm.org/D148216.\r\nExplicitly named globals are now matched literally, instead of emitting a capture group for the name. This resolves  #70047.\r\nMetadata and annotations, on the other hand, are captured and matched against by default, since their identifiers are not stable.\r\n\r\nThe reasons for revert (#63746) have been fixed:\r\nThe first issue, that of duplicated checkers, has already been resolved in #70050.\r\nThis PR resolves the second issue listed in #63746, regarding the order of named and unnamed globals. This is fixed by recording the index of substrings containing global values, and sorting the checks according to that index before emitting them. This results in global value checks being emitted in the order they were seen instead of being grouped separately.\r\n\r\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/utils/update_cc_test_checks/Inputs/annotations.c", "functions": ["foo"]}]}
{"pr_number": 71720, "url": "https://github.com/llvm/llvm-project/pull/71720", "title": "[mlir] Add llvm.linker.options operation to the LLVM IR Dialect", "body": "This patch adds a `llvm.linker.options` operation taking a list of\nstrings to pass to the linker when the resulting object file is linked.\nThis is particularly useful on Windows to specify the CRT version to use\nfor this object file.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Target/LLVMIR/ModuleImport.cpp", "functions": ["emitError"]}, {"filename": "mlir/lib/Dialect/LLVMIR/IR/LLVMDialect.cpp", "functions": ["emitOpError"]}]}
{"pr_number": 72053, "url": "https://github.com/llvm/llvm-project/pull/72053", "title": "[RISCV][CodeGenPrepare] Remove duplicated transform for zext. NFC.", "body": "After #71534 and #72052, the transform `zext -> zext nneg` in `RISCVCodeGenPrepare` is redundant.", "feature_layers": ["codegen"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVCodeGenPrepare.cpp", "functions": ["visitZExtInst"]}]}
{"pr_number": 72072, "url": "https://github.com/llvm/llvm-project/pull/72072", "title": "[clang][CGExprScalar] Remove no-op ptr-to-ptr bitcast (NFC)", "body": "Remove bitcast added back in dcd74716f9d18 .", "feature_layers": ["ast"], "feature_directives": [], "files_changed": [{"filename": "clang/lib/CodeGen/CGExprScalar.cpp", "functions": ["Visit"]}]}
{"pr_number": 72052, "url": "https://github.com/llvm/llvm-project/pull/72052", "title": "[CVP] Infer nneg on existing zext", "body": "This patch infers `nneg` flags for existing zext instructions in CVP.\r\nAfter https://github.com/llvm/llvm-project/pull/71534 and this patch, we can drop `zext -> zext nneg` transform in `RISCVCodeGenPrepare`:\r\n\r\nhttps://github.com/llvm/llvm-project/blob/40671bbdefb6ff83e2685576a3cb041b62f25bbe/llvm/lib/Target/RISCV/RISCVCodeGenPrepare.cpp#L74-L83\r\n\r\nThis is an alternative to #72049.\r\n", "feature_layers": ["codegen"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp", "functions": ["processZExt"]}]}
{"pr_number": 71318, "url": "https://github.com/llvm/llvm-project/pull/71318", "title": "[X86][AVX10] Permit AVX512 options/features used together with AVX10", "body": "This patch relaxes the driver logic to permit combinations between AVX512 and AVX10 options and makes sure we have a unified behavior between options and features combination.\r\n\r\nHere are rules we are following when handle these combinations:\r\n1. evex512 can only be used for avx512xxx options/features. It will be ignored if used without them;\r\n2. avx512xxx and avx10.xxx are options in two worlds. Avoid to use them together in any case. It will enable a common super set when they are used together. E.g., \"-mavx512f -mavx10.1-256\" euqals \"-mavx10.1-512\".\r\n\r\nCompiler emits warnings when user using combinations like \"-mavx512f -mavx10.1-256\" in case they won't get unexpected result silently.\r\n\r\nFunction target feature attribute follows the same rule now. We have to add \"no-evex512\" feature for intrinsics shared between AVX512 and AVX10. We also add \"no-evex512\" for early ISAs like AVX etc., because some of them are called by AVX512 intrinsics.", "feature_layers": [], "feature_directives": ["for", "target"], "files_changed": [{"filename": "clang/lib/Basic/Targets/X86.cpp", "functions": ["if"]}]}
{"pr_number": 72125, "url": "https://github.com/llvm/llvm-project/pull/72125", "title": "[include-cleaner] Add handling for FriendDecls", "body": "Fixes https://github.com/llvm/llvm-project/issues/64382.\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang-tools-extra/include-cleaner/lib/WalkAST.cpp", "functions": ["VisitFriendDecl"]}]}
{"pr_number": 70741, "url": "https://github.com/llvm/llvm-project/pull/70741", "title": "[SelectionDAG] Disable FastISel for swiftasync functions", "body": "Most (x86) swiftasync functions tend to use both SelectionDAGISel and FastISel lowering:\r\n  * FastISel argument lowering can only handle C calling convention.\r\n  * FastISel fails mid-BB in a number of ways, including in simple `ret void` instructions under certain circumstances.\r\n\r\nThis dance of SelectionDAG (argument) -> FastISel (some instructions) -> SelectionDAG(remaining instructions) is lossy; in particular, Argument information lowering is cleared after that first SelectionDAG run.\r\n\r\nSince swiftasync functions rely heavily on proper Argument lowering for debug information, this patch disables the use of FastISel in such functions.\r\n\r\nThis was tested by compiling a big translation unit from the Swift concurrency library, and there was no measurable performance impact:\r\n\r\n```\r\n// Without patch (i.e. using FastISel)\r\n  Time (mean \u00b1 \u03c3):      2.416 s \u00b1  0.016 s    [User: 2.321 s, System: 0.068 s]\r\n  Range (min \u2026 max):    2.403 s \u2026  2.458 s    10 runs\r\n\r\n// With patch (i.e. not using FastISel)\r\n  Time (mean \u00b1 \u03c3):      2.407 s \u00b1  0.011 s    [User: 2.313 s, System: 0.067 s]\r\n  Range (min \u2026 max):    2.396 s \u2026  2.424 s    10 runs\r\n```", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp", "functions": ["dontUseFastISelFor", "any_of", "none_of", "shouldEnableFastISel"]}]}
{"pr_number": 72135, "url": "https://github.com/llvm/llvm-project/pull/72135", "title": "[Flang][Driver][MLIR]  Add support for fomit-frame-pointer", "body": "Made appropriate changes in Flang and MLIR to support 'fomit-frame-pointer' and 'fno-omit-frame-pointer'.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Driver/ToolChains/Clang.cpp", "functions": ["mustUseNonLeafFramePointerForTarget"]}, {"filename": "clang/lib/Driver/ToolChains/CommonArgs.cpp", "functions": ["mustUseNonLeafFramePointerForTarget"]}, {"filename": "mlir/lib/Dialect/LLVMIR/IR/LLVMDialect.cpp", "functions": ["failure"]}]}
{"pr_number": 71880, "url": "https://github.com/llvm/llvm-project/pull/71880", "title": "[mlir][sparse] unify support of (dis)assemble between direct IR/lib path", "body": "Note that the (dis)assemble operations still make some simplfying assumptions (e.g. trailing 2-D COO in AoS format) but now at least both the direct IR and support library path behave exactly the same.\r\n\r\nGeneralizing the ops is still TBD.", "feature_layers": ["parse", "ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/Transforms/SparseTensorCodegen.cpp", "functions": ["genCast"]}, {"filename": "mlir/lib/Dialect/SparseTensor/Transforms/SparseTensorConversion.cpp", "functions": ["success", "createFuncCall"]}]}
{"pr_number": 71413, "url": "https://github.com/llvm/llvm-project/pull/71413", "title": "[APINotes] Upstream APINotes YAML compiler", "body": "This upstreams more of the Clang API Notes functionality that is currently implemented in the Apple fork: https://github.com/apple/llvm-project/tree/next/clang/lib/APINotes", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/APINotes/APINotesYAMLCompiler.cpp", "functions": ["printDiagnostic", "convertParams", "convertModule", "M", "compile", "C", "emitError"]}]}
{"pr_number": 70896, "url": "https://github.com/llvm/llvm-project/pull/70896", "title": "[RISCV][GISel] Add really basic support for FP regbank selection for G_LOAD/G_STORE.", "body": "Coerce the register bank based on the users of the G_LOAD or the defining instruction for the G_STORE.\r\n\r\ns64 on rv32 is handled by forcing the FPR register bank.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/GISel/RISCVRegisterBankInfo.cpp", "functions": ["onlyDefinesFP", "onlyUsesFP"]}]}
{"pr_number": 70873, "url": "https://github.com/llvm/llvm-project/pull/70873", "title": "[flang] Allow polymorphic actual to implicit interface", "body": "Semantics is emitting an error when an actual argument to a procedure that has an implicit interface has a polymorphic type.  This is too general; while TYPE(*) and CLASS(*) unlimited polymorphic items require the presence of an explicit procedure interface, CLASS(T) data can be passed over an implicit interface to a procedure expecting a corresponding dummy argument with TYPE(T), so long as T is not parameterized.\r\n\r\n(Only XLF handles this usage correctly among other Fortran compilers.)\r\n\r\n(Making this work in the case of an actual CLASS(T) array may well require additional changes in lowering to copy data to/from a temporary buffer to ensure contiguity when the actual type of the array is an extension of T.)", "feature_layers": ["sema", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Evaluate/characteristics.cpp", "functions": ["FromActual"]}]}
{"pr_number": 72064, "url": "https://github.com/llvm/llvm-project/pull/72064", "title": "[mlir][py] Overload print with state.", "body": "Enables reusing the AsmState when printing from Python. Also moves the fileObject and binary to the end (pybind11::object was resulting in the overload not working unless `state=` was specified).", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Bindings/Python/IRCore.cpp", "functions": ["accum", "bytes"]}]}
{"pr_number": 71881, "url": "https://github.com/llvm/llvm-project/pull/71881", "title": "[flang] Catch nasty order-of-declarations case", "body": "It is possible to declare the rank of an object after that object has been used in the same specification part in a specification function reference whose result or generic resolution may well have depended on the object being apparently a scalar.\r\n\r\nCatch this case, and emit a warning -- not an error, yet, due to fear of false positives.\r\n\r\nSee the new test for examples.", "feature_layers": ["ast"], "feature_directives": ["for", "declare"], "files_changed": [{"filename": "flang/lib/Semantics/resolve-names.cpp", "functions": ["MustBeScalar", "NoteScalarSpecificationArgument"]}]}
{"pr_number": 72174, "url": "https://github.com/llvm/llvm-project/pull/72174", "title": "[RISCV][GISel] Attempt to simplify how we handle type legality for F and D extensions.", "body": "Add helper that creates a lambda similar to typeIs, but containing the predicate check for hasStdExtF and hasStdD. We can use this with legalIf and all to reduce the number of manual lambdas we need to write.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/GISel/RISCVLegalizerInfo.cpp", "functions": ["typeIs", "typeInSet"]}]}
{"pr_number": 72199, "url": "https://github.com/llvm/llvm-project/pull/72199", "title": "[NFC][CodeGen] clang-format RegAllocFast.cpp", "body": "", "feature_layers": ["codegen", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/CodeGen/RegAllocFast.cpp", "functions": ["getClearedProperties", "getSetProperties", "findLiveVirtReg", "displacePhysReg", "getRequiredProperties", "traceCopyChain", "handleDebugValue", "reloadAtBegin", "allocateBasicBlock", "unmarkRegUsedInInstr", "isClobberedByRegMasks", "useVirtReg", "MachineFunctionPass", "calcSpillCost", "RegAllocFast", "usePhysReg", "traceCopies", "MachineFunctionProperties", "dumpState", "freePhysReg", "definePhysReg", "isPhysRegFree", "getSparseSetIndex", "LiveReg", "findAndSortDefOperandIndexes", "shouldAllocateRegister", "runOnMachineFunction", "mayLiveOut", "allocVirtRegUndef", "isCoalescable", "markPhysRegUsedInInstr", "getPassName", "setPhysReg", "allocateInstruction", "mayLiveIn", "getAnalysisUsage", "isRegUsedInInstr", "getStackSpaceFor", "handleBundle", "printReg", "setPhysRegState", "markRegUsedInInstr", "assignVirtToPhysReg"]}]}
{"pr_number": 70188, "url": "https://github.com/llvm/llvm-project/pull/70188", "title": "[AMDGPU] Fold uniform readfirstlane + cndmask", "body": "Teach SIFoldOperand to fold CNDMASK + READFIRSTLANE + S_CSELECT", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/SIFoldOperands.cpp", "functions": ["if"]}]}
{"pr_number": 71044, "url": "https://github.com/llvm/llvm-project/pull/71044", "title": "[mlir][ArmSME] Make use of backend function attributes for enabling ZA storage", "body": "Previously, we were inserting za.enable/disable intrinsics for functions with the \"arm_za\" attribute (at the MLIR level), rather than using the backend attributes. This was done to avoid a dependency on the SME ABI functions from compiler-rt (which have only recently been implemented).\r\n\r\nDoing things this way did have correctness issues, for example, calling a streaming-mode function from another streaming-mode function (both with ZA enabled) would lead to ZA being disabled after returning to the caller (where it should still be enabled). Fixing issues like this would require re-doing the ABI work already done in the backend within MLIR.\r\n\r\nInstead, this patch switches to use the \"arm_new_za\" (backend) attribute for enabling ZA for an MLIR function. For the integration tests, this requires some way of linking the SME ABI functions. This is done via the `%arm_sme_abi_shlib` lit substitution. By default, this expands to a stub implementation of the SME ABI functions, but this can be overridden by providing the `ARM_SME_ABI_ROUTINES_SHLIB` CMake cache variable (pointing it at an alternative implementation). For now, the ArmSME integration tests pass with just stubs, as we don't make use of nested ZA-enabled calls.\r\n\r\nA future patch may add an option to compiler-rt to build the SME builtins into a standalone shared library to allow easily building/testing with the actual implementation. ", "feature_layers": ["ir"], "feature_directives": ["for", "requires"], "files_changed": [{"filename": "mlir/lib/Dialect/ArmSME/Transforms/LegalizeForLLVMExport.cpp", "functions": ["g", "success"]}, {"filename": "mlir/lib/ExecutionEngine/ArmSMEStub.cpp", "functions": ["__arm_za_disable", "__arm_tpidr2_restore", "__arm_tpidr2_save", "__arm_sme_state"]}]}
{"pr_number": 65957, "url": "https://github.com/llvm/llvm-project/pull/65957", "title": "[Analysis][SVE] Improve cost model for some extending masked loads", "body": "When performing a masked load of an unpacked SVE vector type, i.e.\r\nnxv8i8, followed by a zero- or sign-extend to an illegal wide type\r\nsuch as nxv8i32 we typically end up with a combination of an\r\nextending masked load and pair(s) of uunpklo/hi or sunpklo/hi\r\ninstructions. For example, see test @masked_sload_8i8_8i32 in file\r\n\r\n  CodeGen/AArch64/sve-masked-ldst-sext.ll\r\n\r\nwhere\r\n\r\n  %aval = call <vscale x 8 x i8> @llvm.masked.load.nxv8i8(...\r\n  %aext = sext <vscale x 8 x i8> %aval to <vscale x 8 x i32>\r\n\r\ngets lowered to\r\n\r\n  ld1sb { z1.h }, ...\r\n  sunpklo z0.s, z1.h\r\n  sunpkhi z1.s, z1.h\r\n\r\nCurrently the cost for the 'sext' operation in the example above is\r\n1, whereas this patch changes it to 2 to reflect the pair of\r\ninstructions required. Similarly, when doing a masked load of a\r\nnxv8i8 and extending to nxv8i64 the cost is changed to 6 to reflect\r\nthe 6 unpacks required.", "feature_layers": ["codegen", "ir"], "feature_directives": ["for", "masked"], "files_changed": [{"filename": "llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp", "functions": ["AdjustCost"]}]}
{"pr_number": 68233, "url": "https://github.com/llvm/llvm-project/pull/68233", "title": "[libc++] Use correct size for deallocation of arrays in shared_ptr", "body": "Fixes #68051.\r\n\r\nCurrent implementation passes the number of `_AlignedStorage` objects when it calls to `allocate` and the number of **bytes** on deallocate. This only applies to allocations that allocate control block and the storage together, i.e. `make_shared` and `allocate_shared`.\r\n\r\nFound by ASan.", "feature_layers": [], "feature_directives": ["for", "allocate"], "files_changed": [{"filename": "libcxx/test/libcxx/memory/shared_ptr_array.pass.cpp", "functions": ["main"]}]}
{"pr_number": 69882, "url": "https://github.com/llvm/llvm-project/pull/69882", "title": "[InstCombine] Fold xored one-complemented operand comparisons", "body": "- [InstCombine] Add test coverage for comparisons of operands including one-complemented oparands(NFC).\r\n- [InstCombine] Fold xored one-complemented operand comparisons.\r\nAlive2: https://alive2.llvm.org/ce/z/PZMJeB\r\nFixes #69803.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp", "functions": ["ICmpInst"]}]}
{"pr_number": 68984, "url": "https://github.com/llvm/llvm-project/pull/68984", "title": "[CFIFixup] Allow function prologues to span more than one basic block", "body": "The CFIFixup pass assumes a function prologue is contained in a single basic block. This assumption is broken with upcoming support for stack probing (`-fstack-clash-protection`) in AArch64 - the emitted probing sequence in a prologue may contain loops, i.e. more than one basic block. The generated CFG is not arbitrary though:\r\n * CFI instructions are outside of any loops\r\n * for any two CFI instructions of the function prologue one dominates and is post-dominated by the other\r\n\r\nThus, for the prologue CFI instructions, if one is executed then all are executed, there is a total order of executions, and the last instruction in that order can be considered the end of the prologoue for the purpose of inserting the initial `.cfi_remember_state` directive.\r\n\r\nThat last instruction is found by finding the first block in the post-order traversal which contains prologue CFI instructions.", "feature_layers": ["ir", "ast"], "feature_directives": ["for", "single"], "files_changed": [{"filename": "llvm/lib/CodeGen/CFIFixup.cpp", "functions": ["containsPrologue"]}]}
{"pr_number": 70606, "url": "https://github.com/llvm/llvm-project/pull/70606", "title": "[CodeGen] Revamp counted_by calculations", "body": "Break down the counted_by calculations so that they correctly handle\r\nanonymous structs, which are specified internally as IndirectFieldDecls.\r\n\r\nImproves the calculation of __bdos on a different field member in the struct.\r\nAnd also improves support for __bdos in an index into the FAM. If the index\r\nis further out than the length of the FAM, then we return __bdos's \"can't\r\ndetermine the size\" value (zero or negative one, depending on type).\r\n\r\nAlso simplify the code to use helper methods to get the field referenced\r\nby counted_by and the flexible array member itself, which also had some\r\nissues with FAMs in sub-structs.", "feature_layers": ["codegen", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/CodeGen/CGExpr.cpp", "functions": ["DName"]}, {"filename": "clang/test/CodeGen/attr-counted-by.c", "functions": ["test11", "test4"]}, {"filename": "clang/lib/CodeGen/CGBuiltin.cpp", "functions": ["getDefaultBuiltinObjectSizeResult"]}]}
{"pr_number": 70663, "url": "https://github.com/llvm/llvm-project/pull/70663", "title": "[clang][Interp] Fix stack peek offset for This ptr", "body": "`Function::getArgSize()` include both the instance and the RVO pointer, so we need to subtract here.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/AST/Interp/ByteCodeExprGen.cpp", "functions": ["VisitCallExpr"]}, {"filename": "clang/test/AST/Interp/literals.cpp", "functions": ["ret_a", "test"]}]}
{"pr_number": 69596, "url": "https://github.com/llvm/llvm-project/pull/69596", "title": "[AMDGPU] Generic lowering for rint and nearbyint", "body": "The are three different rounding intrinsics, that are brought down to same instruction.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp", "functions": ["legalizeFroundeven", "legalizeFrint"]}]}
{"pr_number": 70882, "url": "https://github.com/llvm/llvm-project/pull/70882", "title": "[RISCV][GISEL] Add support for lowerFormalArguments that contain scalable vector types", "body": "Scalable vector types from LLVM IR can be lowered to scalable vector\r\ntypes in MIR according to the RISCVAssignFn.\r\n\r\nThis patch is stacked on https://github.com/llvm/llvm-project/pull/70881", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/GISel/RISCVCallLowering.cpp", "functions": ["isSupportedArgumentType"]}]}
{"pr_number": 71328, "url": "https://github.com/llvm/llvm-project/pull/71328", "title": "[nfc][llvm-profdata] Use cl::Subcommand to organize subcommand and options in llvm-profdata", "body": "- The motivation is to reduce the number of arguments passed around (e.g., from `show_main` to `show*Profile`).  In order to do this, move function-defined options to global variables, and create `cl::SubCommand` for {show, merge, overlap, order} to organize options.\r\n   - The side-effect by extracting function local options to a C++ namespace is that the extracted options are no longer (lazily) initialized when the enclosing function runs for the first time. \r\n   - `cl::Subcommand` support (introduced in https://lists.llvm.org/pipermail/llvm-dev/2016-June/101804.html) could put options in a per-subcommand namespace.\r\n- One option could belong to multiple subcommand. This patch defines most of the options once and associates them with multiple subcommands except\r\n   1. `overlap` and `show` both has `value-cutoff` with different default values ([former](https://github.com/llvm/llvm-project/blob/64f62de96609dc3ea9a8a914a9e9445b7f4d625d/llvm/tools/llvm-profdata/llvm-profdata.cpp#L2352) vs [latter](https://github.com/llvm/llvm-project/blob/64f62de96609dc3ea9a8a914a9e9445b7f4d625d/llvm/tools/llvm-profdata/llvm-profdata.cpp#L3009)). Define 'OverlapValueCutoff' and 'ShowValueCutoff' respectively.\r\n   2. `show` supports three profile formats in `ProfileKind` while {`merge`, `overlap`} supports two. Define separate options.\r\n- Clean up obsolete code as a result, including `-h` and `--version` customizations. These two options are supported for all commands.  Results pasted.\r\n   - [-h and --help](https://gist.github.com/minglotus-6/387490e5eeda2dd2f9c440a424d6f360) output.\r\n   - [--version](https://gist.github.com/minglotus-6/f905abcc3a346957bd797f2f84c18c1b)\r\n   - [llvm-profdata show --help](https://gist.github.com/minglotus-6/f143079f02af243a94758138c0af471a)\r\n\r\nThis PR should be `llvm-profdata` only. It depends on https://github.com/llvm/llvm-project/pull/71981", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/tools/llvm-profdata/llvm-profdata.cpp", "functions": ["Output", "ShowAllFunctions", "MergeSubcommand", "NumThreadsA", "ShowProfileVersion", "Filename", "ShowDetailedSummary", "RemappingFile", "mergeWriterContexts", "RemappingFileA", "ShowCounts", "ShowCS", "InputFilenames", "ShowBinaryIds", "OutputFilenameA", "InputFilenamesFileA", "OutputFilename"]}]}
{"pr_number": 72196, "url": "https://github.com/llvm/llvm-project/pull/72196", "title": "[lldb-dap] Add an option to provide a format for threads", "body": "When this option gets enabled, descriptions of threads will be generated using the format provided in the launch configuration instead of generating it manually in the dap code. This allows lldb-dap to show an output similar to the one in the CLI.\nThis is very similar to https://github.com/llvm/llvm-project/pull/71843\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "lldb/source/API/SBThread.cpp", "functions": ["exe_ctx"]}, {"filename": "lldb/source/Target/Thread.cpp", "functions": ["exe_ctx"]}]}
{"pr_number": 71996, "url": "https://github.com/llvm/llvm-project/pull/71996", "title": "[Profile] Remove __llvm_profile_has_correlation()", "body": "As discussed in https://github.com/llvm/llvm-project/pull/70856#issuecomment-1791465183 and https://github.com/llvm/llvm-project/pull/70856#issuecomment-1806281746, it's better not to do runtime check for VARIANT_MASK_DBG_CORRELATE bit in __llvm_profile_raw_version when deciding if profile data/name sections should be dropped or not.", "feature_layers": ["runtime"], "feature_directives": ["for", "sections"], "files_changed": [{"filename": "compiler-rt/lib/profile/InstrProfiling.c", "functions": ["__llvm_profile_has_correlation"]}]}
{"pr_number": 72215, "url": "https://github.com/llvm/llvm-project/pull/72215", "title": "[scudo] Add ScopedTSD to remove UnlockRequired", "body": "This makes the use of TSD be RAII style and avoid the check of UnlockRequired on SharedTSD path.\r\n\r\nAlso move some thread safety analyses from static to runtime because of its limitation. Even we mark some code path as NO_THREAD_SAFETY_ANALYSIS but we still have the `assertLocked()` in essential paths.", "feature_layers": ["runtime", "ir"], "feature_directives": [], "files_changed": [{"filename": "compiler-rt/lib/scudo/standalone/tests/combined_test.cpp", "functions": ["Run"]}, {"filename": "compiler-rt/lib/scudo/standalone/tests/tsd_test.cpp", "functions": ["testRegistry", "stressCache", "TSD"]}]}
{"pr_number": 71801, "url": "https://github.com/llvm/llvm-project/pull/71801", "title": "[OpenMP][libomptarget] Enable parallel copies via multiple SDMA engines", "body": "This enables the AMDGPU plugin to use a new ROCm 5.7 interface to dispatch asynchronous data transfers across SDMA engines.\r\n\r\nThe default functionality stays unchanged, meaning that all data transfers are enqueued into a H2D queue or an D2H queue, depending on transfer direction, via the HSA interface used previously.\r\n\r\nThe new interface can be enabled via the environment variable `LIBOMPTARGET_AMDGPU_USE_MULTIPLE_SDMA_ENGINES=true` when libomptarget is built against a recent ROCm version (5.7 and later).\r\nAs of now, requests are distributed in a round-robin fashion across available SDMA engines.", "feature_layers": ["ir"], "feature_directives": ["parallel", "target", "distribute"], "files_changed": [{"filename": "openmp/libomptarget/plugins-nextgen/amdgpu/src/rtl.cpp", "functions": ["getUseMultipleSdmaEngines", "useMultipleSdmaEngines"]}]}
{"pr_number": 72307, "url": "https://github.com/llvm/llvm-project/pull/72307", "title": "Reland [OpenMP][libomptarget] Enable parallel copies via multiple SDM\u2026", "body": "\u2026A engines (#71801)\r\n\r\nThis enables the AMDGPU plugin to use a new ROCm 5.7 interface to dispatch asynchronous data transfers across SDMA engines.\r\n\r\nThe default functionality stays unchanged, meaning that all data transfers are enqueued into a H2D queue or an D2H queue, depending on transfer direction, via the HSA interface used previously.\r\n\r\nThe new interface can be enabled via the environment variable `LIBOMPTARGET_AMDGPU_USE_MULTIPLE_SDMA_ENGINES=true` when libomptarget is built against a recent ROCm version (5.7 and later). As of now, requests are distributed in a round-robin fashion across available SDMA engines.", "feature_layers": ["ir"], "feature_directives": ["parallel", "target", "distribute"], "files_changed": [{"filename": "openmp/libomptarget/plugins-nextgen/amdgpu/src/rtl.cpp", "functions": ["useMultipleSdmaEngines"]}]}
{"pr_number": 72185, "url": "https://github.com/llvm/llvm-project/pull/72185", "title": "[mlir][sparse][gpu] re-enable all GPU libgen tests", "body": "Previous change no longer properly used the GPU libgen pass (even though most tests still passed falling back to CPU). This revision puts the proper pass order into place. Also bit of a cleanup of CPU codegen vs. libgen setup.", "feature_layers": ["parse", "codegen", "ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/Transforms/SparseTensorPasses.cpp", "functions": ["options"]}]}
{"pr_number": 72184, "url": "https://github.com/llvm/llvm-project/pull/72184", "title": "[mlir] Add `vector.store/maskedstore` of `memref.subview` memref alias folding", "body": "Fixes https://github.com/openxla/iree/issues/15575", "feature_layers": ["ir"], "feature_directives": ["masked"], "files_changed": [{"filename": "mlir/lib/Dialect/MemRef/Transforms/FoldMemRefAliasOps.cpp", "functions": ["getMemRefOperand"]}]}
{"pr_number": 72176, "url": "https://github.com/llvm/llvm-project/pull/72176", "title": "[flang] Fold MATMUL()", "body": "Implements constant folding for matrix multiplication for all four accepted type categories.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Evaluate/fold-complex.cpp", "functions": ["FoldMatmul"]}, {"filename": "flang/lib/Evaluate/fold-integer.cpp", "functions": ["FoldMatmul"]}, {"filename": "flang/lib/Evaluate/fold-logical.cpp", "functions": ["FoldMatmul"]}, {"filename": "flang/lib/Evaluate/fold-real.cpp", "functions": ["FoldMatmul"]}]}
{"pr_number": 70729, "url": "https://github.com/llvm/llvm-project/pull/70729", "title": "[libcxx][test] std::array::iterator are not pointers by C++ standard", "body": "This is to modify a list of libcxx tests written under the assumption that iterators for std::array, std::string_view, and std::string are pointers. The motivation for this PR is to make the tests more universal and potentially being used to test other C++ standard library implementations, for example [microsoft/STL](https://github.com/microsoft/STL).\r\n\r\nI can confirm that this patch makes a number of tests compatible with microsoft STL:\r\n`Failed :  204 (2.12%)`  ->  `Failed :  136 (1.42%)`\r\n, and does not break any tests on `libcxx`.\r\n\r\nThis is not a complete list of such incompatibilities, but I am hoping this will start a discussion about whether we are open to accepting such changes.\r\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "libcxx/test/std/algorithms/alg.sorting/alg.heap.operations/make.heap/ranges_make_heap.pass.cpp", "functions": ["verify_heap_iterator"]}, {"filename": "libcxx/test/std/algorithms/alg.sorting/alg.heap.operations/pop.heap/ranges_pop_heap.pass.cpp", "functions": ["verify_heap_iterator"]}, {"filename": "libcxx/test/std/algorithms/alg.sorting/alg.heap.operations/push.heap/ranges_push_heap.pass.cpp", "functions": ["verify_heap_iterator"]}, {"filename": "libcxx/test/std/algorithms/alg.sorting/alg.heap.operations/sort.heap/ranges_sort_heap.pass.cpp", "functions": ["verify_sorted_iterator"]}, {"filename": "libcxx/test/std/ranges/range.adaptors/range.filter/iterator/arrow.pass.cpp", "functions": ["iter"]}, {"filename": "libcxx/test/std/ranges/range.adaptors/range.filter/iterator/base.pass.cpp", "functions": ["iter"]}, {"filename": "libcxx/test/std/ranges/range.adaptors/range.filter/iterator/ctor.parent_iter.pass.cpp", "functions": ["view"]}, {"filename": "libcxx/test/std/ranges/range.adaptors/range.filter/iterator/deref.pass.cpp", "functions": ["iter"]}, {"filename": "libcxx/test/std/ranges/range.adaptors/range.filter/sentinel/compare.pass.cpp", "functions": ["v"]}]}
{"pr_number": 72262, "url": "https://github.com/llvm/llvm-project/pull/72262", "title": "[mlir] Remove convertible identity restriction for memref.atomic_rmw \u2026", "body": "\u2026to LLVM", "feature_layers": ["ir"], "feature_directives": ["for", "atomic"], "files_changed": [{"filename": "mlir/lib/Conversion/MemRefToLLVM/MemRefToLLVM.cpp", "functions": ["failure"]}]}
{"pr_number": 72102, "url": "https://github.com/llvm/llvm-project/pull/72102", "title": "[X86][MC] Support decoding of EGPR for APX", "body": "https://github.com/llvm/llvm-project/pull/70958 adds registers R16-R31 (EGPR), this patch\r\n\r\n\r\n1. Supports decoding of EGPR for instruction w/ REX2 prefix\r\n2. Supports decoding of EGPR for instruction w/ EVEX prefix\r\n\r\nFor simplicity's sake,  we \r\n1.  Simulate the REX prefix w/ the 1st payload of REX2\r\n2.  Simulate the REX2 prefix w/ the 2nd and 3rd payloads of EVEX\r\n\r\nRFC:\r\nhttps://discourse.llvm.org/t/rfc-design-for-apx-feature-egpr-and-ndd-support/73031/4\r\n\r\nExplanations for some changes:\r\n1. invalid-EVEX-R2.txt is deleted b/c `0x62 0xe1 0xff 0x08 0x79 0xc0` is valid and decoded to `vcvtsd2usi %xmm0, %r16` now.\r\n2. One line in x86-64-err.txt is removed b/c APX relaxes the limitation of the 1st and 2nd payloads of EVEX prefix, so the error message changes", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/X86/Disassembler/X86Disassembler.cpp", "functions": ["consume", "isREX2"]}]}
{"pr_number": 70763, "url": "https://github.com/llvm/llvm-project/pull/70763", "title": "[clang] Use new interpreter in EvaluateAsConstantExpr if requested", "body": "EvaluateAsConstantExpr() uses ::EvaluateInPlace() directly, which does not use the new interpreter if requested. Do it here, which is the same pattern we use in EvaluateAsInitializer.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "clang/test/AST/Interp/literals.cpp", "functions": ["sizeof"]}]}
{"pr_number": 72237, "url": "https://github.com/llvm/llvm-project/pull/72237", "title": "[FileCheck] Don't use regex to find prefixes", "body": "FileCheck currently compiles a regular expression of the form `Prefix1|Prefix2|...` and uses it to find the next prefix in the input.\r\n\r\nIf we had a fast regex implementation, this would be a useful thing to do, as the regex implementation would be able to match multiple prefixes more efficiently than a naive approach. However, with our actual regex implementation, finding the prefixes basically becomes O(InputLen * RegexLen * LargeConstantFactor), which is a lot worse than a simple string search.\r\n\r\nReplace the regex with StringRef::find(), and keeping track of the next position of each prefix. There are various ways this could be improved on, but it's already significantly faster that the previous approach.\r\n\r\nFor me, this improves check-llvm time from 138.5s to 132.5s, so by around 4-5%.\r\n\r\nFor vector-interleaved-load-i16-stride-7.ll in particular, test time drops from 5s to 2.5s.", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/FileCheck/FileCheck.cpp", "functions": ["match"]}]}
{"pr_number": 72315, "url": "https://github.com/llvm/llvm-project/pull/72315", "title": "Add support for arm64 registers in minidump core file saving.", "body": "This patch adds support for saving minidumps with the arm64 architecture. It also will cause unsupported architectures to emit an error where before this patch it would emit a minidump with partial information. This new code is tested by the arm64 windows buildbot that was failing:\r\n\r\nhttps://lab.llvm.org/buildbot/#/builders/219/builds/6868\r\n\r\nThis is needed following this PR: https://github.com/llvm/llvm-project/pull/71772", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "lldb/source/Plugins/ObjectFile/Minidump/MinidumpFileBuilder.cpp", "functions": ["sizeof"]}]}
{"pr_number": 72091, "url": "https://github.com/llvm/llvm-project/pull/72091", "title": "[JITLink][AArch32] Run all error unittests through the main entrypoints applyFixup() and readAddend()", "body": "First commit: Reading implicit addend from a relocation site doesn't require a complete `LinkGraph` edge. The operation is independent from `TargetSymbol`, but constructing an `Edge` instance required one. This patch fixes the inconsistency and simplifies some setup code from the error unittests.\r\n\r\nThe second commit is in preparation for the `Arm`/`Thumb`/`Data` helper functions to be turned into implementation details. Exposing them in the API causes unfortunate inconsistencies that we don't want to error-check all the time, e.g. passing `Thumb_Call` to `readAddendArm()`.", "feature_layers": ["ir"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "llvm/lib/ExecutionEngine/JITLink/ELF_aarch32.cpp", "functions": ["E"]}, {"filename": "llvm/lib/ExecutionEngine/JITLink/aarch32.cpp", "functions": ["readAddendArm", "readAddendData", "R"]}, {"filename": "llvm/unittests/ExecutionEngine/JITLink/AArch32ErrorTests.cpp", "functions": ["E"]}]}
{"pr_number": 70784, "url": "https://github.com/llvm/llvm-project/pull/70784", "title": "[AArch64][GlobalISel] Support udot lowering for vecreduce add", "body": "vecreduce_add(mul(ext, ext)) -> vecreduce_add(udot) \r\nvecreduce_add(ext) -> vecreduce_add(ext)\r\n\r\nVectors of scalar size of 8-bits with element count of multiples of 8", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AArch64/GISel/AArch64PreLegalizerCombiner.cpp", "functions": ["if"]}]}
{"pr_number": 71850, "url": "https://github.com/llvm/llvm-project/pull/71850", "title": "[MLIR][OpenMP] Changes to function-filtering pass", "body": "Currently, when deleting the device functions in the second stage of filtering during MLIR to LLVM translation we can end up with invalid calls to these functions. This is because of the removal of the EarlyOutliningPass which would have otherwise gotten rid of any such calls.\r\n\r\nThis patch aims to alter the function filtering pass in the following way:\r\n\t- Any host function is completely removed.\r\n\t- Call to the host function are also removed and their uses replaced with Undef values.\r\n\t- Any host function with target region code is marked to be removed during the the second stage.\r\n\t- Calls to such functions are still removed and their uses replaced with Undef values.\r\n\r\nCo-authored-by: Sergio Afonso <sergio.afonsofumero@amd.com>", "feature_layers": ["ir"], "feature_directives": ["target"], "files_changed": [{"filename": "flang/lib/Optimizer/Transforms/OMPFunctionFiltering.cpp", "functions": ["opBuilder", "if"]}]}
{"pr_number": 72124, "url": "https://github.com/llvm/llvm-project/pull/72124", "title": "AMDGPU/SILowerI1Copies process phi incomings in specific order", "body": "When merging lane masks value from block that is always visited first\r\n(PrevReg in buildMergeLaneMasks) needs to exist. For PrevReg to exist,\r\nbasic block that should contain PrevReg definition must be processed\r\nfirst.\r\nIf block A dominates block B, block A must be processed first.\r\nThis can be achieved by sorting phi incomings.\r\n\r\nSorting of phi incomings makes no changes for phis created by SDAG\r\nbecause SDAG adds phi incomings as it selects basic blocks in reversed\r\npost order traversal.\r\n\r\nThis change is required by upcoming lane mask merging implementation for\r\nGlobalISel that leaves phi incomings as they are in IR.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/SILowerI1Copies.cpp", "functions": ["Reg", "analyze"]}]}
{"pr_number": 72183, "url": "https://github.com/llvm/llvm-project/pull/72183", "title": "[readtapi] Use OptParser.td for options", "body": "This includes revamping how --compare was handled and adds `-o` ontop of tablegen approach.\r\n\r\nThis will be used to add more complex options.", "feature_layers": ["parse", "parser"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/tools/llvm-readtapi/llvm-readtapi.cpp", "functions": ["convertFileToBinary", "handleCompareAction", "Saver", "InputFileName", "main", "X", "TapiCat", "DiffEngine", "CompareCat", "ExitOnErr"]}]}
{"pr_number": 72294, "url": "https://github.com/llvm/llvm-project/pull/72294", "title": "[SLP][NFC] Make tryToGather[SingleRegister]ExtractElements routines BoUpSLP methods.", "body": "", "feature_layers": [], "feature_directives": ["single"], "files_changed": [{"filename": "llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp", "functions": ["SavedVL", "ExtractMask", "ShufflesRes"]}]}
{"pr_number": 72186, "url": "https://github.com/llvm/llvm-project/pull/72186", "title": "[BOLT] Fix NOP instruction emission on x86", "body": "Use MCAsmBackend::writeNopData() interface to emit NOP instructions on x86. There are multiple forms of NOP instruction on x86 with different sizes. Currently, LLVM's assembly/disassembly does not support all forms correctly which can lead to a breakage of input code semantics, e.g. if the program relies on NOP instructions for reserving a patch space.\r\n\r\nAdd \"--keep-nops\" option to preserve NOP instructions.", "feature_layers": ["sema"], "feature_directives": ["for"], "files_changed": [{"filename": "bolt/lib/Core/BinaryEmitter.cpp", "functions": ["VecOS"]}]}
{"pr_number": 72434, "url": "https://github.com/llvm/llvm-project/pull/72434", "title": "Revert \"[IRBuilder] Handle constexpr-bitcast for IRBuilder::CreateThreadLocalAddress\"", "body": "This reverts ce1b24cca886eb9f05e252f399059167473d0ba3.\r\n\r\nSince opaque pointers are enabled, we can safely revert the patch now. Opaque ptr cleanup effort (NFC).", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/unittests/IR/IRBuilderTest.cpp", "functions": ["Builder"]}]}
{"pr_number": 72012, "url": "https://github.com/llvm/llvm-project/pull/72012", "title": "Remove hardware index from watchpoints and breakpoints", "body": "The Watchpoint and Breakpoint objects try to track the hardware index that was used for them, if they are hardware wp/bp's. The majority of our debugging goes over the gdb remote serial protocol, and when we set the watchpoint/breakpoint, there is no (standard) way for the remote stub to communicate to lldb which hardware index was used.  We have an lldb-extension packet to query the total number of watchpoint registers.\r\n\r\nWhen a watchpoint is hit, there is an lldb extension to the stop reply packet (documented in lldb-gdb-remote.txt) to describe the watchpoint including its actual hardware index,\r\n\r\n<addr within wp range> <wp hw index> <actual accessed address>\r\n\r\n(the third field is specifically needed for MIPS).  At this point, if the stub reported these three fields (the stub is only required to provide the first), we can know the actual hardware index for this watchpoint.\r\n\r\nBreakpoints are worse; there's never any way for us to be notified about which hardware index was used.  Breakpoints got this as a side effect of inherting from StoppointSite with Watchpoints.\r\n\r\nWe expose the watchpoint hardware index through \"watchpoint list -v\" and through SBWatchpoint::GetHardwareIndex.\r\n\r\nWith my large watchpoint support, there is no *single* hardware index that may be used for a watchpoint, it may need multiple resources.  Also I don't see what a user is supposed to do with this information, or an IDE.  Knowing the total number of watchpoint registers on the target, and knowing how many Watchpoint Resources are currently in use, is helpful.  Knowing how many Watchpoint Resources\r\na single user-specified watchpoint needed to be implemented is useful. But knowing which registers were used is an implementation detail and not available until we hit the watchpoint when using gdb remote serial protocol.\r\n\r\nSo given all that, I'm removing watchpoint hardware index numbers. I'm changing the SB API to always return -1.", "feature_layers": ["ir"], "feature_directives": ["for", "single", "target"], "files_changed": [{"filename": "lldb/source/API/SBWatchpoint.cpp", "functions": ["watchpoint_sp"]}, {"filename": "lldb/source/Breakpoint/StoppointSite.cpp", "functions": ["m_id"]}]}
{"pr_number": 71587, "url": "https://github.com/llvm/llvm-project/pull/71587", "title": "[RISCV][GISEL] Add support for scalable vector types in lowerReturnVal", "body": "Scalable vector types from LLVM IR are lowered into physical vector registers in MIR based on calling convention for return instructions.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/GISel/RISCVCallLowering.cpp", "functions": ["isSupportedReturnType"]}]}
{"pr_number": 70344, "url": "https://github.com/llvm/llvm-project/pull/70344", "title": "[libc++] Extend is_trivially_equality_comparable to integral types with the same signedness and size", "body": "This enables all optimizations that rely on `is_trivially_equality_comparable` to work with these integral types, for example `std::equal` and `std::find`.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "libcxx/test/std/algorithms/alg.nonmodifying/alg.equal/equal.pass.cpp", "functions": ["operator"]}]}
{"pr_number": 72126, "url": "https://github.com/llvm/llvm-project/pull/72126", "title": "[X86][AVX10] Fix a bug when using -march with no-evex512 attribute", "body": "#71318 failed to clear EVEX512 feature for intended intrinsics.\r\n\r\nFixes #72106", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CodeGen/X86/pr72106.c", "functions": ["main"]}]}
{"pr_number": 72423, "url": "https://github.com/llvm/llvm-project/pull/72423", "title": "[mlir][sparse] schedule sparse kernels in a separate pass from sparsification.", "body": "", "feature_layers": ["parse", "ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/Transforms/CodegenEnv.cpp", "functions": ["isMaterializing"]}, {"filename": "mlir/lib/Dialect/SparseTensor/Transforms/LoopScheduler.cpp", "functions": ["finder", "iterTypes", "LoopScheduler", "getDimExpr", "topoSort", "visitDimExpr", "includesDenseOutput", "includesAny", "ins", "includesDenseInput", "setPickedIterType", "AffineDimFinder", "AffineMap", "walkPostOrder"]}, {"filename": "mlir/lib/Dialect/SparseTensor/Transforms/SparseReinterpretMap.cpp", "functions": ["failure", "isAdmissibleOrder", "success", "hasNonIdentityOperandsOrResults"]}, {"filename": "mlir/lib/Dialect/SparseTensor/Transforms/Sparsification.cpp", "functions": ["success", "failure", "permute", "worklist", "AffineDimFinder", "iterTypes", "topSortOptimal", "visitDimExpr", "if", "includesDense", "finder", "getDimExpr", "resolveCycle", "includesUndef", "addFilterLoopBasedConstraints", "setPickedIterType", "includesDenseOutput", "inDegree", "includesAny", "includesDenseInput"]}, {"filename": "mlir/lib/Dialect/SparseTensor/Transforms/IterationGraphSorter.cpp", "functions": ["IterationGraphSorter", "LoopScheduler"]}]}
{"pr_number": 71748, "url": "https://github.com/llvm/llvm-project/pull/71748", "title": "[MS-ABI] skip generate comdat for vftable defined with internal alias.", "body": "We got a error:\r\n`LLVM ERROR: Associative COMDAT symbol '??_7?$T@V<lambda_0>@@@@6B@' is not a key for its COMDAT`\r\n\r\nCurrent we create internal alias for vftable when lambd is used.\r\nFor the test, IR generate:\r\n```\r\n $\"??_7?$T@V<lambda_0>@@$0A@@@6b@\" = comdat any\r\n\r\n@0 = private unnamed_addr constant { [2 x ptr] } { [2 x ptr] [ptr @\"??_R4?$T@V<lambda_0>@@$0A@@@6b@\", ptr @\"?c@b@@UEAAXXZ\"] }, comdat($\"??_7?$T@V<lambda_0>@@$0A@@@6b@\")\r\n\r\n@\"??_7?$T@V<lambda_0>@@$0A@@@6b@\" = internal unnamed_addr alias ptr, getelementptr inbounds ({ [2 x ptr] }, ptr @0, i32 0, i32 0, i32 1)\r\n```\r\n\r\nAccording LLVM language reference manual section on COMDATs:\r\nThere are some restrictions on the properties of the global object. It,\r\nor an alias to it, must have the same name as the COMDAT group when\r\ntargeting COFF. The contents and size of this object may be used during\r\nlink-time to determine which COMDAT groups get selected depending on the\r\nselection kind. Because the name of the object must match the name of the\r\nCOMDAT group, the linkage of the global object must not be local; local\r\nsymbols can get renamed if a collision occurs in the symbol table.\r\n\r\nSo one way to fix this is to not create comdat for the alias.\r\n\r\n@0 = private unnamed_addr constant { [2 x ptr] } { [2 x ptr] [ptr @\"??_R4?$T@V<lambda_0>@@@@6B@\", ptr @\"?c@?$T@V<lambda_0>@@@@UEAAXXZ\"] }\r\n\r\n", "feature_layers": ["ir"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "clang/test/CodeGen/windows-seh-EHa-TryInFinally.cpp", "functions": ["bar"]}, {"filename": "clang/lib/AST/MicrosoftMangle.cpp", "functions": ["getIsLocalVFTAliasReq", "setIsLocalVFTAliasReq"]}, {"filename": "clang/test/CodeGenCXX/ms-local-vft-alias-comdat.cpp", "functions": ["s", "j", "ab", "c", "n"]}]}
{"pr_number": 72230, "url": "https://github.com/llvm/llvm-project/pull/72230", "title": "[Sema] Check nullness of captured type before use", "body": "", "feature_layers": ["sema"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/SemaCXX/lambda-invalid-capture.cpp", "functions": ["pr72198"]}]}
{"pr_number": 72472, "url": "https://github.com/llvm/llvm-project/pull/72472", "title": "[mlir][sparse] refactor dim2lvl/lvl2dim lvlsizes setup", "body": "This change provides access to the individual components of dim sizes and lvl sizes after each codegenutil call.\r\n\r\nThis is step 2 out of 3 to make sparse_tensor.new work for BSR", "feature_layers": ["parse", "codegen", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/Transforms/CodegenUtils.cpp", "functions": ["allocaBuffer", "lvlSizesValues"]}, {"filename": "mlir/lib/Dialect/SparseTensor/Transforms/SparseTensorConversion.cpp", "functions": ["constantIndex"]}]}
{"pr_number": 72474, "url": "https://github.com/llvm/llvm-project/pull/72474", "title": "[mlir][sparse] refactor dim2lvl/lvl2dim lvlsizes setup", "body": "This change provides access to the individual components of dim sizes and lvl sizes after each codegenutil call.\r\n\r\nThis is step 2 out of 3 to make sparse_tensor.new work for BSR", "feature_layers": ["parse", "codegen", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/Transforms/CodegenUtils.cpp", "functions": ["allocaBuffer", "lvlSizesValues"]}, {"filename": "mlir/lib/Dialect/SparseTensor/Transforms/SparseTensorConversion.cpp", "functions": ["constantIndex"]}]}
{"pr_number": 72059, "url": "https://github.com/llvm/llvm-project/pull/72059", "title": "[mlir] Verify non-negative `offset` and `size`", "body": "In #71153, the `memref.subview` canonicalizer crashes due to a negative `size` being passed as an operand. During `SubViewOp::verify` this negative `size` is not yet detectable since it is dynamic and only available after constant folding, which happens during the canonicalization passes. As discussed in <https://discourse.llvm.org/t/rfc-more-opfoldresult-and-mixed-indices-in-ops-that-deal-with-shaped-values/72510>, the verifier should not be extended as it should \"only verify local aspects of an operation\".\r\n\r\nThis patch fixes #71153 by not folding in aforementioned situation.\r\n\r\nAlso, this patch adds a basic offset and size check in the `OffsetSizeAndStrideOpInterface` verifier.\r\n\r\nNote: only `offset` and `size` are checked because `stride` is allowed to be negative (https://github.com/llvm/llvm-project/commit/54d81e49e3b72f6a305891fe169ecd7c6f559223).", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/MemRef/IR/MemRefOps.cpp", "functions": ["emitError"]}]}
{"pr_number": 65494, "url": "https://github.com/llvm/llvm-project/pull/65494", "title": "[Bolt] Solving pie support issue", "body": "Now PIE is default supported after clang 14. It cause parsing error when using perf2bolt. The reason is the base address can not get correctly. Fix the method of geting base address. If SegInfo.Alignment is not equal to pagesize, alignDown(SegInfo.FileOffset, SegInfo.Alignment) can not equal to FileOffset. So the SegInfo.FileOffset and FileOffset should be aligned by SegInfo.Alignment first and then judge whether they are equal.\r\nThe .text segment's offset from base address in VAS  is aligned by pagesize. So MMapAddress's offset from base address is alignDown(SegInfo.Address, pagesize) instead of\r\nalignDown(SegInfo.Address, SegInfo.Alignment). So the base address calculate way should be changed.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "bolt/test/perf2bolt/Inputs/perf_test.c", "functions": ["divide", "minus", "main", "add", "multiple"]}]}
{"pr_number": 65301, "url": "https://github.com/llvm/llvm-project/pull/65301", "title": "[clang][dataflow] Emit an error if source code is not compiled as C++.", "body": "The shape of certain elements of the AST can vary depending on the langugage.\nWe currently only support C++.\n", "feature_layers": ["ast"], "feature_directives": [], "files_changed": [{"filename": "clang/unittests/Analysis/FlowSensitive/TransferTest.cpp", "functions": ["target"]}]}
{"pr_number": 72236, "url": "https://github.com/llvm/llvm-project/pull/72236", "title": "[lldb][DWARFASTParserClang] DWARFv5: support DW_TAG_variable static data members declarations", "body": "The accepted DWARFv5 issue 161118.1: \"DW_TAG for C++ static data members\" specifies that static data member declaration be described by DW_TAG_variable. Make sure we recognize such members.\r\n\r\nDepends on:\r\n* https://github.com/llvm/llvm-project/pull/72234\r\n* https://github.com/llvm/llvm-project/pull/72235", "feature_layers": ["parse", "ast", "parser"], "feature_directives": ["for"], "files_changed": [{"filename": "lldb/source/Plugins/SymbolFile/DWARF/DWARFASTParserClang.cpp", "functions": ["attrs"]}]}
{"pr_number": 71955, "url": "https://github.com/llvm/llvm-project/pull/71955", "title": "[IR] Remove support for lshr/ashr constant expressions", "body": "Remove support for the lshr and ashr constant expressions. All places creating them have been removed beforehand, so this just removes the APIs and uses of these constant expressions in tests.\r\n\r\nThis is part of https://discourse.llvm.org/t/rfc-remove-most-constant-expressions/63179.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/bindings/ocaml/llvm/llvm_ocaml.c", "functions": ["llvm_const_ashr", "to_val", "llvm_const_lshr"]}, {"filename": "llvm/lib/AsmParser/LLParser.cpp", "functions": ["error"]}, {"filename": "llvm/lib/IR/ConstantFold.cpp", "functions": ["ExtractConstantBytes"]}, {"filename": "llvm/lib/IR/Core.cpp", "functions": ["LLVMConstLShr", "LLVMConstAShr", "wrap"]}]}
{"pr_number": 69520, "url": "https://github.com/llvm/llvm-project/pull/69520", "title": "[AArch64][Windows] Add MC support for ec_context", "body": "ARM64EC uses the same CONTEXT structure as x86_64 as opposed to the regular ARM64 context, a [new unwind opcode](https://learn.microsoft.com/en-us/cpp/build/arm64-exception-handling?view=msvc-170) (MSFT_OP_EC_CONTEXT) is added to handle this.\r\n\r\n(depends on https://github.com/llvm/llvm-project/pull/69515)", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp", "functions": ["if", "parseDirectiveSEHECContext"]}, {"filename": "llvm/lib/Target/AArch64/MCTargetDesc/AArch64ELFStreamer.cpp", "functions": ["emitARM64WinCFIECContext"]}]}
{"pr_number": 72429, "url": "https://github.com/llvm/llvm-project/pull/72429", "title": "[mlir][nvvm] Improve `cp.async.bulk.tensor.shared.cluster.global` for multicast", "body": "This PR improves `cp.async.bulk.tensor.shared.cluster.global` Op in NVVM dialect to leverage multicast. When the multicast parameter is present, the Op loads data using TMA data from global memory to shared memory of multiple CTAs in the cluster.\r\n\r\nIt resolves #72368", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/LLVMIR/IR/NVVMDialect.cpp", "functions": ["success", "emitError"]}]}
{"pr_number": 71546, "url": "https://github.com/llvm/llvm-project/pull/71546", "title": "[mlir][gpu] Introduce `gpu.dynamic_shared_memory` Op", "body": "While the `gpu.launch` Op allows setting the size via the `dynamic_shared_memory_size` argument, accessing the dynamic shared memory is very convoluted. This PR implements the proposed Op, `gpu.dynamic_shared_memory` that aims to simplify the utilization of dynamic shared memory.\r\n\r\nRFC: https://discourse.llvm.org/t/rfc-simplifying-dynamic-shared-memory-access-in-gpu/\r\n\r\n**Proposal from RFC**\r\nThis PR `gpu.dynamic.shared.memory` Op to use dynamic shared memory feature efficiently. It is is a powerful feature that enables the allocation of shared memory at runtime with the kernel launch on the host. Afterwards, the memory can be accessed directly from the device. I believe similar story exists for AMDGPU.\r\n\r\n**Current way Using Dynamic Shared Memory with MLIR**\r\n\r\nLet me illustrate the challenges of using dynamic shared memory in MLIR with an example below. The process involves several steps:\r\n- memref.global 0-sized array LLVM's NVPTX backend expects\r\n- dynamic_shared_memory_size Set the size of dynamic shared memory\r\n- memref.get_global Access the global symbol\r\n- reinterpret_cast and subview Many OPs for pointer arithmetic\r\n\r\n```\r\n// Step 1. Create 0-sized global symbol. Manually set the alignment\r\nmemref.global \"private\" @dynamicShmem  : memref<0xf16, 3> { alignment = 16 }\r\nfunc.func @main() {\r\n  // Step 2. Allocate shared memory\r\n  gpu.launch blocks(...) threads(...)\r\n    dynamic_shared_memory_size %c10000 {\r\n    // Step 3. Access the global object\r\n    %shmem = memref.get_global @dynamicShmem : memref<0xf16, 3>\r\n    // Step 4. A sequence of `memref.reinterpret_cast` and `memref.subview` operations.\r\n    %4 = memref.reinterpret_cast %shmem to offset: [0], sizes: [14, 64, 128],  strides: [8192,128,1] : memref<0xf16, 3> to memref<14x64x128xf16,3>\r\n    %5 = memref.subview %4[7, 0, 0][7, 64, 128][1,1,1] : memref<14x64x128xf16,3> to memref<7x64x128xf16, strided<[8192, 128, 1], offset: 57344>, 3>\r\n    %6 = memref.subview %5[2, 0, 0][1, 64, 128][1,1,1] : memref<7x64x128xf16, strided<[8192, 128, 1], offset: 57344>, 3> to memref<64x128xf16, strided<[128, 1], offset: 73728>, 3>\r\n    %7 = memref.subview %6[0, 0][64, 64][1,1]  : memref<64x128xf16, strided<[128, 1], offset: 73728>, 3> to memref<64x64xf16, strided<[128, 1], offset: 73728>, 3>\r\n    %8 = memref.subview %6[32, 0][64, 64][1,1] : memref<64x128xf16, strided<[128, 1], offset: 73728>, 3> to memref<64x64xf16, strided<[128, 1], offset: 77824>, 3>\r\n    // Step.5 Use\r\n    \"test.use.shared.memory\"(%7) : (memref<64x64xf16, strided<[128, 1], offset: 73728>, 3>) -> (index)\r\n    \"test.use.shared.memory\"(%8) : (memref<64x64xf16, strided<[128, 1], offset: 77824>, 3>) -> (index)\r\n    gpu.terminator\r\n  }\r\n```\r\n\r\nLet\u2019s write the program above with that:\r\n\r\n```\r\nfunc.func @main() {\r\n    gpu.launch blocks(...) threads(...) dynamic_shared_memory_size %c10000 {\r\n    \t%i = arith.constant 18 : index\r\n        // Step 1: Obtain shared memory directly\r\n        %shmem = gpu.dynamic_shared_memory : memref<?xi8, 3>\r\n        %c147456 = arith.constant 147456 : index\r\n        %c155648 = arith.constant 155648 : index\r\n        %7 = memref.view %shmem[%c147456][] : memref<?xi8, 3> to memref<64x64xf16, 3>\r\n        %8 = memref.view %shmem[%c155648][] : memref<?xi8, 3> to memref<64x64xf16, 3>\r\n\r\n        // Step 2: Utilize the shared memory\r\n        \"test.use.shared.memory\"(%7) : (memref<64x64xf16, 3>) -> (index)\r\n        \"test.use.shared.memory\"(%8) : (memref<64x64xf16, 3>) -> (index)\r\n    }\r\n}\r\n```\r\n\r\nThis PR resolves #72513", "feature_layers": ["runtime", "ir", "ast"], "feature_directives": ["for", "allocate"], "files_changed": [{"filename": "mlir/lib/Conversion/GPUCommon/GPUOpsLowering.cpp", "functions": ["success", "guard"]}, {"filename": "mlir/lib/Dialect/GPU/IR/GPUDialect.cpp", "functions": ["emitOpError", "stringifyEnum"]}, {"filename": "mlir/lib/IR/SymbolTable.cpp", "functions": ["nameBuffer"]}]}
{"pr_number": 71707, "url": "https://github.com/llvm/llvm-project/pull/71707", "title": "[Clang][SME2] Add single and multi min/max by vector builtins", "body": "Adds the following SME2 builtins:\r\n\r\nsvminnm_single_f(16|32|64)_x(2|4)\r\nsvminnm_f(16|32|64)_x(2|4)\r\nsvmaxnm_single_f(16|32|64)_x(2|4)\r\nsvmaxnm_f(16|32|64)_x(2|4)\r\n\r\nSee\r\n[ARM-software/acle#217](https://github.com/ARM-software/acle/pull/217)\r\n\r\nPatch by: Kerry McLaughlin <kerry.mclaughlin@arm.com>", "feature_layers": [], "feature_directives": ["single"], "files_changed": [{"filename": "clang/test/CodeGen/aarch64-sme2-intrinsics/acle_sme2_maxnm.c", "functions": ["SVE_ACLE_FUNC"]}, {"filename": "clang/test/CodeGen/aarch64-sme2-intrinsics/acle_sme2_minnm.c", "functions": ["SVE_ACLE_FUNC"]}]}
{"pr_number": 72096, "url": "https://github.com/llvm/llvm-project/pull/72096", "title": "[RISCV] Split regalloc between RVV and other", "body": "Enable this flow by -riscv-split-regalloc=1 (default disable), and could designate specific allocator to RVV by -riscv-rvv-regalloc=<fast|basic|greedy>\r\n\r\nIt uses the RegClass filter function to decide which regclass need to be processed.\r\n\r\nThis patch is pre-requirement for supporting PostRA vsetvl insertion pass.", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVTargetMachine.cpp", "functions": ["createGreedyRegisterAllocator", "Ctor", "RegisterRegAllocBase", "createGreedyRVVRegisterAllocator", "initializeDefaultRVVRegisterAllocatorOnce", "createBasicRegisterAllocator", "addRegAssignAndRewriteOptimized", "createFastRegisterAllocator", "createFastRVVRegisterAllocator", "addRegAssignAndRewriteFast"]}]}
{"pr_number": 71541, "url": "https://github.com/llvm/llvm-project/pull/71541", "title": "[RISCV][GISEL] Add vector RegisterBanks and vector support in getRegBankFromRegClass", "body": "Vector Register banks are created for the various register vector\r\nregister groupings. getRegBankFromRegClass is implemented to go from\r\nvector TargetRegisterClass to the corresponding vector RegisterBank.\r\n\r\nTypeSize is used in places needed to prevent RegBankSelectionFrom failing.", "feature_layers": [], "feature_directives": ["for", "target"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/GISel/RISCVRegisterBankInfo.cpp", "functions": ["getRegBank"]}]}
{"pr_number": 71985, "url": "https://github.com/llvm/llvm-project/pull/71985", "title": "[clang] Make `-fvisibility={}` and `-ftype-visibility={}` benign options.", "body": "Both options do not affect the AST content that is serialized into the PCM. This\r\ncommit includes the following changes:\r\n    \r\n1.) Mark `-fvisibility={}` and `-ftype-visibility={}` as benign options. That\r\n     means they are no longer considered part of the module hash, which can\r\n     reduce the number of module variants.\r\n    \r\n2.) Add a test to verify the generated LLVM IR is not affected by the default\r\n     visibiliy mode in the module.\r\n\r\n3.) Add a test to clang-scan-deps to ensure only one module is build, even if\r\n      the above mentioned options are used.\r\n    \r\nThis fixes rdar://118246054.", "feature_layers": ["ir", "ast"], "feature_directives": [], "files_changed": [{"filename": "clang/test/ClangScanDeps/strip-visibility.c", "functions": ["a"]}, {"filename": "clang/test/Modules/codegen-visibility.cpp", "functions": ["f3", "f1", "test", "f4", "f2"]}, {"filename": "clang/test/Modules/visibility.cpp", "functions": ["f3", "f1", "test", "f4", "f2"]}]}
{"pr_number": 71992, "url": "https://github.com/llvm/llvm-project/pull/71992", "title": "[flang][NVPTX] Add initial support to the NVPTX target", "body": "This patch adds initial support to the NVPTX target, enabling `flang` to produce OpenMP offload code for NVPTX targets.", "feature_layers": [], "feature_directives": ["for", "target"], "files_changed": [{"filename": "flang/lib/Frontend/FrontendActions.cpp", "functions": ["userKeyString", "getExplicitAndImplicitNVPTXTargetFeatures"]}]}
{"pr_number": 71392, "url": "https://github.com/llvm/llvm-project/pull/71392", "title": "[clang][analyzer] Improve 'errno' handling in StdLibraryFunctionsChecker.", "body": "The checker now displays one combined note tag for errno-related and \"case\"-related notes. Previous functions in the errno-modeling part that were used for construction of note tags are removed. The note tag added by StdLibraryFunctionsChecker contains the code to display the note tag for 'errno' (this was done previously by these removed functions).", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp", "functions": ["describe"]}, {"filename": "clang/test/Analysis/std-c-library-functions-path-notes.c", "functions": ["test_readlink_bufsize_zero"]}, {"filename": "clang/test/Analysis/stream-errno-note.c", "functions": ["check_fwrite_zeroarg"]}]}
{"pr_number": 72324, "url": "https://github.com/llvm/llvm-project/pull/72324", "title": "[Kaleidoscope] Switch to the new PassManager, revisited.", "body": "Rollforward of #69032, which was reverted in [63d19cf](https://github.com/llvm/llvm-project/commit/63d19cfd853b0b4e374f40842ee388b0da5de36f).\r\n\r\nNew: implemented changes in https://github.com/llvm/llvm-project/pull/69032#issuecomment-1809250162.\r\nGiven the PassBuilder is how we expect users to register passes, the tutorial should reflect that.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/examples/Kaleidoscope/Chapter4/toy.cpp", "functions": ["InitializeModuleAndManagers", "InitializeModuleAndPassManager"]}, {"filename": "llvm/examples/Kaleidoscope/Chapter5/toy.cpp", "functions": ["InitializeModuleAndManagers", "InitializeModuleAndPassManager"]}, {"filename": "llvm/examples/Kaleidoscope/Chapter6/toy.cpp", "functions": ["InitializeModuleAndManagers", "InitializeModuleAndPassManager"]}, {"filename": "llvm/examples/Kaleidoscope/Chapter7/toy.cpp", "functions": ["InitializeModuleAndManagers", "InitializeModuleAndPassManager"]}]}
{"pr_number": 68617, "url": "https://github.com/llvm/llvm-project/pull/68617", "title": "[CodeLayout] Faster basic block reordering, ext-tsp", "body": "Aggressive inlining might produce huge functions with >10K of basic \r\nblocks. Since BFI treats _all_ blocks and jumps as \"hot\" having \r\nnon-negative (but perhaps small) weight, the current implementation can\r\nbe slow, taking minutes to produce an layout. This change introduces a\r\nfew modifications that significantly (up to 50x on some instances) \r\nspeeds up the computation. Some notable changes:\r\n- reduced the maximum chain size to 512 (from the prior 4096);\r\n- introduced MaxMergeDensityRatio param to avoid merging chains with\r\nvery different densities;\r\n- dropped a couple of params that seem unnecessary.\r\n\r\nLooking at some \"offline\" metrics (e.g., the number of created \r\nfall-throughs), there shouldn't be problems; in fact, I do see some\r\nmetrics go up. But it might be hard/impossible to measure perf \r\ndifference for such small changes. I did test the performance clang-14 \r\nbinary and do not record a perf or i-cache-related differences.\r\n\r\nMy 5 benchmarks, with ext-tsp runtime (the lower the better) and \r\n\"tsp-score\" (the higher the better).\r\n**Before**:\r\n\r\n- benchmark 1:\r\n  num functions: 13,047\r\n  reordering running time is 2.4 seconds\r\n  score: 125503458 (128.3102%)\r\n- benchmark 2:\r\n  num functions: 16,438\r\n  reordering running time is 3.4 seconds\r\n  score: 12613997277 (129.7495%)\r\n- benchmark 3:\r\n  num functions: 12,359\r\n  reordering running time is 1.9 seconds\r\n  score: 1315881613 (105.8991%)\r\n- benchmark 4:\r\n  num functions: 96,588\r\n  reordering running time is 7.3 seconds\r\n  score: 89513906284 (100.3413%)\r\n- benchmark 5:\r\n  num functions: 1\r\n  reordering running time is 372 seconds\r\n  score: 21292505965077 (99.9979%)\r\n- benchmark 6:\r\n  num functions:  71,155\r\n  reordering running time is 314 seconds\r\n  score: 29795381626270671437824 (102.7519%)\r\n\r\n**After**:\r\n- benchmark 1:\r\n  reordering running time is 2.2 seconds\r\n  score: 125510418 (128.3130%)\r\n\r\n- benchmark 2:\r\n  reordering running time is 2.6 seconds\r\n  score: 12614502162 (129.7525%)\r\n\r\n- benchmark 3:\r\n  reordering running time is 1.6 seconds\r\n  score: 1315938168 (105.9024%)\r\n\r\n- benchmark 4:\r\n  reordering running time is 4.9 seconds\r\n  score: 89518095837 (100.3454%)\r\n\r\n- benchmark 5:\r\n  reordering running time is 4.8 seconds\r\n  score: 21292295939119 (99.9971%)\r\n\r\n- benchmark 6:\r\n  reordering running time is 104 seconds\r\n  score: 29796710925310302879744 (102.7565%)\r\n", "feature_layers": ["runtime", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Utils/CodeLayout.cpp", "functions": ["isSuccessor", "empty", "density"]}]}
{"pr_number": 70932, "url": "https://github.com/llvm/llvm-project/pull/70932", "title": "[WIP][AMDGPU] Enable hostcall printf for OpenCL", "body": "Attempt to enable OpenCL hostcall printf (SWDEV-204804).  I would like to have some inputs regarding few key points listed here,\r\n\r\n1. We continue to use \"-mprintf-kind\" option to decide the lowering scheme. It now supports a new value \"none\" that just makes compiler use default lowering scheme. (hostcalls for HIP, Buffered for OpenCL)\r\n2. OpenCL now treats printf as a builtin so that the printf expansion happens via clang CodeGen. This would also mean that the \"AMDGPUPrintfRuntimeBinding\" pass would no longer be required since all printf calls would be expanded earlier.\r\n3. The implementation adds vector processing support both for hostcall and buffered cases. The vector elements are extracted and pushed onto the buffer individually (each alingned to 8 byte boundary)\r\n4. for OpenCL hostcall case, The format string pointer is addrspace casted to generic address space to be compatible with hostcall device lib functions.\r\n", "feature_layers": ["codegen", "runtime", "ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/CodeGen/CGGPUBuiltin.cpp", "functions": ["isString", "IRB"]}, {"filename": "llvm/lib/Transforms/Utils/AMDGPUEmitPrintf.cpp", "functions": ["appendArg", "appendVectorArg", "locateCStrings"]}]}
{"pr_number": 72549, "url": "https://github.com/llvm/llvm-project/pull/72549", "title": "[RISCV] Use bset+addi for (not (sll -1, X)).", "body": "This is an alternative to #71420 that handles i32 on RV64 safely by pre-promoting the pattern in DAG combine.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVISelLowering.cpp", "functions": ["DL"]}]}
{"pr_number": 72550, "url": "https://github.com/llvm/llvm-project/pull/72550", "title": "[mlir][sparse] code cleanup (remove topSort in CodegenEnv).", "body": "", "feature_layers": ["parse", "codegen", "ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/Transforms/CodegenEnv.cpp", "functions": ["getLoopStackUpTo", "sortDependentLoops"]}, {"filename": "mlir/lib/Dialect/SparseTensor/Transforms/Sparsification.cpp", "functions": ["genFilterLoop", "genCoIteration", "isInvariantAffine"]}]}
{"pr_number": 70631, "url": "https://github.com/llvm/llvm-project/pull/70631", "title": "[libc++] Speed up classic locale", "body": "Locale objects use atomic reference counting, which may be very expensive in parallel applications. The classic locale is used by default by all streams and can be very contended. But it's never destroyed, so the reference counting is also completely pointless on the classic locale. Currently ~70% of time in the parallel stringstream benchmarks is spent in locale ctor/dtor. And the execution radically slows down with more threads.\r\n\r\nAvoid reference counting on the classic locale and inline common ctors/dtor. With this change locale ctor/dtor time become negligible and the benchmark starts to scale with threads.\r\n\r\n```\r\n                                       \u2502 bench/stream.baseline.res \u2502     bench/stream.optimized.res      \u2502\r\n                                       \u2502          sec/op           \u2502   sec/op     vs base                \u2502\r\nIstream_numbers/0/real_time/threads:1                  4.686\u00b5 \u00b1 0%   4.213\u00b5 \u00b1 0%  -10.09% (p=0.000 n=24)\r\nIstream_numbers/0/real_time/threads:72               339.712\u00b5 \u00b1 4%   8.939\u00b5 \u00b1 2%  -97.37% (p=0.000 n=24)\r\nIstream_numbers/1/real_time/threads:1                  4.900\u00b5 \u00b1 0%   4.773\u00b5 \u00b1 0%   -2.60% (p=0.000 n=24)\r\nIstream_numbers/1/real_time/threads:72                49.308\u00b5 \u00b1 3%   9.694\u00b5 \u00b1 1%  -80.34% (p=0.000 n=24)\r\nIstream_numbers/2/real_time/threads:1                  4.902\u00b5 \u00b1 0%   4.769\u00b5 \u00b1 0%   -2.72% (p=0.000 n=24)\r\nIstream_numbers/2/real_time/threads:72                 416.6\u00b5 \u00b1 9%   410.5\u00b5 \u00b1 6%        ~ (p=0.111 n=24)\r\nIstream_numbers/3/real_time/threads:1                  4.716\u00b5 \u00b1 0%   4.737\u00b5 \u00b1 0%   +0.45% (p=0.000 n=24)\r\nIstream_numbers/3/real_time/threads:72                 419.7\u00b5 \u00b1 6%   458.3\u00b5 \u00b1 4%   +9.19% (p=0.003 n=24)\r\nOstream_number/0/real_time/threads:1                   184.0n \u00b1 1%   135.0n \u00b1 1%  -26.63% (p=0.000 n=24)\r\nOstream_number/0/real_time/threads:72                17279.0n \u00b1 4%   308.0n \u00b1 1%  -98.22% (p=0.000 n=24)\r\nOstream_number/1/real_time/threads:1                   253.5n \u00b1 1%   199.0n \u00b1 1%  -21.50% (p=0.000 n=24)\r\nOstream_number/1/real_time/threads:72                13957.5n \u00b1 2%   382.0n \u00b1 0%  -97.26% (p=0.000 n=24)\r\nOstream_number/2/real_time/threads:1                   253.0n \u00b1 1%   202.0n \u00b1 1%  -20.16% (p=0.000 n=24)\r\nOstream_number/2/real_time/threads:72                  28.04\u00b5 \u00b1 4%   18.80\u00b5 \u00b1 7%  -32.96% (p=0.000 n=24)\r\nOstream_number/3/real_time/threads:1                   187.0n \u00b1 1%   190.5n \u00b1 0%   +1.87% (p=0.000 n=24)\r\nOstream_number/3/real_time/threads:72                  20.25\u00b5 \u00b1 7%   20.37\u00b5 \u00b1 5%        ~ (p=0.736 n=24)\r\n\r\n```", "feature_layers": [], "feature_directives": ["parallel", "atomic"], "files_changed": [{"filename": "libcxx/benchmarks/stringstream.bench.cpp", "functions": ["l", "istream_numbers", "sel"]}, {"filename": "libcxx/src/locale.cpp", "functions": ["make_global", "__locale_", "classic"]}]}
{"pr_number": 71227, "url": "https://github.com/llvm/llvm-project/pull/71227", "title": "[llvm] Reduce memory footprint of Debug metadata nodes", "body": "Using a combination of reordering fields and using empty SubclassData32 / SubclassData1, it's possible to improve the size of data structures used to store debug info in the IR:\r\n\r\nBefore:\r\n\r\nDILexicalBlock: 24\r\nDILexicalBlockFile: 24\r\nDIModule: 24\r\nDITemplateParameter: 24\r\nDICommonBlock: 24\r\nDIMacro: 24\r\nDICompileUnit: 56\r\nDIType: 48\r\nDINamespace: 24\r\nDIVariable: 24\r\nDIGlobalVariable: 32\r\nDILocalVariable: 32\r\nDILabel: 24\r\n\r\nAfter:\r\n\r\nDILexicalBlock: 24\r\nDILexicalBlockFile: 16\r\nDIModule: 16\r\nDITemplateParameter: 16\r\nDICommonBlock: 16\r\nDIMacro: 16\r\nDICompileUnit: 48\r\nDIType: 40\r\nDINamespace: 16\r\nDIVariable: 24\r\nDIGlobalVariable: 24\r\nDILocalVariable: 32\r\nDILabel: 16", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/IR/DebugInfoMetadata.cpp", "functions": ["DIScope", "DINode"]}]}
{"pr_number": 72573, "url": "https://github.com/llvm/llvm-project/pull/72573", "title": "[mlir][sparse] code cleanup (remove dead code related to filter loop).", "body": "", "feature_layers": ["parse", "ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/Transforms/Sparsification.cpp", "functions": ["findAffine", "Value", "env"]}, {"filename": "mlir/unittests/Dialect/SparseTensor/MergerTest.cpp", "functions": ["merger"]}]}
{"pr_number": 72561, "url": "https://github.com/llvm/llvm-project/pull/72561", "title": "[mlir][sparse] Use variable instead of inlining sparse encoding", "body": "Example:\r\n\r\n#CSR = #sparse_tensor.encoding<{\r\n  map = (d0, d1) -> (d0 : dense, d1 : compressed),\r\n}>\r\n\r\n// CHECK: #[[$CSR.*]] = #sparse_tensor.encoding<{ map = (d0, d1) -> (d0 : dense, d1 : compressed) }>\r\n// CHECK-LABEL: func private @sparse_csr(\r\n// CHECK-SAME: tensor<?x?xf32, **#[[$CSR]]**>)\r\nfunc.func private @sparse_csr(tensor<?x?xf32, #CSR>)", "feature_layers": ["parse", "ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/IR/SparseTensorDialect.cpp", "functions": ["getAlias"]}]}
{"pr_number": 72450, "url": "https://github.com/llvm/llvm-project/pull/72450", "title": "LoopVectorize: Set branch_weight for conditional branches", "body": "Consistently add `branch_weights` metadata in any condition branch created by `LoopVectorize.cpp`:\r\n- Will only add metadata if the original loop-latch branch had metadata assigned.\r\n- Most checks should rarely trigger so I am using a 127:1 ratio.\r\n- For the middle block we assume an equal distribution of modulo results.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/IR/ProfDataUtils.cpp", "functions": ["MDB", "setBranchWeights"]}, {"filename": "llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp", "functions": ["MDB"]}, {"filename": "llvm/lib/Transforms/Instrumentation/IndirectCallPromotion.cpp", "functions": ["MDB"]}, {"filename": "llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp", "functions": ["MDB"]}, {"filename": "llvm/lib/Transforms/Utils/LoopPeel.cpp", "functions": ["MDB", "fixupBranchWeights"]}, {"filename": "llvm/lib/Transforms/Utils/LoopRotationUtils.cpp", "functions": ["MDB"]}, {"filename": "llvm/lib/Transforms/Vectorize/LoopVectorize.cpp", "functions": ["MDB"]}]}
{"pr_number": 72585, "url": "https://github.com/llvm/llvm-project/pull/72585", "title": "[mlir][sparse] implement direct IR alloc/empty/new for non-permutations", "body": "This change implements the correct *level* sizes set up for the direct IR codegen fields in the sparse storage scheme. This brings libgen and codegen together again.\r\n\r\nThis is step 3 out of 3 to make sparse_tensor.new work for BSR", "feature_layers": ["parse", "codegen", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/Transforms/SparseTensorCodegen.cpp", "functions": ["constantIndex"]}]}
{"pr_number": 70567, "url": "https://github.com/llvm/llvm-project/pull/70567", "title": "[Clang] Warn against unused parameters in C++ coroutines with `-Wunused-parameters`", "body": "This PR is proposing a fix for https://github.com/llvm/llvm-project/issues/65971.\r\n\r\nPreviously, given a coroutine like this\r\n```\r\ntask foo(int a) {\r\n  co_return;\r\n}\r\n```\r\nParameter `a` is never used. However, because C++ coroutines move constructs the variable to a heap allocated coroutine activation frame, we considered all parameters referenced. When diagnosing unused parameters, we cannot distinguish if the variable reference was due to coroutine parameter moves. \r\n\r\n\r\nCompiler Explorer shows that GCC warns against this case correctly, but clang does not: https://godbolt.org/z/Wo7dfqeaf\r\n\r\nThis change adds a flag `LastReferenceInCoroutineParamMoves` to `Decl`s. All other references to the `Decl` will clear the flag, so we are still able to tell if the reference is from the user defined coroutine body. ", "feature_layers": ["ast"], "feature_directives": ["task", "for", "allocate"], "files_changed": [{"filename": "clang/test/SemaCXX/warn-unused-parameters-coroutine.cpp", "functions": ["final_suspend", "unhandled_exception", "foo", "bar", "await_suspend", "initial_suspend", "return_void", "await_ready", "get_return_object", "await_resume"]}, {"filename": "clang/lib/Sema/SemaDecl.cpp", "functions": ["VisitStmt", "SRV"]}]}
{"pr_number": 71269, "url": "https://github.com/llvm/llvm-project/pull/71269", "title": "[mlir][affine][nfc] cleanup deprecated T.cast style functions", "body": "detail see the docment: https://mlir.llvm.org/deprecation/\r\n\r\nNot all changes are made manually, most of them are made through a clang tool I wrote https://github.com/lipracer/cpp-refactor.", "feature_layers": ["ir", "ast"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/CAPI/IR/AffineExpr.cpp", "functions": ["unwrap", "wrap"]}, {"filename": "mlir/lib/Dialect/Affine/Analysis/LoopAnalysis.cpp", "functions": ["if"]}, {"filename": "mlir/lib/Dialect/Affine/IR/AffineOps.cpp", "functions": ["if"]}, {"filename": "mlir/lib/Dialect/SparseTensor/IR/Detail/DimLvlMap.cpp", "functions": ["Var", "SymVar"]}, {"filename": "mlir/lib/Dialect/SparseTensor/Transforms/Sparsification.cpp", "functions": ["getDimExpr"]}, {"filename": "mlir/lib/IR/AffineMap.cpp", "functions": ["hasPoison", "getResult", "getNumResults"]}]}
{"pr_number": 69909, "url": "https://github.com/llvm/llvm-project/pull/69909", "title": "[SCEV][LV] Invalidate LCSSA exit phis more thoroughly", "body": "This an alternative to #69886. The basic problem is that SCEV can look through trivial LCSSA phis. When the phi node later becomes non-trivial, we do invalidate it, but this doesn't catch uses that are not covered by the IR use-def walk, such as those in BECounts.\r\n\r\nFix this by adding a special invalidation method for LCSSA phis, which will also invalidate all the SCEVUnknowns/SCEVAddRecExprs used by the LCSSA phi node and defined in the loop.\r\n\r\nWe should probably also use this invalidation method in other places that add predecessors to exit blocks, such as loop unrolling and loop peeling.\r\n\r\nFixes #69097.\r\nFixes #66616.\r\nFixes #63970.\r\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Analysis/ScalarEvolution.cpp", "functions": ["isDone", "follow", "C"]}]}
{"pr_number": 71900, "url": "https://github.com/llvm/llvm-project/pull/71900", "title": "[mlir][SCF] Do not peel already peeled loops", "body": "Loop peeling is not beneficial if the step size already divides \"ub - lb\". There are currently some simple checks to prevent peeling in such cases when lb, ub, step are constants. This commit adds support for IR that is the result of loop peeling in the general case; i.e., lb, ub, step do not necessarily have to be constants.\r\n\r\nThis change adds a new affine_map simplification rule for semi-affine maps that appear during loop peeling and are guaranteed to evaluate to a constant zero. Affine maps such as:\r\n```\r\n(1) affine_map<()[ub, step] -> ((ub - ub mod step) mod step)\r\n(2) affine_map<()[ub, lb, step] -> ((ub - (ub - lb) mod step - lb) mod step)\r\n(3)                                         ^ may contain additional summands\r\n```\r\nOther affine maps with modulo expressions are not supported by the new simplification rule.\r\n\r\nThis fixes #71469.\r\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/SCF/Transforms/LoopSpecialization.cpp", "functions": ["failure"]}, {"filename": "mlir/lib/IR/AffineExpr.cpp", "functions": ["getAffineBinaryOpExpr", "isNegatedAffineExpr", "simplifySemiAffine", "getAffineConstantExpr", "getSummandExprs"]}]}
{"pr_number": 72494, "url": "https://github.com/llvm/llvm-project/pull/72494", "title": "[mlir][emitc] Rename `call` op to `call_opaque`", "body": "This renames the `emitc.call` op to `emitc.call_opaque` as the existing call op does not refer to the callee by symbol. The rename allows to introduce a new call op alongside with a future `emitc.func` op to model and facilitate functions and function calls.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Target/Cpp/TranslateToCpp.cpp", "functions": ["printOperation"]}]}
{"pr_number": 72634, "url": "https://github.com/llvm/llvm-project/pull/72634", "title": "[lldb] enable wasm source debugging", "body": "Rebase https://reviews.llvm.org/D78978 on latest code base, with less modification to LLDB core part:\r\n\r\nI treat wasm locals, globals and operand stack values as virtual registers, and implement a wasmRegisterContext to handle this. \r\n\r\n2 high bits in the reg_num are used as a tag to distinguish wasm values", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "lldb/source/Plugins/Process/wasm/ProcessWasm.cpp", "functions": ["DataBufferHeap", "wasm_addr", "ProcessGDBRemote", "g_name"]}, {"filename": "lldb/source/Plugins/Process/wasm/ThreadWasm.cpp", "functions": ["process_sp"]}, {"filename": "lldb/source/Plugins/Process/wasm/wasmRegisterContext.cpp", "functions": ["WasmVirtualRegisterInfo", "reg_data"]}]}
{"pr_number": 72544, "url": "https://github.com/llvm/llvm-project/pull/72544", "title": "[Offloading][NFC] Refactor handling of offloading entries", "body": "Summary:\nThis patch is a simple refactoring of code out of the linker wrapper\ninto a common location. The main motivation behind this change is to\nmake it easier to change the handling in the future to accept a triple\nto be used to emit entries that function on that target.\n", "feature_layers": [], "feature_directives": ["target"], "files_changed": [{"filename": "clang/tools/clang-linker-wrapper/OffloadWrapper.cpp", "functions": ["GlobalVariable"]}, {"filename": "llvm/lib/Frontend/Offloading/Utility.cpp", "functions": ["GlobalVariable"]}]}
{"pr_number": 72540, "url": "https://github.com/llvm/llvm-project/pull/72540", "title": "[RISCV] Remove custom instruction selection for VFCVT_RM and friends", "body": "We already have the pseudo's for lowering these as MI nodes with rounding mode operands, and the generic FRM insertion pass.  Doing the insertion later in the backend allows SSA level passes to avoid reasoning about physical register copies, and happens to produce better code in practice.  The later is mostly an accident of our insertion order; we happen to place the frm write after the vsetvli, and it's very common for a register to be killed at the vsetvli.  End result is that we get slightly better scalar register allocation.\r\n\r\nI'm a bit unclear on the history here.  I was surprised to find this code in ISEL lowering at all, but am also surprised once I found it that all the patterns and pseudos seem to already exist.  My best guess is that maybe we didn't do all the possible cleanup after introducing the HasRoundMode mechanism?", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVISelLowering.cpp", "functions": ["emitVFCVT_RM"]}]}
{"pr_number": 70234, "url": "https://github.com/llvm/llvm-project/pull/70234", "title": "[OpenACC] Initial commits to support OpenACC", "body": "Initial commits to support OpenACC.  This patchset:\r\n\r\nadds a clang-command line argument '-fopenacc', and starts\r\n to define _OPENACC, albeit to '1' instead of the standardized\r\nvalue (since we don't properly implement OpenACC yet).\r\n\r\nThe OpenACC spec defines `_OPENACC` to be equal to the latest standard\r\nimplemented. However, since we're not done implementing any standard,\r\nwe've defined this by default to be `1`. As it is useful to run our\r\ncompiler against existing OpenACC workloads, we're providing a\r\ntemporary override flag to change the `_OPENACC` value to be any\r\nentirely digit value, permitting testing against any existing OpenACC\r\nproject.\r\n\r\nExactly like the OpenMP parser, the OpenACC pragma parser needs to\r\nconsume and reprocess the tokens. This patch sets up the infrastructure\r\nto do so by refactoring the OpenMP version of this into a more general\r\nversion that works for OpenACC as well.\r\n\r\nAdditionally, this adds a few diagnostics and token kinds to get us\r\nstarted.", "feature_layers": ["parse", "ir", "ast", "parser"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Parse/ParseDeclCXX.cpp", "functions": ["ParseOpenACCDirective"]}, {"filename": "clang/lib/Parse/ParseOpenACC.cpp", "functions": ["StmtEmpty"]}, {"filename": "clang/lib/Parse/ParsePragma.cpp", "functions": ["if"]}, {"filename": "clang/lib/Parse/ParseStmt.cpp", "functions": ["ParseOpenACCDirectiveStmt"]}, {"filename": "clang/lib/Parse/Parser.cpp", "functions": ["ParseOpenACCDirective"]}, {"filename": "clang/test/ParserOpenACC/unimplemented.c", "functions": ["func"]}, {"filename": "clang/test/ParserOpenACC/unimplemented.cpp", "functions": ["func"]}]}
{"pr_number": 71945, "url": "https://github.com/llvm/llvm-project/pull/71945", "title": "[coroutines] Introduce [[clang::coro_return_type]] and [[clang::coro_wrapper]]", "body": "First step in the implementation of [RFC](https://discourse.llvm.org/t/rfc-lifetime-bound-check-for-parameters-of-coroutines/74253) ([final approved doc](https://docs.google.com/document/d/1hkfXHuvIW1Yv5LI-EIkpWzdWgIoUlzO6Zv_KJpknQzM/edit)).\r\n\r\nThis introduces the concepts of a **coroutine return type** and explicit **coroutine wrapper** functions. ", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/SemaCXX/coro-return-type-and-wrapper.cpp", "functions": ["coor_containing_lambda", "foo", "coro_containing_lambda", "return_value", "foo_coro", "wrapper_lambda"]}, {"filename": "clang/lib/Sema/SemaDecl.cpp", "functions": ["isGetReturnObject"]}]}
{"pr_number": 72147, "url": "https://github.com/llvm/llvm-project/pull/72147", "title": "[DebugInfo] Make DIArgList inherit from Metadata and always unique", "body": "This patch changes the `DIArgList` class's inheritance from `MDNode` to `Metadata, ReplaceableMetadataImpl`, and ensures that it is always unique, i.e. a distinct DIArgList should never be produced.\r\n\r\nCurrently a distinct DIArgList will never be emitted to bitcode or IR, but they could appear in-memory if a DIArgList had one of its arguments RAUWd such that the contents of the DIArgList were identical to an already-existing DIArgList. Adding support for reuniquing DIArgLists in these cases caused some significant performance regressions (~3%); these are resolved by changing DIArgList to no longer inherit from MDNode.\r\n\r\nConceptually, having DIArgList inherit from MDNode does not make a lot of sense - part of the initial reason for the relationship was to make use of MDNode's RAUW support, but in the end the number of exceptions and special cases for DIArgLists makes it probably not worth the shared logic. Outside of the RAUW logic, DIArgLists don't make use of any features of MDNodes, so it makes sense to simply disentangle them.\r\n\r\nThis should not result in any changes to IR or bitcode; the parsing and printing format for DIArgList is unchanged, and the order in which it appears should also be identical. As a minor note, this patch also fixes a gap in the verifier, where the ValueAsMetadata operands to a DIArgList would not be visited.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/AsmParser/LLParser.cpp", "functions": ["parseDIArgList"]}, {"filename": "llvm/lib/Bitcode/Writer/BitcodeWriter.cpp", "functions": ["writeDIArgList"]}, {"filename": "llvm/lib/IR/Verifier.cpp", "functions": ["visitDIArgList"]}]}
{"pr_number": 72350, "url": "https://github.com/llvm/llvm-project/pull/72350", "title": "Modify llvm-gsymutil lookups to handle overlapping ranges correctly.", "body": "llvm-gsymutil allows address ranges to overlap. There was a bug where if we had debug info for a function with a range like [0x100-0x200) and a symbol at the same start address yet with a larger range like [0x100-0x300), we would randomly get either only information from the first or second entry. This could cause lookups to fail due to the way the binary search worked.\r\n\r\nThis patch makes sure that when lookups happen we find the first address table entry that can match an address, and also ensures that we always select the first FunctionInfo that could match. FunctionInfo entries are sorted such that the most debug info rich entries come first. And if we have two ranges that have the same start address, the smaller range comes first and the larger one comes next. This patch also adds the ability to iterate over all function infos with the same start address to always find a range that contains the address.\r\n\r\nAdded a unit test to test this functionality that failed prior to this fix and now succeeds.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/DebugInfo/GSYM/GsymReader.cpp", "functions": ["Data", "DataExtractor"]}, {"filename": "llvm/unittests/DebugInfo/GSYM/GSYMTest.cpp", "functions": ["DumpStrm"]}]}
{"pr_number": 72571, "url": "https://github.com/llvm/llvm-project/pull/72571", "title": "[mlir][sparse] Clean up parser", "body": "Remove unused functions in parser.", "feature_layers": ["parse", "ir", "parser"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/IR/Detail/DimLvlMap.cpp", "functions": ["getRHS", "Var", "getLHS", "DimLvlExpr", "SymVar", "os", "castDimLvlVar", "matchNeg", "castSymVar", "castConstantValue"]}, {"filename": "mlir/lib/Dialect/SparseTensor/IR/Detail/Var.cpp", "functions": ["occursIn", "contains"]}]}
{"pr_number": 72518, "url": "https://github.com/llvm/llvm-project/pull/72518", "title": "[lld][COFF][NFC] Factor out exception table sorting.", "body": "This is a preparation for ARM64EC support, which needs to sort both ARM and x86_64 tables separately.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "lld/COFF/Writer.cpp", "functions": ["sortExceptionTables", "sortExceptionTable", "timeScope"]}]}
{"pr_number": 72661, "url": "https://github.com/llvm/llvm-project/pull/72661", "title": "[OpenACC] Implement initial parsing for `parallel` construct", "body": "As the first real parsing effort for the OpenACC implementation effort, this implements the parsing for first construct/directive name. This does not do any semantic analysis, nor any of the clauses.  Those will come in a future patch.\r\n\r\nFor the time being, we warn when we hit a point that we don't implement the parsing for either of these situations.", "feature_layers": ["sema", "ir"], "feature_directives": ["parallel", "for"], "files_changed": [{"filename": "clang/lib/Parse/ParseDeclCXX.cpp", "functions": ["ParseOpenACCDirective", "ParseOpenACCDirectiveDecl"]}, {"filename": "clang/lib/Parse/ParseOpenACC.cpp", "functions": ["GetOpenACCDirectiveKind", "T", "ParseOpenACCAtomicDirective"]}, {"filename": "clang/lib/Parse/Parser.cpp", "functions": ["ParseOpenACCDirective", "ParseOpenACCDirectiveDecl"]}, {"filename": "clang/test/ParserOpenACC/parse-constructs.c", "functions": ["routine_func", "func2"]}]}
{"pr_number": 72689, "url": "https://github.com/llvm/llvm-project/pull/72689", "title": "[NFC][SHT_LLVM_BB_ADDR_MAP] Define and use constructor and accessors for BBAddrMap fields.", "body": "The fields are still kept as public for now since our tooling accesses them. Will change them to private visibility in a later patch.\r\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/unittests/Object/ELFObjectFileTest.cpp", "functions": ["E2", "E3", "E4", "E1"]}]}
{"pr_number": 72656, "url": "https://github.com/llvm/llvm-project/pull/72656", "title": "[readtapi] Add Merge functionality", "body": "Merge allows a user to merge different files (tbds for now or dylibs in the future) to emit out a single tbd with all input contents. This does require that all inputs represent the same library.", "feature_layers": ["ir"], "feature_directives": ["for", "single"], "files_changed": [{"filename": "llvm/tools/llvm-readtapi/llvm-readtapi.cpp", "functions": ["handleCompareAction", "reportError", "handleMergeAction", "OS", "handleWriteAction", "ExitOnErr"]}]}
{"pr_number": 72612, "url": "https://github.com/llvm/llvm-project/pull/72612", "title": "[test][msan] Precommit tests for vararg improvements", "body": "", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "compiler-rt/test/msan/vararg_shadow.cpp", "functions": ["__attribute__", "main"]}]}
{"pr_number": 66126, "url": "https://github.com/llvm/llvm-project/pull/66126", "title": "[sanitizer_symbolizer] Symbolizer Markup for linux", "body": "This change adds support for sanitizer symbolizer markup for linux.\r\nFor more informationa about symbolzier markup please visit https://llvm.org/docs/SymbolizerMarkupFormat.html", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "compiler-rt/lib/hwasan/hwasan_report.cpp", "functions": ["PrintStackAllocationsMarkup"]}, {"filename": "compiler-rt/lib/sanitizer_common/sanitizer_stacktrace_libcdep.cpp", "functions": ["text_printer", "output_", "markup_printer", "StackTraceTextPrinter"]}, {"filename": "compiler-rt/lib/sanitizer_common/sanitizer_stacktrace_printer.cpp", "functions": ["RenderNeedsSymbolization"]}, {"filename": "compiler-rt/lib/sanitizer_common/sanitizer_symbolizer_markup.cpp", "functions": ["RenderFrameMarkup"]}, {"filename": "compiler-rt/test/asan/TestCases/Linux/use-after-free-symbolizer-markup.cpp", "functions": ["main"]}]}
{"pr_number": 69364, "url": "https://github.com/llvm/llvm-project/pull/69364", "title": "[ValueTracking] Expand cmpExcludesZero to optionally work with non-constant RHS", "body": "- [ValueTracking] Add tests for proving phi-nonzero based on ICmp without constants; NFC\n- [ValueTracking] Expand `cmpExcludesZero` to optionally work with non-constant RHS\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Analysis/ValueTracking.cpp", "functions": ["cmpExcludesZero"]}]}
{"pr_number": 70977, "url": "https://github.com/llvm/llvm-project/pull/70977", "title": "[SimplifyCFG] Add optimization for switches of powers of two", "body": "Optimization reduces range for switches which cases are positive powers of two by replacing each case with count_trailing_zero(case).\r\n\r\nResolves #70756", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Utils/SimplifyCFG.cpp", "functions": ["requestResimplify"]}]}
{"pr_number": 71021, "url": "https://github.com/llvm/llvm-project/pull/71021", "title": "[CodeGen][DebugInfo] Add missing debug info for jump table BB", "body": "visitJumpTable is called on FinishBasicBlock. At that time, getCurSDLoc\r\nwill always return SDLoc without DebugLoc since CurInst was set to\r\nnullptr after visiting each instruction.\r\nThis patch passes SDLoc to buildJumpTable when visiting SwitchInst so\r\nthat visitJumpTable can use it later.", "feature_layers": ["codegen"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/CodeGen/SwitchLoweringUtils.cpp", "functions": ["JT"]}]}
{"pr_number": 68519, "url": "https://github.com/llvm/llvm-project/pull/68519", "title": "[mlir][affine] remove divide zero check when simplifer affineMap (#64622)", "body": "When performing constant folding on the affineApplyOp, there is a division of 0 in the affine map.\r\n[related issue](https://github.com/llvm/llvm-project/issues/64622)", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Analysis/FlatLinearValueConstraints.cpp", "functions": ["failure"]}, {"filename": "mlir/lib/Dialect/Affine/IR/AffineOps.cpp", "functions": ["flattener"]}, {"filename": "mlir/lib/IR/AffineExpr.cpp", "functions": ["failure", "success", "visitDivExpr"]}, {"filename": "mlir/lib/IR/AffineMap.cpp", "functions": ["floorDiv", "ceilDiv", "mod"]}]}
{"pr_number": 71987, "url": "https://github.com/llvm/llvm-project/pull/71987", "title": "[RISCV][GISel] Instruction selection for G_JUMP_TABLE and G_BRJT.", "body": "", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp", "functions": ["selectJumpTable"]}]}
{"pr_number": 71952, "url": "https://github.com/llvm/llvm-project/pull/71952", "title": "[DebugInfo][RemoveDIs] Support finding DPValues as well as dbg.values in findDbgValues", "body": "The first commit here extends findDbgValues and friends to optionally fill out a vector of DPValue pointers, containing DPValues that refer to the sought Value. This will allow us to incrementally add instrumentation to other optimisation passes one-at-a-time, while un-instrumented passes will not (yet) update DPValues.\r\n\r\nHowever, we're not 100% there yet -- observe the DIArgList added in the unit test. This currently isn't discoverable by findDbgIntrinsincs (so the test fails today). I believe the reason why is that, as DIArgLists aren't Temporary by default, they don't have a use-list / UseMap maintained for them, therefore we can't lookup users backwards in the same way that we can for LocalAsMetadatas.\r\n\r\nHacking all DIArgLists to be temporary (see the second commit in this PR) fixes this and the test passes. CC @SLTozer , as you're polishing the Metadata tracking situation, is this something that'll be addressed by that work?", "feature_layers": ["sema", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/IR/DebugInfo.cpp", "functions": ["findDbgIntrinsics"]}]}
{"pr_number": 72486, "url": "https://github.com/llvm/llvm-project/pull/72486", "title": "[mlir][emitc] Rename call op to call_opaque", "body": "The existing emit.call op doesn't refer to an MLIR symbol/value as the callee.\nThis commit renames this op in order to avoid confusion with the MLIR\ncaller/callee modeling and facilitate future support of EmitC functions and\nfunction calls.\n", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Target/Cpp/TranslateToCpp.cpp", "functions": ["printOperation"]}]}
{"pr_number": 72750, "url": "https://github.com/llvm/llvm-project/pull/72750", "title": "[clang] Turn invented Exprs' source locations in __builtin_dump_struct to empty", "body": "This reflects the comment in https://github.com/llvm/llvm-project/pull/71366#issuecomment-1817271492.\r\n\r\nAs that PR suggests, the invented CallExpr's source location previously pointed to the beginning of the `__builtin_dump_struct`. These spurious AST nodes confused clangd while displaying parameter inlay hints.\r\n\r\nThis patch takes another approach to address the same issue, by turning the location for each _argument_ within an invented call to printf to empty, (maybe) at the risk of breaking the invariant for CallExpr -- The source location for an argument could be invalid from now on.", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang-tools-extra/clangd/unittests/InlayHintTests.cpp", "functions": ["printf", "GetX", "main", "PutX"]}, {"filename": "clang/lib/Sema/SemaChecking.cpp", "functions": ["S"]}]}
{"pr_number": 71729, "url": "https://github.com/llvm/llvm-project/pull/71729", "title": "Recommit \"[DAGCombiner] Transform (icmp eq/ne (and X,C0),(shift X,C1)) to use rotate or to getter constants.\" (2nd Try)", "body": "- [X86] Add more tests for transform `(icmp eq/ne (and X,C0),(shift X,C1))`; PR71598\n- Recommit \"[DAGCombiner] Transform `(icmp eq/ne (and X,C0),(shift X,C1))` to use rotate or to getter constants.\" (2nd Try)\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp", "functions": ["SDValue", "DL"]}]}
{"pr_number": 71309, "url": "https://github.com/llvm/llvm-project/pull/71309", "title": "[InstCombine] Add transforms for `icmp uPred (trunc x),(truncOrZext(y))` -> `icmp uPred x,y`", "body": "- [InstCombine] Add tests for transforming `(icmp eq/ne trunc(x), truncOrZext(y))`; NFC\n- [InstCombine] Add transforms for `(icmp uPred (trunc x),(truncOrZext(y)))`->`(icmp uPred x,y)`\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp", "functions": ["if", "ICmpInst"]}]}
{"pr_number": 72547, "url": "https://github.com/llvm/llvm-project/pull/72547", "title": "[mlir][affine] implement `promoteIfSingleIteration` for `AffineForOp`", "body": "Recently someone on discord asked if `AffineForOp` could be refactored to just implement the `promoteIfSingleIteration` interface method on `LoopLikeOpInterface` (rather than have a dangling method). Went more smoothly than I thought so here it is.\r\n\r\n", "feature_layers": ["ir"], "feature_directives": ["for", "single"], "files_changed": [{"filename": "mlir/lib/Dialect/Affine/IR/AffineOps.cpp", "functions": ["lbSplatValueMap", "ubValueMap"]}, {"filename": "mlir/lib/Dialect/Affine/Transforms/AffineDataCopyGeneration.cpp", "functions": ["rewriter"]}, {"filename": "mlir/lib/Dialect/Affine/Utils/LoopFusionUtils.cpp", "functions": ["rewriter"]}, {"filename": "mlir/lib/Dialect/Affine/Utils/LoopUtils.cpp", "functions": ["success", "topBuilder", "promoteIfSingleIteration", "failure", "builder", "replaceIterArgsAndYieldResults", "rewriter"]}, {"filename": "mlir/lib/Dialect/Affine/Utils/Utils.cpp", "functions": ["rewriter"]}, {"filename": "mlir/test/lib/Dialect/Affine/TestAffineDataCopy.cpp", "functions": ["rewriter"]}, {"filename": "mlir/lib/Dialect/Affine/Analysis/LoopAnalysis.cpp", "functions": ["lbSplatValueMap", "ubValueMap"]}]}
{"pr_number": 71769, "url": "https://github.com/llvm/llvm-project/pull/71769", "title": "Add new API in SBTarget for loading core from SBFile", "body": "Add a new API in SBTarget to Load Core from a SBFile.\r\nThis will enable a target to load core from a file descriptor.\r\nSo that in coredumper, we don't need to write core file to disk, instead we can pass the input file descriptor to lldb directly.\r\n\r\n\r\nTest:\r\n```\r\n(lldb) script\r\nPython Interactive Interpreter. To exit, type 'quit()', 'exit()' or Ctrl-D.\r\n>>> file_object = open(\"/home/hyubo/210hda79ms32sr0h\", \"r\")\r\n>>> fd=file_object.fileno()\r\n>>> file = lldb.SBFile(fd,'r', True)\r\n>>> error = lldb.SBError()\r\n>>> target = lldb.debugger.CreateTarget(None)\r\n>>> target.LoadCore(file,error)\r\nSBProcess: pid = 56415, state = stopped, threads = 1\r\n```\r\n", "feature_layers": ["ir"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "lldb/source/API/SBTarget.cpp", "functions": ["target_sp"]}]}
{"pr_number": 65735, "url": "https://github.com/llvm/llvm-project/pull/65735", "title": "[AMDGPU][SIInsertWaitcnts] Do not add s_waitcnt when the counters are known to be 0 already", "body": "Currently a WIP, I've only updated a single test to depict the change (there are ~50 tests that need update).\r\n\r\nDifferential Revision: https://reviews.llvm.org/D156679", "feature_layers": [], "feature_directives": ["single"], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp", "functions": ["updateWaitcntIfSoft", "dbgs", "setNonKernelFunctionInitialState"]}]}
{"pr_number": 72142, "url": "https://github.com/llvm/llvm-project/pull/72142", "title": "[mlir][vector] Extend TransferReadDropUnitDimsPattern to support partially-static memrefs", "body": "This patch extends TransferReadDropUnitDimsPattern to support dropping\r\nunit dims from partially-static memrefs, for example:\r\n```\r\n%v = vector.transfer_read %base[%c0, %c0], %pad {in_bounds = [true, true]} :\r\n  memref<?x1xi8, strided<[?, ?], offset: ?>>, vector<[16]x1xi8>\r\n```\r\nIs rewritten as:\r\n```\r\n%dim0 = memref.dim %base, %c0 : memref<?x1xi8, strided<[?, ?], offset: ?>>\r\n%subview = memref.subview %base[0, 0] [%dim0, 1] [1, 1] :\r\n  memref<?x1xi8, strided<[?, ?], offset: ?>> to memref<?xi8, #map1>\r\n%v = vector.transfer_read %subview[%c0], %pad {in_bounds = [true]}\r\n  : memref<?xi8, #map1>, vector<[16]xi8>\r\n```\r\nScalable vectors are now also supported, the scalable dims were being\r\ndropped when creating the rank-reduced vector type. The xfer op can also\r\nhave a mask of type 'vector.create_mask', which gets rewritten as long\r\nas the mask of the unit dim is a constant of 1.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Vector/Transforms/VectorTransferOpTransforms.cpp", "functions": ["getReducedShape", "failure", "trimUnitDims", "trimNonScalableUnitDims"]}]}
{"pr_number": 72811, "url": "https://github.com/llvm/llvm-project/pull/72811", "title": "[NewPM] Remove LoopSinkLegacy Pass", "body": "This pass isn't used anywhere and thus has no test coverage. For these reasons, remove it.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Scalar/LoopSink.cpp", "functions": ["runOnLoop", "getAnalysisUsage"]}]}
{"pr_number": 72812, "url": "https://github.com/llvm/llvm-project/pull/72812", "title": "[NewPM] Remove LoopInstSimplifyLegacyPass", "body": "This pass isn't used anywhere and thus has no test coverage. Remove it for these reasons.\r\n\r\nFor whatever reason, there was no entry in `llvm/include/llvm/LinkAllPasses.h` to remove.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp", "functions": ["simplifyLoopInst", "getAnalysisUsage", "runOnLoop", "MSSAU", "LoopInstSimplifyLegacyPass"]}]}
{"pr_number": 72509, "url": "https://github.com/llvm/llvm-project/pull/72509", "title": "[AMDGPU] Emit backend_stack_size PAL metadata", "body": "For chain functions, PAL uses a `backend_stack_size` metadata item, which at the moment has the same meaning as `stack_frame_size_in_bytes`. We emit both for now in order to simplify coordination with PAL.\r\n\r\nThe new item must be emitted in the `shader_functions` section, just as the metadata for other module entry functions. For simplicity, we mark chain functions as module entry functions and emit the same metadata for all of them.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.cpp", "functions": ["isEntryFunctionCC"]}]}
{"pr_number": 72816, "url": "https://github.com/llvm/llvm-project/pull/72816", "title": "[NewPM] Remove UnifyFunctionExitNodesLegacyPass", "body": "UnifyFunctionExitNodesLegacyPass isn't used anywhere in upstream and thus isn't tested at all. For these reasons, remove it.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Utils/UnifyFunctionExitNodes.cpp", "functions": ["FunctionPass", "UnifyFunctionExitNodesLegacyPass"]}]}
{"pr_number": 71276, "url": "https://github.com/llvm/llvm-project/pull/71276", "title": "[LoongArch][MC] Refine MCInstrAnalysis based on registers used", "body": "MCInstrAnalysis can return properties of instructions (e.g., isCall(), isBranch(),...) based on the informations that MCInstrDesc can get from *InstrInfo*.td files. These infos are based on opcodes only, but JIRL can have different properties based on different registers used.\r\n\r\nSo this patch refines several MCInstrAnalysis methods: isTerminator, isCall,isReturn,isBranch,isUnconditionalBranch and isIndirectBranch.\r\n\r\nThis patch also allows BOLT which will be supported on LoongArch later to get right instruction infos.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/LoongArch/MCTargetDesc/LoongArchMCTargetDesc.cpp", "functions": ["isBranch", "isUnconditionalBranch", "isReturn", "isIndirectBranch", "isCall", "isTerminator"]}, {"filename": "llvm/unittests/Target/LoongArch/MCInstrAnalysisTest.cpp", "functions": ["jirl", "MCInstBuilder", "bl", "SetUpTestSuite", "beq"]}]}
{"pr_number": 71903, "url": "https://github.com/llvm/llvm-project/pull/71903", "title": "[LoongArch][NFC] Pre-commit MCInstrAnalysis tests for instruction 'b'", "body": "The tests for 'b' which commented with FIXME are incorrect, the following patch will fix it.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/unittests/Target/LoongArch/MCInstrAnalysisTest.cpp", "functions": ["b"]}]}
{"pr_number": 68565, "url": "https://github.com/llvm/llvm-project/pull/68565", "title": "[AArch64][SME] Remove immediate argument restriction for svldr and svstr", "body": "The svldr_vnum and svstr_vnum builtins always modify the base register and tile slice and provide immediate offsets of zero, even when the offset provided to the builtin is an immediate. This patch optimises the output of the builtins when the offset is an immediate, to pass it directly to the instruction and to not need the base register and tile slice updates.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CodeGen/aarch64-sme-intrinsics/acle_sme_ldr.c", "functions": ["test_svldr_vnum_za_2", "test_svldr_vnum_za_var"]}, {"filename": "clang/test/CodeGen/aarch64-sme-intrinsics/acle_sme_str.c", "functions": ["test_svstr_vnum_za_2"]}, {"filename": "llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp", "functions": ["SelectSMELdrStrZA", "DL"]}, {"filename": "llvm/lib/Target/AArch64/AArch64ISelLowering.cpp", "functions": ["LowerSMELdrStr", "DL"]}]}
{"pr_number": 72594, "url": "https://github.com/llvm/llvm-project/pull/72594", "title": "[mlir][vector] Modernize `vector.transpose` op", "body": "* Declare arguments/results with `let` statements.\r\n* Rename `transp` to `permutation`.\r\n* Change type of `transp` from `I64ArrayAttr` to `DenseI64ArrayAttr` (provides direct access to `ArrayRef<int64_t>` instead of `ArrayAttr`).", "feature_layers": ["ir"], "feature_directives": ["declare"], "files_changed": [{"filename": "mlir/lib/Dialect/Vector/IR/VectorOps.cpp", "functions": ["emitOpError"]}]}
{"pr_number": 72389, "url": "https://github.com/llvm/llvm-project/pull/72389", "title": "[APINotes] Upstream APINotesManager", "body": "This upstreams more of the Clang API Notes functionality that is currently implemented in the Apple fork: https://github.com/apple/llvm-project/tree/next/clang/lib/APINotes", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/APINotes/APINotesManager.cpp", "functions": ["print", "Path", "First", "hasPrivateSubmodules", "SM", "OS", "APINotesPath"]}, {"filename": "clang/lib/Basic/SourceMgrAdapter.cpp", "functions": ["SourceLocation", "Range", "SourceRange", "SrcMgr"]}]}
{"pr_number": 72852, "url": "https://github.com/llvm/llvm-project/pull/72852", "title": "[mlir][ArmSME] Move vector.extract/insert lowerings to vector-to-arm-sme (NFC)", "body": "These were placed in LegalizeForLLVMExport.cpp, which is the wrong stage for these, as these lower to high-level ArmSME ops, not intrinsics.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Conversion/VectorToArmSME/VectorToArmSME.cpp", "functions": ["failure", "success"]}, {"filename": "mlir/lib/Dialect/ArmSME/Transforms/LegalizeForLLVMExport.cpp", "functions": ["failure", "success"]}]}
{"pr_number": 68118, "url": "https://github.com/llvm/llvm-project/pull/68118", "title": "[LV] Stability fix for outerloop vectorization", "body": "HCFG builder doesn't correctly handle cases when non-outermost loop is requested to be vectorized\r\n\r\n[Original] Differential Revision: https://reviews.llvm.org/D150700", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Vectorize/VPlanHCFGBuilder.cpp", "functions": ["doesContainLoop", "isNestedLoop"]}]}
{"pr_number": 72443, "url": "https://github.com/llvm/llvm-project/pull/72443", "title": "[InstrProf] Add pgo use block coverage test", "body": "Back in https://reviews.llvm.org/D124490 we added a block coverage mode that instruments a subset of basic blocks using single byte counters to get coverage for the whole function.\r\n\r\nThis commit adds a test to make sure that we correctly assign branch weights based on the coverage profile.\r\n\r\nI noticed this test was missing after seeing that we had no coverage on `PGOUseFunc::populateCoverage()`\r\nhttps://lab.llvm.org/coverage/coverage-reports/coverage/Users/buildslave/jenkins/workspace/coverage/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp.html#L1383", "feature_layers": [], "feature_directives": ["for", "single"], "files_changed": [{"filename": "llvm/lib/ProfileData/InstrProfReader.cpp", "functions": ["if"]}]}
{"pr_number": 71398, "url": "https://github.com/llvm/llvm-project/pull/71398", "title": "[C23] Complete support for WG14 N2508", "body": "In Clang 16, we implemented the ability to add a label at the end of a compound statement. These changes complete the implementation by allowing a label to be followed by a declaration in C.\r\n\r\nNote, this seems to have fixed an issue with some OpenMP stand-alone directives not being properly diagnosed as per:\r\nhttps://www.openmp.org/spec-html/5.1/openmpsu19.html#x34-330002.1.3\r\n(The same requirement exists in OpenMP 5.2 as well.)", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Parse/ParseStmt.cpp", "functions": ["DiagnoseLabelFollowedByDecl"]}, {"filename": "clang/test/C/C2x/n2508.c", "functions": ["test", "test_labels"]}]}
{"pr_number": 69010, "url": "https://github.com/llvm/llvm-project/pull/69010", "title": "[Clang] Add __builtin_vectorelements to get number of elements in vector", "body": "Adds a new `__builtin_vectorelements()` function which returns the number of elements for a given vector either at compile-time for fixed-sized vectors, e.g., created via `__attribute__((vector_size(N)))` or at runtime via a call to `@llvm.vscale.i32()` for scalable vectors, e.g., SVE or RISCV V.\r\n\r\nThe new builtin follows a similar path as `sizeof()`, as it essentially does the same thing but for the number of elements in vector instead of the number of bytes. This allows us to re-use a lot of the existing logic to handle types etc. \r\n\r\nA small side addition is `Type::isSizelessVectorType()`, which we need to distinguish between sizeless vectors (SVE, RISCV V) and sizeless types (WASM). \r\n\r\nThis is the [corresponding discussion](https://discourse.llvm.org/t/new-builtin-function-to-get-number-of-lanes-in-simd-vectors/73911). ", "feature_layers": ["runtime"], "feature_directives": ["for", "simd"], "files_changed": [{"filename": "clang/lib/AST/ExprConstant.cpp", "functions": ["Success"]}, {"filename": "clang/lib/AST/Type.cpp", "functions": ["isSVESizelessBuiltinType"]}, {"filename": "clang/lib/Parse/ParseExpr.cpp", "functions": ["if"]}, {"filename": "clang/lib/Sema/SemaExpr.cpp", "functions": ["CheckVectorElementsTraitOperandType"]}, {"filename": "clang/test/CodeGen/builtin_vectorelements.c", "functions": ["test_builtin_vectorelements_riscv32m2", "test_builtin_vectorelements_sve8", "test_builtin_vectorelements_sve16", "test_builtin_vectorelements_riscv8", "test_builtin_vectorelements_sve32", "test_builtin_vectorelements_riscv64"]}, {"filename": "clang/test/Sema/builtin_vectorelements.c", "functions": ["test_builtin_vectorelements", "__attribute__"]}, {"filename": "clang/test/SemaCXX/builtin_vectorelements.cpp", "functions": ["test_bad_constexpr", "consteval_elements", "__builtin_vectorelements"]}, {"filename": "clang/lib/Sema/SemaChecking.cpp", "functions": ["ExprError"]}, {"filename": "clang/test/Sema/convertvector.c", "functions": ["__builtin_convertvector"]}]}
{"pr_number": 72276, "url": "https://github.com/llvm/llvm-project/pull/72276", "title": "[DebugInfo][RemoveDIs] Add local-utility plumbing for DPValues", "body": "This patch re-implements a variety of debug-info maintenence functions to use DPValues instead of DbgValueInst's: supporting the \"new\" non-intrinsic representation of debug-info. As per [0], we need to have parallel implementations of various utilities for a time, and these are the most fundamental utilities used throughout the compiler.\r\n\r\nI've added --try-experimental-debuginfo-iterators to a variety of RUN lines: this is a flag that turns on \"new debug-info\" if it's built into LLVM, and not otherwise. This should ensure that we have the same behaviour for the same IR inputs, but using a different internal representation. For the most part these changes affect SROA/Mem2Reg promotion of dbg.declares into dbg.value intrinsics (now DPValues), we're leaving dbg.declares as instructions until later in the day. There's also some salvaging changes made.\r\n\r\nI believe the tests that I've added cover almost all the code being updated here. The only thing I'm not confident about is SimplifyCFG, which calls rewriteDebugUsers down a variety of code paths. Those changes can't immediately get full coverage as an additional patch is needed that updates handling of Unreachable instructions, will upload that shortly.\r\n\r\n[0] https://discourse.llvm.org/t/rfc-instruction-api-changes-needed-to-eliminate-debug-intrinsics-from-ir/68939/9", "feature_layers": ["ir"], "feature_directives": ["parallel", "for", "declare"], "files_changed": [{"filename": "llvm/lib/Transforms/Utils/Local.cpp", "functions": ["insertDbgValueOrDPValueAfter", "insertDbgValueOrDPValue", "rewriteDebugUsers"]}]}
{"pr_number": 71877, "url": "https://github.com/llvm/llvm-project/pull/71877", "title": "[Clang] Correct handling of negative and out-of-bounds indices", "body": "GCC returns 0 for a negative index on an array in a structure. It also\r\nreturns 0 for an array index that goes beyond the extent of the array.\r\nIn addition. a pointer to a struct field returns that field's size, not\r\nthe size of it plus the rest of the struct, unless it's the first field\r\nin the struct.\r\n\r\n  struct s {\r\n    int count;\r\n    char dummy;\r\n    int array[] __attribute((counted_by(count)));\r\n  };\r\n\r\n  struct s *p = malloc(...);\r\n\r\n  p->count = 10;\r\n\r\nA __bdos on the elements of p return:\r\n\r\n  __bdos(p, 0) == 30\r\n  __bdos(p->array, 0) == 10\r\n  __bdos(&p->array[0], 0) == 10\r\n  __bdos(&p->array[-1], 0) == 0\r\n  __bdos(&p->array[42], 0) == 0\r\n\r\nAlso perform some refactoring, putting the \"counted_by\" calculations in\r\ntheir own function.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/CodeGen/CGBuiltin.cpp", "functions": ["getDefaultBuiltinObjectSizeResult"]}]}
{"pr_number": 72606, "url": "https://github.com/llvm/llvm-project/pull/72606", "title": "[Libomptarget] Handle dynamic stack sizes for AMD COV5", "body": "Summary:\nOne of the changes in the AMD code-object version five was that kernels\nthat use an unknown amount of private stack memory now no longer default\nto 16 KBs. Instead it emits a flag that indicates the runtime must\nprovide a value. This patch checks if we must provide such a stack, and\nuses the existing handling of the stack environment variable to\nconfigure it.\n", "feature_layers": ["runtime", "ir"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "openmp/libomptarget/plugins-nextgen/amdgpu/src/rtl.cpp", "functions": ["usesDynamicStack"]}]}
{"pr_number": 72589, "url": "https://github.com/llvm/llvm-project/pull/72589", "title": "LoopVectorize: Add better heuristic for vectorized epilogue skip test", "body": "This is a follow-up to PR #72450 correcting the branch_weights used\r\nfor the test whether the vectorized epilogue loop should be skipped.\r\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Vectorize/LoopVectorize.cpp", "functions": ["MDB"]}]}
{"pr_number": 72178, "url": "https://github.com/llvm/llvm-project/pull/72178", "title": "[NFC] Simplify the tiling implementation using cloning.", "body": "The current implementation of tiling using `scf.for` is convoluted to make sure that the destination passing style of the untiled program is preserved. The addition of support to tile using `scf.forall` (adapted from the transform operation in Linalg) in https://github.com/llvm/llvm-project/pull/67083 used cloning of the tiled operations to better streamline the implementation. This PR adapts the other tiling methods to use a similar approach, making the transformations (and handling destination passing style semantics) more systematic.", "feature_layers": ["sema"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/SCF/Transforms/TileUsingInterface.cpp", "functions": ["tileStrides"]}]}
{"pr_number": 72740, "url": "https://github.com/llvm/llvm-project/pull/72740", "title": "[llvm-profdata] Fix binary ids with multiple raw profiles in a single\u2026", "body": "Save binary ids when iterating through `RawInstrProfReader`.\r\n\r\nFixes #72699.", "feature_layers": [], "feature_directives": ["single"], "files_changed": [{"filename": "compiler-rt/test/profile/Linux/binary-id.c", "functions": ["bar", "foo"]}, {"filename": "llvm/lib/ProfileData/InstrProfReader.cpp", "functions": ["error"]}]}
{"pr_number": 72692, "url": "https://github.com/llvm/llvm-project/pull/72692", "title": "[OpenACC] Implement compound construct parsing", "body": "This patch implements the compound construct parsing, which allows 'parallel loop', 'serial loop', and 'kernel loop' to act as their own constructs.\r\n", "feature_layers": ["ir"], "feature_directives": ["parallel"], "files_changed": [{"filename": "clang/lib/Parse/ParseOpenACC.cpp", "functions": ["isOpenACCDirectiveKind"]}]}
{"pr_number": 70743, "url": "https://github.com/llvm/llvm-project/pull/70743", "title": "[TargetInstrInfo] enable foldMemoryOperand for InlineAsm", "body": "[TargetInstrInfo] enable foldMemoryOperand for InlineAsm\r\n    \r\nfoldMemoryOperand looks at pairs of instructions (generally a load to\r\nvirt reg then use of the virtreg, or def of a virtreg then a store) and\r\nattempts to combine them.  This can reduce register pressure.\r\n    \r\nA prior commit added the ability to mark such a MachineOperand as\r\nfoldable. In terms of INLINEASM, this means that \"rm\" was used (rather\r\nthan just \"r\") to denote that the INLINEASM may use a memory operand\r\nrather than a register operand. This effectively undoes decisions made\r\nby the instruction selection framework.  Callers will be added in the\r\nregister allocation frameworks. This has been tested with all of the\r\nabove (which will come as follow up patches).\r\n    \r\nThanks to @topperc who suggested this at last years LLVM US Dev Meeting\r\nand @qcolombet who confirmed this was the right approach.\r\n\r\nLink: https://github.com/llvm/llvm-project/issues/20571", "feature_layers": ["ir", "ast"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "llvm/lib/CodeGen/TargetInstrInfo.cpp", "functions": ["F"]}]}
{"pr_number": 71230, "url": "https://github.com/llvm/llvm-project/pull/71230", "title": "[lldb][split-dwarf] implement GetSeparateDebugInfo for SymbolFileOnDemand", "body": "Easy change to get `image dump separate-debug-info` working when using `symbols.load-on-demand`. Also added a line of space in the default table output.\r\n\r\nUpdated the testing in response to comments.\r\n\r\nAdded tests\r\n```\r\nbin/lldb-dotest -p TestDumpDwo\r\n```\r\n\r\nIt's easy to verify this manually by running \r\n```\r\nlldb --one-line-before-file \"settings set symbols.load-on-demand true\" <some_target>\r\n(lldb) image dump separate-debug-info\r\n...\r\n```", "feature_layers": [], "feature_directives": ["for", "target"], "files_changed": [{"filename": "lldb/test/API/commands/target/dump-separate-debug-info/dwo/main.c", "functions": ["main"]}, {"filename": "lldb/test/API/commands/target/dump-separate-debug-info/dwo/main.cpp", "functions": ["main"]}]}
{"pr_number": 72696, "url": "https://github.com/llvm/llvm-project/pull/72696", "title": "[SelectionDAG] Add support to filter SelectionDAG dumps during ISel by function names", "body": "`-debug-only=isel-dump` is the new debug type for printing SelectionDAG after each ISel phase. This can be furthered filter by `-filter-print-funcs=<function names>`.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp", "functions": ["printMBBReference"]}]}
{"pr_number": 72846, "url": "https://github.com/llvm/llvm-project/pull/72846", "title": "[NFC][SROA] Remove implementation details from SROA header", "body": "This moves the SROA implementation from SROAPass into a separate SROA class that is defined in the cpp file, and reduces the SROAPass class to a thin NewPM wrapper. This allows to remove all implementation details from the SROA header, and the SROALegacyPass can wrap the SROA class instead of the NewPM SROAPass.\r\n\r\nThe trigger for this change is a GCC warning about visibility of implementation details in the SROA header after D138238. Credits to Nikita Popov for suggesting this reorganization.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Scalar/SROA.cpp", "functions": ["FunctionPass", "PreserveCFG", "deleteDeadInstructions", "intptr_t", "areNoneSpeculatable", "areAnySpeculatable", "clobberUse", "DTU", "areAllSpeculatable", "C", "presplitLoadsAndStores", "isSpeculatable", "runImpl", "promoteAllocas", "SelectHandSpeculativity", "splitAlloca"]}]}
{"pr_number": 72921, "url": "https://github.com/llvm/llvm-project/pull/72921", "title": "Revert \"[nfc][InstrProfTest]Factor out common code for value profile test\"", "body": "Reverts llvm/llvm-project#72611", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/unittests/ProfileData/InstrProfTest.cpp", "functions": ["Record1"]}]}
{"pr_number": 69536, "url": "https://github.com/llvm/llvm-project/pull/69536", "title": "[libc] Remove the optional arguments for NVPTX constructors", "body": "Summary:\r\nWe call the global constructors by function pointer. For whatever reason\r\nthe NVPTX architecture relies very specifically on the arguments to the\r\nfunction pointer invocation matching what the function is implemented\r\nas. This is problematic as most of these constructors are generated\r\nwith no arguments. This patch removes the extended arguments that GNU\r\nand LLVM use for the constructors optionally so that it can support the\r\ncommon case.\r\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "libc/startup/gpu/nvptx/start.cpp", "functions": ["call_init_array_callbacks"]}]}
{"pr_number": 66787, "url": "https://github.com/llvm/llvm-project/pull/66787", "title": "[InstCombine] Improve handling of `not` and free inversion.", "body": "- [InstCombine] Add tests for folding `(X + Y) - (W + Z)`; NFC\r\n- [InstCombine] Add folds for `(X + Y) - (W + Z)`\r\n- [InstCombine] Make `isFreeToInvert` check recursively.\r\n- [InstCombine] Add additional tests for free inversion; NFC\r\n- [InstCombine] add `getFreeInverted` to perform folds for free inversion of op\r\n- [InstCombine] Replace `isFreeToInvert` + `CreateNot` with `getFreelyInverted`\r\n- [InstCombine] Add transform for `~X + ~Y)` -> `-2 - Y - X`\r\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp", "functions": ["getFreelyInverted", "replaceInstUsesWith"]}, {"filename": "llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp", "functions": ["ICmpInst"]}]}
{"pr_number": 69557, "url": "https://github.com/llvm/llvm-project/pull/69557", "title": "[RecursiveASTVisitor] Fix RecursiveASTVisitor (RAV) fails to visit the initializer of a bitfield", "body": "The problem was introduced in commit https://github.com/llvm/llvm-project/commit/6b8e3c02ca44fb6c3738bb0c75859c11a03e30ed when the possibility of initialized bitfields was added, but the logic in RecursiveASTVisitor was not updated.\r\n\r\nThis fixes https://github.com/llvm/llvm-project/issues/64916.\r\n\r\nPatch by Scott McPeak", "feature_layers": ["ast"], "feature_directives": [], "files_changed": [{"filename": "clang/unittests/Tooling/RecursiveASTVisitorTests/BitfieldInitializer.cpp", "functions": ["VisitIntegerLiteral"]}]}
{"pr_number": 72801, "url": "https://github.com/llvm/llvm-project/pull/72801", "title": "[mlir][async] Avoid crash when not using `func.func`", "body": "The `createParallelComputeFunction` crashed when calling `getFunctionTypeAttrName` during the creation of a new `FuncOp` inside the pass. The problem is that `getFunctionTypeAttrName` looks up the attribute name for the function type which in this case is `func.func`. However, `name.getAttributeNames()` was empty when clients used `llvm.func` instead of `func.func`.\r\n\r\nTo fix this, the `func` dialect is now registered as a dependent dialect. Also, I've added an assertion which could save other people some time.\r\n\r\nFixes #71281, fixes #64326.", "feature_layers": ["ir"], "feature_directives": ["parallel", "for"], "files_changed": [{"filename": "mlir/lib/Dialect/Async/Transforms/AsyncParallelFor.cpp", "functions": ["getDependentDialects"]}]}
{"pr_number": 69360, "url": "https://github.com/llvm/llvm-project/pull/69360", "title": "[RFC] Perform lifetime bound checks for arguments to coroutine", "body": "This idea was introduced in [RFC: Lifetime bound checks for parameters of coroutine](https://discourse.llvm.org/t/rfc-lifetime-bound-check-for-parameters-of-coroutines/74253)\r\n\r\nThe plan here is to gather comments, and if the direction looks good, then introduce a formal clang annotation `clang::lifetimebound_coroutine` as part of this change.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/SemaCXX/coroutine-lifetimebound-args.cpp", "functions": ["wrapper2", "forward", "await_transform", "operator", "fp_callable_", "getInt", "initial_suspend", "plain_return_foo_decl", "lambdas", "use_std_function", "await_resume", "complex_plain_return", "UnsafeWrapper", "wrapper1", "unhandled_exception", "value_coro", "return_value", "bar_coro", "foo_coro", "await_suspend", "plain_return_co", "unsafe_wrapper", "RefWrapperCoro", "await_ready", "safe_forwarding", "get_return_object", "final_suspend"]}]}
{"pr_number": 72930, "url": "https://github.com/llvm/llvm-project/pull/72930", "title": "[NewPM] Remove LoopSimplifyCFGLegacyPass", "body": "This pass isn't used anywhere in upstream and thus has no test coverage. For these reasons, remove it.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp", "functions": ["LoopSimplifyCFGLegacyPass", "runOnLoop", "getAnalysisUsage"]}]}
{"pr_number": 72934, "url": "https://github.com/llvm/llvm-project/pull/72934", "title": "[NewPM] Remove SimpleLoopUnswitchLegacyPass", "body": "This pass isn't used anywhere in upstream and thus doesn't have any test coverage. For these reasons, remove it.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp", "functions": ["getAnalysisUsage", "SimpleLoopUnswitchLegacyPass", "runOnLoop", "MSSAU", "LoopPass"]}]}
{"pr_number": 69337, "url": "https://github.com/llvm/llvm-project/pull/69337", "title": "[HWASan] Prevent same tag for adjacent heap objects", "body": "Previously, the random tag generation could lead to undetected heap under- and overflows due to tag collisions.\nThis modification to the tag generaten ensures that different tags are generated for adjacent heap objects.\nFor stack objects, additional changes in the instrumentation pass are necessary.\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "compiler-rt/test/hwasan/TestCases/adjacent_tag_collisions_heap.c", "functions": ["main", "check_collisions_on_heap"]}]}
{"pr_number": 72888, "url": "https://github.com/llvm/llvm-project/pull/72888", "title": "[mlir][tensor] Fix crash when canonicalizing invalid IR", "body": "This commit fixes a crash of the canonicalizer when there are slice ops with offset/size SSA values that have a negative constant value. Such ops are invalid if they are reachable and their offsets/sizes should not be folded to static integer values. (But such ops may appear in non-reachable block.)\r\n\r\nThis commit fixes #71150.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/Tensor/IR/TensorOps.cpp", "functions": ["failure"]}, {"filename": "mlir/lib/Dialect/Utils/StaticValueUtils.cpp", "functions": ["foldDynamicIndexList"]}]}
{"pr_number": 71930, "url": "https://github.com/llvm/llvm-project/pull/71930", "title": "[SVE2.1][Clang][LLVM]Add 128bits builtin in Clang and LLVM intrinisc", "body": "This patch implements the builtins in Clang\r\nand the LLVM-IR intrinsic for the following:\r\n\r\nEXTQ\r\n// Variants are also available for:\r\n// _s8, _s16, _u16, _s32, _u32, _s64, _u64\r\n// _bf16, _f16, _f32, _f64\r\nsvuint8_t svextq_lane[_u8](svuint8_t zdn, svuint8_t zm, uint64_t imm);\r\n\r\nTBLQ and TBXQ\r\n// Variants are also available for:\r\n// _u8, _u16, _s16, _u32, _s32, _u64, _s64\r\n// _bf16, _f16, _f32, _f64\r\nsvint8_t svtblq[_s8](svint8_t zn, svuint8_t zm);\r\nsvint8_t svtbxq[_s8](svint8_t zn, svuint8_t zm);\r\n\r\nUZPQ1, UZPQ2, ZIPQ1 and ZIPQ2\r\n// Variants are also available for:\r\n// _s8, _u16, _s16, _u32, _s32, _u64, _s64\r\n// _bf16, _f16, _f32, _f64\r\nsvuint8_t svuzpq1[_u8](svuint8_t zn, svuint8_t zm); svuint8_t svuzpq2[_u8](svuint8_t zn, svuint8_t zm); svuint8_t svzipq1[_u8](svuint8_t zn, svuint8_t zm); svuint8_t svzipq2[_u8](svuint8_t zn, svuint8_t zm);\r\n\r\nPMOV\r\n// Variants are available for:\r\n// _s8, _u16, _s16, _s32, _u32, _s64, _u64\r\nsvbool_t svpmov_lane[_u8](svuint8_t zn, uint64_t imm); svbool_t svpmov[_u8](svuint8_t zn); // The immediate is zero svuint8_t svpmov_u8_z(svbool_t pn); // The immediate is zero\r\n\r\n// Variants are available for:\r\n// _s16, _s32, _u32, _s64, _u64\r\nsvuint16_t svpmov_lane[_u16]_m(svuint16_t zd, svbool_t pn, uint64_t imm);\r\n\r\nAccording to the PR#257[1]\r\n[1]ARM-software/acle#257\r\n\r\nCo-authored-by: Hassnaa Hamdi <hassnaa.hamdi@arm.com>", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_extq.c", "functions": ["test_svextq_lane_f32", "test_svextq_lane_f16", "test_svextq_lane_u32", "test_svextq_lane_s16", "test_svextq_lane_u16", "test_svextq_lane_s8", "test_svextq_lane_bf16", "test_svextq_lane_f64", "test_svextq_lane_u64", "test_svextq_lane_u8", "test_svextq_lane_s64", "SVE_ACLE_FUNC", "test_svextq_lane_s32"]}, {"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_pmov_to_pred.c", "functions": ["test_svpmov_u8", "test_svpmov_s32", "test_svpmov_s64", "test_svpmov_u32", "test_svpmov_s16", "test_svpmov_lane_u64", "test_svpmov_u64", "test_svpmov_s8", "test_svpmov_lane_s32", "test_svpmov_lane_u16", "test_svpmov_lane_s16", "test_svpmov_lane_s64", "test_svpmov_lane_u8", "test_svpmov_u16", "SVE_ACLE_FUNC", "test_svpmov_lane_s8", "test_svpmov_lane_u32"]}, {"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_pmov_to_vector.c", "functions": ["test_svpmov_lane_u32_m", "test_svpmov_lane_s64_z", "test_svpmov_lane_s32_z", "test_svpmov_lane_u16_z", "test_svpmov_lane_s64_m", "test_svpmov_lane_u64_z", "test_svpmov_lane_u16_m", "test_svpmov_lane_u64_m", "test_svpmov_lane_s8_z", "test_svpmov_lane_s32_m", "test_svpmov_lane_s16_m", "test_svpmov_lane_u32_z", "SVE_ACLE_FUNC", "test_svpmov_lane_s16_z", "test_svpmov_lane_u8_z"]}, {"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_tblq.c", "functions": ["test_svtblq_s64", "test_svtblq_bf16", "test_svtblq_s16", "test_svtblq_f32", "test_svtblq_u8", "test_svtblq_s32", "test_svtblq_f16", "test_svtblq_u32", "test_svtblq_s8", "test_svtblq_u16", "test_svtblq_f64", "SVE_ACLE_FUNC", "test_svtblq_u64"]}, {"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_tbxq.c", "functions": ["test_svtbxq_u64", "test_svtbxq_u16", "test_svtbxq_bf16", "test_svtbxq_s8", "test_svtbxq_f64", "test_svtbxq_u8", "test_svtbxq_f16", "test_svtbxq_s16", "test_svtbxq_f32", "test_svtbxq_u32", "SVE_ACLE_FUNC", "test_svtbxq_s32", "test_svtbxq_s64"]}, {"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_uzpq1.c", "functions": ["svuzpq1_u16", "svuzpq1_f32", "svuzpq1_f16", "svuzpq1_s8", "svuzpq1_f64", "svuzpq1_s64", "svuzpq1_bf16", "svuzpq1_s32", "svuzpq1_u64", "svuzpq1_s16", "SVE_ACLE_FUNC", "svuzpq1_u8", "svuzpq1_u32"]}, {"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_uzpq2.c", "functions": ["svuzpq2_s32", "svuzpq2_s16", "svuzpq2_u32", "svuzpq2_f16", "svuzpq2_f64", "svuzpq2_f32", "svuzpq2_u16", "svuzpq2_u8", "svuzpq2_bf16", "svuzpq2_s8", "svuzpq2_u64", "SVE_ACLE_FUNC", "svuzpq2_s64"]}, {"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_zipq1.c", "functions": ["svzipq1_s8", "svzipq1_f32", "svzipq1_bf16", "svzipq1_u32", "svzipq1_u64", "svzipq1_u16", "svzipq1_f64", "svzipq1_f16", "svzipq1_s16", "svzipq1_u8", "svzipq1_s64", "SVE_ACLE_FUNC", "svzipq1_s32"]}, {"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_zipq2.c", "functions": ["svzipq2_u8", "svzipq2_f64", "svzipq2_bf16", "svzipq2_s32", "svzipq2_f16", "svzipq2_f32", "svzipq2_u32", "svzipq2_s16", "svzipq2_u64", "svzipq2_u16", "SVE_ACLE_FUNC", "svzipq2_s64", "svzipq2_s8"]}, {"filename": "clang/test/Sema/aarch64-sve2p1-intrinsics/acle_sve2p1_imm.cpp", "functions": ["test_svpmov_lane"]}]}
{"pr_number": 72879, "url": "https://github.com/llvm/llvm-project/pull/72879", "title": "[ConstraintElim] Use isKnownNonNegative for condition transfer.", "body": "Use isKnownNonNegative for information transfer. This can improve results, in cases where ValueTracking can infer additional non-negative info, e.g. for phi nodes.\r\n\r\nThis allows simplifying the check from\r\nhttps://github.com/llvm/llvm-project/issues/63126 by ConstraintElimination. It is also simplified by IndVarSimplify now; note the changes in llvm/test/Transforms/PhaseOrdering/loop-access-checks.ll, due to this now being simplified earlier.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Scalar/ConstraintElimination.cpp", "functions": ["doesHold"]}]}
{"pr_number": 72809, "url": "https://github.com/llvm/llvm-project/pull/72809", "title": "[mlir][spirv] Add some op decorations", "body": "NoSignedWrap, NoUnsignedWrap, FPFastMathMode.", "feature_layers": ["ir", "ast"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Target/SPIRV/Deserialization/Deserializer.cpp", "functions": ["emitError"]}, {"filename": "mlir/lib/Target/SPIRV/Serialization/Serializer.cpp", "functions": ["emitError", "getDecorationName"]}]}
{"pr_number": 72697, "url": "https://github.com/llvm/llvm-project/pull/72697", "title": "[Offload] Initial support for registering offloading entries on COFF targets", "body": "Summary:\nThis patch provides the initial support to allow handling the new\ndriver's offloading entries. Normally, the ELF target can emit varibles\nat C-identifier named sections and the linker will provide a pointer to\nthe section. For COFF target, instead the linker merges sections\ncontaining a `$` in alphabetical order. We thus can emit these variables\nat sections and then emit two variables that are guaranteed to be sorted\nbefore and after the others to traverse it. Previous patches\nconsolidated the handling of offloading entries so that this patch more\neasily can handle mapping them to the appropriate section.\n\nIdeally, the only remaining step to allow the new driver to run on\nWindows targets is to accurately map the following `ld.lld` arguments to\ntheir `llvm-link` equivalents. These are used inside the linker-wrapper,\nso we should simply need to remap the arguments to the same\nfunctionality if possible.\n```\n-o, -output\n-l, --library\n-L, --library-path\n-v, --version\n-rpath\n-whole-archive, -no-whole-archive\n```\n\nI have not tested this at runtime as I do not have access to a windows\nmachine.\n\nThis patch was adapted from some initial efforts in\nhttps://reviews.llvm.org/D137470.\n", "feature_layers": ["runtime", "ir"], "feature_directives": ["for", "sections", "target"], "files_changed": [{"filename": "llvm/lib/Frontend/Offloading/Utility.cpp", "functions": ["Triple", "GlobalVariable"]}]}
{"pr_number": 66481, "url": "https://github.com/llvm/llvm-project/pull/66481", "title": "[analyzer] Add std::variant checker", "body": "As my BSc thesis I've implemented a checker for std::variant and std::any, and in the following weeks I'll upload a revised version of them here.\r\n\r\n# Prelude\r\n\r\n@Szelethus and I sent out an email with our initial plans here: https://discourse.llvm.org/t/analyzer-new-checker-for-std-any-as-a-bsc-thesis/65613/2 We also created a stub checker patch here: https://reviews.llvm.org/D142354.\r\n\r\nUpon the recommendation of @haoNoQ , we explored an option where instead of writing a checker, we tried to improve on how the analyzer natively inlined the methods of std::variant and std::any. Our attempt is in this patch https://reviews.llvm.org/D145069, but in a nutshell, this is what happened: The analyzer was able to model much of what happened inside those classes, but our false positive suppression machinery erroneously suppressed it. After months of trying, we could not find a satisfying enhancement on the heuristic without introducing an allowlist/denylist of which functions to not suppress.\r\n\r\nAs a result (and partly on the encouragement of @Xazax-hun) I wrote a dedicated checker!\r\n\r\nThe advantage of the checker is that it is not dependent on the standard's implementation and won't put warnings in the standard library definitions. Also without the checker it would be difficult to create nice user-friendly warnings and NoteTags -- as per the standard's specification, the analysis is sinked by an exception, which we don't model well now.\r\n\r\n# Design ideas\r\n\r\nThe working of the checker is straightforward: We find the creation of an std::variant instance, store the type of the variable we want to store in it, then save this type for the instance. When retrieving type from the instance we check what type we want to retrieve as, and compare it to the actual type. If the two don't march we emit an error.\r\n\r\nDistinguishing variants by instance (e.g. MemRegion *) is not the most optimal way. Other checkers, like MallocChecker uses a symbol-to-trait map instead of region-to-trait. The upside of using symbols (which would be the value of a variant, not the variant itself itself) is that the analyzer would take care of modeling copies, moves, invalidation, etc, out of the box. The problem is that for compound types, the analyzer doesn't create a symbol as a result of a constructor call that is fit for this job. MallocChecker in contrast manipulates simple pointers.\r\n\r\nMy colleges and I considered the option of making adjustments directly to the memory model of the analyzer, but for the time being decided against it, and go with the bit more cumbersome, but immediately viable option of simply using MemRegions.\r\n\r\n# Current state and review plan\r\n\r\nThis patch contains an already working checker that can find and report certain variant/any misuses, but still lands it in alpha. I plan to upload the rest of the checker in later patches.\r\n\r\nThe full checker is also able to \"follow\" the symbolic value held by the std::variant and updates the program state whenever we assign the value stored in the variant. I have also built a library that is meant to model union-like types similar to variant, hence some functions being a bit more multipurpose then is immediately needed.\r\n\r\nI also intend to publish my std::any checker in a later commit.", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/StaticAnalyzer/Checkers/StdVariantChecker.cpp", "functions": ["getCaller", "calledFromSystemHeader"]}, {"filename": "clang/test/Analysis/std-variant-checker.cpp", "functions": ["cannotChangePtr", "stdGetType", "changesToInt", "temporaryObjectsAssignment", "changeVariantType", "variantHoldingVariant", "clang_analyzer_warnIfReached", "temporaryObjectsConstructor", "nonInlineFunctionCall", "copyInAFunction", "assignmentOperator", "pointerTypeHeld", "functionCallWithCopyAssignment", "stdGetPointerAndPointee", "clang_analyzer_eval", "typefdefedVariant", "swap", "createPointer", "changeVariantPtr", "copyFromUnknownVariant", "defaultConstructor", "contNonInlinePtr", "typedefedTypedfefedVariant", "copyFromUnknownVariantBef", "typeChangeThreeTimes", "inlineFunctionCall", "constNonInlineRef", "getUnknownChar", "copyConstructor", "wontConfuseStdGets", "changeThruPointers", "typedefedGet", "fromVariable", "nonInlineFunctionCallPtr", "stdGetPointer", "copyAssignmentOperator", "unknowValueButKnownType", "cantDo", "typedefedPack", "stdGetObject"]}]}
{"pr_number": 71960, "url": "https://github.com/llvm/llvm-project/pull/71960", "title": "[mlir][mesh] Add collective communication operations", "body": "Add all-gather, all-reduce, all-to-all and reduce-scatter. These operations have device mesh semantics.\r\n\r\nI have not included ops like reduce, gather, send and recv to see first if reviewers notice any systemic issues. Also this PR is already big enough.\r\n", "feature_layers": ["sema", "ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/Mesh/IR/MeshOps.cpp", "functions": ["int64_t", "emitError"]}]}
{"pr_number": 72874, "url": "https://github.com/llvm/llvm-project/pull/72874", "title": "[mlir] use TypeSize and uint64_t in DataLayout", "body": "Data layout queries may be issued for types whose size exceeds the range of 32-bit integer as well as for types that don't have a size known at compile time, such as scalable vectors. Use best practices from LLVM IR and adopt `llvm::TypeSize` for size-related queries and `uint64_t` for alignment-related queries.\r\n\r\nSee #72678.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/LLVMIR/IR/LLVMTypes.cpp", "functions": ["getTypeSize", "emitError", "extractStructSpecValue"]}, {"filename": "mlir/lib/Interfaces/DataLayoutInterfaces.cpp", "functions": ["extractABIAlignment", "divideCeil", "extractPreferredAlignment", "getIndexBitwidth", "cachedLookup"]}, {"filename": "mlir/lib/Target/LLVMIR/DataLayoutImporter.cpp", "functions": ["results"]}, {"filename": "mlir/test/lib/Dialect/Test/TestTypes.cpp", "functions": ["extractKind"]}]}
{"pr_number": 70474, "url": "https://github.com/llvm/llvm-project/pull/70474", "title": "[AArch64][SVE2.1] Add intrinsics for quadword loads/stores with unscaled offset", "body": "This patch adds a set of SVE2.1 quadword load/store intrisics:\r\n\r\n  * Contiguous zero-extending load to quadword (single vector)\r\n\r\n    sv<type>_t svld1uwq[_<typ>](svbool_t, const <type>_t *ptr);\r\n    sv<type>_t svld1uwq_vnum[_<typ>](svbool_t, const <type> *ptr, int64_t vnum);\r\n \r\n    sv<type>_t svld1udq[_<typ>](svbool_t, const <type>_t *ptr);\r\n    sv<type>_t svld1udq_vnum[_<typ>](svbool_t, const <type>_t *ptr, int64_t vnum);\r\n\r\n  * Contiguous truncating store of single vector operand\r\n\r\n    void svst1uwq[_<typ>](svbool_t, const <type>_t *ptr, sv<type>_t data);\r\n    void svst1uwq_vnum[_<typ>](svbool_t, const <type>_t *ptr, int64_t vnum, sv<type>_t data);\r\n\r\n    void svst1udq[_<typ>](svbool_t, const <type>_t *ptr, sv<type>_t data);\r\n    void svst1udq_vnum[_<typ>](svbool_t, const <type>_t *ptr, int64_t vnum, sv<type>_t data);\r\n\r\n  * Gather load quadword\r\n\r\n    sv<type>_t svld1q_gather[_u64base]_<typ>(svbool_t pg, svuint64_t zn);\r\n    sv<type>_t svld1q_gather[_u64base]_offset_<typ>(svbool_t pg, svuint64_t zn, int64_t offset);\r\n\r\n  * Scatter store quadword\r\n\r\n    void svst1q_scatter[_u64base][_<typ>](svbool_t pg, svuint64_t zn, sv<type>_t data);\r\n    void svst1q_scatter[_u64base]_offset[_<typ>](svbool_t pg, svuint64_t zn, int64_t offset, sv<type>_t data);\r\n\r\n  * Contiguous load two, three or four quadword structures.\r\n\r\n    sv<type>x2_t svld2q[_<typ>](svbool_t pg, const <type>_t *rn);\r\n    sv<type>x2_t svld2q_vnum[_<typ>](svbool_t pg, const <type>_t *rn, uint64_t vnum);\r\n    sv<type>x3_t svld3q[_<typ>](svbool_t pg, const <type>_t *rn);\r\n    sv<type>x3_t svld3q_vnum[_<typ>](svbool_t pg, const <type>_t *rn, uint64_t vnum);\r\n    sv<type>x4_t svld4q[_<typ>](svbool_t pg, const <type>_t *rn);\r\n    sv<type>x4_t svld4q_vnum[_<typ>](svbool_t pg, const <type>_t *rn, uint64_t vnum);\r\n\r\n  * Contiguous store two, three or four quadword structures.\r\n\r\n    void svst2q[_<typ>](svbool_t pg, <type>_t *rn, sv<type>x2_t zt);\r\n    void svst2q_vnum[_<typ>](svbool_t pg, <type>_t *rn, int64_t vnum, sv<type>x2_t zt);\r\n    void svst3q[_<typ>](svbool_t pg, <type>_t *rn, sv<type>x3_t zt);\r\n    void svst3q_vnum[_<typ>](svbool_t pg, <type>_t *rn, int64_t vnum, sv<type>x3_t zt);\r\n    void svst4q[_<typ>](svbool_t pg, <type>_t *rn, sv<type>x4_t zt);\r\n    void svst4q_vnum[_<typ>](svbool_t pg, <type>_t *rn, int64_t vnum, sv<type>x4_t zt);\r\n\r\nACLE spec: https://github.com/ARM-software/acle/pull/257\r\n\r\nCo-authored-by: Caroline Concatto <caroline.concatto@arm.com>\r\nCo-authored-by: Hassnaa Hamdi <hassnaa.hamdi@arm.com>\r\n", "feature_layers": [], "feature_directives": ["for", "single"], "files_changed": [{"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_ld1_single.c", "functions": ["test_svld1uwq_s32", "test_svld1udq_u64", "test_svld1udq_vnum_u64", "test_svld1uwq_vnum_s32", "test_svld1udq_vnum_f64", "test_svld1uwq_u32", "test_svld1uwq_vnum_f32", "test_svld1udq_f64", "test_svld1uwq_f32", "SVE_ACLE_FUNC", "test_svld1udq_vnum_s64", "test_svld1udq_s64", "test_svld1uwq_vnum_u32"]}, {"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_loads.c", "functions": ["SVE_ACLE_FUNC", "test_svld3q_s8"]}, {"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_st1_single.c", "functions": ["test_svst1uwq_vnum_s32", "test_svst1uwq_f32", "test_svst1uwq_u32", "test_svst1udq_s64", "test_svst1udq_vnum_s64", "test_svst1udq_vnum_f64", "test_svst1udq_u64", "test_svst1uwq_vnum_u32", "test_svst1uwq_s32", "test_svst1udq_f64", "test_svst1udq_vnum_u64", "test_svst1uwq_vnum_f32"]}, {"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_store.c", "functions": ["test_svst2q_bf16", "test_svst2q_f32", "test_svst4q_vnum_u16", "test_svst1q_scatter_u64base_f16", "test_svst1q_scatter_u64base_u64", "test_svst4q_vnum_s32", "test_svst2q_u32", "test_svst4q_f32", "test_svst2q_f64", "test_svst2q_s16", "test_svst2q_vnum_s8", "test_svst4q_vnum_f32", "test_svst2q_vnum_bf16", "test_svst1q_scatter_u64base_f32", "test_svst4q_vnum_bf16", "test_svst1q_scatter_u64base_u8", "test_svst4q_s32", "test_svst1q_scatter_u64base_offset_f32", "test_svst2q_u8", "test_svst1q_scatter_u64base_bf16", "test_svst2q_vnum_s32", "test_svst1q_scatter_u64base_offset_u8", "test_svst4q_vnum_s16", "test_svst2q_vnum_u16", "test_svst1q_scatter_u64base_f64", "test_svst3q_vnum_f64", "test_svst1q_scatter_u64base_offset_f16", "test_svst2q_vnum_f64", "test_svst3q_u8", "test_svst2q_vnum_f32", "test_svst3q_s32", "test_svst2q_vnum_u64", "test_svst4q_vnum_f16", "test_svst3q_vnum_f32", "test_svst2q_s32", "test_svst1q_scatter_u64base_offset_f64", "test_svst2q_s64", "test_svst1q_scatter_u64base_offset_s32", "test_svst1q_scatter_u64base_offset_u64", "test_svst3q_f16", "test_svst2q_u16", "test_svst4q_vnum_f64", "test_svst1q_scatter_u64base_offset_u32", "test_svst2q_vnum_u8", "test_svst1q_scatter_u64base_offset_u16", "test_svst1q_scatter_u64base_offset_s64", "test_svst3q_vnum_f16", "test_svst3q_s64", "test_svst3q_vnum_s16", "test_svst3q_vnum_u8", "test_svst1q_scatter_u64base_offset_s16", "test_svst1q_scatter_u64base_u32", "test_svst4q_u16", "test_svst3q_s16", "test_svst3q_vnum_s8", "test_svst2q_vnum_s64", "test_svst2q_u64", "test_svst3q_s8", "test_svst3q_vnum_u16", "test_svst3q_f32", "test_svst4q_u32", "test_svst1q_scatter_u64base_offset_bf16", "test_svst2q_s8", "test_svst3q_u64", "test_svst1q_scatter_u64base_s64", "test_svst1q_scatter_u64base_offset_s8", "test_svst3q_u16", "test_svst4q_u8", "test_svst4q_s64", "test_svst4q_bf16", "test_svst4q_vnum_u32", "test_svst2q_vnum_u32", "test_svst3q_vnum_u64", "test_svst3q_vnum_u32", "test_svst1q_scatter_u64base_s8", "test_svst4q_s8", "test_svst2q_f16", "test_svst2q_vnum_f16", "test_svst3q_vnum_s32", "test_svst4q_u64", "test_svst4q_f16", "test_svst3q_f64", "test_svst3q_u32", "test_svst3q_vnum_s64", "test_svst4q_s16", "test_svst3q_bf16", "test_svst1q_scatter_u64base_s32", "test_svst3q_vnum_bf16", "test_svst4q_vnum_s64", "test_svst1q_scatter_u64base_u16", "test_svst4q_vnum_u8", "test_svst4q_vnum_s8", "test_svst4q_f64", "test_svst4q_vnum_u64", "test_svst2q_vnum_s16", "test_svst1q_scatter_u64base_s16"]}, {"filename": "llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp", "functions": ["EVT"]}, {"filename": "llvm/lib/Target/AArch64/AArch64ISelLowering.cpp", "functions": ["performScatterStoreCombine", "performGatherLoadCombine"]}]}
{"pr_number": 72610, "url": "https://github.com/llvm/llvm-project/pull/72610", "title": "[ELF] Support R_RISCV_SET_ULEB128/R_RISCV_SUB_ULEB128 in non-SHF_ALLOC sections", "body": "For a label difference like `.uleb128 A-B`, MC generates a pair of\nR_RISCV_SET_ULEB128/R_RISCV_SUB_ULEB128 if A-B cannot be folded as a\nconstant. GNU assembler generates a pair of relocations in more cases\n(when A or B is in a code section with linker relaxation).\n\n`.uleb128 A-B` is primarily used by DWARF v5\n.debug_loclists/.debug_rnglists (DW_LLE_offset_pair/DW_RLE_offset_pair\nentry kinds) implemented in Clang and GCC.\n\n`.uleb128 A-B` can be used in SHF_ALLOC sections as well (e.g.\n`.gcc_except_table`). This patch does not handle SHF_ALLOC.\n\n`-z dead-reloc-in-nonalloc=` can be used to change the relocated value,\nif the R_RISCV_SET_ULEB128 symbol is in a discarded section. We don't\ncheck the R_RISCV_SUB_ULEB128 symbol since for the expected cases A and\nB should be defined in the same input section.", "feature_layers": ["ir"], "feature_directives": ["for", "sections"], "files_changed": [{"filename": "lld/ELF/InputSection.cpp", "functions": ["overwriteULEB128"]}]}
{"pr_number": 72916, "url": "https://github.com/llvm/llvm-project/pull/72916", "title": "[OpenACC] Implement enter data/exit data construct parsing", "body": "These two constructs, 'enter data' and 'exit data', are novel compared to what is currently in the parser, as this is the first set implemented where the first token is itself not a valid construct.  Because of this, it requires some additional work to do the first keyword parsing.", "feature_layers": ["parse", "ir", "parser"], "feature_directives": ["requires"], "files_changed": [{"filename": "clang/lib/Parse/ParseOpenACC.cpp", "functions": ["getOpenACCDirectiveKind"]}]}
{"pr_number": 70476, "url": "https://github.com/llvm/llvm-project/pull/70476", "title": "[AArch64] Add SVE2.1 intrinsics for indexed quadword gather loads and scatter stores", "body": "[Note, first patch is a part of another pull request]\r\n    \r\nThis patch adds the quadword gather load intrinsics of the form\r\n\r\n```\r\n  sv<type>_t svld1q_gather_u64index_<typ>(svbool_t, const <type>_t *, svuint64_t);\r\n  sv<type>_t svld1q_gather_u64base_index_<typ>(svbool_t, svuint64_t, int64_t);\r\n```\r\nand the quadword scatter store intrinsics of the form\r\n```\r\n  void svst1q_scatter_u64index_<typ>(svbool_t, <type>_t *, svuint64_t, sv<type>_t);\r\n  void svst1q_scatter_u64base_index_<typ>(svbool, svuint64_t, int64_t, sv<type>_t);\r\n``` \r\n\r\nACLE spec: https://github.com/ARM-software/acle/pull/257\r\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_loads.c", "functions": ["test_svld1q_gather_u64index_u32", "test_svld1q_gather_u64index_bf16", "test_svld1q_gather_u64base_index_bf16", "test_svld1q_gather_u64base_index_f64", "test_svld1q_gather_u64index_s64", "test_svld1q_gather_u64base_index_f32", "test_svld1q_gather_u64base_index_s64", "test_svld1q_gather_u64base_index_s32", "test_svld1q_gather_u64index_s16", "test_svld1q_gather_u64base_index_s16", "test_svld1q_gather_u64base_index_f16", "test_svld1q_gather_u64index_s32", "test_svld1q_gather_u64base_index_u64", "test_svld1q_gather_u64index_u64", "test_svld1q_gather_u64base_index_u32", "test_svld1q_gather_u64index_f16", "test_svld1q_gather_u64base_index_u16", "SVE_ACLE_FUNC", "test_svld1q_gather_u64index_f32", "test_svld1q_gather_u64index_u16", "test_svld1q_gather_u64index_f64"]}, {"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_store.c", "functions": ["test_svst1q_scatter_u64index_s16", "test_svst1q_scatter_u64base_index_s64", "test_svst1q_scatter_u64base_index_u16", "test_svst1q_scatter_u64base_index_f32", "test_svst1q_scatter_u64index_s64", "test_svst1q_scatter_u64base_index_s32", "test_svst1q_scatter_u64base_index_u64", "test_svst1q_scatter_u64base_index_s16", "test_svst1q_scatter_u64index_f32", "test_svst1q_scatter_u64index_u64", "test_svst1q_scatter_u64index_f16", "test_svst1q_scatter_u64base_index_f16", "test_svst1q_scatter_u64base_index_bf16", "test_svst1q_scatter_u64index_u16", "test_svst1q_scatter_u64index_f64", "test_svst1q_scatter_u64base_index_f64", "test_svst1q_scatter_u64index_bf16", "test_svst1q_scatter_u64index_u32", "test_svst1q_scatter_u64index_s32", "test_svst1q_scatter_u64base_index_u32"]}, {"filename": "llvm/lib/Target/AArch64/AArch64ISelLowering.cpp", "functions": ["performScatterStoreCombine"]}]}
{"pr_number": 72910, "url": "https://github.com/llvm/llvm-project/pull/72910", "title": "reapply \"[TargetInstrInfo] enable foldMemoryOperand for InlineAsm (#70743)\"", "body": "This reverts commit 42204c94ba9fcb0b4b1335e648ce140a3eef8a9d.\r\n\r\nIt was accidentally backed out.\r\n\r\n#20571\r\n#70743\r\n", "feature_layers": [], "feature_directives": ["for", "target"], "files_changed": [{"filename": "llvm/lib/CodeGen/TargetInstrInfo.cpp", "functions": ["F"]}]}
{"pr_number": 72253, "url": "https://github.com/llvm/llvm-project/pull/72253", "title": "[DebugInfo][RemoveDIs] Interpret DPValue objects in SelectionDAG", "body": "DPValues are the non-intrinsic replacements for dbg.values, and when an IR function is converted by SelectionDAG we need to convert the variable location information in the same way. Happily all the information is in the same format, it's just stored in a slightly different object, therefore this patch refactors a few things to store the set of {Variable,Expr,DILocation,Location} instead of just a pointer to a DbgValueInst.\r\n\r\nThis also adds a hook in llc that's much like the one I've added to opt in PR #71937, allowing tests to optionally ask for the use RemoveDIs mode if support for it is built into the compiler.\r\n\r\nI've added that flag to a variety of SelectionDAG debug-info tests to ensure that we get some coverage on the RemoveDIs / debug-info-iterator buildbot.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp", "functions": ["printDDI"]}]}
{"pr_number": 70362, "url": "https://github.com/llvm/llvm-project/pull/70362", "title": "[SVE2.1][Clang][LLVM]Add BFloat16 builtin in Clang and LLVM intrinisc", "body": "This patch implements the builtins in Clang\r\nand the LLVM-IR intrinsic for the following:\r\n\r\nFor BFADD , BFSUB, BFMAX, BFMIN, BFMAXNM and BFMINNM, for instance: \r\nsvbfloat16_t svadd[_bf16]_m (svbool_t pg, svbfloat16_t zdn, svbfloat16_t zm); \r\nsvbfloat16_t svadd[_bf16]_x (svbool_t pg, svbfloat16_t zdn, svbfloat16_t zm); \r\nsvbfloat16_t svadd[_bf16]_z (svbool_t pg, svbfloat16_t zdn, svbfloat16_t zm); \r\nsvbfloat16_t svadd[_n_bf16]_m (svbool_t pg, svbfloat16_t zdn, bfloat16_t zm); \r\nsvbfloat16_t svadd[_n_bf16]_x (svbool_t pg, svbfloat16_t zdn, bfloat16_t zm); \r\nsvbfloat16_t svadd[_n_bf16]_z (svbool_t pg, svbfloat16_t zdn, bfloat16_t zm); \r\nthe add, could be replaced by sub, max, min, maxnm and minnm.\r\n\r\nFor BFMUL:\r\nsvbfloat16_t svmul[_bf16]_m(svbool_t pg, svbfloat16_t zdn, svbfloat16_t zm); \r\nsvbfloat16_t svmul[_bf16]_x(svbool_t pg, svbfloat16_t zdn, svbfloat16_t zm); \r\nsvbfloat16_t svmul[_bf16]_z(svbool_t pg, svbfloat16_t zdn, svbfloat16_t zm); \r\nsvbfloat16_t svmul[_n_bf16]_m(svbool_t pg, svbfloat16_t zdn, bfloat16_t zm); \r\nsvbfloat16_t svmul[_n_bf16]_x(svbool_t pg, svbfloat16_t zdn, bfloat16_t zm); \r\nsvbfloat16_t svmul[_n_bf16]_z(svbool_t pg, svbfloat16_t zdn, bfloat16_t zm);\r\n\r\nsvbfloat16_t svmul_lane[_bf16](svbfloat16_t zn, svbfloat16_t zm,\r\n                               uint64_t imm_idx);\r\n\r\nFor BFCLAMP:\r\nsvbfloat16_t svclamp[_bf16](svbfloat16_t op, svbfloat16_t min, svbfloat16_t max);\r\n\r\nFor BFMLA and BFMLS\r\nsvbfloat16_t svmla[_bf16]_m(svbool_t pg, svbfloat16_t zda, svbfloat16_t zn,\r\n                            svbfloat16_t zm);\r\nsvbfloat16_t svmla[_bf16]_z(svbool_t pg, svbfloat16_t zda, svbfloat16_t zn,\r\n                            svbfloat16_t zm);\r\nsvbfloat16_t svmla[_bf16]_x(svbool_t pg, svbfloat16_t zda, svbfloat16_t zn,\r\n                            svbfloat16_t zm);\r\nsvbfloat16_t svmla[_n_bf16]_m(svbool_t pg, svbfloat16_t zda, svbfloat16_t zn,\r\n                              bfloat16_t zm);\r\nsvbfloat16_t svmla[_n_bf16]_z(svbool_t pg, svbfloat16_t zda, svbfloat16_t zn,\r\n                              bfloat16_t zm);\r\nsvbfloat16_t svmla[_n_bf16]_x(svbool_t pg, svbfloat16_t zda, svbfloat16_t zn,\r\n                              bfloat16_t zm);\r\n\r\nsvbfloat16_t svmla_lane[_bf16](svbfloat16_t zda, svbfloat16_t zn,\r\n                               svbfloat16_t zm, uint64_t\r\n\r\nAccording to the PR#257[1]\r\n[1]ARM-software/acle#257\r\n\r\nCo-authored-by: Matthew Devereau <matthew.devereau@arm.com>", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_bfadd.c", "functions": ["test_svadd_bf16_m", "test_svadd_bf16_x", "test_svadd_bf16_n_x", "test_svadd_bf16_n_m", "test_svadd_bf16_z", "SVE_ACLE_FUNC", "test_svadd_bf16_n_z"]}, {"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_bfclamp.c", "functions": ["SVE_ACLE_FUNC", "test_svclamp_bf16"]}, {"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_bfmax.c", "functions": ["test_svmax_bf16_n_m", "test_svmax_bf16_x", "test_svmax_bf16_m", "test_svmax_bf16_z", "test_svmax_bf16_n_z", "test_svmax_bf16_n_x", "SVE_ACLE_FUNC"]}, {"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_bfmaxnm.c", "functions": ["test_svmaxnm_bf16_n_z", "test_svmaxnm_bf16_m", "test_svmaxnm_bf16_z", "test_svmaxnm_bf16_n_x", "SVE_ACLE_FUNC", "test_svmaxnm_bf16_n_m", "test_svmaxnm_bf16_x"]}, {"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_bfmin.c", "functions": ["test_svmin_bf16_m", "test_svmin_bf16_n_x", "test_svmin_bf16_x", "test_svmin_bf16_n_m", "test_svmin_bf16_n_z", "test_svmin_bf16_z", "SVE_ACLE_FUNC"]}, {"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_bfminnm.c", "functions": ["test_svminnm_bf16_n_x", "test_svminnm_bf16_z", "test_svminnm_bf16_n_z", "test_svminnm_bf16_m", "test_svminnm_bf16_n_m", "test_svminnm_bf16_x", "SVE_ACLE_FUNC"]}, {"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_bfmla.c", "functions": ["test_svmla_n_bf16_m", "test_svmla_bf16_x", "test_svmla_bf16_z", "test_svmla_n_bf16_x", "test_svmla_bf16_m", "test_svmla_n_bf16_z", "SVE_ACLE_FUNC"]}, {"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_bfmla_lane.c", "functions": ["test_svmla_lane_bf16_idx1", "test_svmla_lane_bf16_idx7", "SVE_ACLE_FUNC", "test_svmla_lane_bf16_idx3"]}, {"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_bfmls.c", "functions": ["test_svmls_bf16_m", "test_svmls_bf16_x", "test_svmls_n_bf16_m", "test_svmls_n_bf16_x", "test_svmls_bf16_z", "SVE_ACLE_FUNC", "test_svmls_n_bf16_z"]}, {"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_bfmls_lane.c", "functions": ["test_svmls_lane_bf16_idx1", "test_svmls_lane_bf16_idx7", "test_svmls_lane_bf16_idx3", "SVE_ACLE_FUNC"]}, {"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_bfmul.c", "functions": ["test_svmul_bf16_n_z", "test_svmul_bf16_x", "test_svmul_bf16_m", "test_svmul_bf16_z", "test_svmul_bf16_n_m", "test_svmul_bf16_n_x", "SVE_ACLE_FUNC"]}, {"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_bfmul_lane.c", "functions": ["test_svmul_lane_bf16_idx3", "test_svmul_lane_bf16_idx1", "test_svmul_lane_bf16_idx7", "SVE_ACLE_FUNC"]}, {"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_bfsub.c", "functions": ["test_svsub_bf16_m", "test_svsub_bf16_n_z", "test_svsub_bf16_x", "test_svsub_bf16_n_x", "test_svsub_bf16_z", "test_svsub_bf16_n_m", "SVE_ACLE_FUNC"]}, {"filename": "clang/test/Sema/aarch64-sve2p1-intrinsics/acle_sve2p1_imm.cpp", "functions": ["test_svbfml_lane", "test_svbfmul_lane"]}]}
{"pr_number": 73015, "url": "https://github.com/llvm/llvm-project/pull/73015", "title": "[OpenACC] Implement Atomic construct variants", "body": "`atomic` is required to be followed by a special `atomic clause`, so this patch manages the parsing of that.  We are representing each of the variants of the atomic construct as separate kinds, because they have distinct rules/application/etc, and this should make it easier to check rules in the future.", "feature_layers": ["ir"], "feature_directives": ["atomic"], "files_changed": [{"filename": "clang/lib/Parse/ParseOpenACC.cpp", "functions": ["ParseOpenACCAtomicKind", "getOpenACCAtomicKind", "ParseOpenACCAtomicDirective", "getOpenACCAtomicDirectiveKind"]}]}
{"pr_number": 72611, "url": "https://github.com/llvm/llvm-project/pull/72611", "title": "[nfc][InstrProfTest]Factor out common code for value profile test", "body": "Three existing test cases {get_icall_data_read_write, get_icall_data_read_write_with_weight, get_icall_data_read_write_big_endian} have common test data and testing logic. Extract common code into  `testICallDataReadWrite`.\r\n- Add helper function `addValueProfData` and `testValueDataArray`. This two helper functions are used by `testICallDataReadWrite`, and possibly other test cases.\r\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/unittests/ProfileData/InstrProfTest.cpp", "functions": ["VD", "getFuncVDArrayForSerializationTest", "TearDown", "testValueProfileMergeSaturation", "addValueProfData", "testValueProfileMergeTrunc"]}]}
{"pr_number": 73004, "url": "https://github.com/llvm/llvm-project/pull/73004", "title": "[flang] Remove dead code and update test (NFC) ", "body": "OutputUnformattedBlock and InputUnformattedBlock are not used.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "flang/runtime/io-api.cpp", "functions": ["IONAME"]}]}
{"pr_number": 73032, "url": "https://github.com/llvm/llvm-project/pull/73032", "title": "[sanitizer_symbolizer] Add MarkupStackTracePrinter", "body": "This PR is part of a stack, #73029 should be merged\r\nand reviewed first. Please only review the last commit \r\nof this PR.\r\n\r\nAdds a new Implementation of StackTracePrinter that only\r\nemits symbolizer markup. Currently this change only\r\naffects Fuchsia OS. Should be NFC.", "feature_layers": ["ir", "ast"], "feature_directives": [], "files_changed": [{"filename": "compiler-rt/lib/sanitizer_common/sanitizer_stacktrace_printer.cpp", "functions": ["new"]}, {"filename": "compiler-rt/lib/sanitizer_common/sanitizer_symbolizer_markup.cpp", "functions": ["new", "RenderNeedsSymbolization"]}]}
{"pr_number": 73047, "url": "https://github.com/llvm/llvm-project/pull/73047", "title": "[mlir][sparse] code cleanup", "body": "removed two unused methods, removed obsoleted FIXME", "feature_layers": ["parse", "ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/IR/SparseTensorDialect.cpp", "functions": ["getStaticDimSliceSize", "getDimSlice"]}]}
{"pr_number": 71564, "url": "https://github.com/llvm/llvm-project/pull/71564", "title": "Supports viewing class member variables in lambda when using the vs debugger", "body": "Use \"__this\" in DataMemberRecord, make vs debugger can be parsed normally\r\n\r\nFixes #71562", "feature_layers": ["parse"], "feature_directives": [], "files_changed": [{"filename": "clang/test/CodeGenCXX/debug-info-lambda-this.cpp", "functions": ["foo", "main"]}]}
{"pr_number": 72493, "url": "https://github.com/llvm/llvm-project/pull/72493", "title": "[mlir][vector] Move transpose with unit-dim to shape_cast pattern", "body": "Moved from lowering to canonicalization.", "feature_layers": ["ir", "ast"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/Vector/IR/VectorOps.cpp", "functions": ["failure", "success"]}, {"filename": "mlir/lib/Dialect/Vector/Transforms/LowerVectorTranspose.cpp", "functions": ["success"]}]}
{"pr_number": 72835, "url": "https://github.com/llvm/llvm-project/pull/72835", "title": "[X86][MC] Support encoding/decoding for JMPABS", "body": "JMPABS is a 64-bit only ISA extension, and acts as a near-direct branch with an absolute target. The 64-bit immediate operand is treated an as absolute effective address, which is subject to canonicality checks. It is in legacy map 0 and requires REX2 prefix with `REX2.M0=0` and `REX2.W=0`. All other REX2 payload bits are ignored.\r\n\r\nblog: https://kanrobert.github.io/rfc/All-about-APX-JMPABS/\r\n\r\nThis patch\r\n1. Extends `ExplicitVEXPrefix` to `ExplicitOpPrefix` for instrcutions requires explicit `REX2` or `EVEX`\r\n2. Adds `ATTR_REX2` and `IC_64BIT_REX2` to put `JMPABS` , `MOV EAX, moffs32` in different tables to avoid opcode conflict \r\n\r\nNOTE:\r\n1. `ExplicitREX2Prefix` can be reused by the following PUSHP/POPP instructions.\r\n2. `ExplicitEVEXPrefix` will be used by the instructions promoted to EVEX space for EGPR.\r\n", "feature_layers": ["ir"], "feature_directives": ["for", "target", "requires"], "files_changed": [{"filename": "llvm/utils/TableGen/X86DisassemblerTables.cpp", "functions": ["if"]}, {"filename": "llvm/utils/TableGen/X86RecognizableInstr.cpp", "functions": ["if"]}]}
{"pr_number": 69676, "url": "https://github.com/llvm/llvm-project/pull/69676", "title": "Reland \"[clang][Sema] Use original template pattern when declaring implicit deduction guides for nested template classes\"", "body": "Reland of dd0fba11690f9fef304d5f48cde646e5eca8d3c0\r\n\r\nWhen a nested template is instantiated, the template pattern of the inner class is not copied into the outer class\r\nClassTemplateSpecializationDecl. The specialization contains a ClassTemplateDecl with an empty record that points to the original template pattern instead.\r\n\r\nAs a result, when looking up the constructors of the inner class, no results are returned. This patch finds the original template pattern and uses that for the lookup instead.\r\n\r\nBased on CWG2471 we must also substitute the known outer template arguments when creating deduction guides for the inner class.\r\n\r\nChanges from the last iteration:\r\n1. The outer retained levels from the outer template are always added to the `MultiLevelTemplateArgumentList` for rewriting `FunctionTemplateDecl` arguments, even if there is no FTD and the arguments are empty.\r\n2. When building implicit deduction guides, the template pattern underlying decl is pushed as the current context. This resolves the issue where `FindInstantiatedDecl` is unable to find the inner template class.\r\n3. Tests are updated to cover the failing case, and to assert that the type is correct after argument deduction in the implicit case. ", "feature_layers": ["sema", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Sema/SemaTemplate.cpp", "functions": ["SavedContext"]}, {"filename": "clang/test/SemaTemplate/nested-implicit-deduction-guides.cpp", "functions": ["N"]}]}
{"pr_number": 72918, "url": "https://github.com/llvm/llvm-project/pull/72918", "title": "Revert \"[mlir][vector] Move transpose with unit-dim to shape_cast pattern (#72493)\"", "body": "This reverts commit 95acb33b458128b7ff2314efa3b41b93b3897179.", "feature_layers": ["ir", "ast"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/Vector/IR/VectorOps.cpp", "functions": ["failure", "success"]}, {"filename": "mlir/lib/Dialect/Vector/Transforms/LowerVectorTranspose.cpp", "functions": ["success"]}]}
{"pr_number": 71545, "url": "https://github.com/llvm/llvm-project/pull/71545", "title": "[llvm][ARM] Emit MVE .arch_extension after .fpu directive if it does not include MVE features", "body": "The floating-point and MVE features together specify the MVE functionality that is supported on the Cortex-M85 processor. But the FPU extension for the underlying architecture(armv8.1-m.main) is FPV5 which does not include MVE-F. So Compiler's -S output and `-save-temps=obj` loses MVE feature which leads to assembler error. What happening here is .fpu directive overrides any previously set features by .cpu directive. Since the the corresponding .fpu generated (.fpu fpv5-d16) does not include MVE-F, it overrides those features even though it is supported and set by the .cpu directive. Looks like .fpu is supposed to do this.\r\n\r\nIn this case, there should be an .arch_extension directive re-enabling the relevant extensions after .fpu  if the goal is to keep these extensions enabled. GCC also does the same.\r\n\r\nSo this patch enables the MVE features by emitting the below arch extension:\r\n  .fpu fpv5-d16\r\n  .arch_extension mve.fp", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/ARM/MCTargetDesc/ARMTargetStreamer.cpp", "functions": ["if"]}, {"filename": "clang/test/CodeGen/arm-v8.1m-check-mve.c", "functions": ["foo"]}]}
{"pr_number": 72867, "url": "https://github.com/llvm/llvm-project/pull/72867", "title": "[IR][TLI] Cache getLibFunc() result on Function (NFC)", "body": "Cache the result of the TLI libfunc lookup in the Function object. This only caches the actual lookup of the LibFunc in the TLI map, but not the prototype validation, as that might differ between different TLI instances.\r\n\r\nThis uses the existing mechanism for invalidating the intrinsic ID when the function name changes. The libfunc will be invalidated in that case as well.\r\n\r\nThis results in a small compile-time improvement: http://llvm-compile-time-tracker.com/compare.php?from=a2e1de193477e7d92ec5c0a2ecd17a622cbf7aed&to=125c1c7aa60d73a3b041e9a011ff1d41c3d6194b&stat=instructions:u\r\n\r\nI don't believe this increases the size of Function on 64bit (which currently has a trailing `bool` member), and I don't think we would particularly care if it did, as Functions are uncommon as Values go.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Analysis/TargetLibraryInfo.cpp", "functions": ["getLibFunc", "isValidProtoForLibFunc"]}]}
{"pr_number": 72903, "url": "https://github.com/llvm/llvm-project/pull/72903", "title": "[FuncSpec] Update function specialization to handle phi-chains", "body": "When using the LLVM flang compiler with alias analysis (AA) enabled, SPEC2017:548.exchange2_r was running significantly slower than wihtout the AA.\r\n\r\nThis was caused by the GVN pass replacing many of the loads in the pre-AA code with phi-nodes that form a long chain of dependencies, which the function specialization was unable to follow.\r\n\r\nThis adds a function to discover phi-nodes in a transitive set, with some limitations to avoid spending ages analysing phi-nodes.\r\n\r\nThe minimum latency savings also had to be lowered - fewer load instructions means less saving.\r\n\r\nAdding some more prints to help debugging the isProfitable decision.\r\n\r\nNo significant change in compile time or generated code-size.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/IPO/FunctionSpecialization.cpp", "functions": ["if"]}]}
{"pr_number": 72890, "url": "https://github.com/llvm/llvm-project/pull/72890", "title": "[mlir][ArmSME] Move ArmSME -> intrinsics lowerings to `convert-arm-sme-to-llvm` pass", "body": "This gives more flexibility with when these lowerings are performed, without also lowering unrelated vector ops.\r\n\r\nThis is a NFC (other than adding a new `-convert-arm-sme-to-llvm` pass)", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Conversion/ArmSMEToLLVM/ArmSMEToLLVM.cpp", "functions": ["target", "converter"]}, {"filename": "mlir/lib/Conversion/VectorToLLVM/ConvertVectorToLLVMPass.cpp", "functions": ["armSMEConverter"]}]}
{"pr_number": 72284, "url": "https://github.com/llvm/llvm-project/pull/72284", "title": "[DebugInfo][RemoveDIs] Implement redundant elimination for DPValues", "body": "This pass steps through a block forwards and backwards, identifying those variable assignment records that are redundant, and erases them, saving us a decent wedge of compile-time. This patch re-implements it to use the replacement for DbgValueInsts, DPValues, in an almost identical way.\r\n\r\nAlas the test I've added the try-remove-dis flag to is the only one I've been able to find that manually runs this pass.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Utils/BasicBlockUtils.cpp", "functions": ["DPValuesRemoveRedundantDbgInstrsUsingBackwardScan", "DPValuesRemoveRedundantDbgInstrsUsingForwardScan", "Key"]}]}
{"pr_number": 72967, "url": "https://github.com/llvm/llvm-project/pull/72967", "title": "[mlir] `im2col` & `l2cache` on cp.async.bulk.tensor.shared.cluster.global`", "body": "PR adds support of `im2col` and `l2cache` to `cp.async.bulk.tensor.shared.cluster.global`. The Op is now supports all the traits of the corresponding PTX instruction. \r\n\r\nThe current structure of this operation looks somewhat like below. The PR also simplifies types so we don't need to write obvious types after `:` anymore. \r\n```\r\nnvvm.cp.async.bulk.tensor.shared.cluster.global\r\n\t\t%dest, %tmaDescriptor, %barrier,\r\n\t\tbox[%crd0,%crd1,%crd2,%crd3,%crd4]\r\n\t\tim2col[%off0,%off1,%off2] \t\t\t<-- PR introduces\r\n\t\tmulticast_mask = %ctamask\r\n\t\tl2_cache_hint = %cacheHint\t\t\t<-- PR introduces\r\n\t\t: !llvm.ptr<3>, !llvm.ptr\r\n```\r\n\r\n", "feature_layers": ["ir", "ast"], "feature_directives": ["barrier"], "files_changed": [{"filename": "mlir/lib/Dialect/LLVMIR/IR/NVVMDialect.cpp", "functions": ["emitError"]}]}
{"pr_number": 70790, "url": "https://github.com/llvm/llvm-project/pull/70790", "title": "[Flang][OpenMP] NFC: Minor refactoring of Reduction lowering code", "body": "Move reduction lowering code into a ReductionProcessor class. Create an enumeration for Intrinsic Procedure reductions.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Lower/OpenMP.cpp", "functions": ["getRealName", "guard", "if", "modBuilder", "getReductionName"]}]}
{"pr_number": 72985, "url": "https://github.com/llvm/llvm-project/pull/72985", "title": "[clang][dataflow] Clear `ExprToLoc` and `ExprToVal` at the start of a block.", "body": "We never need to access entries from these maps outside of the current basic\nblock. This could only ever become a consideration when flow control happens\ninside a full-expression (i.e. we have multiple basic blocks for a full\nexpression); there are two kinds of expression where this can happen, but we\nalready deal with these in other ways:\n\n*  Short-circuiting logical operators (`&&` and `||`) have operands that live in\n   different basic blocks than the operator itself, but we already have code in\n   the framework to retrieve the value of these operands from the environment\n   for the block they are computed in, rather than in the environment of the\n   block containing the operator.\n\n*  The conditional operator similarly has operands that live in different basic\n   blocks. However, we currently don't implement a transfer function for the\n   conditional operator. When we do this, we need to retrieve the values of the\n   operands from the environments of the basic blocks they live in, as we\n   already do for logical operators. This patch adds a comment to this effect\n   to the code.\n\nClearing out `ExprToLoc` and `ExprToVal` has two benefits:\n\n*  We avoid performing joins on boolean expressions contained in `ExprToVal` and\n   hence extending the flow condition in cases where this is not needed. Simpler\n   flow conditions should reduce the amount of work we do in the SAT solver.\n\n* Debugging becomes easier when flow conditions are simpler and `ExprToLoc` /\n  `ExprToVal` don\u2019t contain any extraneous entries.\n\nBenchmark results on Crubit's `pointer_nullability_analysis_benchmark show a\nslight runtime increase for simple benchmarks, offset by substantial runtime\nreductions for more complex benchmarks:\n\n```\nname                              old cpu/op   new cpu/op   delta\nBM_PointerAnalysisCopyPointer     29.8\u00b5s \u00b1 1%  29.9\u00b5s \u00b1 4%     ~     (p=0.879 n=46+49)\nBM_PointerAnalysisIntLoop          101\u00b5s \u00b1 3%   104\u00b5s \u00b1 4%   +2.96%  (p=0.000 n=55+57)\nBM_PointerAnalysisPointerLoop      378\u00b5s \u00b1 3%   245\u00b5s \u00b1 3%  -35.09%  (p=0.000 n=47+55)\nBM_PointerAnalysisBranch           118\u00b5s \u00b1 2%   122\u00b5s \u00b1 3%   +3.37%  (p=0.000 n=59+59)\nBM_PointerAnalysisLoopAndBranch    779\u00b5s \u00b1 3%   413\u00b5s \u00b1 5%  -47.01%  (p=0.000 n=56+45)\nBM_PointerAnalysisTwoLoops         187\u00b5s \u00b1 3%   192\u00b5s \u00b1 5%   +2.80%  (p=0.000 n=57+58)\nBM_PointerAnalysisJoinFilePath    17.4ms \u00b1 3%   7.2ms \u00b1 3%  -58.75%  (p=0.000 n=58+57)\nBM_PointerAnalysisCallInLoop      14.7ms \u00b1 4%  10.3ms \u00b1 2%  -29.87%  (p=0.000 n=56+58)\n```\n", "feature_layers": ["runtime", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/unittests/Analysis/FlowSensitive/DataflowEnvironmentTest.cpp", "functions": ["Env2", "Env1"]}, {"filename": "clang/unittests/Analysis/FlowSensitive/TypeErasedDataflowAnalysisTest.cpp", "functions": ["target", "foo", "DACtx", "Env", "runDataflowAnalysis"]}]}
{"pr_number": 72850, "url": "https://github.com/llvm/llvm-project/pull/72850", "title": "[clang][dataflow] Discard unneeded `ExprToLoc` and `ExprToVal` entries.", "body": "This has two major benefits:\n\n*  We avoid performing joins on boolean expressions and hence extending the flow\n   condition in cases where this is not needed. Simpler flow conditions should\n   reduce the amount of work we do in the SAT solver.\n\n*  Debugging becomes easier when flow conditions are simpler and ExprToVal\n   doesn\u2019t contain any extraneous entries.\n\nIn tests on an internal codebase, we see a reduction in SAT solver timeouts of\nover 40% and a reduction in \"reached maximum iterations\" errors of over 60%.\n\nBenchmark results on Crubit's `pointer_nullability_analysis_benchmark show a\nslight runtime increase for simple benchmarks, offset by runtime reductions\n(some of them substantial) for more complex benchmarks:\n\n```\nname                              old cpu/op   new cpu/op   delta\nBM_PointerAnalysisCopyPointer     29.5\u00b5s \u00b1 2%  32.0\u00b5s \u00b1 3%   +8.42%  (p=0.000 n=46+47)\nBM_PointerAnalysisIntLoop          100\u00b5s \u00b1 3%   109\u00b5s \u00b1 3%   +9.40%  (p=0.000 n=54+60)\nBM_PointerAnalysisPointerLoop      376\u00b5s \u00b1 4%   253\u00b5s \u00b1 3%  -32.51%  (p=0.000 n=48+55)\nBM_PointerAnalysisBranch           116\u00b5s \u00b1 3%   126\u00b5s \u00b1 3%   +9.23%  (p=0.000 n=60+59)\nBM_PointerAnalysisLoopAndBranch    776\u00b5s \u00b1 3%   425\u00b5s \u00b1 4%  -45.20%  (p=0.000 n=59+59)\nBM_PointerAnalysisTwoLoops         184\u00b5s \u00b1 2%   200\u00b5s \u00b1 3%   +8.48%  (p=0.000 n=59+58)\nBM_PointerAnalysisJoinFilePath    17.3ms \u00b1 3%   9.4ms \u00b1 2%  -45.48%  (p=0.000 n=60+60)\nBM_PointerAnalysisCallInLoop      14.7ms \u00b1 2%  11.0ms \u00b1 3%  -25.02%  (p=0.000 n=57+56)\n```\n\nRunning the pointer nullability check on several real-world files shows no\nsignificant change in runtime.\n", "feature_layers": ["runtime"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Analysis/FlowSensitive/TypeErasedDataflowAnalysis.cpp", "functions": ["Builder", "AC"]}, {"filename": "clang/unittests/Analysis/FlowSensitive/DataflowEnvironmentTest.cpp", "functions": ["ExprToDiscard", "ExprToKeep", "Env1"]}, {"filename": "clang/unittests/Analysis/FlowSensitive/TypeErasedDataflowAnalysisTest.cpp", "functions": ["target", "foo", "DACtx", "Env", "runDataflowAnalysis"]}]}
{"pr_number": 71826, "url": "https://github.com/llvm/llvm-project/pull/71826", "title": "[AArch64] Add check that prologue insertion doesn't clobber live regs.", "body": "This patch extends AArch64FrameLowering::emitProglogue to check if the inserted prologue clobbers live registers.\r\n\r\nIt updates `llvm/test/CodeGen/AArch64/framelayout-scavengingslot.mir` with an extra load to make x9 live before the store, preserving the original test.\r\n\r\nIt uses the original `llvm/test/CodeGen/AArch64/framelayout-scavengingslot.mir` as `llvm/test/CodeGen/AArch64/emit-prologue-clobber-verification.mir`, because there x9 is marked as live on entry, but used as scratch reg as it is not callee saved.\r\n\r\nThe new assertion catches a mis-compile in `store-swift-async-context-clobber-live-reg.ll` on https://github.com/apple/llvm-project/tree/next", "feature_layers": ["codegen", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AArch64/AArch64FrameLowering.cpp", "functions": ["LiveRegs"]}]}
{"pr_number": 73058, "url": "https://github.com/llvm/llvm-project/pull/73058", "title": "[mlir][sparse] change dim level type -> level type", "body": "The \"dimension\" before \"level\" does not really make sense Note that renaming the actual type DimLevelType to LevelType is still TBD, since this is an externally visible change (e.g. visible to Python API).", "feature_layers": ["parse", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/IR/SparseTensorDialect.cpp", "functions": ["callback"]}, {"filename": "mlir/lib/Dialect/SparseTensor/Transforms/Sparsification.cpp", "functions": ["findAffine", "isCompressedLT", "findDepIdxSet", "isCompressedDLT"]}]}
{"pr_number": 72003, "url": "https://github.com/llvm/llvm-project/pull/72003", "title": "[mlir] Add narrow type emulation for `memref.reinterpret_cast`", "body": "", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/MemRef/Transforms/EmulateNarrowType.cpp", "functions": ["success", "convertCastingOp"]}]}
{"pr_number": 72919, "url": "https://github.com/llvm/llvm-project/pull/72919", "title": "Remove `__cdecl` from _ReturnAddress", "body": "As an intrinsic, `_ReturnAddress` does not need it; additionally,\r\nif someone else declares `_ReturnAddress` without `__cdecl` (for\r\nexample, `<intrin.h>`)\r\n\r\nAdditionally, actually add a test for this change. I've tested it locally with both LLVM and MSVC.", "feature_layers": [], "feature_directives": ["for", "declare"], "files_changed": [{"filename": "compiler-rt/test/asan/TestCases/Windows/msvc/gz.cpp", "functions": ["main"]}]}
{"pr_number": 73073, "url": "https://github.com/llvm/llvm-project/pull/73073", "title": "[Clang][Coroutines] Properly emit EH code for initial suspend `await_resume` ", "body": "This change aims to fix an ICE in issue https://github.com/llvm/llvm-project/issues/63803\r\n\r\nThe crash happens in `ExitCXXTryStmt` because `EmitAnyExpr()` adds additional cleanup to the `EHScopeStack`. This messes up the assumption in `ExitCXXTryStmt` that the top of the stack should be a `EHCatchScope`. \r\n\r\nHowever, since we never read a value returned from `await_resume()` of an init suspend, we can skip the part that builds this `RValue`.\r\n\r\nThe code here may not be in the best shape. There's another bug that `memberCallExpressionCanThrow` doesn't work on the current Expr due to type mismatch. I am preparing a separate PR to address it plus some refactoring might be beneficial. ", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CodeGenCoroutines/coro-init-await-nontrivial-return.cpp", "functions": ["final_suspend", "unhandled_exception", "await_suspend", "initial_suspend", "return_void", "await_ready", "get_return_object", "await_resume", "coro_create"]}]}
{"pr_number": 71502, "url": "https://github.com/llvm/llvm-project/pull/71502", "title": "P1957R2: remove special-case for booleans in std::variant", "body": "This picks up the std::variant half of P1957R2. Fixes #62332.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "libcxx/test/std/utilities/variant/variant.variant/variant.ctor/T.pass.cpp", "functions": ["test_vector_bool"]}, {"filename": "libcxx/test/std/utilities/variant/variant.variant/variant.assign/T.pass.cpp", "functions": ["test_T_assignment_vector_bool"]}]}
{"pr_number": 72004, "url": "https://github.com/llvm/llvm-project/pull/72004", "title": "[mlir] Add subbyte emulation support for `memref.store`.", "body": "", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/MemRef/Transforms/EmulateNarrowType.cpp", "functions": ["success", "getValueOrCreateConstantIndexOp"]}]}
{"pr_number": 72181, "url": "https://github.com/llvm/llvm-project/pull/72181", "title": "[mlir] Add narrow type emulation conversions", "body": "Adds narrow type emulation support for:\r\n    - `memref.alloca`\r\n    - `memref.store`\r\n    - `memref.reinterpret_cast`\r\n\r\nFixes https://github.com/openxla/iree/issues/15370", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/MemRef/Transforms/EmulateNarrowType.cpp", "functions": ["success", "getValueOrCreateConstantIndexOp"]}]}
{"pr_number": 72745, "url": "https://github.com/llvm/llvm-project/pull/72745", "title": "[mlir] Fix `TileUsingForOp` attr-dict printing/parsing, cleanup assembly format", "body": "`TileUsingForOp` has an optional Attribute `interchange` which was given in curly braces like this: `{interchange = [...]}`. The way this was parsed meant that no normal `attr-dict` could be attached to the Op.\r\nThis patch changes the assembly format of the op to represent the `interchange` Attribute more like other array Attributes in the transform Ops and adds printing/parsing of an optional attr-dict.\r\n\r\n`transform.structured.tile_using_for %0 [5, 6] interchange [1, 0]`", "feature_layers": ["parse", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Linalg/TransformOps/LinalgTransformOps.cpp", "functions": ["success"]}]}
{"pr_number": 73178, "url": "https://github.com/llvm/llvm-project/pull/73178", "title": "Revert \"[mlir] Fix `TileUsingForOp` attr-dict printing/parsing, cleanup assembly format\"", "body": "Reverts llvm/llvm-project#72745 as it is causing test failures on mlir-nvidia in \r\n`mlir/test/python/dialects/transform_structured_ext.py`.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Linalg/TransformOps/LinalgTransformOps.cpp", "functions": ["success"]}]}
{"pr_number": 72765, "url": "https://github.com/llvm/llvm-project/pull/72765", "title": "Make MLIR Value more consistent in terms of `const` \"correctness\" (NFC)", "body": "MLIR can't really be const-correct (it would need a `ConstValue` class alongside the `Value` class really, like `ArrayRef` and `MutableArrayRef`). This is however making is more consistent: method that are directly modifying the Value shouldn't be marked const.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/examples/toy/Ch4/mlir/Dialect.cpp", "functions": ["handleTerminator"]}, {"filename": "mlir/examples/toy/Ch5/mlir/Dialect.cpp", "functions": ["handleTerminator"]}, {"filename": "mlir/examples/toy/Ch6/mlir/Dialect.cpp", "functions": ["handleTerminator"]}, {"filename": "mlir/examples/toy/Ch7/mlir/Dialect.cpp", "functions": ["handleTerminator"]}, {"filename": "mlir/lib/Dialect/Func/Extensions/InlinerExtension.cpp", "functions": ["handleTerminator"]}, {"filename": "mlir/lib/Dialect/LLVMIR/IR/LLVMInlining.cpp", "functions": ["handleTerminator"]}, {"filename": "mlir/lib/Dialect/Linalg/IR/LinalgDialect.cpp", "functions": ["handleTerminator"]}, {"filename": "mlir/lib/Dialect/SCF/IR/SCF.cpp", "functions": ["handleTerminator"]}, {"filename": "mlir/lib/Dialect/SPIRV/IR/SPIRVDialect.cpp", "functions": ["handleTerminator"]}, {"filename": "mlir/test/lib/Dialect/Test/TestDialectInterfaces.cpp", "functions": ["handleTerminator"]}]}
{"pr_number": 72000, "url": "https://github.com/llvm/llvm-project/pull/72000", "title": "[RISCV][GISel] Add support for G_IS_FPCLASS in F and D extensions", "body": "Add legalizer, regbankselect, and isel supports for floating point version of G_IS_FPCLASS.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp", "functions": ["GFpClassImm", "selectIsFPClass"]}, {"filename": "llvm/lib/Target/RISCV/GISel/RISCVLegalizerInfo.cpp", "functions": ["MIB", "GFpClassImm", "STI"]}]}
{"pr_number": 72605, "url": "https://github.com/llvm/llvm-project/pull/72605", "title": "[sanitizer_symbolizer] Add initial symbolizer markup", "body": "for linux\r\n\r\nAdds initial support of symbolizer markup for linux. This change adds a runtime sanitizer common flag `enable_symbolizer_markup` that controls the instance of the StackTracePrinter to be used, besides that, it also controls the usage of the implementation of SymbolizerTool that produces symbolizer markup `MarkupSymbolizerTool`.\r\n\r\nComming in future PRs:\r\n- There is some repetition of code between the implementation of the fuchsia symbolizer markup and the more generic symbolizer markup. Making these changes in a different PR will guarantee it is an NFC.\r\n- The RenderContext code uses the Symbolizer list of modules to render the list of modules, according to the symbolizer markup spec. This dependency between the Renderer and Symbolizer can be removed by using a ListOfModules directly and hooking into the right interceptors. Also defering it to make sure it is an NFC.", "feature_layers": ["runtime", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "compiler-rt/lib/sanitizer_common/sanitizer_stacktrace_printer.cpp", "functions": ["l"]}, {"filename": "compiler-rt/lib/sanitizer_common/sanitizer_symbolizer_markup.cpp", "functions": ["new"]}, {"filename": "compiler-rt/lib/sanitizer_common/sanitizer_symbolizer_markup_fuchsia.cpp", "functions": ["new", "l"]}, {"filename": "compiler-rt/test/asan/TestCases/use-after-free-symbolizer-markup.cpp", "functions": ["main"]}, {"filename": "compiler-rt/test/hwasan/TestCases/use-after-free-symbolizer-markup.c", "functions": ["main"]}]}
{"pr_number": 72889, "url": "https://github.com/llvm/llvm-project/pull/72889", "title": "[LinkerWrapper] Accept some needed lld-link linker arguments for COFF targets", "body": "Summary:\nThe linker wrapper is a utility used to create offloading programs from\nsingle-source offloading languages such as OpenMP or CUDA. This is done\nby embedding device code into the host object, then feeding it into the\nlinker wrapper which extracts the accelerator object files, links them,\nthen wraps them in registration code for the target  runtime. This\npreviously has only worked in Linux / ELF platforms.\n\nThis patch attempts to hand Windows / COFF inputs by also accepting COFF\nforms of certain linker arguments we use internally. The important\narguments are library search paths, so we can identify libraries which\nmay contain device code, libraries themselves, and the output name used\nfor intermediate output.\n\nI am not intimately familiar with the semantics here for the semantics\nin how a `lib` file is earched. I am simply treating `foo.lib` as the\nGNU equivalent `-l:foo.lib` in the search logic. Similarly, I am\nassuming that static libraries will be llvm-ar style libraries. I will\nneed to investigate the actual deficiencies later, but this should be a\ngood starting point along with https://github.com/llvm/llvm-project/pull/72697\n", "feature_layers": ["sema", "runtime"], "feature_directives": ["for", "single", "target"], "files_changed": [{"filename": "clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp", "functions": ["if"]}]}
{"pr_number": 73165, "url": "https://github.com/llvm/llvm-project/pull/73165", "title": "[nfc][InstrProfTest]Parameterize the edge cases of value profile merge by value kind", "body": "There are three test cases to test the merge of value profiles. 'get_icall_data_merge1' tests the basic case; {get_icall_data_merge1_saturation, get_icall_data_merge_site_trunc} tests the edge case. \r\n\r\nThis patch parameterizes the edge case test coverage by value kind and adds the coverage of 'IPVK_MemOPSize'. Keep the basic test structure as it is. The main reason is test data construction and test assertions is clearer for each kind in the basic test.\r\n- Using a loop for different value kinds in one test case doesn't work very well. The instr-prof-writer is stateful (e.g., keeps track of per-function profile data in a [container](https://github.com/llvm/llvm-project/blob/a9c149df7666bb2f8755794b97573134e5cfeb38/llvm/include/llvm/ProfileData/InstrProfWriter.h#L43))", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/unittests/ProfileData/InstrProfTest.cpp", "functions": ["getValueProfileKind", "VD", "SetUp"]}]}
{"pr_number": 72479, "url": "https://github.com/llvm/llvm-project/pull/72479", "title": "[clangd] Add includes from source to non-self-contained headers", "body": "It's a hack to solve include headers from source to non-self-contained headers\r\n\r\nLimitations:\r\n- header file must be matched by `isHeaderFile` without language options\r\n- non-self-contained header must be included by source\r\n- AST for source must be cached before open non-self-contained header\r\n- resolved only includes, without macros and symbols from source file\r\n\r\nExample:\r\n```cpp\r\n// header\r\n\r\nvoid hello(std::string Name);\r\n```\r\n```cpp\r\n// source\r\n#include <string>\r\n\r\n#include \"header.h\"\r\n\r\n#include <iostream>\r\n\r\nint main(){\r\n  hello(\"World\");\r\n  return 0;\r\n}\r\n\r\nvoid hello(std::string Name){\r\n  std::cout << \"Hello, \" << Name << \"\\n\";\r\n}\r\n```\r\n\r\nCurrent clangd behavior for header - show error `Use of undeclared identifier 'std'`\r\n\r\nWith this PR, clangd adds include <string> to command line for header\r\n\r\n\r\nPartially resolves clangd/clangd#45", "feature_layers": ["ast"], "feature_directives": ["for", "declare"], "files_changed": [{"filename": "clang-tools-extra/clangd/TUScheduler.cpp", "functions": ["update"]}]}
{"pr_number": 70461, "url": "https://github.com/llvm/llvm-project/pull/70461", "title": "[Flang] Add partial support for lowering procedure pointer assignment.", "body": "**Scope of the PR:**\r\n1. Lowering global and local procedure pointer declaration statement with explicit or implicit interface. The explicit interface can be from an interface block, a module procedure or an internal procedure.\r\n2. Lowering procedure pointer assignment, where the target procedure could be external, module or internal procedures.\r\n3. Lowering reference to procedure pointers so that it works end to end.\r\n\r\n**PR notes:**\r\n1. The first commit of the PR does not include testing. I would like to collect some comments first, which may alter the output. Once I confirm the implementation, I will add some testing as a follow up commit to this PR.\r\n2. No special handling of the host-associated entities when an internal procedure is the target of a procedure pointer assignment in this PR.\r\n\r\n**Implementation notes:**\r\n1. The implementation is using the HLFIR path.\r\n2. Flang currently uses `getUntypedBoxProcType` to get the `fir::BoxProcType` for `ProcedureDesignator` when getting the address of a procedure in order to pass it as an actual argument. This PR inherits the same design decision for procedure pointer as the `fir::StoreOp` requires the same memory type.\r\n\r\n", "feature_layers": ["ir"], "feature_directives": ["for", "target", "requires"], "files_changed": [{"filename": "flang/lib/Lower/ConvertType.cpp", "functions": ["proc"]}, {"filename": "flang/lib/Lower/ConvertProcedureDesignator.cpp", "functions": ["proc"]}]}
{"pr_number": 71399, "url": "https://github.com/llvm/llvm-project/pull/71399", "title": "clang/CodeGen/RISCV: test lowering of math builtins", "body": "Ever since 98c90a1 (ISel: introduce vector ISD::LRINT, ISD::LLRINT; custom RISCV lowering) landed, there have been several discussions on how the lrint and llrint libcalls would lower to LLVM IR via clang on RV32 and RV64, in an effort to enable vectorization of lrint and llrint via SLPVectorizer and LoopVectorize. This patch adds a new math-builtins.c test to the RISC-V target to test the lowering of all math libcalls, including lrint and llrint.", "feature_layers": ["codegen", "ir"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "clang/test/CodeGen/RISCV/math-builtins.c", "functions": ["copysignf", "log10l", "copysign", "rintl", "roundf", "fmax", "exp2f", "log2l", "lrint", "exp2", "llrintl", "llroundl", "lround", "roundevenf", "sinl", "trunc", "lrintf", "logl", "round", "llroundf", "roundevenl", "ceil", "sinf", "sin", "cosl", "fmaxf", "ceill", "logf", "nearbyintl", "rintf", "ceilf", "fmodl", "exp2l", "truncf", "roundeven", "llround", "fabsl", "sqrt", "exp", "fabsf", "fmaxl", "fmod", "log10", "cos", "copysignl", "fminl", "powf", "truncl", "log2", "fabs", "lroundl", "test", "sqrtf", "lroundf", "rint", "llrintf", "expf", "floor", "fmin", "llrint", "floorl", "nearbyint", "log", "pow", "powl", "expl", "fminf", "log2f", "fmodf", "roundl", "sqrtl", "log10f", "lrintl", "cosf", "nearbyintf", "floorf"]}]}
{"pr_number": 73013, "url": "https://github.com/llvm/llvm-project/pull/73013", "title": "[mlir][LLVM] Support `immargs` in LLVM_IntrOpBase intrinsics", "body": "This extends `LLVM_IntrOpBase` so that it can be passed a list of `immArgPositions` and a list (of the same length) of `immArgAttrNames`. `immArgPositions` contains the positions of `immargs` on the LLVM IR intrinsic, and `immArgAttrNames` maps those to a corresponding MLIR attribute.\r\n\r\nThis allows modeling LLVM `immargs` as MLIR attributes, which is the closest match semantically (and had already been done manually for the LLVM dialect intrinsics).\r\n\r\nThis has two upsides:\r\n  * It's slightly easier to implement intrinsics with immargs now (especially if they make use of other features, such as overloads)\r\n  * It clearly defines that `immargs` should map to attributes, before there was no mention of `immargs` in LLVMOpBase.td, so implementing them was unclear\r\n\r\nThis works with other features of the `LLVM_IntrOpBase`, so `immargs` can be marked as overloaded too (which is used in some intrinsics).\r\n\r\nAs part of this patch (and to test correctness) existing intrinsics have been updated to use these new parameters.\r\n\r\nThis also uncovered a few issues with the\r\n`llvm.intr.vector.insert/extract` intrinsics. First, the argument order for insert did not match the LLVM intrinsic, and secondly, both were missing a mlirBuilder (so failed to import from LLVM IR). This is corrected with this patch (and a test case added).", "feature_layers": ["sema", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Target/LLVMIR/ModuleImport.cpp", "functions": ["failure", "if", "operands"]}, {"filename": "mlir/lib/Target/LLVMIR/ModuleTranslation.cpp", "functions": ["args"]}]}
{"pr_number": 72886, "url": "https://github.com/llvm/llvm-project/pull/72886", "title": "[clang] Ensure minimal alignment of global vars of incomplete type.", "body": "The SystemZ ABI requires any global variable to be aligned to at least 2 bytes, and therefore an external global Value with an opaque type should get this alignment as well.\r\n\r\n", "feature_layers": ["ir", "ast"], "feature_directives": ["for", "requires"], "files_changed": [{"filename": "clang/test/Driver/systemz-alignment.c", "functions": ["__attribute__"]}]}
{"pr_number": 73042, "url": "https://github.com/llvm/llvm-project/pull/73042", "title": "[DebugInfo][RemoveDIs] Instrument loop-deletion for DPValues", "body": "Loop deletion identifies dbg.value intrinsics in the loop, sets them to undef/poison, and sinks them to the exit of the loop, to ensure that any variable assignments that happen in a deleted loop are \"optimised out\". This needs to be replicated for DPValues, the non-instruction replacement for dbg.value intrinsics.\r\n\r\nThe movement API for DPValues is (deliberately) more limited than dbg.values, which is tricky because inserting the collection of dbg.values at an arbitary iterator can insert a dbg.value in the middle of a sequence of dbg.values. A big no-no for DPValues. This patch replicates the order by inserting DPValues in reverse at the head-iterator of the block, to ensure the same output as dbg.value mode. Technically the order isn't important, but we're trying to ensure identical outputs from optimisation passes right now.\r\n\r\nAdd more CHECK lines for dbg.values in diundef.ll to ensure that we don't create any spurious dbg.values, and to ensure that sequences of dbg.values come out of the optimisation in the correct order.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Utils/LoopUtils.cpp", "functions": ["Key"]}]}
{"pr_number": 73230, "url": "https://github.com/llvm/llvm-project/pull/73230", "title": "[SystemZ] Move new test into existing CodeGen test.", "body": "The test for emitted alignments is better placed in CodeGen.\r\n", "feature_layers": ["codegen"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CodeGen/SystemZ/align-systemz.c", "functions": ["__attribute__"]}, {"filename": "clang/test/Driver/systemz-alignment.c", "functions": ["__attribute__"]}]}
{"pr_number": 73147, "url": "https://github.com/llvm/llvm-project/pull/73147", "title": "[mlir] Workaround for export lib generation on Windows for `mlir_arm_sme_abi_stubs`", "body": "Using mlir cmake in downstream project fails with error\r\n```\r\nCMake Error at D:/projs/llvm/llvm-install/lib/cmake/mlir/MLIRTargets.cmake:2537 (message):\r\n  The imported target \"mlir_arm_sme_abi_stubs\" references the file\r\n\r\n     \"D:/projs/llvm/llvm-install/lib/mlir_arm_sme_abi_stubs.lib\"\r\n\r\n  but this file does not exist.  Possible reasons include:\r\n\r\n  * The file was deleted, renamed, or moved to another location.\r\n\r\n  * An install or uninstall procedure did not complete successfully.\r\n\r\n  * The installation package was faulty and contained\r\n\r\n     \"D:/projs/llvm/llvm-install/lib/cmake/mlir/MLIRTargets.cmake\"\r\n\r\n  but not all the files it references.\r\n\r\nCall Stack (most recent call first):\r\n  D:/projs/llvm/llvm-install/lib/cmake/mlir/MLIRConfig.cmake:37 (include)\r\n  mlir/CMakeLists.txt:5 (find_package)\r\n```\r\n\r\nWindows cmake needs export libaries but it seems they are only being generated if you have at least one exported symbol.\r\nAdd export attributes to symbols.\r\n\r\nNot sure what the best approach to fix this (probably we should just disable this lib on windows entirely), but it fixed things for me locally.", "feature_layers": ["ir", "ast"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "mlir/lib/ExecutionEngine/ArmSMEStubs.cpp", "functions": ["__arm_tpidr2_restore", "__arm_tpidr2_save", "__arm_za_disable", "__arm_sme_state", "__aarch64_sme_accessible"]}]}
{"pr_number": 73224, "url": "https://github.com/llvm/llvm-project/pull/73224", "title": "[mlir] do not inject malloc/free in to-LLVM translation", "body": "In the early days of MLIR-to-LLVM IR translation, it had to forcefully inject declarations of `malloc` and `free` functions as then-standard (now `memref`) dialect ops were unconditionally lowering to libc calls. This is no longer the case. Even when they do lower to libc calls, the signatures of those methods are injected at lowering since calls must target declared functions in valid IR. Don't inject those declarations anymore.", "feature_layers": ["ir"], "feature_directives": ["for", "target", "declare"], "files_changed": [{"filename": "mlir/lib/Target/LLVMIR/ModuleTranslation.cpp", "functions": ["builder"]}]}
{"pr_number": 73238, "url": "https://github.com/llvm/llvm-project/pull/73238", "title": "Reland [mlir] Workaround for export lib generation on Windows for mlir_arm_sme_abi_stubs #73147 ", "body": "https://github.com/llvm/llvm-project/pull/73147\r\n\r\nFixed the visibility macro", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/ExecutionEngine/ArmSMEStubs.cpp", "functions": ["__arm_tpidr2_restore", "__arm_tpidr2_save", "__arm_za_disable", "__arm_sme_state", "__aarch64_sme_accessible"]}]}
{"pr_number": 73221, "url": "https://github.com/llvm/llvm-project/pull/73221", "title": "[flang] Re-land #70461 (procedure pointer lowering)", "body": "#70461 was reverted by 49f55d107548a340992eaec1b9767c0f8fc443cd because of\r\nfailing gfotran tests in the llvm-test-suite.\r\n\r\n#70461 is correct, the issue is that no semantics errors are emitted for these \"bad fortran\" tests (used to be happy because they considered the lowering TODO as a semantic error).\r\n\r\nI opened an issue against semantic https://github.com/llvm/llvm-project/issues/73215 and I am disabling the tests in the meantime: https://github.com/llvm/llvm-test-suite/pull/55.", "feature_layers": ["sema"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Lower/ConvertProcedureDesignator.cpp", "functions": ["proc"]}, {"filename": "flang/lib/Lower/ConvertType.cpp", "functions": ["proc"]}]}
{"pr_number": 73131, "url": "https://github.com/llvm/llvm-project/pull/73131", "title": "[NFC] Add unit tests for TypeSize:isXBitVector", "body": "The tests are showing that the current behaviour isn't correct.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/CodeGen/ValueTypes.cpp", "functions": ["isExtendedVector"]}]}
{"pr_number": 72260, "url": "https://github.com/llvm/llvm-project/pull/72260", "title": "[SVE] Don't require lookup when demangling vector function mappings", "body": "We can determine the VF from a combination of the mangled name (which\r\nindicates the arguments that take vectors) and the element sizes of\r\nthe arguments for the scalar function the mapping has been established\r\nfor.\r\n\r\nThe assert when demangling fails has been removed in favour of just\r\nnot adding the mapping, which prevents the crash seen in\r\nhttps://github.com/llvm/llvm-project/issues/71892\r\n\r\nThis patch also stops using _LLVM_ as an ISA for scalable vector tests,\r\nsince there aren't defined rules for the way vector arguments should be\r\nhandled (e.g. packed vs. unpacked representation).\r\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Analysis/VFABIDemangling.cpp", "functions": ["getElementCountForTy"]}, {"filename": "llvm/tools/vfabi-demangle-fuzzer/vfabi-demangler-fuzzer.cpp", "functions": ["CI", "volatile"]}, {"filename": "llvm/unittests/Analysis/VectorFunctionABITest.cpp", "functions": ["CI"]}]}
{"pr_number": 68642, "url": "https://github.com/llvm/llvm-project/pull/68642", "title": "[libcxx] Unifying __is_trivial_equality_predicate and __is_trivial_plus_operation into __desugars_to", "body": "When working on an OpenMP offloading backend for standard parallel algorithms (https://github.com/llvm/llvm-project/pull/66968) we noticed the need of a generalization of `__is_trivial_plus_operation`. For now, I have converted `__is_trivial_equality_predicate` and `__is_trivial_plus_operation` into `__desugars_to`, and we may then extend the latter to support other binary operations as well.", "feature_layers": [], "feature_directives": ["parallel", "for"], "files_changed": [{"filename": "libcxx/test/libcxx/algorithms/pstl.transform_reduce.string.pass.cpp", "functions": ["test_execution_policy", "vec", "main"]}]}
{"pr_number": 67349, "url": "https://github.com/llvm/llvm-project/pull/67349", "title": "[ClangRepl] Type Directed Code Completion", "body": "Differential Revision: https://reviews.llvm.org/D159128", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "clang/lib/Interpreter/CodeCompletion.cpp", "functions": ["CompletionContextHandler", "handleMacro", "handlePattern", "CCC", "handleDeclaration", "handleKeyword"]}]}
{"pr_number": 73076, "url": "https://github.com/llvm/llvm-project/pull/73076", "title": "[BOLT] Extend calculateEmittedSize() for block size calculation", "body": "This commit modifies BinaryContext::calculateEmittedSize to update the BinaryBasicBlock::OutputAddressRange for each basic block in the input BF. The modification is done in place, where BinaryBasicBlock::getOutputSize() now gives the emitted size of the basic block.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "bolt/lib/Core/BinaryFunction.cpp", "functions": ["formatv"]}]}
{"pr_number": 73231, "url": "https://github.com/llvm/llvm-project/pull/73231", "title": "[mlir] fix LLVM type converter for structs", "body": "Existing implementation of the LLVM type converter for LLVM structs containing incompatible types was attempting to change identifiers of the struct in case of name clash post-conversion (all identified structs have different names post-conversion since one cannot change the body of the struct once initialized). Beyond a trivial error of not updating the counter in renaming, this approach was broken for recursive structs that can't be made aware of the renaming and would use the pre-existing struct with clashing name instead.\r\n\r\nFor example, given\r\n\r\n`!llvm.struct<\"_Converted.foo\", (struct<\"_Converted.foo\">, f32)>`\r\n\r\nthe following type\r\n\r\n`!llvm.struct<\"foo\", (struct<\"foo\", index>)>`\r\n\r\nwould incorrectly convert to\r\n\r\n```\r\n!llvm.struct<\"_Converted_1.foo\",\r\n             (struct<\"_Converted.foo\",\r\n\t             (struct<\"_Converted.foo\">, f32)>)>\r\n```\r\n\r\nRemove this incorrect renaming and simply refuse to convert types if it would lead to identifier clashes for structs with different bodies. Document the expectation that such generated names are reserved and must not be present in the input IR of the converter. If we ever actually need to use handle such cases, this can be achieved by temporarily renaming structs with reserved identifiers to an unreserved name and back in a pre/post-processing pass that does _not_ use the type conversion infra.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Conversion/LLVMCommon/TypeConverter.cpp", "functions": ["failure", "success"]}]}
{"pr_number": 71132, "url": "https://github.com/llvm/llvm-project/pull/71132", "title": "[libc++] <experimental/simd> Add implicit type conversion constructor for class simd/simd_mask", "body": "", "feature_layers": [], "feature_directives": ["for", "simd"], "files_changed": [{"filename": "libcxx/test/std/experimental/simd/simd.class/simd_ctor_conversion.pass.cpp", "functions": ["main", "constexpr", "operator"]}, {"filename": "libcxx/test/std/experimental/simd/simd.mask.class/simd_mask_ctor_conversion.pass.cpp", "functions": ["main", "constexpr", "operator"]}]}
{"pr_number": 73278, "url": "https://github.com/llvm/llvm-project/pull/73278", "title": "[NFC][X86] Clang-format X86RecognizableInstr.cpp", "body": "", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/utils/TableGen/X86RecognizableInstr.cpp", "functions": ["if", "byteFromRec", "Mnemonic", "llvm_unreachable"]}]}
{"pr_number": 73233, "url": "https://github.com/llvm/llvm-project/pull/73233", "title": "[X86][MC] Support encoding/decoding for PUSH2[P]/POP2[P]", "body": "PUSH2 and POP2 are two new instructions for (respectively) pushing/popping 2 GPRs at a time to/from\r\nthe stack. The opcodes of PUSH2 and POP2 are those of \u201cPUSH r/m\u201d and \u201cPOP r/m\u201d from legacy map 0, but we\r\nrequire ModRM.Mod = 3 in order to disallow memory operand. \r\n\r\nThe 1-bit Push-Pop Acceleration hint described in #73092 applies to PUSH2/POP2 too, then we have PUSH2P/POP2P.\r\n\r\nFor AT&T syntax, PUSH2[P] pushes the registers from right to left onto the stack. POP2[P] pops the stack to registers from right to left.  Intel syntax has the opposite order - from left to right. \r\n\r\nThe assembly syntax is aligned with GCC & binutils https://gcc.gnu.org/pipermail/gcc-patches/2023-November/637718.html \r\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/X86/Disassembler/X86Disassembler.cpp", "functions": ["consume"]}]}
{"pr_number": 73281, "url": "https://github.com/llvm/llvm-project/pull/73281", "title": "[SelectionDAG] Add instantiated OPC_CheckType", "body": "The most common type is i32 or i64 so we add `OPC_CheckTypeI32` and\n`OPC_CheckTypeI64` to save one byte.\n\nOverall this reduces the llc binary size with all in-tree targets by\nabout 29K.\n", "feature_layers": [], "feature_directives": ["target"], "files_changed": [{"filename": "llvm/utils/TableGen/DAGISelMatcherEmitter.cpp", "functions": ["getEnumName"]}]}
{"pr_number": 73287, "url": "https://github.com/llvm/llvm-project/pull/73287", "title": "[NFC][X86] Clang-format X86FrameLowering.cpp", "body": "", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/X86/X86FrameLowering.cpp", "functions": ["HasNestArgument"]}]}
{"pr_number": 72388, "url": "https://github.com/llvm/llvm-project/pull/72388", "title": "[AMDGPU] New AMDGPUInsertSingleUseVDST pass", "body": "Add support for emitting GFX11.5 s_singleuse_vdst instructions. This is\na power saving feature whereby the compiler can annotate VALU\ninstructions whose results are known to have only a single use, so the\nhardware can in some cases avoid writing the result back to VGPR RAM.\n\nTo begin with the pass is disabled by default because of one missing\nfeature: we need an exclusion list of opcodes that never qualify as\nsingle-use producers and/or consumers. A future patch will implement\nthis and enable the pass by default.\n", "feature_layers": [], "feature_directives": ["for", "single"], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/AMDGPUInsertSingleUseVDST.cpp", "functions": ["runOnMachineFunction", "emitSingleUseVDST"]}]}
{"pr_number": 71674, "url": "https://github.com/llvm/llvm-project/pull/71674", "title": "[mlir][vector][spirv] Lower vector.load and vector.store to SPIR-V", "body": "Add patterns to lower vector.load to spirv.load and vector.store to spirv.store.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Conversion/VectorToSPIRV/VectorToSPIRV.cpp", "functions": ["success"]}]}
{"pr_number": 69724, "url": "https://github.com/llvm/llvm-project/pull/69724", "title": "[clang][ASTImporter] Fix import of SubstTemplateTypeParmType in return type of function.", "body": "Import of a function with `auto` return type that is expanded to a `SubstTemplateTypeParmType` could fail if the function itself is the template specialization where the parameter was replaced.", "feature_layers": ["ast"], "feature_directives": [], "files_changed": [{"filename": "clang/unittests/AST/ASTImporterTest.cpp", "functions": ["testImport", "foo"]}]}
{"pr_number": 70499, "url": "https://github.com/llvm/llvm-project/pull/70499", "title": "[clang] Refactor TBAA Base Info construction", "body": "I noticed a few issues with `CodeGenTBAA::getBaseTypeInfo`.\r\n\r\n1) `isValidBaseType` explicitly checks for a reference type to return false, but then also returns false for all non-record types. Just remove that reference check.\r\n\r\n2) All uses of `CodeGenTBAA::getBaseTypeInfo` from within that class are when we've already checked the type `isValidBaseType`. The only case where this isn't true is from outside the class. `isValidBaseType` isn't a trivial check, so add a new `maybeGetBaseTypeInfo` entry point that returns nullptr for non-valid base types, and remove the check from the current entry point. Make that private too.\r\n\r\n3) The `BaseTypeMetadataCache` can legitimately store null values, but it also uses that to mean 'no entry', because of the use of `operator[]`. Hence it can continually recompute the metadata information for those types with null metadata. (AFAICT null entries can never become non-null.) Use `find` to lookup, and only compute when there was no entry.\r\n\r\n4) Both `getBaseTypeInfo` and `getBaseTypeInfoHelper` insert the metadata into the cache -- but the latter does so inconsistently. So only do the insertion in the former, and use `try_emplace` to insert and verify it didn't get unexpectedly inserted during its own calculation. (And side-effecting return statements make me uncomfortable.)\r\n\r\n5) Finally, `getBaseTypeInfoHelper` is rather tightly tied to `getBaseTypeInfo`, its only caller. It's more localized to use a lambda there, and will make it easier to be inlined into its only caller.\r\n\r\nI tried getting some performance data with bootstrap builds.  While some runs showed an improvement (.3%), there seemed to be quite a bit of noise, and .3% seems surprisingly high.", "feature_layers": ["codegen"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/CodeGen/CodeGenTBAA.cpp", "functions": ["getTypeInfo", "getBaseTypeInfo"]}]}
{"pr_number": 72546, "url": "https://github.com/llvm/llvm-project/pull/72546", "title": "[DebugInfo][RemoveDIs] Support cloning and remapping DPValues", "body": "NB: this contains three commits sadly, the first is #72526 (necessary), the second is a RemoveDIs utility update (see commit message), the third is the proper topic of this review:\r\n\r\n[DebugInfo][RemoveDIs] Support cloning and remapping DPValues\r\n\r\nThis patch adds support for CloneBasicBlock duplicating the DPValues\r\nattached to instructions, and adds facilities to remap them into their new\r\ncontext. The plumbing to achieve this is fairly straightforwards and\r\nmechanical.\r\n\r\nI've also added illustrative uses to LoopUnrollRuntime, SimpleLoopUnswitch\r\nand SimplifyCFG. The former only updates for the epilogue right now so I've\r\nadded CHECK lines just for the end of an unrolled loop (further updates\r\ncoming later). SimpleLoopUnswitch had no debug-info tests so I've added a\r\nnew one. The two modified parts of SimplifyCFG are covered by the two\r\nmodified SimplifyCFG tests.\r\n\r\nThese are scenarios where we have to do extra cloning for copying of\r\nDPValues because they're no longer instructions, and remap them too.\r\n", "feature_layers": ["runtime", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Utils/ValueMapper.cpp", "functions": ["remapDPValue"]}]}
{"pr_number": 72105, "url": "https://github.com/llvm/llvm-project/pull/72105", "title": "[mlir][vector] Add vector.transpose with unit-dim to vector.shape_cast pattern", "body": "This patch extends the vector.transpose lowering to replace:\r\n\r\n  vector.transpose %0, [1, 0] : vector<nx1x<eltty>> to vector<1xnx<eltty>>\r\n\r\nwith:\r\n\r\n  vector.shape_cast %0 : vector<nx1x<eltty>> to vector<1xnx<eltty>>\r\n\r\nSource with leading unit-dim (inverse) is also replaced. Unit dim must be fixed. Non-unit dim can be scalable.\r\n\r\nA check is also added to bail out for scalable vectors before unrolling.", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Vector/Transforms/LowerVectorTranspose.cpp", "functions": ["failure", "success"]}]}
{"pr_number": 72719, "url": "https://github.com/llvm/llvm-project/pull/72719", "title": "[GISel][RISCV] Fix several boundary cases in narrow G_SEXT_INREG.", "body": "This fixes cases when SizeInBits is a multiple of the narrow size.\r\n\r\nIf SizeBits is equal to NarrowTy size, the first block would create an illegal G_SEXT_INREG where the the extension size is equal to the type. I tried to turn it into G_TRUNC+G_SEXT, but that just turned back into G_SEXT_INREG causing an infinite loop. So punt to the splitting case.\r\n\r\nIn the for loop we should copy when the part ends on SizeInBits. In that case there is no G_SEXT_INREG needed for partial. But we should note that register in PartialExtensionReg for the first full part to use.\r\n\r\nIf the part starts on SizeInBits then we should do an AShr of PartialExtensionReg.\r\n\r\nWe should only get to the G_SEXT_INREG case if the SizeInBits is in the middle of the part.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp", "functions": ["if"]}]}
{"pr_number": 73300, "url": "https://github.com/llvm/llvm-project/pull/73300", "title": "[SimpleLoopUnswitch] Remove callbacks", "body": "After the removal of the legacyPM version of simple loop unswitch, there is no longer a need for the callback mechanism to handle PM specific tasks. This patch removes the callbacks to help simplify the code now that they're no longer needed.", "feature_layers": [], "feature_directives": ["task", "for"], "files_changed": [{"filename": "llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp", "functions": ["LoopName"]}]}
{"pr_number": 73363, "url": "https://github.com/llvm/llvm-project/pull/73363", "title": "[mlir][spirv] Split codegen for float min/max reductions and others v2. [NFC]", "body": "This is https://github.com/llvm/llvm-project/pull/69023 but with cleanups.\r\nReduced complexity by avoiding CRTP and preprocessor defines in favor of free functions\r\n\r\nOriginal description by @unterumarmung:\r\n\r\n---\r\n\r\nThis patch is part of a larger initiative aimed at fixing floating-point `max` and `min` operations in MLIR: https://discourse.llvm.org/t/rfc-fix-floating-point-max-and-min-operations-in-mlir/72671.\r\n\r\nThere are two types of min/max operations for floating-point numbers: `minf`/`maxf` and `minimumf`/`maximumf`. The code generation for these operations should differ from that of other vector reduction kinds. This difference arises because CL and GL operations for floating-point min and max do not have the same semantics when handling NaNs. Therefore, we must enforce the desired semantics with additional ops.\r\n\r\n~~However, since the code generation for floating-point min/max operations shares the same functionality as extracting values for the vector, we have decided to refactor the existing code using the CRTP pattern.~~ This change does not alter the actual behavior of the code and is necessary for future fixes to the codegen for floating-point min/max operations.", "feature_layers": ["sema", "codegen", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Conversion/VectorToSPIRV/VectorToSPIRV.cpp", "functions": ["failure"]}]}
{"pr_number": 69023, "url": "https://github.com/llvm/llvm-project/pull/69023", "title": "[mlir][spirv] Split codegen for float min/max reductions and others (NFC)", "body": "This patch is part of a larger initiative aimed at fixing floating-point `max` and `min` operations in MLIR: https://discourse.llvm.org/t/rfc-fix-floating-point-max-and-min-operations-in-mlir/72671.\n\nThere are two types of min/max operations for floating-point numbers: `minf`/`maxf` and `minimumf`/`maximumf`. The code generation for these operations should differ from that of other vector reduction kinds. This difference arises because CL and GL operations for floating-point min and max do not have the same semantics when handling NaNs. Therefore, we must enforce the desired semantics with additional ops.\n\nHowever, since the code generation for floating-point min/max operations shares the same functionality as extracting values for the vector, we have decided to refactor the existing code using the CRTP pattern. This change does not alter the actual behavior of the code and is necessary for future fixes to the codegen for floating-point min/max operations.\n", "feature_layers": ["sema", "codegen", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Conversion/VectorToSPIRV/VectorToSPIRV.cpp", "functions": ["success"]}]}
{"pr_number": 73268, "url": "https://github.com/llvm/llvm-project/pull/73268", "title": "[llvm-jitlink] Support plain AArch32 range extension stubs in jitlink-check's stub_addr() expressions", "body": "We want to use regular `stub_addr()` expressions in `jitlink-check` lines to test the generation of stubs in AArch32, but we don't want this to require a standardized GOT-based PLT implementation. In terms of performance and binary size it doesn't seem beneficial. And in terms of patching, we should be able to handle range-extension- and interworking-stubs without a lot of extra logic.\r\n\r\nThis patch adds a separate path for AArch32 stubs in `llvm-jitlink-elf` to allow it. The relocations in our stubs are not pointing to the GOT, but to the external symbol directly. Thus, we have to avoid access to the block of the edge target. Instead we only return the symbol name. This is enough to use `stub_addr()` expressions in tests.\r\n\r\nIn order to allow decoding of stub target addresses in the future, we mention the stub flavor in the section name.", "feature_layers": ["ir"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "llvm/tools/llvm-jitlink/llvm-jitlink-elf.cpp", "functions": ["isELFAArch32StubsSection"]}]}
{"pr_number": 70233, "url": "https://github.com/llvm/llvm-project/pull/70233", "title": "[Clang][OpenMP] Emit unsupported directive error", "body": "Hello!\r\n\r\nThis PR fixes #63871. Clang should no longer crash and instead emits an error message. \r\n@shiltian is this what you had in mind for an error message? I think I followed everything in [1] but I did not add a unit test as this behavior should change in the future when dispatch is implemented. Also I did not find any existing unit tests that test for behavior like this.\r\n\r\nBelow is an example of the new error message:\r\n\r\n```\r\n~/dev/fork-llvm-project omp_dispatch_unimpl\r\n\u276f ./install/bin/clang -fopenmp  -c -emit-llvm -Xclang -disable-llvm-passes test.c\r\ntest.c:6:5: error: cannot compile this OpenMP dispatch directive yet\r\n    6 |     #pragma omp dispatch\r\n      |     ^~~~~~~~~~~~~~~~~~~~\r\n1 error generated.\r\n```\r\n\r\nPlease let me know if there's anything you'd like me to change.\r\n\r\nPS. This is my first open source contribution so if there's any etiquette or instructions I missed please let me know.\r\n\r\n[1] https://llvm.org/docs/Contributing.html", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/OpenMP/dispatch_unsupported.c", "functions": ["a"]}]}
{"pr_number": 68721, "url": "https://github.com/llvm/llvm-project/pull/68721", "title": "[DWARFLinkerParallel] Add support for -odr mode.", "body": "This patch is extracted from D96035, it adds support for the type deduplication mode. With this patch DWARFLinkerParallel handles --odr option. It also processes clang modules.\r\n\r\nrun-time performance and memory requirements for clang binary --num-threads 16 :\r\n    \r\n```\r\n------------------------------------------------------------------------------\r\n                                |  time, sec   |  mem, GB  | .debug_info, MB |\r\n------------------------------------------------------------------------------\r\ndsymutil --odr --linker llvm    |      45      |     13    |       192       |\r\n------------------------------------------------------------------------------\r\ndsymutil --odr --linker apple   |     115      |     11    |       561       |\r\n------------------------------------------------------------------------------\r\n\r\n```    \r\nrun-time performance and memory requirements for clang binary --num-threads 1 :\r\n    \r\n```\r\n------------------------------------------------------------------------------\r\n                                |  time, sec   |  mem, GB  | .debug_info, MB |\r\n------------------------------------------------------------------------------\r\ndsymutil --odr --linker llvm    |     236      |    12.6   |       192       |\r\n------------------------------------------------------------------------------\r\ndsymutil --odr --linker apple   |     187      |    10.0   |       561       |\r\n------------------------------------------------------------------------------\r\n\r\n```    \r\nNote: Sometimes DWARFLinkerParallel may produce non-deterministic results.\r\nThe reason for that is ambiguous input DWARF. That problem is assumed\r\nto be solved with separate patches(most probably not for DWARFLinkerParallel\r\nbut for generated DWARF).\r\n    \r\nNote: The dependency tracking algorithm handles DW_TAG_imported_module and\r\nDW_TAG_imported_declaration differently than current DWARFLinker. Current\r\nDWARFLinker keeps all content referenced by DW_AT_import attribute despite\r\nthe fact whether it references live code or not. This patch keeps only DIEs\r\nreferencing live addresses(and all their dependencies)", "feature_layers": ["ir"], "feature_directives": ["parallel", "for"], "files_changed": [{"filename": "llvm/lib/DWARFLinkerParallel/AcceleratorRecordsSaver.cpp", "functions": ["djbHash"]}, {"filename": "llvm/lib/DWARFLinkerParallel/DIEAttributeCloner.cpp", "functions": ["Expr"]}, {"filename": "llvm/lib/DWARFLinkerParallel/DWARFLinkerCompileUnit.cpp", "functions": ["needToClone", "resolveDIEReference", "getAsTypeUnit", "Ptr", "getAsCompileUnit", "NameBuilder", "ChildrenIndexAssigner", "DIEGenerator", "AccelRecordsSaver", "DwarfUnit", "PlainDIEGenerator", "if", "getDirAndFilenameFromLineTable", "assignTypeNamesRec", "CUDiePair", "isPathAbsoluteOnWindowsOrPosix", "djbHash"]}, {"filename": "llvm/lib/DWARFLinkerParallel/DWARFLinkerImpl.cpp", "functions": ["OutputSections", "File", "UniqueUnitID"]}, {"filename": "llvm/lib/DWARFLinkerParallel/DWARFLinkerTypeUnit.cpp", "functions": ["DIEGen", "getVersion", "DIETreeGenerator", "DwarfUnit", "emitDebugLine"]}, {"filename": "llvm/lib/DWARFLinkerParallel/DependencyTracker.cpp", "functions": ["isAlreadyMarked", "isNamespaceLikeEntry", "childrenCanBeRemoved", "Parent", "if", "ChildEntry", "markLiveRootsAsKept"]}, {"filename": "llvm/lib/DWARFLinkerParallel/OutputSections.cpp", "functions": ["SectionPatch", "Die"]}, {"filename": "llvm/lib/DWARFLinkerParallel/SyntheticTypeNameBuilder.cpp", "functions": ["if", "format_hex_no_prefix", "addDIETypeName", "stream"]}, {"filename": "llvm/test/tools/dsymutil/X86/DWARFLinkerParallel/dead-stripped.cpp", "functions": ["foo", "bar"]}, {"filename": "llvm/test/tools/dsymutil/X86/DWARFLinkerParallel/inlined-static-variable.cpp", "functions": ["foo", "unused", "__attribute__", "removed"]}, {"filename": "llvm/test/tools/dsymutil/X86/DWARFLinkerParallel/odr-anon-namespace.cpp", "functions": ["foo"]}, {"filename": "llvm/test/tools/dsymutil/X86/DWARFLinkerParallel/odr-member-functions.cpp", "functions": ["foo", "baz", "bar"]}, {"filename": "llvm/test/tools/dsymutil/X86/DWARFLinkerParallel/odr-uniquing.cpp", "functions": ["CU", "foo"]}]}
{"pr_number": 73087, "url": "https://github.com/llvm/llvm-project/pull/73087", "title": "Reland \"[clang][Sema] Use original template pattern when declaring implicit deduction guides for nested template classes\"", "body": "Reland of f418319730341e9d41ce8ead6fbfe5603c343985 with proper handling of template constructors\r\n\r\nWhen a nested template is instantiated, the template pattern of the inner class is not copied into the outer class\r\nClassTemplateSpecializationDecl. The specialization contains a ClassTemplateDecl with an empty record that points to the original template pattern instead.\r\n\r\nAs a result, when looking up the constructors of the inner class, no results are returned. This patch finds the original template pattern and uses that for the lookup instead.\r\n\r\nBased on CWG2471 we must also substitute the known outer template arguments when creating deduction guides for the inner class.\r\n\r\nChanges from last iteration:\r\n\r\n1. In template constructors, arguments are first rewritten to depth - 1 relative to the constructor as compared to depth 0 originally. These arguments are needed for substitution into constraint expressions.\r\n2. Outer arguments are then applied with the template instantiator to produce a template argument at depth zero for use in the deduction guide. This substitution does not evaluate constraints, which preserves constraint arguments at the correct depth for later evaluation.\r\n3. Tests are added that cover template constructors within nested deduction guides for all special substitution cases.\r\n4. Computation of the template pattern and outer instantiation arguments are pulled into the constructor of `ConvertConstructorToDeductionGuideTransform`.", "feature_layers": ["sema", "ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Sema/SemaTemplate.cpp", "functions": ["SemaRef", "SavedContext"]}, {"filename": "clang/test/SemaTemplate/nested-implicit-deduction-guides.cpp", "functions": ["req", "N", "requires", "cc", "default_arg"]}]}
{"pr_number": 73404, "url": "https://github.com/llvm/llvm-project/pull/73404", "title": "[NewPM] Remove Reg2Mem Legacy Pass", "body": "This pass isn't used anywhere upstream and thus has no test coverage. For these reasons it should be removed.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Scalar/Reg2Mem.cpp", "functions": ["RegToMemLegacy", "getAnalysisUsage", "runPass", "runOnFunction"]}]}
{"pr_number": 73407, "url": "https://github.com/llvm/llvm-project/pull/73407", "title": "[NewPM] Remove PredicateInfoPrinterLegacyPass", "body": "This pass isn't used anywhere upstream and thus has no test coverage. For these reasons, remove it.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Utils/PredicateInfo.cpp", "functions": ["FunctionPass"]}]}
{"pr_number": 73409, "url": "https://github.com/llvm/llvm-project/pull/73409", "title": "[NewPM] Remove CallGraphPrinterLegacyPass", "body": "This pass isn't used anywhere upstream and thus doesn't have any test coverage. For these reasons, remove it.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Analysis/CallGraph.cpp", "functions": ["getAnalysisUsage", "runOnModule"]}]}
{"pr_number": 73410, "url": "https://github.com/llvm/llvm-project/pull/73410", "title": "[NewPM] Remove CFGViewerLegacyPass", "body": "This pass isn't used anywhere upstream, has a NewPM equivalent, and has no test coverage. For these reasons, remove it.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Analysis/CFGPrinter.cpp", "functions": ["print", "getAnalysisUsage", "runOnFunction"]}]}
{"pr_number": 73411, "url": "https://github.com/llvm/llvm-project/pull/73411", "title": "[NewPM] Remove CFGOnlyViewerLegacyPass", "body": "This pass has a NewPM equivalent, isn't used anywhere upstream, and doesn't have any test coverage. For these reasons, remove it.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Analysis/CFGPrinter.cpp", "functions": ["print", "getAnalysisUsage", "runOnFunction"]}]}
{"pr_number": 73405, "url": "https://github.com/llvm/llvm-project/pull/73405", "title": "[NewPM] Remove Legacy RedudantDbgInstEliminationPass", "body": "This pass isn't used by anywhere upstream and thus has no test coverage. For these reasons, remove it.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Scalar/DCE.cpp", "functions": ["getAnalysisUsage", "runOnFunction", "RedundantDbgInstElimination"]}]}
{"pr_number": 73412, "url": "https://github.com/llvm/llvm-project/pull/73412", "title": "[NewPM] Remove CFGOnlyPrinterLegacyPass", "body": "This pass has no test coverage upstream, is not used anywhere upstream, and has a NewPM equivalent. For these reasons, remove it.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Analysis/CFGPrinter.cpp", "functions": ["print", "CFGOnlyPrinterLegacyPass", "getAnalysisUsage", "runOnFunction"]}]}
{"pr_number": 73414, "url": "https://github.com/llvm/llvm-project/pull/73414", "title": "[NewPM] Remove CFGPrinterLegacyPass", "body": "This pass has no test coverage in upstream LLVM, is not used anywhere in upstream LLVM, and has a NewPM equivalent. For these reasons, remove it.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Analysis/CFGPrinter.cpp", "functions": ["print", "CFGPrinterLegacyPass", "getAnalysisUsage", "runOnFunction"]}]}
{"pr_number": 73427, "url": "https://github.com/llvm/llvm-project/pull/73427", "title": "[llvm][Coroutines] Remove no-op ptr-to-ptr bitcasts (NFC)", "body": "Opaque ptr cleanup effort", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Coroutines/Coroutines.cpp", "functions": ["BitCastInst"]}]}
{"pr_number": 73403, "url": "https://github.com/llvm/llvm-project/pull/73403", "title": "[NewPM] Remove StripGCRelocatesLegacyPass", "body": "This pass isn't used anywhere upstream and thus has no test coverage. For these reasons, remove it.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Utils/StripGCRelocates.cpp", "functions": ["getAnalysisUsage", "runOnFunction"]}]}
{"pr_number": 72884, "url": "https://github.com/llvm/llvm-project/pull/72884", "title": "[DebugInfo][RemoveDIs] Instrument inliner for non-instr debug-info", "body": "With intrinsics representing debug-info, we just clone all the intrinsics when inlining a function and don't think about it any further. With non-instruction debug-info however we need to be a bit more careful and manually move the debug-info from one place to another. For the most part, this means keeping a \"cursor\" during block cloning of where we last copied debug-info from, and performing debug-info copying whenever we successfully clone another instruction.\r\n\r\nThere are several utilities in LLVM for doing this, all of which now need to manually call cloneDebugInfo. The testing story for this is not well covered as we could rely on normal instruction-cloning mechanisms to do all the hard stuff. Thus, I've added a few tests to explicitly test dbg.value behaviours, ahead of them becoming not-instructions.\r\n\r\nHere's a mapping of what's-tested-by-what:\r\n  * `DebugInfoFinder`: tested by all the inlining tests, it's what maintains CU relationships for example,\r\n  * `PruningFunctionCloner::CloneBlock` the new inline-dbg-values.ll test\r\n  * `CloneAndPruneIntoFromInst`: above ^^^\r\n  * `fixupLineNumbers`: above^^^\r\n  * dropDbgValues call in the same: Transforms/Inline/no-inline-line-tables.ll\r\n  * `remapInstructionsIntoBlocks`: Transforms/LoopUnroll/debug-info.ll\r\n  * `DuplicateInstructionsInSplitBetween`: the added jump-threading test and the modified callsitesplitting test. Both passes needed a new call to dropDbgValues too, which it tested.\r\n  * setTailBit: the new inline-alloca-ordering.ll test.\r\n\r\nThe latter is the weirdest part of RemoveDIs/DDD: when we splice ranges of instructions, normally it's not inclusive of preceeding dbg.values and inclusive of trailing dbg.values. Quite often we do actually intend on including preceeding dbg.values, and that's where the \"head\" bit of an iterator gets set. However it's technically possible to not want to move the _trailing_ dbg.values on an instruction sequence... and this is the only place in LLVM that I've found which requires that behaviour. It's purely because the inliner steps through all allocas until it finds a non-alloca, and then it moves that range. Every other part of LLVM identifies two real instructions and then moves a range, just not this part.\r\n\r\nIf we had to scatter this all around LLVM it would probably be unreasonably hard, but IMO this is limited enough of an edge case for us to just work around it.", "feature_layers": ["ir", "ast"], "feature_directives": ["for", "requires"], "files_changed": [{"filename": "llvm/lib/Transforms/Utils/InlineFunction.cpp", "functions": ["inlineDebugLoc"]}]}
{"pr_number": 72997, "url": "https://github.com/llvm/llvm-project/pull/72997", "title": "[DebugInfo][RemoveDIs] Instrument loop-rotate for DPValues", "body": "Loop-rotate manually maintains dbg.value intrinsics -- it also needs to manually maintain the replacement for dbg.value intrinsics, DPValue objects. For the most part this patch adds parallel implementations using the new type  Some extra juggling is needed when loop-rotate hoists loop-invariant instructions out of the loop: the DPValues attached to such an instruction need to get rotated but not hoisted. Exercised by the new test function invariant_hoist in dbgvalue.ll.\r\n\r\nThere's also a \"don't insert duplicate debug intrinsics\" facility in LoopRotate. The value and correctness of this isn't clear, but to continue preserving behaviour that's now tested in the \"tak_dup\" function in dbgvalue.ll.\r\n\r\nOther things in this patch include a helper DebugVariable constructor for DPValues, a insertDebugValuesForPHIs handler for RemoveDIs (exercised by the new tests), and beefing up the dbg.value checking in dbgvalue.ll to ensure that each record is tested (and that there's an implicit check-not).", "feature_layers": [], "feature_directives": ["parallel", "for"], "files_changed": [{"filename": "llvm/lib/IR/DebugInfoMetadata.cpp", "functions": ["Variable"]}, {"filename": "llvm/lib/Transforms/Utils/LoopRotationUtils.cpp", "functions": ["if"]}]}
{"pr_number": 73466, "url": "https://github.com/llvm/llvm-project/pull/73466", "title": "[mlir][spirv] Add floating point dot product", "body": "Because `OpDot` does not require any extra capabilities or extensions, enable it by default in the vector to spirv conversion.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Conversion/VectorToSPIRV/VectorToSPIRV.cpp", "functions": ["success"]}]}
{"pr_number": 73467, "url": "https://github.com/llvm/llvm-project/pull/73467", "title": "[LLDB] Add more helper functions to CompilerType class.", "body": "This adds 23 new helper functions to LLDB's CompilerType class, things like IsSmartPtrType, IsPromotableIntegerType, GetNumberofNonEmptyBaseClasses, and GetTemplateArgumentType (to name a few).\r\n\r\nThese helper functions are needed as part of the implementation for the Data Inspection Language, (see\r\nhttps://discourse.llvm.org/t/rfc-data-inspection-language/69893).", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "lldb/source/Symbol/CompilerType.cpp", "functions": ["GetCanonicalType", "GetEnumerationIntegerType"]}]}
{"pr_number": 73435, "url": "https://github.com/llvm/llvm-project/pull/73435", "title": "[libc++][test] Cleanup typos and unnecessary semicolons", "body": "I've structured this into a series of commits for even easier reviewing, if that helps. I could easily split this up into separate PRs if desired, but as this is low-risk with simple edits, I thought one PR would be easiest.\r\n\r\n* Drop unnecessary semicolons after function definitions.\r\n* Cleanup comment typos.\r\n* Cleanup `static_assert` typos.\r\n* Cleanup test code typos.\r\n  + There should be no functional changes, assuming I've changed all occurrences.\r\n* ~~Fix massive test code typos.~~\r\n  + This was a real problem, but needed more surgery. I reverted those changes here, and @philnik777 is fixing this properly with #73444.\r\n* clang-formatting as requested by the CI.\r\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "libcxx/test/std/containers/views/mdspan/extents/ctad.pass.cpp", "functions": ["NoDefaultCtorIndex"]}, {"filename": "libcxx/test/std/utilities/utility/pairs/pairs.pair/assign_rv_pair_U_V.pass.cpp", "functions": ["CountAssign", "Derived"]}, {"filename": "libcxx/test/std/ranges/range.adaptors/range.join.view/sentinel/ctor.other.pass.cpp", "functions": ["outer"]}, {"filename": "libcxx/test/std/thread/futures/futures.async/async.pass.cpp", "functions": ["test"]}, {"filename": "libcxx/test/std/utilities/expected/expected.expected/swap/free.swap.pass.cpp", "functions": ["swap"]}, {"filename": "libcxx/test/std/utilities/expected/expected.expected/swap/member.swap.pass.cpp", "functions": ["swap"]}, {"filename": "libcxx/test/std/utilities/expected/expected.void/swap/free.swap.pass.cpp", "functions": ["swap"]}, {"filename": "libcxx/test/std/utilities/expected/expected.void/swap/member.swap.pass.cpp", "functions": ["swap"]}, {"filename": "libcxx/test/std/utilities/tuple/tuple.tuple/tuple.cnstr/alloc_const_Types.verify.cpp", "functions": ["e"]}, {"filename": "libcxx/test/std/containers/sequences/forwardlist/forwardlist.ops/remove_if.pass.cpp", "functions": ["operator"]}, {"filename": "libcxx/test/std/containers/sequences/forwardlist/forwardlist.ops/unique_pred.pass.cpp", "functions": ["operator"]}, {"filename": "libcxx/test/std/containers/sequences/list/list.ops/remove_if.pass.cpp", "functions": ["operator"]}, {"filename": "libcxx/test/std/containers/sequences/list/list.ops/unique_pred.pass.cpp", "functions": ["operator"]}, {"filename": "libcxx/test/std/utilities/memory/util.smartptr/util.smartptr.shared/util.smartptr.shared.const/pointer_deleter.pass.cpp", "functions": ["MoveDeleter", "operator"]}, {"filename": "libcxx/test/std/utilities/memory/util.smartptr/util.smartptr.shared/util.smartptr.shared.const/pointer_deleter_allocator.pass.cpp", "functions": ["MoveDeleter", "operator"]}]}
{"pr_number": 73241, "url": "https://github.com/llvm/llvm-project/pull/73241", "title": "[SelectionDAG] Add instantiated OPC_EmitInteger and OPC_EmitStringInteger", "body": "These two opcodes are used to be followed by a MVT operand, which is\nalways one of i8/i16/i32/i64.\n\nWe add instantiated `OPC_EmitInteger` and `OPC_EmitStringInteger` with\ni8/i16/i32/i64 so that we can reduce one byte.\n\nWe reserve `OPC_EmitInteger` and `OPC_EmitStringInteger` in case that\nwe may need them someday, though I haven't found one usage after this\nchange.\n\nOverall this reduces the llc binary size with all in-tree targets by\nabout 200K.\n", "feature_layers": [], "feature_directives": ["target"], "files_changed": [{"filename": "llvm/utils/TableGen/DAGISelMatcherEmitter.cpp", "functions": ["getEnumName"]}]}
{"pr_number": 73475, "url": "https://github.com/llvm/llvm-project/pull/73475", "title": "[mlir][spirv] Add missing group non-uniform bitwise and logical ops", "body": "This covers the following ops:\r\n`spirv.GroupNonUniform` x {`Bitwise`, `Logical`} x {`And`, `Or`, `Xor`}\r\n\r\nWe need these to efficiently lower from the `gpu.subgroup_reduce` op.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/SPIRV/IR/GroupOps.cpp", "functions": ["parseGroupNonUniformArithmeticOp", "verifyGroupNonUniformArithmeticOp"]}]}
{"pr_number": 73338, "url": "https://github.com/llvm/llvm-project/pull/73338", "title": "[CVP] Don't try to fold load/store operands to constant", "body": "CVP currently tries to fold load/store pointer operands to constants using LVI. If there is a dominating condition of the form `icmp eq ptr %p, @g`, then `%p` will be replaced with `@g`.\r\n\r\nLVI is geared towards range-based optimizations, and is *very* inefficient at handling simple pointer equality conditions. We have other passes that can handle this optimization in a more efficient way, such as IPSCCP and GVN.\r\n\r\nRemoving this optimization gives a geomean 0.4-1.2% compile-time improvement depending on configuration: http://llvm-compile-time-tracker.com/compare.php?from=7eeedc124f9901a65573668bc504a45111a3f837&to=4769e20ad4d5f35db561bf14b00e91cec325039a&stat=instructions:u Especially notable is a 4% improvement on tramp3d-v4 with ThinLTO. At the same time, there is no impact on codegen.", "feature_layers": ["codegen"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp", "functions": ["processMemAccess"]}]}
{"pr_number": 72871, "url": "https://github.com/llvm/llvm-project/pull/72871", "title": "[mlir][gpu] Support Cluster of Thread Blocks in `gpu.launch_func`", "body": "NVIDIA Hopper architecture introduced the Cooperative Group Array (CGA). It is a new level of parallelism, allowing clustering of Cooperative Thread Arrays (CTA) to synchronize and communicate through shared memory while running concurrently.\r\n\r\nThis PR enables support for CGA within the `gpu.launch_func` in the GPU dialect. It extends `gpu.launch_func` to accommodate this functionality. \r\n\r\nThe GPU dialect remains architecture-agnostic, so we've added CGA functionality as optional parameters. We want to leverage mechanisms that we have in the GPU dialects such as outlining and kernel launching, making it a practical and convenient choice.\r\n\r\nAn example of this implementation can be seen below:\r\n\r\n```\r\ngpu.launch_func @kernel_module::@kernel\r\n                clusters in (%1, %0, %0) // <-- Optional\r\n                blocks in (%0, %0, %0)\r\n                threads in (%0, %0, %0)\r\n```\r\n\r\nThe PR also introduces index and dimensions Ops specific to clusters, binding them to NVVM Ops:\r\n\r\n```\r\n%cidX = gpu.cluster_id  x\r\n%cidY = gpu.cluster_id  y\r\n%cidZ = gpu.cluster_id  z\r\n\r\n%cdimX = gpu.cluster_dim  x\r\n%cdimY = gpu.cluster_dim  y\r\n%cdimZ = gpu.cluster_dim  z\r\n```\r\n\r\nWe will introduce cluster support in `gpu.launch` Op in an upcoming PR. \r\n\r\nSee [the documentation](https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#cluster-of-cooperative-thread-arrays) provided by NVIDIA for details. ", "feature_layers": ["ir"], "feature_directives": ["parallel", "for"], "files_changed": [{"filename": "mlir/lib/Dialect/GPU/IR/GPUDialect.cpp", "functions": ["emitOpError", "parseLaunchDimType"]}, {"filename": "mlir/lib/Target/LLVMIR/Dialect/GPU/SelectObjectAttr.cpp", "functions": ["getClusterKernelLaunchFn"]}]}
{"pr_number": 73292, "url": "https://github.com/llvm/llvm-project/pull/73292", "title": "[X86][CodeGen] Teach frame lowering to spill/reload registers w/ PUSHP/POPP, PUSH2[P]/POP2[P]", "body": "#73092 supported the encoding/decoding for PUSHP/POPP\r\n#73233 supported the encoding/decoding for PUSH2[P]/POP2[P]\r\n\r\nIn this patch, we teach frame lowering to spill/reload registers w/ these instructions.\r\n\r\n1. Use PPX for balanced spill/reload\r\n2. Use PUSH2/POP2 for continuous spills/reloads\r\n3. PUSH2/POP2 must be 16B-aligned on the stack, so pad when necessary\r\n ", "feature_layers": ["codegen"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/X86/X86FrameLowering.cpp", "functions": ["getKillRegState"]}]}
{"pr_number": 73484, "url": "https://github.com/llvm/llvm-project/pull/73484", "title": "[clang][dataflow] Strengthen widening of boolean values.", "body": "Before we widen to top, we now check if both values can be proved either true or\nfalse in their respective environments; if so, widening returns a true or false\nliteral. The idea is that we avoid losing information if posssible.\n\nThis patch includes a test that fails without this change to widening.\n\nThis change does mean that we call the SAT solver in more places, but this seems\nacceptable given the additional precision we gain.\n\nIn tests on an internal codebase, the number of SAT solver timeouts we observe\nwith Crubit's nullability checker does increase by about 25%. They can be\nbrought back to the previous level by doubling the SAT solver work limit.\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/unittests/Analysis/FlowSensitive/TransferTest.cpp", "functions": ["target", "return_int"]}]}
{"pr_number": 73518, "url": "https://github.com/llvm/llvm-project/pull/73518", "title": "piper export cl 583969847", "body": "- [clang][dataflow] Strengthen widening of boolean values.\n- [clang][dataflow] Defer initialization of `Environment`.\n- [clang][dataflow] Add synthetic fields to `RecordStorageLocation`.\n- [clang][dataflow] Make UncheckedOptionalAccessModel use synthetic fields.\n", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "clang/unittests/Analysis/FlowSensitive/TransferTest.cpp", "functions": ["target", "return_int"]}, {"filename": "clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp", "functions": ["Environment", "DACtx"]}, {"filename": "clang/lib/Analysis/FlowSensitive/TypeErasedDataflowAnalysis.cpp", "functions": ["AC", "initializeEnvironment"]}, {"filename": "clang/lib/Analysis/FlowSensitive/DataflowAnalysisContext.cpp", "functions": ["arena", "createRecordStorageLocation", "getKeys"]}, {"filename": "clang/lib/Analysis/FlowSensitive/Models/UncheckedOptionalAccessModel.cpp", "functions": ["valueTypeFromOptionalType", "setHasValue", "isNulloptConstructor", "isNonEmptyOptional", "cxxConstructExpr", "hasAnyOptionalType", "isEmptyOptional"]}, {"filename": "clang/unittests/Analysis/FlowSensitive/UncheckedOptionalAccessModelTest.cpp", "functions": ["UncheckedOptionalAccessModel"]}]}
{"pr_number": 73143, "url": "https://github.com/llvm/llvm-project/pull/73143", "title": "[OpenACC] Implement 'routine' construct parsing", "body": "The 'routine' construct applies either to a function directly, or, when\r\nprovided a name, applies to the function named (and is visible in the\r\ncurrent scope). This patch implements the parsing for this.  The\r\nidentifier provided (or Id Expression) is required to be a valid,\r\ndeclared identifier, though the semantic analysis portion of the Routine\r\ndirective will need to enforce it being a function/overload set.", "feature_layers": ["sema", "ir"], "feature_directives": ["for", "declare"], "files_changed": [{"filename": "clang/lib/Parse/ParseOpenACC.cpp", "functions": ["ExprError", "ParseOpenACCDirective", "getActions"]}, {"filename": "clang/test/ParserOpenACC/parse-constructs.c", "functions": ["routine_func"]}, {"filename": "clang/test/ParserOpenACC/parse-constructs.cpp", "functions": ["templ", "foo"]}]}
{"pr_number": 72954, "url": "https://github.com/llvm/llvm-project/pull/72954", "title": "[clangtidy] Allow safe suspensions in coroutine-hostile-raii check", "body": "Certain `awaitable` types could be safe to `co_await` on even when we have suspension-hostile RAII objects in scope. \r\nThis PR adds a way for users to mark such safe `awaitable` and silence false positive warnings in `co_await` expressions involving such an `awaitable`.\r\n\r\n`co_await`-ing an expression of `awaitable` type is considered safe if the type is part of `SafeAwaiatablesList` check option. RAII objects persisting across such a `co_await` expression are\r\nconsidered safe and hence are not flagged.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang-tools-extra/test/clang-tidy/checkers/misc/coroutine-hostile-raii.cpp", "functions": ["await_ready", "await_suspend", "await_resume"]}, {"filename": "clang-tools-extra/clang-tidy/misc/CoroutineHostileRAIICheck.cpp", "functions": ["typeWithNameIn"]}]}
{"pr_number": 71944, "url": "https://github.com/llvm/llvm-project/pull/71944", "title": "[Flang][OpenMP] Fix issue with empty critical or critical without surrounding context", "body": "Add the sourcerange for critical directive.\r\n\r\nFixes #65571", "feature_layers": ["ir"], "feature_directives": ["for", "critical"], "files_changed": [{"filename": "flang/lib/Semantics/resolve-names.cpp", "functions": ["Pre", "Post"]}]}
{"pr_number": 73172, "url": "https://github.com/llvm/llvm-project/pull/73172", "title": "[libc++] Remove experimental pmr headers now shipped in mainline", "body": "Several experimental headers around std::pmr have been slated for removal for a while now. This patch actually performs the removal and cleanups from the code base.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "libcxx/src/experimental/memory_resource.cpp", "functions": ["do_is_equal", "null_memory_resource", "ResourceInitHelper", "do_allocate", "guard", "new_delete_resource", "do_deallocate", "set_default_resource", "__default_memory_resource", "get_default_resource"]}, {"filename": "libcxx/test/libcxx/experimental/memory/memory.polymorphic.allocator.class/memory.polymorphic.allocator.mem/assert.deallocate.pass.cpp", "functions": ["a", "main"]}, {"filename": "libcxx/test/libcxx/experimental/memory/memory.polymorphic.allocator.class/memory.polymorphic.allocator.mem/construct_piecewise_pair.pass.cpp", "functions": ["construct", "alloc", "main"]}, {"filename": "libcxx/test/libcxx/experimental/memory/memory.resource.adaptor/memory.resource.adaptor.mem/assert.deallocate.pass.cpp", "functions": ["r", "main"]}, {"filename": "libcxx/test/libcxx/experimental/memory/memory.resource.global/global_memory_resource_lifetime.pass.cpp", "functions": ["constructed_after_resources2", "main", "constructed_after_resources", "swap"]}, {"filename": "libcxx/test/libcxx/experimental/memory/memory.resource.global/new_delete_resource_lifetime.pass.cpp", "functions": ["main", "constructed_after_resources", "swap"]}, {"filename": "libcxx/test/std/experimental/memory/memory.polymorphic.allocator.class/memory.polymorphic.allocator.ctor/assign.pass.cpp", "functions": ["main"]}, {"filename": "libcxx/test/std/experimental/memory/memory.polymorphic.allocator.class/memory.polymorphic.allocator.ctor/copy.pass.cpp", "functions": ["a2", "a", "main"]}, {"filename": "libcxx/test/std/experimental/memory/memory.polymorphic.allocator.class/memory.polymorphic.allocator.ctor/default.pass.cpp", "functions": ["R1", "main"]}, {"filename": "libcxx/test/std/experimental/memory/memory.polymorphic.allocator.class/memory.polymorphic.allocator.ctor/memory_resource_convert.pass.cpp", "functions": ["a", "main"]}, {"filename": "libcxx/test/std/experimental/memory/memory.polymorphic.allocator.class/memory.polymorphic.allocator.ctor/other_alloc.pass.cpp", "functions": ["a2", "a", "main"]}, {"filename": "libcxx/test/std/experimental/memory/memory.polymorphic.allocator.class/memory.polymorphic.allocator.eq/equal.pass.cpp", "functions": ["a1", "d1", "a2", "main", "d2"]}, {"filename": "libcxx/test/std/experimental/memory/memory.polymorphic.allocator.class/memory.polymorphic.allocator.eq/not_equal.pass.cpp", "functions": ["a1", "d1", "a2", "main", "d2"]}, {"filename": "libcxx/test/std/experimental/memory/memory.polymorphic.allocator.class/memory.polymorphic.allocator.mem/allocate.pass.cpp", "functions": ["testAllocForSizeThrows", "a", "main", "testForSizeAndAlign"]}, {"filename": "libcxx/test/std/experimental/memory/memory.polymorphic.allocator.class/memory.polymorphic.allocator.mem/construct_pair.pass.cpp", "functions": ["main"]}, {"filename": "libcxx/test/std/experimental/memory/memory.polymorphic.allocator.class/memory.polymorphic.allocator.mem/construct_pair_const_lvalue_pair.pass.cpp", "functions": ["test_pmr_not_uses_allocator", "main", "test_pmr_uses_allocator", "A"]}, {"filename": "libcxx/test/std/experimental/memory/memory.polymorphic.allocator.class/memory.polymorphic.allocator.mem/construct_pair_rvalue.pass.cpp", "functions": ["test_pmr_not_uses_allocator", "main", "test_pmr_uses_allocator", "A"]}, {"filename": "libcxx/test/std/experimental/memory/memory.polymorphic.allocator.class/memory.polymorphic.allocator.mem/construct_pair_values.pass.cpp", "functions": ["test_pmr_not_uses_allocator", "main", "test_pmr_uses_allocator", "A"]}, {"filename": "libcxx/test/std/experimental/memory/memory.polymorphic.allocator.class/memory.polymorphic.allocator.mem/construct_piecewise_pair.pass.cpp", "functions": ["t1", "A", "main", "test_pmr_uses_allocator", "test_pmr_not_uses_allocator"]}, {"filename": "libcxx/test/std/experimental/memory/memory.polymorphic.allocator.class/memory.polymorphic.allocator.mem/construct_piecewise_pair_evil.pass.cpp", "functions": ["pma", "main", "test_evil", "holds", "EvilAlloc"]}, {"filename": "libcxx/test/std/experimental/memory/memory.polymorphic.allocator.class/memory.polymorphic.allocator.mem/construct_types.pass.cpp", "functions": ["doTestUsesAllocV0", "R", "test_non_pmr_uses_alloc", "doTestUsesAllocV2", "construct", "main", "test_pmr_not_uses_alloc", "doTest", "doTestUsesAllocV1", "test_pmr_uses_alloc", "test_alloc"]}, {"filename": "libcxx/test/std/experimental/memory/memory.polymorphic.allocator.class/memory.polymorphic.allocator.mem/deallocate.pass.cpp", "functions": ["a", "main", "testForSizeAndAlign"]}, {"filename": "libcxx/test/std/experimental/memory/memory.polymorphic.allocator.class/memory.polymorphic.allocator.mem/destroy.pass.cpp", "functions": ["main"]}, {"filename": "libcxx/test/std/experimental/memory/memory.polymorphic.allocator.class/memory.polymorphic.allocator.mem/resource.pass.cpp", "functions": ["a", "main"]}, {"filename": "libcxx/test/std/experimental/memory/memory.polymorphic.allocator.class/memory.polymorphic.allocator.mem/select_on_container_copy_construction.pass.cpp", "functions": ["a", "main"]}, {"filename": "libcxx/test/std/experimental/memory/memory.polymorphic.allocator.class/memory.polymorphic.allocator.overview/nothing_to_do.pass.cpp", "functions": ["main"]}, {"filename": "libcxx/test/std/experimental/memory/memory.resource.adaptor/memory.resource.adaptor.ctor/alloc_copy.pass.cpp", "functions": ["r", "a", "main"]}, {"filename": "libcxx/test/std/experimental/memory/memory.resource.adaptor/memory.resource.adaptor.ctor/alloc_move.pass.cpp", "functions": ["r", "a", "main"]}, {"filename": "libcxx/test/std/experimental/memory/memory.resource.adaptor/memory.resource.adaptor.ctor/default.pass.cpp", "functions": ["main"]}, {"filename": "libcxx/test/std/experimental/memory/memory.resource.adaptor/memory.resource.adaptor.mem/do_allocate_and_deallocate.pass.cpp", "functions": ["check_alloc_max_size", "main", "check_allocate_deallocate"]}, {"filename": "libcxx/test/std/experimental/memory/memory.resource.adaptor/memory.resource.adaptor.mem/do_is_equal.pass.cpp", "functions": ["a1", "a2", "main", "r1", "r2"]}, {"filename": "libcxx/test/std/experimental/memory/memory.resource.adaptor/memory.resource.adaptor.overview/overview.pass.cpp", "functions": ["main"]}, {"filename": "libcxx/test/std/experimental/memory/memory.resource.aliases/header_deque_synop.pass.cpp", "functions": ["main"]}, {"filename": "libcxx/test/std/experimental/memory/memory.resource.aliases/header_forward_list_synop.pass.cpp", "functions": ["main"]}, {"filename": "libcxx/test/std/experimental/memory/memory.resource.aliases/header_list_synop.pass.cpp", "functions": ["main"]}, {"filename": "libcxx/test/std/experimental/memory/memory.resource.aliases/header_map_synop.pass.cpp", "functions": ["main"]}, {"filename": "libcxx/test/std/experimental/memory/memory.resource.aliases/header_regex_synop.pass.cpp", "functions": ["test_match_result_typedef", "main"]}, {"filename": "libcxx/test/std/experimental/memory/memory.resource.aliases/header_set_synop.pass.cpp", "functions": ["main"]}, {"filename": "libcxx/test/std/experimental/memory/memory.resource.aliases/header_string_synop.pass.cpp", "functions": ["test_string_typedef", "main", "test_basic_string_alias"]}, {"filename": "libcxx/test/std/experimental/memory/memory.resource.aliases/header_unordered_map_synop.pass.cpp", "functions": ["main"]}, {"filename": "libcxx/test/std/experimental/memory/memory.resource.aliases/header_unordered_set_synop.pass.cpp", "functions": ["main"]}, {"filename": "libcxx/test/std/experimental/memory/memory.resource.aliases/header_vector_synop.pass.cpp", "functions": ["main"]}, {"filename": "libcxx/test/std/experimental/memory/memory.resource.global/default_resource.pass.cpp", "functions": ["main"]}, {"filename": "libcxx/test/std/experimental/memory/memory.resource.global/new_delete_resource.pass.cpp", "functions": ["do_is_equal", "do_allocate", "test_equality", "main", "do_deallocate", "test_allocate_deallocate", "test_return"]}, {"filename": "libcxx/test/std/experimental/memory/memory.resource.global/null_memory_resource.pass.cpp", "functions": ["do_is_equal", "test_allocate", "do_allocate", "test_deallocate", "test_equality", "main", "do_deallocate", "test_return"]}, {"filename": "libcxx/test/std/experimental/memory/memory.resource.synop/nothing_to_do.pass.cpp", "functions": ["main"]}, {"filename": "libcxx/test/std/experimental/memory/memory.resource/construct.verify.cpp", "functions": ["main"]}, {"filename": "libcxx/test/std/experimental/memory/memory.resource/memory.resource.eq/equal.pass.cpp", "functions": ["mr1", "main", "r1", "mr2", "r2"]}, {"filename": "libcxx/test/std/experimental/memory/memory.resource/memory.resource.eq/not_equal.pass.cpp", "functions": ["mr1", "main", "r1", "mr2", "r2"]}, {"filename": "libcxx/test/std/experimental/memory/memory.resource/memory.resource.overview/nothing_to_do.pass.cpp", "functions": ["main"]}, {"filename": "libcxx/test/std/experimental/memory/memory.resource/memory.resource.priv/private_members.verify.cpp", "functions": ["main"]}, {"filename": "libcxx/test/std/experimental/memory/memory.resource/memory.resource.public/allocate.pass.cpp", "functions": ["main", "R"]}, {"filename": "libcxx/test/std/experimental/memory/memory.resource/memory.resource.public/deallocate.pass.cpp", "functions": ["main", "R"]}, {"filename": "libcxx/test/std/experimental/memory/memory.resource/memory.resource.public/dtor.pass.cpp", "functions": ["main"]}, {"filename": "libcxx/test/std/experimental/memory/memory.resource/memory.resource.public/is_equal.pass.cpp", "functions": ["R1", "main", "R2"]}]}
{"pr_number": 73476, "url": "https://github.com/llvm/llvm-project/pull/73476", "title": "[mlir][spirv] Handle non-innerprod float vector add reductions", "body": "Instead of extracting all individual vector components and performing a scalar summation, use `spirv.Dot` with the original reduction operand and a vector constant of all ones.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Conversion/VectorToSPIRV/VectorToSPIRV.cpp", "functions": ["success"]}]}
{"pr_number": 73423, "url": "https://github.com/llvm/llvm-project/pull/73423", "title": "[mlir][gpu] Align reduction operations with vector combining kinds", "body": "The motivation for this change is explained in\r\nhttps://github.com/llvm/llvm-project/issues/72354.\r\n\r\nBefore this change, we could not tell between signed/unsigned minimum/maximum and NaN treatment for floating point values.\r\n\r\nThe mapping of old reduction operations to the new ones is as follows:\r\n*  `min` --> `minsi` for ints, `minf` for floats\r\n*  `max` --> `maxsi` for ints, `maxf` for floats\r\n\r\nNew reduction kinds not represented in the old enum: `minui`, `maxui`, `minimumf`, `maximumf`.\r\n\r\nAs a next step, I would like to have a common definition of combining kinds used by the `vector` and `gpu` dialects. Separately, the GPU to SPIR-V lowering does not yet properly handle zero and NaN values -- the behavior of floating point min/max group reductions is not specified by the SPIR-V spec.\r\n\r\nIssue: https://github.com/llvm/llvm-project/issues/72354", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/GPU/IR/GPUDialect.cpp", "functions": ["failure", "success", "getType", "emitError"]}, {"filename": "mlir/lib/Dialect/GPU/Transforms/AllReduceLowering.cpp", "functions": ["getCmpFactory"]}]}
{"pr_number": 72441, "url": "https://github.com/llvm/llvm-project/pull/72441", "title": "[RISCV] Partially move doPeepholeMaskedRVV into RISCVFoldMasks", "body": "This change is motived by a point of confusion on https://github.com/llvm/llvm-project/pull/71764.  I hadn't fully understood why doPeepholeMaskedRVV needed to be part of the same change.  As indicated in the fixme in this patch, the reason is that performCombineVMergeAndVOps doesn't know how to deal with the true side of the merge being a all-ones masked instruction.\r\n\r\nThis change removes one of two calls to the routine in RISCVISELDAGToDAG, and adds a clarifying comment on the precondition for the remaining call.  The post-ISEL code is tested by the cases where we can form a unmasked instruction after folding the vmerge back into true.\r\n\r\nI don't really care if we actually land this patch, or leave it roled into https://github.com/llvm/llvm-project/pull/71764.  I'm posting it mostly to clarify the confusion.", "feature_layers": [], "feature_directives": ["for", "masked"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVFoldMasks.cpp", "functions": ["convertToUnmasked"]}]}
{"pr_number": 72726, "url": "https://github.com/llvm/llvm-project/pull/72726", "title": "[RISCV] Add register bank and instruction selection support for FP G_SELECT.", "body": "Try to pick the FP register bank based on surrounding use/defs. Code is basically copied from AArch64.\r\n\r\nNeed legalizer changes to make this more useful. Right now we're stuck with only being able to FP select types the same size as XLen.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/GISel/RISCVRegisterBankInfo.cpp", "functions": ["onlyUsesFP"]}]}
{"pr_number": 73144, "url": "https://github.com/llvm/llvm-project/pull/73144", "title": "[mlir] Add narrow type emulation for `memref.reinterpret_cast`", "body": "", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/MemRef/Transforms/EmulateNarrowType.cpp", "functions": ["success", "convertCastingOp"]}]}
{"pr_number": 73259, "url": "https://github.com/llvm/llvm-project/pull/73259", "title": "Revert \"[ClangRepl] Type Directed Code Completion\"", "body": "Reverts llvm/llvm-project#67349", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "clang/lib/Interpreter/CodeCompletion.cpp", "functions": ["CompletionContextHandler", "handleMacro", "handlePattern", "CCC", "handleDeclaration", "handleKeyword"]}]}
{"pr_number": 73186, "url": "https://github.com/llvm/llvm-project/pull/73186", "title": "Fix ISel crash when lowering BUILD_VECTOR", "body": "512bit vpbroadcastw is available only with AVX512BW. Avoid lowering BUILD_VEC into vbroard_cast node when the condition is not met. This fixed a crash (see the added new test).", "feature_layers": ["ast"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/Target/X86/X86ISelDAGToDAG.cpp", "functions": ["needBWI"]}]}
{"pr_number": 72112, "url": "https://github.com/llvm/llvm-project/pull/72112", "title": "[libc++] Speed up classic locale", "body": "Locale objects use atomic reference counting, which may be very expensive in parallel applications. The classic locale is used by default by all streams and can be very contended. But it's never destroyed, so the reference counting is also completely pointless on the classic locale. Currently ~70% of time in the parallel stringstream benchmarks is spent in locale ctor/dtor. And the execution radically slows down with more threads.\r\n\r\nAvoid reference counting on the classic locale. With this change parallel benchmarks start to scale with threads.\r\n\r\n```\r\n                              \u2502   baseline   \u2502    optimized                            \u2502\r\n                              \u2502    sec/op    \u2502    sec/op      vs base                  \u2502\r\nIstream_numbers/0/threads:1      4.672\u00b5 \u00b1 0%   4.419\u00b5 \u00b1 0%     -5.42% (p=0.000 n=30+39)\r\nIstream_numbers/0/threads:72   539.817\u00b5 \u00b1 0%   9.842\u00b5 \u00b1 1%    -98.18% (p=0.000 n=30+40)\r\nIstream_numbers/1/threads:1      4.890\u00b5 \u00b1 0%   4.750\u00b5 \u00b1 0%     -2.85% (p=0.000 n=30+40)\r\nIstream_numbers/1/threads:72     66.44\u00b5 \u00b1 1%   10.14\u00b5 \u00b1 1%    -84.74% (p=0.000 n=30+40)\r\nIstream_numbers/2/threads:1      4.888\u00b5 \u00b1 0%   4.746\u00b5 \u00b1 0%     -2.92% (p=0.000 n=30+40)\r\nIstream_numbers/2/threads:72     494.8\u00b5 \u00b1 0%   410.2\u00b5 \u00b1 1%    -17.11% (p=0.000 n=30+40)\r\nIstream_numbers/3/threads:1      4.697\u00b5 \u00b1 0%   4.695\u00b5 \u00b1 5%          ~ (p=0.391 n=30+37)\r\nIstream_numbers/3/threads:72     421.5\u00b5 \u00b1 7%   421.9\u00b5 \u00b1 9%          ~ (p=0.665 n=30)\r\nOstream_number/0/threads:1       183.0n \u00b1 0%   141.0n \u00b1 2%    -22.95% (p=0.000 n=30)\r\nOstream_number/0/threads:72    24196.5n \u00b1 1%   343.5n \u00b1 3%    -98.58% (p=0.000 n=30)\r\nOstream_number/1/threads:1       250.0n \u00b1 0%   196.0n \u00b1 2%    -21.60% (p=0.000 n=30)\r\nOstream_number/1/threads:72    16260.5n \u00b1 0%   407.0n \u00b1 2%    -97.50% (p=0.000 n=30)\r\nOstream_number/2/threads:1       254.0n \u00b1 0%   196.0n \u00b1 1%    -22.83% (p=0.000 n=30)\r\nOstream_number/2/threads:72      28.49\u00b5 \u00b1 1%   18.89\u00b5 \u00b1 5%    -33.72% (p=0.000 n=30)\r\nOstream_number/3/threads:1       185.0n \u00b1 0%   185.0n \u00b1 0%      0.00% (p=0.017 n=30)\r\nOstream_number/3/threads:72      19.38\u00b5 \u00b1 4%   19.33\u00b5 \u00b1 5%          ~ (p=0.425 n=30)\r\n```", "feature_layers": [], "feature_directives": ["parallel", "atomic"], "files_changed": [{"filename": "libcxx/benchmarks/stringstream.bench.cpp", "functions": ["loc", "l", "istream_numbers", "guard"]}, {"filename": "libcxx/src/locale.cpp", "functions": ["__locale_", "operator"]}]}
{"pr_number": 73059, "url": "https://github.com/llvm/llvm-project/pull/73059", "title": "[RISCV][GISel] Legalize and select G_BRINDIRECT.", "body": "", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp", "functions": ["constrainSelectedInstRegOperands"]}]}
{"pr_number": 73569, "url": "https://github.com/llvm/llvm-project/pull/73569", "title": "    [libc] Move in_use into OptionalStorage", "body": "The previous optional class would call the destructor on a non-trivially\ndestructible object regardless of if it had already been reset. This\npatch fixes this by moving tracking for if the object exists into the\ninternal storage class for optional.\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "libc/test/src/__support/CPP/optional_test.cpp", "functions": ["Complicated"]}]}
{"pr_number": 73573, "url": "https://github.com/llvm/llvm-project/pull/73573", "title": "[sanitizer][nfc] Reformat sanitizer_linux sources", "body": "", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "compiler-rt/lib/sanitizer_common/sanitizer_linux.cpp", "functions": ["internal_sched_yield", "Aarch64GetESR", "internal_syscall", "internal_getpid", "int", "internal_dup", "__asm__", "proc_maps", "internal_getppid", "ReadBinaryName", "internal_close"]}, {"filename": "compiler-rt/lib/sanitizer_common/sanitizer_linux_libcdep.cpp", "functions": ["__android_log_write", "real_clock_gettime", "async_safe_write_log", "InitTlsSize", "memory_mapping", "ThreadSelf", "int", "android_set_abort_message", "proc_maps", "ThreadSelfTlsTcb"]}, {"filename": "compiler-rt/lib/sanitizer_common/sanitizer_linux_s390.cpp", "functions": ["__asm__"]}]}
{"pr_number": 72657, "url": "https://github.com/llvm/llvm-project/pull/72657", "title": "[readtapi] Add Extract & Remove architecture functionality", "body": "NOTE: This is a part of a stack. Please review https://github.com/llvm/llvm-project/pull/72656 first.\r\n\r\nThis adds functionality to tbd files similar to what `lipo -extract`\r\nand `lipo -remove` does for binaries.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/tools/llvm-readtapi/llvm-readtapi.cpp", "functions": ["handleWriteAction", "getInterfaceFile", "handleSingleFileAction"]}]}
{"pr_number": 73561, "url": "https://github.com/llvm/llvm-project/pull/73561", "title": "[mlir][sparse] rename DimLevelType to LevelType", "body": "The \"Dim\" prefix is a legacy left-over that no longer makes sense, since we have a very strict \"Dimension\" vs. \"Level\" definition for sparse tensor types and their storage.", "feature_layers": ["parse", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/IR/SparseTensorDialect.cpp", "functions": ["callback"]}]}
{"pr_number": 73575, "url": "https://github.com/llvm/llvm-project/pull/73575", "title": "[mlir][sparse] code cleanup, remove FIXMEs", "body": "", "feature_layers": ["parse", "ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/IR/SparseTensorDialect.cpp", "functions": ["getStaticDimSliceStride", "toStoredDim", "toLvl", "getStaticDimSliceOffset"]}, {"filename": "mlir/lib/Dialect/SparseTensor/Transforms/CodegenUtils.cpp", "functions": ["resShape"]}, {"filename": "mlir/lib/Dialect/SparseTensor/Transforms/LoopEmitter.cpp", "functions": ["createOrFoldSliceStrideOp", "createOrFoldSliceOffsetOp"]}]}
{"pr_number": 73408, "url": "https://github.com/llvm/llvm-project/pull/73408", "title": "[NewPM] Remove LazyValueInfoPrinter Pass", "body": "This pass isn't used anywhere upstream and thus has no test coverage. For these reasons, remove it.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Analysis/LazyValueInfo.cpp", "functions": ["getAnalysisUsage", "runOnFunction"]}]}
{"pr_number": 73192, "url": "https://github.com/llvm/llvm-project/pull/73192", "title": "[NFC sanitizer_symbolizer] Move Fuchsia specific code.", "body": "Moves sanitizer symbolizer code that is specific for\nfuchsia into its own _fuchsia.cpp file.\nThis is preparation to enable symbolizer markup in\nlinux.\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "compiler-rt/lib/sanitizer_common/sanitizer_symbolizer_markup.cpp", "functions": ["new", "RenderNeedsSymbolization"]}, {"filename": "compiler-rt/lib/sanitizer_common/sanitizer_symbolizer_markup_fuchsia.cpp", "functions": ["new"]}]}
{"pr_number": 73193, "url": "https://github.com/llvm/llvm-project/pull/73193", "title": "[sanitizer_symbolizer] Add initial symbolizer markup support for linux.", "body": "This is part of a stack of PRs to add support for symbolizer\nmarkup in linux.\n\nYou can check the symbolizer markup specification at:\nhttps://llvm.org/docs/SymbolizerMarkupFormat.html\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "compiler-rt/lib/sanitizer_common/sanitizer_symbolizer_markup.cpp", "functions": ["new", "RenderNeedsSymbolization"]}, {"filename": "compiler-rt/lib/sanitizer_common/sanitizer_symbolizer_markup_fuchsia.cpp", "functions": ["new"]}]}
{"pr_number": 73184, "url": "https://github.com/llvm/llvm-project/pull/73184", "title": "[RISCV][GISel] Select G_FENCE.", "body": "Using IR test to make it easier to compare with the SelectionDAG test output. The constant operands otherwise make it harder to understand.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp", "functions": ["selectFence"]}]}
{"pr_number": 73266, "url": "https://github.com/llvm/llvm-project/pull/73266", "title": "[mlir][affine] Fix dim index out of bounds crash", "body": "This PR suggests a way to fix https://github.com/llvm/llvm-project/issues/70418. It now throws an error if the `index` operand for `memref.dim` is out of bounds. Catching it in the verifier was not possible because the constant value is not yet available at that point. Unfortunately, the error is not very descriptive since it was only possible to propagate boolean up.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Affine/IR/AffineOps.cpp", "functions": ["emitOpError"]}]}
{"pr_number": 71780, "url": "https://github.com/llvm/llvm-project/pull/71780", "title": "Reland \"[clang][DebugInfo] Emit global variable definitions for static data members with constant initializers\"", "body": "This patch relands https://github.com/llvm/llvm-project/pull/70639\r\n\r\nIt was reverted because under certain conditions we triggered an assertion\r\nin `DIBuilder`. Specifically, in the original patch we called `EmitGlobalVariable`\r\nat the end of `CGDebugInfo::finalize`, after all the temporary `DIType`s have\r\nbeen uniqued. With limited debug-info such temporary nodes would be created\r\nmore frequently, leaving us with non-uniqued nodes by the time we got to\r\n`DIBuilder::finalize`; this violated its pre-condition and caused\r\nassertions to trigger.\r\n\r\nTo fix this, the latest iteration of the patch moves `EmitGlobalVariable` to the\r\nbeginning of `CGDebugInfo::finalize`. Now, when we create a temporary\r\n`DIType` node as a result of emitting a variable definition, it will get uniqued\r\nin time. A test-case was added for this scenario.\r\n\r\nWe also now don't emit a linkage name for non-locationed constants since\r\nLLDB doesn't make use of it anyway.\r\n\r\nOriginal commit message:\r\n\"\"\"\r\nWhen an LLDB user asks for the value of a static data member, LLDB starts\r\nby searching the Names accelerator table for the corresponding variable\r\ndefinition DIE. For static data members with out-of-class definitions that\r\nworks fine, because those get represented as global variables with a location\r\nand making them eligible to be added to the Names table. However, in-class\r\ndefinitions won\u2019t get indexed because we usually don't emit global variables\r\nfor them. So in DWARF we end up with a single `DW_TAG_member` that\r\nusually holds the constant initializer.  But we don't get a corresponding\r\nCU-level `DW_TAG_variable` like we do for out-of-class definitions.\r\n\r\nTo make it more convenient for debuggers to get to the value of inline static data\r\nmembers, this patch makes sure we emit definitions for static variables with\r\nconstant initializers the same way we do for other static variables. This also aligns\r\nClang closer to GCC, which produces CU-level definitions for inline statics and also\r\nemits these into `.debug_pubnames`.\r\n\r\nThe implementation keeps track of newly created static data members.\r\nThen in `CGDebugInfo::finalize`, we emit a global `DW_TAG_variable` with a\r\n`DW_AT_const_value` for any of those declarations that didn't end up with a\r\ndefinition in the `DeclCache`.\r\n\r\nThe newly emitted `DW_TAG_variable` will look as follows:\r\n```\r\n0x0000007b:   DW_TAG_structure_type\r\n                DW_AT_calling_convention        (DW_CC_pass_by_value)\r\n                DW_AT_name      (\"Foo\")\r\n                ...\r\n\r\n0x0000008d:     DW_TAG_member\r\n                  DW_AT_name    (\"i\")\r\n                  DW_AT_type    (0x00000062 \"const int\")\r\n                  DW_AT_external        (true)\r\n                  DW_AT_declaration     (true)\r\n                  DW_AT_const_value     (4)\r\n\r\nNewly added\r\nvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv\r\n\r\n0x0000009a:   DW_TAG_variable\r\n                DW_AT_specification     (0x0000008d \"i\")\r\n                DW_AT_const_value       (4)\r\n                DW_AT_linkage_name      (\"_ZN2t2IiE1iIfEE\")\r\n```\r\n\r\nThis patch also drops the `DW_AT_const_value` off of the declaration since we\r\nnow always have it on the definition. This ensures that the `DWARFParallelLinker`\r\ncan type-merge class with static members where we couldn't attach the constant\r\non the declaration in some CUs.\r\n\"\"\"\r\n\r\nDependent changes:\r\n* https://github.com/llvm/llvm-project/pull/71800", "feature_layers": [], "feature_directives": ["parallel", "for", "single"], "files_changed": [{"filename": "clang/test/CodeGenCXX/debug-info-static-inline-member.cpp", "functions": ["func", "main"]}]}
{"pr_number": 71663, "url": "https://github.com/llvm/llvm-project/pull/71663", "title": "[InstCombine] Make indexed compare fold GEP source type independent", "body": "The indexed compare fold converts comparisons of GEPs with same (indirect) base into comparisons of offset. Currently, it only supports GEPs with the same source element type.\r\n\r\nThis change makes the transform operate on offsets instead, which removes the type dependence. To keep closer to the scope of the original implementation, this keeps the limitation that we should only have at most one variable index per GEP.\r\n\r\nThis addresses the main regression from https://github.com/llvm/llvm-project/pull/68882.\r\n\r\nTBH I have some doubts that this is really a useful transform (at least for the case where there are extra pointer users, so we have to rematerialize pointers at some point). I can only assume it exists for a reason...", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp", "functions": ["Offset"]}]}
{"pr_number": 73117, "url": "https://github.com/llvm/llvm-project/pull/73117", "title": "[mlir] Add mlirTranslateModuleToLLVMIR to MLIR-C", "body": "Fixes #73008\r\n\r\nThis is my first PR to LLVM, hope everything is okay.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/test/CAPI/llvm.c", "functions": ["testToLLVMIR"]}, {"filename": "mlir/test/CAPI/translation.c", "functions": ["main", "testToLLVMIR"]}]}
{"pr_number": 68845, "url": "https://github.com/llvm/llvm-project/pull/68845", "title": "[lldb] [mostly NFC] Large WP foundation: WatchpointResources", "body": "This patch is rearranging code a bit to add WatchpointResources to Process.  A WatchpointResource is meant to represent a hardware watchpoint register in the inferior process.  It has an address, a size, a type, and a list of Watchpoints that are using this WatchpointResource.\r\n\r\nThis current patch doesn't add any of the features of WatchpointResources that make them interesting -- a user asking to watch a 24 byte object could watch this with three 8 byte WatchpointResources.  Or a Watchpoint on 1 byte at 0x1002 and a second watchpoint on 1 byte at 0x1003, these must both be served by a single WatchpointResource on that doubleword at 0x1000 on a 64-bit target, if two hardware watchpoint registers were used to track these separately, one of them may not be hit.  Or if you have one Watchpoint on a variable with a condition set, and another Watchpoint on that same variable with a command defined or different condition, or ignorecount, both of those Watchpoints need to evaluate their criteria/commands when their WatchpointResource has been hit.\r\n\r\nThere's a bit of code movement to rearrange things in the direction I'll need for implementing this feature, so I want to start with reviewing & landing this mostly NFC patch and we can focus on the algorithmic choices about how WatchpointResources are shared and handled as they're triggeed, separately.\r\n\r\nThis patch also stops printing \"Watchpoint <n> hit: old value: <x>, new vlaue: <y>\" for Read watchpoints.  I could make an argument for print \"Watchpoint <n> hit: current value <x>\" but the current output doesn't make any sense, and the user can print the value if they are particularly interested.  Read watchpoints are used primarily to understand what code is reading a variable.\r\n\r\nThis patch adds more fallbacks for how to print the objects being watched if we have types, instead of assuming they are all integral values, so a struct will print its elements.  As large watchpoints are added, we'll be doing a lot more of those.\r\n\r\nTo track the WatchpointSP in the WatchpointResources, I changed the internal API which took a WatchpointSP and devolved it to a Watchpoint*, which meant touching several different Process files. I removed the watchpoint code in ProcessKDP which only reported that watchpoints aren't supported, the base class does that already.\r\n\r\nI haven't yet changed how we receive a watchpoint to identify the WatchpointResource responsible for the trigger, and identify all Watchpoints that are using this Resource to evaluate their conditions etc.  This is the same work that a BreakpointSite needs to do when it has been tiggered, where multiple Breakpoints may be at the same address.\r\n\r\nThere is not yet any printing of the Resources that a Watchpoint is implemented in terms of (\"watchpoint list\", or\r\nSBWatchpoint::GetDescription).\r\n\r\n\"watchpoint set var\" and \"watchpoint set expression\" take a size argument which was previously 1, 2, 4, or 8 (an enum).  I've changed this to an unsigned int.  Most hardware implementations can only watch 1, 2, 4, 8 byte ranges, but with Resources we'll allow a user to ask for different sized watchpoints and set them in hardware-expressble terms soon.\r\n\r\nI've annotated areas where I know there is work still needed with LWP_TODO that I'll be working on once this is landed.\r\n\r\nI've tested this on aarch64 macOS, aarch64 Linux, and Intel macOS.\r\n\r\nhttps://discourse.llvm.org/t/rfc-large-watchpoint-support-in-lldb/72116", "feature_layers": ["ir"], "feature_directives": ["for", "single", "target"], "files_changed": [{"filename": "lldb/source/Plugins/Process/gdb-remote/ProcessGDBRemote.cpp", "functions": ["GetGDBStoppointType", "if"]}, {"filename": "lldb/source/Target/WatchpointResource.cpp", "functions": ["m_addr"]}, {"filename": "lldb/source/Target/WatchpointResourceList.cpp", "functions": ["guard"]}, {"filename": "lldb/source/Breakpoint/WatchpointCollection.cpp", "functions": ["lhs_guard", "guard"]}, {"filename": "lldb/source/Breakpoint/WatchpointResource.cpp", "functions": ["m_id"]}, {"filename": "lldb/source/Breakpoint/WatchpointResourceList.cpp", "functions": ["FindByWatchpoint", "guard"]}, {"filename": "lldb/source/Breakpoint/BreakpointSite.cpp", "functions": ["guard"]}, {"filename": "lldb/source/Breakpoint/BreakpointSiteList.cpp", "functions": ["site_sp", "guard", "operator"]}, {"filename": "lldb/source/Breakpoint/StopPointSiteList.cpp", "functions": ["guard"]}, {"filename": "lldb/source/Plugins/Platform/MacOSX/PlatformDarwin.cpp", "functions": ["bp_loc_sp"]}, {"filename": "lldb/source/Target/Platform.cpp", "functions": ["bp_loc_sp"]}, {"filename": "lldb/source/Target/Process.cpp", "functions": ["BreakpointSite"]}]}
{"pr_number": 68567, "url": "https://github.com/llvm/llvm-project/pull/68567", "title": "[mlir][linalg] Add TransposeConv2D Transform Op", "body": "* Add a LinAlg pass to convert 2D convolutions and quantized 2D convolutions that have the `FHWC` filter channel ordering into a transpose followed by 2D convolutions that have the `HWCF` channel ordering.\r\n\r\n* Add a lit test to check the semantics of the transformation are correct for both quantized and unquantized variants.", "feature_layers": ["sema", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Linalg/TransformOps/LinalgTransformOps.cpp", "functions": ["emitDefaultSilenceableFailure", "transposeConv2D"]}, {"filename": "mlir/lib/Dialect/Linalg/Transforms/TransposeConv2D.cpp", "functions": ["success", "newFilterShape", "filterPerm", "populateTranposeConv2DPatterns", "failure"]}]}
{"pr_number": 73325, "url": "https://github.com/llvm/llvm-project/pull/73325", "title": "[TableGen] Split GlobalISelCombinerEmitter into multiple files", "body": "Split MatchDataInfo, CXXPredicates and the Pattern hierarchy into their own files.\r\n\r\nThis should help with maintenance a bit, and make the API easier to navigate.\r\nI hope this encourages a bit more experimentation with MIR patterns, e.g. I'd like to try getting them in ISel at some point.\r\n\r\nCurrently, this is pretty much only moving code around. There is no significant refactoring in there.\r\nI want to split the Combiner backend even more at some point though, e.g. by separating the TableGen parsing logic into yet another file so other backends could very easily parse patterns themselves. \r\n\r\nNote: I moved the responsibility of managing string lifetimes into the backend instead of the Pattern class.\r\ne.g. Before you'd do `P.addOperand(Name)` but now it's `P.addOperand(insertStrRef(Name))`.\r\nI verified this was done correctly by running the tests with UBSan/ASan.", "feature_layers": ["parse", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/utils/TableGen/GlobalISel/CXXPredicates.cpp", "functions": ["CXXPredicateCode", "Code"]}, {"filename": "llvm/utils/TableGen/GlobalISel/MatchDataInfo.cpp", "functions": ["AssignMatchDataVariables"]}, {"filename": "llvm/utils/TableGen/GlobalISel/Patterns.cpp", "functions": ["count_if", "PT", "OS", "getImmValue", "isVariadic", "OTC", "CXXPattern", "Expander", "getInstName", "getOperand"]}, {"filename": "llvm/utils/TableGen/GlobalISelCombinerEmitter.cpp", "functions": ["getApplyDefsNeeded", "getOperandName", "LookupResult", "getName", "getAllApplyCode", "classof", "CXXPredicateCode", "propagateTypes", "isLiveIn", "Code", "isLLT", "PatFrag", "printExtras", "isNamedOperand", "getLLTCodeGen", "print", "getNumInstOperands", "named_operands", "lookup", "isSpecial", "Expander", "num_alternatives", "isDef", "canBeMatchRoot", "addOutParam", "PatternSymbol", "addUnsetFlag", "hasVariadicDefs", "str", "getQualifiedVariableName", "end", "getIsEnabledPredicateEnumName", "getTypeOf", "getNumInstDefs", "hasName", "addCopyFlag", "isVariadic", "get", "insertStrRef", "hasAllDefs", "hasVariableName", "setIsApply", "CXXPattern", "isNamedImmediate", "addSetFlag", "getInstName", "hasImmValue", "getOperand", "getPatternSymbol", "getAllMatchCode", "getType", "bool", "operands_size", "OTC", "InstructionPattern", "num_in_params", "isTypeOf", "setType", "num_out_params", "setVariableName", "if", "dump", "getBuiltinKind", "makeAnonPatName", "values", "withNewName", "setIsDef", "getParamIdx", "count_if", "OS", "getTypeOfOpName", "addInParam", "addOpcode", "Name", "out_params", "getLLTCodeGenOrTempType", "PrintError", "Kind", "begin", "getSorted", "buildOperandsTables", "PT", "getVariableName", "diagnoseAllSpecialTypes", "num_roots", "getRawCode", "map_range", "reportUnreachable", "getParamKindStr", "getImmValue", "in_params", "getLoc", "num_params", "checkSemantics", "printParamsList", "AssignMatchDataVariables", "describe", "getKind", "getEnumNameWithPrefix", "needsUnreachable", "is", "Pattern", "isNone", "keys", "Value", "getBuiltinInfo"]}]}
{"pr_number": 73234, "url": "https://github.com/llvm/llvm-project/pull/73234", "title": "[Clang] Improve support for expression messages in `static_assert`", "body": "- Support non-member functions and callable objects for size and data(). We previously tried to (badly) pick the best overload ourselves, in a way that would only support member functions. We now leave clang construct an unresolved member expression and call that, properly performing overload resolution with callable objects and static functions, consistent with the logic for `get` calls for structured bindings.\r\n- Support UDLs as message expression.\r\n- Add tests and mark CWG2798 as resolved", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CXX/drs/dr27xx.cpp", "functions": ["data", "size", "string"]}, {"filename": "clang/test/SemaCXX/static-assert-cxx26.cpp", "functions": ["data", "size", "operator"]}]}
{"pr_number": 73307, "url": "https://github.com/llvm/llvm-project/pull/73307", "title": "[LLDB] Respect the DW_AT_alignment attribute.", "body": "Part of fixes for #72913.\r\n\r\nclang emits `DW_AT_alignment` attribute, however LLDB didn't respect it, resulting in incorrect RecordDecls built by lldb.\r\n\r\nThis only fixes non-inheritance cases. The inheritance case will be handled in a follow-up patch.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "lldb/test/API/lang/cpp/alignas_base_class/main.cpp", "functions": ["alignas"]}]}
{"pr_number": 67430, "url": "https://github.com/llvm/llvm-project/pull/67430", "title": "[VFABI] Refactor try demangle for vfabi to use only the vector abi mangled names", "body": "    [VFABI] Refactor tryDemangleForVFABI to use only the Vector ABI mangled names\r\n            and the call's argument types to construct the VFInfo.\r\n    \r\n    Currently the tryDemangleForVFABI is incorrectly making assumptions that when\r\n    the mangled name has __LLVM__ set as ISA and _vlen_ is set to scalable/VLA\r\n    the module can be queried to identify the correct VF. This works currently only\r\n    by chance rather than by design and limits the ability to maximise the use for\r\n    the Vector ABI. This behaviour is changed by\r\n    https://github.com/llvm/llvm-project/pull/66656 and\r\n    https://github.com/llvm/llvm-project/pull/67308\r\n    and means demangling can be implemented as expected based solely on the rules\r\n    as documented within the VFABI.\r\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/tools/vfabi-demangle-fuzzer/vfabi-demangler-fuzzer.cpp", "functions": ["CI"]}, {"filename": "llvm/unittests/Analysis/VectorFunctionABITest.cpp", "functions": ["CI", "OpTys"]}, {"filename": "llvm/lib/Analysis/VFABIDemangling.cpp", "functions": ["verifyAllVectorsHaveSameWidth", "getECFromSignature", "tryParseVLEN", "Shape"]}]}
{"pr_number": 73096, "url": "https://github.com/llvm/llvm-project/pull/73096", "title": "[clang][AST][ASTMerge] prevent AST nodes from being deallocated early", "body": "This patch aims to fix [error in ast-merge to new ast file](https://github.com/llvm/llvm-project/issues/72783).\r\n`ASTUnit` is put in `for` body and AST nodes would be deallocated by allocator. Using these nodes later would lead to use after free bug.\r\nDebug the [issue](https://github.com/llvm/llvm-project/issues/72783) can prove it. Address interval (local from 0x3a9a00 to 0x3aaa00) allocated by allocator contains a `IdentifierInfo` variable (local address:0x3aa190) whose address is freed early.\r\nAs system header like stdio.h or math.h can't be put into test, it's hard to add testcase. Could anyone give me some guidance? Thanks in advance!", "feature_layers": ["ast"], "feature_directives": ["for", "allocate"], "files_changed": [{"filename": "clang/lib/Frontend/ASTMerge.cpp", "functions": ["Units"]}]}
{"pr_number": 72266, "url": "https://github.com/llvm/llvm-project/pull/72266", "title": "[AMDGPU] Allow folding to FMAAK with SGPR and immediate operand on GFX10+", "body": "Allow foldImmediate to create instructions like:\n\n  v_fmaak_f32 v0, s0, v0, 0x42000000\n\nThis instruction has two \"scalar values\": s0 and 0x42000000. On GFX10+\nthis is allowed. This fold was originally implemented before the\ncompiler supported GFX10, when all ASICs were limited to one scalar\nvalue.\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/SIInstrInfo.cpp", "functions": ["if"]}]}
{"pr_number": 68267, "url": "https://github.com/llvm/llvm-project/pull/68267", "title": "clang: Add pragma clang fp reciprocal", "body": "Just follow along with the reassociate pragma. This allows locally setting the arcp fast math flag. Previously you could only access this through the global -freciprocal-math.\r\n\r\nFixes #64798", "feature_layers": ["ast"], "feature_directives": [], "files_changed": [{"filename": "clang/test/CodeGen/fp-reciprocal-pragma.cpp", "functions": ["fp_recip_many", "fp_recip_call_helper", "fp_recip_scoped", "fp_file_scope_on", "fp_recip_off", "helper_func", "fp_recip_with_reassoc_simple", "fp_recip_simple", "base", "fp_recip_template", "fp_file_scope_stop", "fp_recip_disable", "template_recip"]}, {"filename": "clang/test/Parser/pragma-fp-contract.c", "functions": ["fp_recip_fail", "fp_recip_no_fast"]}, {"filename": "clang/test/Sema/eval-method-with-unsafe-math.c", "functions": ["f4_reciprocal_reassociate", "f2_reciprocal", "f3_reciprocal", "f4_reciprocal"]}]}
{"pr_number": 73606, "url": "https://github.com/llvm/llvm-project/pull/73606", "title": "[RISCV] Split build_vector into vreg sized pieces when exact VLEN is known", "body": "If we have a high LMUL build_vector and a known exact VLEN, we can decompose the build_vector into one build_vector per register in the register group. Doing so requires exact knowledge of which elements correspond to each register in the register group, and thus an exact VLEN must be known.\r\n\r\nSince we no longer have operations which are linear (or worse) in LMUL, this also allows us to lower all build_vectors without resorting to going through the stack.", "feature_layers": ["ir"], "feature_directives": ["requires"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVISelLowering.cpp", "functions": ["BuildVectorOps"]}]}
{"pr_number": 72392, "url": "https://github.com/llvm/llvm-project/pull/72392", "title": "[AArch64] Introduce the Armv9.5-A architecture version", "body": "This introduces the Armv9.5-A architecture version, including the\nrelevant command-line option for -march.\n\nMode details about the Armv9.5-A architecture version can be found at:\n* https://community.arm.com/arm-community-blogs/b/architectures-and-processors-blog/posts/arm-a-profile-architecture-developments-2023\n* https://developer.arm.com/documentation/ddi0602/2023-09/\n\nPatch by Oliver Stannard.\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Basic/Targets/AArch64.cpp", "functions": ["if"]}, {"filename": "clang/lib/Driver/ToolChains/Arch/AArch64.cpp", "functions": ["if"]}, {"filename": "llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp", "functions": ["if"]}]}
{"pr_number": 73183, "url": "https://github.com/llvm/llvm-project/pull/73183", "title": "[MsgPack] Handle Expected<T> errors in document reader", "body": "This was causing an assert on invalid in the modified test case.\r\n\r\nFixes this Issue: https://github.com/llvm/llvm-project/issues/48378\r\n\r\nThanks for taking a look!", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/Utils/AMDGPUPALMetadata.cpp", "functions": ["Reader"]}]}
{"pr_number": 73356, "url": "https://github.com/llvm/llvm-project/pull/73356", "title": "[NFC][libc++] Refactors the time.cal tests.", "body": "These tests use an old way to test code in constexpr context. This changes the code to the idomatic libc++ method.\r\n\r\nThis is a preparation for #73162.\r\n\r\nSide changes\r\n- Updated formatting\r\n- Made some helper functions constexpr\r\n- Some naming improvements", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "libcxx/test/std/time/time.cal/time.cal.day/time.cal.day.members/decrement.pass.cpp", "functions": ["d", "test", "main", "testConstexpr"]}, {"filename": "libcxx/test/std/time/time.cal/time.cal.day/time.cal.day.members/increment.pass.cpp", "functions": ["d", "test", "main", "testConstexpr"]}, {"filename": "libcxx/test/std/time/time.cal/time.cal.day/time.cal.day.members/plus_minus_equal.pass.cpp", "functions": ["d", "test", "main", "testConstexpr"]}, {"filename": "libcxx/test/std/time/time.cal/time.cal.day/time.cal.day.nonmembers/minus.pass.cpp", "functions": ["test", "main", "testConstexpr"]}, {"filename": "libcxx/test/std/time/time.cal/time.cal.day/time.cal.day.nonmembers/plus.pass.cpp", "functions": ["test", "main", "testConstexpr"]}, {"filename": "libcxx/test/std/time/time.cal/time.cal.month/time.cal.month.nonmembers/minus.pass.cpp", "functions": ["test", "main", "testConstexpr"]}, {"filename": "libcxx/test/std/time/time.cal/time.cal.weekday/time.cal.weekday.members/c_encoding.pass.cpp", "functions": ["test", "main", "wd", "testConstexpr"]}, {"filename": "libcxx/test/std/time/time.cal/time.cal.weekday/time.cal.weekday.members/decrement.pass.cpp", "functions": ["test", "main", "wd", "testConstexpr"]}, {"filename": "libcxx/test/std/time/time.cal/time.cal.weekday/time.cal.weekday.members/increment.pass.cpp", "functions": ["test", "main", "wd", "testConstexpr"]}, {"filename": "libcxx/test/std/time/time.cal/time.cal.weekday/time.cal.weekday.members/iso_encoding.pass.cpp", "functions": ["test", "main", "wd", "testConstexpr"]}, {"filename": "libcxx/test/std/time/time.cal/time.cal.weekday/time.cal.weekday.members/plus_minus_equal.pass.cpp", "functions": ["test", "main", "wd", "testConstexpr"]}, {"filename": "libcxx/test/std/time/time.cal/time.cal.weekday/time.cal.weekday.nonmembers/minus.pass.cpp", "functions": ["test", "main", "testConstexpr"]}, {"filename": "libcxx/test/std/time/time.cal/time.cal.weekday/time.cal.weekday.nonmembers/plus.pass.cpp", "functions": ["test", "main", "testConstexpr"]}, {"filename": "libcxx/test/std/time/time.cal/time.cal.year/time.cal.year.members/decrement.pass.cpp", "functions": ["yr", "test", "main", "testConstexpr"]}, {"filename": "libcxx/test/std/time/time.cal/time.cal.year/time.cal.year.members/increment.pass.cpp", "functions": ["yr", "test", "main", "testConstexpr"]}, {"filename": "libcxx/test/std/time/time.cal/time.cal.year/time.cal.year.members/plus_minus.pass.cpp", "functions": ["yr", "test", "main", "testConstexpr"]}, {"filename": "libcxx/test/std/time/time.cal/time.cal.year/time.cal.year.members/plus_minus_equal.pass.cpp", "functions": ["yr", "test", "main", "testConstexpr"]}, {"filename": "libcxx/test/std/time/time.cal/time.cal.year/time.cal.year.nonmembers/minus.pass.cpp", "functions": ["test", "main", "testConstexpr"]}, {"filename": "libcxx/test/std/time/time.cal/time.cal.year/time.cal.year.nonmembers/plus.pass.cpp", "functions": ["test", "main", "testConstexpr"]}, {"filename": "libcxx/test/std/time/time.cal/time.cal.ym/time.cal.ym.members/plus_minus_equal_month.pass.cpp", "functions": ["ym", "test", "main", "testConstexpr"]}, {"filename": "libcxx/test/std/time/time.cal/time.cal.ym/time.cal.ym.members/plus_minus_equal_year.pass.cpp", "functions": ["ym", "test", "main", "testConstexpr"]}, {"filename": "libcxx/test/std/time/time.cal/time.cal.ym/time.cal.ym.nonmembers/minus.pass.cpp", "functions": ["test", "main"]}, {"filename": "libcxx/test/std/time/time.cal/time.cal.ymd/time.cal.ymd.members/plus_minus_equal_month.pass.cpp", "functions": ["ym", "main", "ymd", "test", "testConstexpr"]}, {"filename": "libcxx/test/std/time/time.cal/time.cal.ymd/time.cal.ymd.members/plus_minus_equal_year.pass.cpp", "functions": ["ym", "test", "main", "testConstexpr"]}, {"filename": "libcxx/test/std/time/time.cal/time.cal.ymd/time.cal.ymd.nonmembers/plus.pass.cpp", "functions": ["test", "main", "testConstexprMonths", "testConstexprYears"]}, {"filename": "libcxx/test/std/time/time.cal/time.cal.ymdlast/time.cal.ymdlast.members/plus_minus_equal_month.pass.cpp", "functions": ["ym", "test", "main", "testConstexpr"]}, {"filename": "libcxx/test/std/time/time.cal/time.cal.ymdlast/time.cal.ymdlast.members/plus_minus_equal_year.pass.cpp", "functions": ["ymdl", "test", "main", "testConstexpr"]}, {"filename": "libcxx/test/std/time/time.cal/time.cal.ymdlast/time.cal.ymdlast.nonmembers/minus.pass.cpp", "functions": ["test", "main", "testConstexprMonths", "testConstexprYears"]}, {"filename": "libcxx/test/std/time/time.cal/time.cal.ymdlast/time.cal.ymdlast.nonmembers/plus.pass.cpp", "functions": ["test", "main", "testConstexprMonths", "testConstexprYears"]}, {"filename": "libcxx/test/std/time/time.cal/time.cal.ymwd/time.cal.ymwd.members/plus_minus_equal_month.pass.cpp", "functions": ["ymwd", "test", "main", "testConstexpr"]}, {"filename": "libcxx/test/std/time/time.cal/time.cal.ymwd/time.cal.ymwd.members/plus_minus_equal_year.pass.cpp", "functions": ["ymwd", "test", "main", "testConstexpr"]}, {"filename": "libcxx/test/std/time/time.cal/time.cal.ymwd/time.cal.ymwd.nonmembers/minus.pass.cpp", "functions": ["test", "main", "testConstexprMonths", "testConstexprYears"]}, {"filename": "libcxx/test/std/time/time.cal/time.cal.ymwd/time.cal.ymwd.nonmembers/plus.pass.cpp", "functions": ["test", "main", "testConstexprMonths", "testConstexprYears"]}, {"filename": "libcxx/test/std/time/time.cal/time.cal.ymwdlast/time.cal.ymwdlast.members/plus_minus_equal_month.pass.cpp", "functions": ["ymwd", "test", "main", "testConstexpr"]}, {"filename": "libcxx/test/std/time/time.cal/time.cal.ymwdlast/time.cal.ymwdlast.members/plus_minus_equal_year.pass.cpp", "functions": ["ymwd", "test", "main", "testConstexpr"]}, {"filename": "libcxx/test/std/time/time.cal/time.cal.ymwdlast/time.cal.ymwdlast.nonmembers/minus.pass.cpp", "functions": ["test", "main", "testConstexprMonths", "testConstexprYears"]}, {"filename": "libcxx/test/std/time/time.cal/time.cal.ymwdlast/time.cal.ymwdlast.nonmembers/plus.pass.cpp", "functions": ["test", "main", "testConstexprMonths", "testConstexprYears"]}]}
{"pr_number": 70353, "url": "https://github.com/llvm/llvm-project/pull/70353", "title": "[Clang] Warn on deprecated specializations used in system headers.", "body": "When the top of the instantiation stack is in user code.\r\n\r\nThe goal of this PR is to allow deprecation of some char_traits specializations in libc++ as done in https://reviews.llvm.org/D157058 which was later reverted by\r\nhttps://github.com/llvm/llvm-project/pull/66153#issuecomment-1719578384 as Clang never emitted the libc++ warnings.\r\n\r\nBecause Clang likes to eagerly instantiate, we can look for the location of the top of the instantiation stack, and emit a warning if that location is in user code.\r\n\r\nThe warning emission is forced by temporarily instructing the diag engine not to silence warning in system headers.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Sema/SemaAvailability.cpp", "functions": ["Engine"]}]}
{"pr_number": 72638, "url": "https://github.com/llvm/llvm-project/pull/72638", "title": "[Flang] Add code-object-version option", "body": "Information about code object version can be configured by the user for AMD GPU target and it needs to be placed in LLVM IR generated by Flang.\r\n\r\nInformation about code object version in MLIR generated by the parser can be reused by other tools. There is no need to specify extra flags if we want to invoke MLIR tools (like fir-opt) separately.", "feature_layers": ["parse", "ir", "parser"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "flang/lib/Frontend/FrontendActions.cpp", "functions": ["builder"]}]}
{"pr_number": 73174, "url": "https://github.com/llvm/llvm-project/pull/73174", "title": "[mlir] Add subbyte emulation support for `memref.store`.", "body": "This adds a conversion for narrow type emulation of memref.store ops. The conversion replaces the memref.store with two memref.atomic_rmw ops. Atomics are used to prevent race conditions on same-byte accesses, in the event that two threads are storing into the same byte.\r\n\r\nFixes https://github.com/openxla/iree/issues/15370", "feature_layers": ["ir"], "feature_directives": ["for", "atomic"], "files_changed": [{"filename": "mlir/lib/Dialect/MemRef/Transforms/EmulateNarrowType.cpp", "functions": ["success", "getValueOrCreateConstantIndexOp"]}]}
{"pr_number": 72709, "url": "https://github.com/llvm/llvm-project/pull/72709", "title": "[AMDGPU] Fix folding of v2i16/v2f16 splat imms", "body": "We can use inline constants with packed 16-bit operands, but these should use op_sel. Currently splat of inlinable constants is considered legal, which is not really true if we fail to fold it with op_sel and drop the high half. It may be legal as a literal but not as inline constant, but then usual literal checks must be performed.\r\n\r\nThis patch makes these splat literals illegal but adds additional logic to the operand folding to keep current folds. This logic is somewhat heavy though.\r\n\r\nThis has fixed constant bus violation in the fdot2 test.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/SIFoldOperands.cpp", "functions": ["Fold", "if", "tryFoldImmWithOpSel", "canUseImmWithOpSel"]}, {"filename": "llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.cpp", "functions": ["isInlinableLiteralV216", "isInlinableIntLiteralV216"]}]}
{"pr_number": 72139, "url": "https://github.com/llvm/llvm-project/pull/72139", "title": "[HLSL] Parameter modifier parsing and AST", "body": "This change implements parsing for HLSL's parameter modifier keywords `in`, `out` and `inout`. Because HLSL doesn't support references or pointers, these keywords are used to allow parameters to be passed in and out of functions.\r\n\r\nThis change only implements the parsing and AST support. In the HLSL ASTs we represent `out` and `inout` parameters as references, and we implement the semantics of by-value passing during IR generation.\r\n\r\nIn HLSL parameters marked `out` and `inout` are ambiguous in function declarations, and `in`, `out` and `inout` may be ambiguous at call sites.\r\n\r\nThis means a function may be defined as `fn(in T)` and `fn(inout T)` or `fn(out T)`, but not `fn(inout T)` and `fn(out T)`. If a funciton `fn` is declared with `in` and `inout` or `out` arguments, the call will be ambiguous the same as a C++ call would be ambiguous given declarations `fn(T)` and `fn(T&)`.\r\n\r\nFixes #59849", "feature_layers": ["sema", "ir", "ast"], "feature_directives": ["for", "declare"], "files_changed": [{"filename": "clang/lib/Parse/ParseDecl.cpp", "functions": ["getLangOpts"]}, {"filename": "clang/test/ParserHLSL/hlsl_parameter_modifiers.cpp", "functions": ["inFn", "fn6", "fn2", "fn5", "outFn", "implicitFn", "fn", "inoutFn", "fn4", "fn7", "fn3"]}]}
{"pr_number": 72952, "url": "https://github.com/llvm/llvm-project/pull/72952", "title": "Add support for parsing type unit entries in .debug_names.", "body": "This is a follow up patch after .debug_names can now emit local type unit entries when we compile with type units + DWARF5 + .debug_names. The pull request that added this functionality was:\r\n\r\nhttps://github.com/llvm/llvm-project/pull/70515\r\n\r\nThis patch makes sure that the DebugNamesDWARFIndex in LLDB will not manually need to parse type units if they have a valid index. It also fixes the index to be able to correctly extract name entries that reference type unit DIEs. Added a test to verify things work as expected.", "feature_layers": ["parse"], "feature_directives": ["for"], "files_changed": [{"filename": "lldb/test/Shell/SymbolFile/DWARF/x86/debug-types-debug-names.cpp", "functions": ["set", "main", "gets", "get", "b"]}]}
{"pr_number": 73037, "url": "https://github.com/llvm/llvm-project/pull/73037", "title": "[X86] With large code model, put functions into .ltext with large section flag", "body": "So that when mixing small and large text, large text stays out of the way of the rest of the binary.\n\nThis is useful for mixing precompiled small code model object files and built-from-source large code model binaries so that the the text sections don't get merged.\n", "feature_layers": [], "feature_directives": ["for", "sections"], "files_changed": [{"filename": "llvm/lib/Target/TargetMachine.cpp", "functions": ["getCodeModel"]}]}
{"pr_number": 71412, "url": "https://github.com/llvm/llvm-project/pull/71412", "title": "[OpenMP] Use simple VLA implementation to replace uses of actual VLA", "body": "Use of VLA can cause compile warning that was introduced in D156565. This patch\r\nimplements a simple stack/heap-based VLA that can miminc the behavior of an\r\nactual VLA and prevent the warning. By default the stack accomodates the\r\nelements. If the number of emelements is greater than N, which by default is 8,\r\na heap buffer will be allocated and used to acccomodate the elements.", "feature_layers": [], "feature_directives": ["allocate"], "files_changed": [{"filename": "openmp/runtime/src/kmp_gsupport.cpp", "functions": ["dep_list"]}, {"filename": "openmp/runtime/src/kmp_runtime.cpp", "functions": ["args"]}]}
{"pr_number": 73708, "url": "https://github.com/llvm/llvm-project/pull/73708", "title": "[mlir][sparse] move toCOOType into SparseTensorType class", "body": "Migrates dangling convenience method into proper SparseTensorType class. Also cleans up some details (picking right dim2lvl/lvl2dim). Removes more dead code.", "feature_layers": ["parse", "ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/Transforms/SparseTensorRewriting.cpp", "functions": ["getCOOType", "getCOOFromTypeWithOrdering"]}, {"filename": "mlir/lib/Dialect/SparseTensor/IR/SparseTensorDialect.cpp", "functions": ["src"]}]}
{"pr_number": 73290, "url": "https://github.com/llvm/llvm-project/pull/73290", "title": "[clang][ASTImporter] IdentifierInfo of Attribute should be set using 'ToASTContext'", "body": "", "feature_layers": ["ast"], "feature_directives": [], "files_changed": [{"filename": "clang/unittests/AST/ASTImporterTest.cpp", "functions": ["importAttr"]}]}
{"pr_number": 73630, "url": "https://github.com/llvm/llvm-project/pull/73630", "title": "[CodeGen] Port CallBrPrepare to new pass manager", "body": "IIUC in the new pass manager infrastructure, the analysis result is always computed lazily. So just use `getResult` here.", "feature_layers": ["codegen", "ast"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/CodeGen/CallBrPrepare.cpp", "functions": ["InsertIntrinsicCalls", "SplitCriticalEdges"]}]}
{"pr_number": 73733, "url": "https://github.com/llvm/llvm-project/pull/73733", "title": "[mlir][sparse] remove COO test from  trait and encoding", "body": "This is a minor step towards moving ALL COO related tests into the SparseTensorType class rather than\r\nhaving it all over the place (with risk of becoming inconsistent). Next revision will move ALL COO related methods into this class.", "feature_layers": ["parse", "ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/IR/SparseTensorDialect.cpp", "functions": ["getImpl"]}]}
{"pr_number": 73714, "url": "https://github.com/llvm/llvm-project/pull/73714", "title": "[MemProf] Add interface for reseting the profile file descriptor", "body": "Add __memprof_profile_reset() interface which can be used to facilitate\ndumping multiple rounds of profiles from a single binary run. This\ncloses the current file descriptor and resets the internal file\ndescriptor to invalid (-1), which ensures the underlying writer reopens\nthe recorded profile filename. This can be used once the client is done\nmoving or copying a dumped profile, to prepare for reinvoking profile\ndumping.\n", "feature_layers": [], "feature_directives": ["for", "single"], "files_changed": [{"filename": "compiler-rt/lib/memprof/memprof_allocator.cpp", "functions": ["__memprof_profile_reset"]}, {"filename": "compiler-rt/test/memprof/TestCases/profile_reset.cpp", "functions": ["main"]}]}
{"pr_number": 72935, "url": "https://github.com/llvm/llvm-project/pull/72935", "title": "[Clang] Fix ICE when `initial_suspend()`'s `await_resume()` returns a non-trivially destructible type", "body": "Attempts to fix https://github.com/llvm/llvm-project/issues/63803.\r\n\r\nA (close to) minimal repro:\r\n```\r\n#include <coroutine>\r\n\r\nstruct NontrivialType {\r\n  ~NontrivialType() {}\r\n};\r\n\r\nstruct Task {\r\n    struct promise_type;\r\n    using handle_type = std::coroutine_handle<promise_type>;\r\n\r\n    struct initial_suspend_awaiter {\r\n        bool await_ready() {\r\n            return false;\r\n        }\r\n\r\n        void await_suspend(handle_type h) {}\r\n\r\n        // Nontrivial type caused crash!\r\n        NontrivialType await_resume() noexcept {\r\n          return {};\r\n        }\r\n    };\r\n\r\n    struct promise_type {\r\n        void return_void() {}\r\n        void unhandled_exception() {}\r\n        initial_suspend_awaiter initial_suspend() { return {}; }\r\n        std::suspend_never final_suspend() noexcept { return {}; }\r\n        Task get_return_object() {\r\n            return Task{handle_type::from_promise(*this)};\r\n        }\r\n    };\r\n\r\n    handle_type handler;\r\n};\r\n\r\nTask coro() {\r\n    co_return;\r\n}\r\n```\r\n\r\nThe crash occurs when the return type of await_resume is not trivially destructible. We tried to emit an expr that binds the temporary to a RValue [here](https://github.com/llvm/llvm-project/blob/2ca028ce7c6de5f1350440012355a65383b8729a/clang/lib/CodeGen/CGCoroutine.cpp#L232-L259), that EmitAnyExpr messed up the EHScopeStack state EnterCXXTryStmt sets up for us.\r\n\r\nHowever, prior to this change, we created a `CXXTryStmt` around just `co_await promise-type.initial_suspend()` if the coroutine's ExceptionHandler exists. This PR merges the try stmt with the main try stmt and make it more like what the standard suggests in https://eel.is/c++draft/dcl.fct.def.coroutine#5.\r\n\r\nTODO: rewrite test. There's a single test failure to check existence of the exception flag in the original design. This is not really necessary anymore, but we should check that we successfully compile one try stmt that encloses the initial suspend as well. ", "feature_layers": ["codegen"], "feature_directives": ["task", "for", "single"], "files_changed": [{"filename": "clang/lib/CodeGen/CGCoroutine.cpp", "functions": ["memberCallExpressionCanThrow"]}]}
{"pr_number": 72346, "url": "https://github.com/llvm/llvm-project/pull/72346", "title": "[Clang] Fix finding instantiated decls for class template specializations during instantiation", "body": "This change aims to fix https://github.com/llvm/llvm-project/issues/70375\r\n\r\nIt appears to me that the logic here should be handling specializations in general, not just partial specialization. It also seems that both the comment before the block and the `isInstantiationOf(ClassTemplate, SpecTemplate)` below agree with my judgement. \r\n\r\nThe issue might just be a mistake that someone mistaken specialization as a special case of partial specializations, while it's actually the other way around.\r\n\r\nNeeds some experts to comment here if this is the right fix. \r\n\r\nThe code that caused clang ICE is added as a test case. ", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Sema/SemaTemplateInstantiateDecl.cpp", "functions": ["if"]}, {"filename": "clang/test/SemaCXX/member-template-specialization.cpp", "functions": ["take", "bar", "main", "foo"]}, {"filename": "clang/test/SemaCXX/template-specialization.cpp", "functions": ["take", "instantiate", "bar", "foo"]}]}
{"pr_number": 73649, "url": "https://github.com/llvm/llvm-project/pull/73649", "title": "[RISCV] Generate bexti for (select(setcc eq (and x, c))) where c is power of 2.", "body": "Currently, llvm can transform (setcc ne (and x, c)) to (bexti x, log2(c)) where c is power of 2.\r\nThis patch transform (select (setcc ne (and x, c)), T, F) into (select (setcc eq (and x, c)), F, T).\r\nIt is benefit to the case c is not fit to 12-bits.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVISelLowering.cpp", "functions": ["SDValue", "DL"]}]}
{"pr_number": 73160, "url": "https://github.com/llvm/llvm-project/pull/73160", "title": "[Clang] CGCoroutines skip emitting try block for value returning `noexcept` init `await_resume` calls", "body": "Previously we were not properly skipping the generation of the `try { }` block around the `init_suspend.await_resume()` if the `await_resume` is not returning void. The reason being that the resume expression was wrapped in a `CXXBindTemporaryExpr` and the first dyn_cast failed, silently ignoring the noexcept. This only mattered for `init_suspend` because it had its own try block.\r\n\r\nThis patch changes to first extract the sub expression when we see a `CXXBindTemporaryExpr`. Then perform the same logic to check for `noexcept`.\r\n\r\nAnother version of this patch also wanted to assert the second step by `cast<CXXMemberCallExpr>` and as far as I understand it should be a valid assumption. I can change to that if upstream prefers. \r\n", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/CodeGen/CGCoroutine.cpp", "functions": ["FunctionCanThrow", "isNoexceptExceptionSpec", "ResumeExprCanThrow", "ResumeStmtCanThrow", "FunctionProtoNoexcept"]}, {"filename": "clang/test/CodeGenCoroutines/coro-init-await-nontrivial-return.cpp", "functions": ["final_suspend", "unhandled_exception", "await_suspend", "initial_suspend", "return_void", "await_ready", "get_return_object", "await_resume", "coro_create"]}]}
{"pr_number": 73728, "url": "https://github.com/llvm/llvm-project/pull/73728", "title": "[msan][aarch64] Fix mallinfo interceptor", "body": "Not sure how the previous implementation supposed to work, but the test\nwas disabled.\n\nThis implementation works for x86_64 and aarch64.\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "compiler-rt/lib/msan/msan_interceptors.cpp", "functions": ["clear_mallinfo", "volatile"]}]}
{"pr_number": 73627, "url": "https://github.com/llvm/llvm-project/pull/73627", "title": "[mlir] Re-Add mlirTranslateModuleToLLVMIR to MLIR-C", "body": "The test was checking something unrelated to what it controlled so it failed after that part changed, i removed that.\r\n\r\nSee https://github.com/llvm/llvm-project/pull/73117", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/test/CAPI/llvm.c", "functions": ["testToLLVMIR"]}, {"filename": "mlir/test/CAPI/translation.c", "functions": ["main", "testToLLVMIR"]}]}
{"pr_number": 70634, "url": "https://github.com/llvm/llvm-project/pull/70634", "title": "[AMDGPU] Folding imm offset in more cases for scratch access", "body": "For scratch load/store, our hardware only accept non-negative value in SGPR/VGPR. Besides the case that we can prove from known bits, we can also prove that the value in `base` will be non-negative: 1.) When the ADD for the address calculation has NonUnsignedWrap flag. 2.) When the immediate offset is already negative.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/AMDGPUISelDAGToDAG.cpp", "functions": ["isNoUnsignedWrap"]}, {"filename": "llvm/lib/Target/AMDGPU/AMDGPUInstructionSelector.cpp", "functions": ["isNoUnsignedWrap"]}]}
{"pr_number": 73749, "url": "https://github.com/llvm/llvm-project/pull/73749", "title": "Revert \"[mlir] Re-Add mlirTranslateModuleToLLVMIR to MLIR-C (#73627)\"", "body": "Still breaks https://lab.llvm.org/buildbot/#/builders/5/builds/38743/steps/9/logs/stdio\r\n\r\nThere is some info on how to reproduce https://github.com/google/sanitizers/wiki/SanitizerBotReproduceBuild\r\n\r\nThis reverts commit 523160555925ff451e7c6d213a377d191e514805.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/test/CAPI/translation.c", "functions": ["main", "testToLLVMIR"]}]}
{"pr_number": 72489, "url": "https://github.com/llvm/llvm-project/pull/72489", "title": "[llvm-exegesis] Set stack pointer register after starting perf counter", "body": "Before this patch, in subprocess mode, llvm-exegesis setup the stack pointer register with the rest of the registers when it was requested by the user. This would cause a segfault when the instructions to start the perf counter ran as they use the stack to preserve the three registers needed to make the syscall. This patch moves the setup of the stack register to after the configuration of the perf counter to fix this issue so that we have a valid stack pointer for all the preceeding operations.\r\n\r\nRegression test added.\r\n\r\nThis fixes #72193.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/tools/llvm-exegesis/lib/X86/Target.cpp", "functions": ["getStackRegister"]}]}
{"pr_number": 73690, "url": "https://github.com/llvm/llvm-project/pull/73690", "title": "[OpenMP] Support for `nothing` in `metadirective`", "body": "- Removed an unnecessary check that was preventing `nothing` to work properly inside `metadirective`.", "feature_layers": ["ir"], "feature_directives": ["for", "metadirective"], "files_changed": [{"filename": "clang/lib/Parse/ParseOpenMP.cpp", "functions": ["getOpenMPDirectiveName"]}]}
{"pr_number": 73636, "url": "https://github.com/llvm/llvm-project/pull/73636", "title": "MachineTraceMetrics: fix may-store instrs in calculation", "body": "Since the MachineInstr/MachineOperand interface falls short of marking the first operand of a store as a def/write, introduce mayWriteReg as an approximation using MachineInstr::mayStore as an approximation to fix the depths of may-store instructions, and heights of instructions that depend on may-store instructions in MachineTraceMetrics. The patch has no impact on codegen in any target.\r\n\r\n-- 8< --\r\nDependent on #73324. Please review only second patch.", "feature_layers": ["codegen", "ir"], "feature_directives": ["target"], "files_changed": [{"filename": "llvm/lib/CodeGen/MachineTraceMetrics.cpp", "functions": ["mayWriteReg"]}]}
{"pr_number": 73530, "url": "https://github.com/llvm/llvm-project/pull/73530", "title": "[flang] Handle absent optional in LOC", "body": "LOC is a GNU extension, so gfortran is the reference for it, and it accepts absent OPTIONAL and returns zero. Support this use case in flang too.\r\n\r\nUpdate the LOC test to use HLFIR while touching it.\r\n\r\nFixes https://github.com/llvm/llvm-project/issues/72823.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Optimizer/Builder/IntrinsicCall.cpp", "functions": ["isOptional"]}]}
{"pr_number": 73251, "url": "https://github.com/llvm/llvm-project/pull/73251", "title": "[DebugInfo][RemoveDIs] Make debugify pass convert to/from RemoveDIs mode", "body": "Debugify is extremely useful as a testing and debugging tool, and a good number of LLVM-IR transform tests use it. We need it to support \"new\" non-instruction debug-info to get test coverage, but it's not important enough to completely convert right now (and it'd be a large undertaking). Thus: convert to/from dbg.value/DPValue mode on entry and exit of the pass, which gives us the functionality without any further work. The cost is compile-time, but again this is only happening during tests.\r\n\r\nTested by: the large set of debugify tests enabled here. Note the InstCombine test (cast-mul-select.ll) that hasn't been fully enabled: this is because there's a debug-info sinking piece of code there that hasn't been instrumented.", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Utils/Debugify.cpp", "functions": ["checkDebugifyMetadata", "applyDebugify"]}]}
{"pr_number": 73533, "url": "https://github.com/llvm/llvm-project/pull/73533", "title": "[libc++] Speed up classic locale (take 2)", "body": "[libc++] Speed up classic locale (#73533)\r\n\r\nLocale objects use atomic reference counting, which may be very\r\nexpensive in parallel applications. The classic locale is used by\r\ndefault by all streams and can be very contended. But it's never\r\ndestroyed, so the reference counting is also completely pointless on the\r\nclassic locale. Currently ~70% of time in the parallel stringstream\r\nbenchmarks is spent in locale ctor/dtor. And the execution radically\r\nslows down with more threads.\r\n\r\nAvoid reference counting on the classic locale. With this change\r\nparallel benchmarks start to scale with threads.\r\n\r\nThis is a re-application of f8afc53d641c (aka PR #72112) which was\r\nreverted in 4e0c48b907f1 because it broke the sanitizer builds due\r\nto an initialization order fiasco. This issue has now been fixed by\r\nensuring that the locale is constinit'ed.\r\n\r\n```\r\n                              \u2502   baseline   \u2502    optimized                            \u2502\r\n                              \u2502    sec/op    \u2502    sec/op      vs base                  \u2502\r\nIstream_numbers/0/threads:1      4.672\u00b5 \u00b1 0%   4.419\u00b5 \u00b1 0%     -5.42% (p=0.000 n=30+39)\r\nIstream_numbers/0/threads:72   539.817\u00b5 \u00b1 0%   9.842\u00b5 \u00b1 1%    -98.18% (p=0.000 n=30+40)\r\nIstream_numbers/1/threads:1      4.890\u00b5 \u00b1 0%   4.750\u00b5 \u00b1 0%     -2.85% (p=0.000 n=30+40)\r\nIstream_numbers/1/threads:72     66.44\u00b5 \u00b1 1%   10.14\u00b5 \u00b1 1%    -84.74% (p=0.000 n=30+40)\r\nIstream_numbers/2/threads:1      4.888\u00b5 \u00b1 0%   4.746\u00b5 \u00b1 0%     -2.92% (p=0.000 n=30+40)\r\nIstream_numbers/2/threads:72     494.8\u00b5 \u00b1 0%   410.2\u00b5 \u00b1 1%    -17.11% (p=0.000 n=30+40)\r\nIstream_numbers/3/threads:1      4.697\u00b5 \u00b1 0%   4.695\u00b5 \u00b1 5%          ~ (p=0.391 n=30+37)\r\nIstream_numbers/3/threads:72     421.5\u00b5 \u00b1 7%   421.9\u00b5 \u00b1 9%          ~ (p=0.665 n=30)\r\nOstream_number/0/threads:1       183.0n \u00b1 0%   141.0n \u00b1 2%    -22.95% (p=0.000 n=30)\r\nOstream_number/0/threads:72    24196.5n \u00b1 1%   343.5n \u00b1 3%    -98.58% (p=0.000 n=30)\r\nOstream_number/1/threads:1       250.0n \u00b1 0%   196.0n \u00b1 2%    -21.60% (p=0.000 n=30)\r\nOstream_number/1/threads:72    16260.5n \u00b1 0%   407.0n \u00b1 2%    -97.50% (p=0.000 n=30)\r\nOstream_number/2/threads:1       254.0n \u00b1 0%   196.0n \u00b1 1%    -22.83% (p=0.000 n=30)\r\nOstream_number/2/threads:72      28.49\u00b5 \u00b1 1%   18.89\u00b5 \u00b1 5%    -33.72% (p=0.000 n=30)\r\nOstream_number/3/threads:1       185.0n \u00b1 0%   185.0n \u00b1 0%      0.00% (p=0.017 n=30)\r\nOstream_number/3/threads:72      19.38\u00b5 \u00b1 4%   19.33\u00b5 \u00b1 5%          ~ (p=0.425 n=30)\r\n```", "feature_layers": [], "feature_directives": ["parallel", "atomic"], "files_changed": [{"filename": "libcxx/benchmarks/stringstream.bench.cpp", "functions": ["istream_numbers", "BM_Ostream_number", "guard", "sel", "loc"]}, {"filename": "libcxx/src/locale.cpp", "functions": ["g", "__no_destroy", "__locale_", "release", "operator", "get", "c", "acquire"]}]}
{"pr_number": 73780, "url": "https://github.com/llvm/llvm-project/pull/73780", "title": "[mlir][nvvm] Introduce `setmaxregister.sync.aligned` Op", "body": "This PR introduce `setmaxregister.sync.aligned` Op to increase or decrease the register size.\r\n\r\nhttps://docs.nvidia.com/cuda/parallel-thread-execution/index.html#miscellaneous-instructions-setmaxnreg", "feature_layers": ["ir"], "feature_directives": ["parallel"], "files_changed": [{"filename": "mlir/lib/Dialect/LLVMIR/IR/NVVMDialect.cpp", "functions": ["emitOpError"]}]}
{"pr_number": 72272, "url": "https://github.com/llvm/llvm-project/pull/72272", "title": "[AArch64][SME2] Enable CLAMP multi-vector builtins for SME2", "body": "Thing change add builtins for SME2:\r\n    sclamp.single.x2\r\n    uclamp.single.x2\r\n    fclamp.single.x2\r\n    sclamp.single.x4\r\n    uclamp.single.x4\r\n    fclamp.single.x4\r\n\r\nPatch by: Hassnaa Hamdi <hassnaa.hamdi@arm.com>", "feature_layers": [], "feature_directives": ["for", "single"], "files_changed": [{"filename": "clang/test/CodeGen/aarch64-sme2-intrinsics/acle_sme2_clamp.c", "functions": ["test_svclamp_single_u64_x2", "test_svclamp_single_s64_x4", "test_svclamp_single_u32_x2", "test_svclamp_single_s8_x4", "test_svclamp_single_s16_x4", "test_svclamp_single_u8_x4", "test_svclamp_single_f64_x4", "test_svclamp_single_s64_x2", "test_svclamp_single_s32_x2", "test_svclamp_single_u8_x2", "test_svclamp_single_f32_x4", "test_svclamp_single_s32_x4", "test_svclamp_single_f64_x2", "test_svclamp_single_u16_x2", "test_svclamp_single_s16_x2", "SVE_ACLE_FUNC", "test_svclamp_single_u16_x4", "test_svclamp_single_u32_x4", "test_svclamp_single_u64_x4", "test_svclamp_single_f16_x2", "test_svclamp_single_f16_x4", "test_svclamp_single_f32_x2", "test_svclamp_single_s8_x2"]}]}
{"pr_number": 73799, "url": "https://github.com/llvm/llvm-project/pull/73799", "title": "[libc] Fix the GPU build for the hashing support", "body": "Summary:\nFor reasons unknown to me, this function is undefined only on the GPU\nbuild if you use `uintptr_t` but not `uint64_t` directly. This patch\nmakes an ifdef to use this directly for the GPU build to fix the bots.\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "libc/src/__support/HashTable/generic/bitmask_impl.inc", "functions": ["repeat_byte"]}]}
{"pr_number": 73641, "url": "https://github.com/llvm/llvm-project/pull/73641", "title": "[flang] add fir.box_offset operation", "body": "This operation allows computing the address of descriptor fields. It is needed to help attaching descriptors in OpenMP/OpenACC target region. The pointers inside the descriptor structure must be mapped too, but the fir.box is abstract, so these fields cannot be computed with fir.coordinate_of.\r\n\r\nTo preserve the abstraction of the descriptor layout in FIR, introduce an operation specifically to !fir.ref<fir.box<>> address fields based on field names (base_addr or derived_type).", "feature_layers": ["ir"], "feature_directives": ["target"], "files_changed": [{"filename": "flang/lib/Optimizer/Dialect/FIROps.cpp", "functions": ["emitOpError", "if"]}]}
{"pr_number": 73592, "url": "https://github.com/llvm/llvm-project/pull/73592", "title": "[C API] Add support for setting/getting new nneg flag on zext instructions", "body": "This flag was added in #67982, but was not yet accessible via the C API. This commit adds a getter/setter for this flag, and a test for it", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/IR/Core.cpp", "functions": ["LLVMSetNNeg", "LLVMGetNNeg"]}]}
{"pr_number": 65392, "url": "https://github.com/llvm/llvm-project/pull/65392", "title": "[RISCV] Extract subregister if VLEN is known when lowering extract_subvector", "body": "If we know VLEN at compile time, then we can workout what subregister an index into a fixed length vector will be at.\r\nWe can use this information when lowering extract_subvector to perform the vslidedown on a smaller subregister. This allows us to use a smaller LMUL, or if the extract is aligned to a vector register then we can avoid the slide\r\naltogether.\r\n\r\nThe logic here is a bit tangled with the scalable path: If people find this too unwieldy, I can separate it out and duplicate it for the fixed case.\r\n\r\nThis technique could be applied to extract_vector_elt, insert_vector_elt and insert_subvector too.\r\n\r\nThis is stacked upon https://github.com/llvm/llvm-project/pull/65391", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVISelLowering.cpp", "functions": ["convertFromScalableVector"]}]}
{"pr_number": 73813, "url": "https://github.com/llvm/llvm-project/pull/73813", "title": "[OpenMP][NFC] Rename OmptCallback.cpp into OpenMP/OMPT/Callback.cpp", "body": "Also revert the ifdef OMPT_SUPPORT order to have the short fallback first and not after 400 lines.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "openmp/libomptarget/src/OpenMP/OMPT/Callback.cpp", "functions": ["ompt_libomptarget_connect"]}]}
{"pr_number": 73396, "url": "https://github.com/llvm/llvm-project/pull/73396", "title": "[libc++][format] Fixes formatting code units as integers.", "body": "This paper was voted in as a DR, so it's retroactively enabled back to C++20; the C++ version that introduced std::format.\r\n\r\nImplements:\r\n- P2909R4 Fix formatting of code units as integers (Dude, where\u2019s my ``char``?)", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "libcxx/test/std/utilities/format/format.formatter/format.formatter.spec/formatter.char.fsigned-char.pass.cpp", "functions": ["test", "main", "constexpr"]}, {"filename": "libcxx/test/std/utilities/format/format.formatter/format.formatter.spec/formatter.char.funsigned-char.pass.cpp", "functions": ["test", "main", "constexpr"]}]}
{"pr_number": 67700, "url": "https://github.com/llvm/llvm-project/pull/67700", "title": "[HLSL] Support vector swizzles on scalars", "body": "HLSL supports vector swizzles on scalars by implicitly converting the scalar to a single-element vector. This syntax is a convienent way to initialize vectors based on filling a scalar value.\r\n\r\nThere are two parts of this change. The first part in the Lexer splits numeric constant tokens when a `.x` or `.r` suffix is encountered. This splitting is a bit hacky but allows the numeric constant to be parsed separately from the vector element expression. There is an ambiguity here with the `r` suffix used by fixed point types, however fixed point types aren't supported in HLSL so this should not cause any exposable problems (a separate issue has been filed to track validating language options for HLSL: #67689).\r\n\r\nThe second part of this change is in Sema::LookupMemberExpr. For HLSL, if the base type is a scalar, we implicit cast the scalar to a one-element vector then call back to perform the vector lookup.\r\n\r\nFixes #56658 and #67511", "feature_layers": ["parse", "sema", "ir", "ast", "lexer"], "feature_directives": ["for", "single"], "files_changed": [{"filename": "clang/lib/CodeGen/CGExpr.cpp", "functions": ["EmitUnsupportedLValue", "EmitLValue"]}]}
{"pr_number": 72543, "url": "https://github.com/llvm/llvm-project/pull/72543", "title": "[libc++] Implements Runtime format strings II.", "body": "Implements\r\n- P2918R2 Runtime format strings II", "feature_layers": ["runtime"], "feature_directives": ["for"], "files_changed": [{"filename": "libcxx/test/std/utilities/format/format.fmt.string/ctor.runtime-format-string.pass.cpp", "functions": ["main"]}, {"filename": "libcxx/test/std/utilities/format/format.functions/format.locale.runtime_format.pass.cpp", "functions": ["main"]}, {"filename": "libcxx/test/std/utilities/format/format.functions/format.runtime_format.pass.cpp", "functions": ["main"]}, {"filename": "libcxx/test/std/utilities/format/format.syn/runtime_format_string.pass.cpp", "functions": ["main", "test_properties"]}]}
{"pr_number": 73819, "url": "https://github.com/llvm/llvm-project/pull/73819", "title": "[NFC][asan] clang-format for asan_init change ", "body": "[\ud835\ude00\ud835\uddfd\ud835\uddff] initial version", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "compiler-rt/lib/asan/asan_interceptors.cpp", "functions": ["REAL"]}]}
{"pr_number": 73817, "url": "https://github.com/llvm/llvm-project/pull/73817", "title": "[OpenMP][NFC] Separate OpenMP/OpenACC specific mapping code", "body": "While this does not really encapsulate the mapping code, it at least moves most of the declarations out of the way.", "feature_layers": ["ast"], "feature_directives": [], "files_changed": [{"filename": "openmp/libomptarget/src/OpenMP/Mapping.cpp", "functions": ["Info", "dumpTargetPointerMappings", "Kernel"]}]}
{"pr_number": 73751, "url": "https://github.com/llvm/llvm-project/pull/73751", "title": "Reapply \"[mlir] Add mlirTranslateModuleToLLVMIR to MLIR-C (#73627)\" (#73749)", "body": "", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/test/CAPI/translation.c", "functions": ["main", "testToLLVMIR"]}]}
{"pr_number": 73761, "url": "https://github.com/llvm/llvm-project/pull/73761", "title": "[mlir] Adopt `ConvertToLLVMPatternInterface` GpuToLLVMConversionPass to align with `convert-to-llvm`", "body": "This is a follow-up to the introduction of `convert-to-llvm`: it is supposed to be a unifying pass through the `ConvertToLLVMPatternInterface`, but some specific conversion (like the GPU target) aren't vanilla LLVM target. Instead they need extra customizations that are specific to LLVM-on-GPUs and our custom runtime wrappers.\r\nThis change make the GpuToLLVMConversionPass just as pluggable as the `convert-to-llvm` by using the same mechanism.", "feature_layers": ["runtime", "ir"], "feature_directives": ["target"], "files_changed": [{"filename": "mlir/lib/Conversion/GPUCommon/GPUToLLVMConversion.cpp", "functions": ["target", "options", "converter", "patterns", "getDependentDialects"]}]}
{"pr_number": 73397, "url": "https://github.com/llvm/llvm-project/pull/73397", "title": "[JITLink][AArch32] Draft fixture class for fixup tests and out-of-range errors in particular", "body": "Design draft for testing out-of-range errors and packing helper functions into a gtest fixture:\r\nhttps://github.com/google/googletest/blob/main/docs/primer.md#test-fixtures-using-the-same-data-configuration-for-multiple-tests-same-data-multiple-tests", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/unittests/ExecutionEngine/JITLink/AArch32ErrorTests.cpp", "functions": ["Interworking", "LastInRange", "FirstOutOfRange", "write"]}]}
{"pr_number": 73430, "url": "https://github.com/llvm/llvm-project/pull/73430", "title": "[BOLT] Add structure of CDSplit to SplitFunctions", "body": "This commit establishes the general structure of the CDSplit strategy in SplitFunctions without incorporating the exact splitting logic. With -split-functions -split-strategy=cdsplit, the SplitFunctions pass will run twice: the first time is before function reordering and functions are hot-cold split; the second time is after function reordering and functions are hot-warm-cold split based on the fixed function ordering. Currently, all functions are hot-warm split after the entry block in the second splitting pass. Subsequent commits will introduce the precise splitting logic. NFC.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "bolt/lib/Passes/SplitFunctions.cpp", "functions": ["compactFragments", "keepEmpty"]}, {"filename": "bolt/lib/Rewrite/BinaryPassManager.cpp", "functions": ["threeWaySplit"]}]}
{"pr_number": 73469, "url": "https://github.com/llvm/llvm-project/pull/73469", "title": "[libc] [search] implement hcreate(_r)/hsearch(_r)/hdestroy(_r)", "body": "This patch implements `hcreate(_r)/hsearch(_r)/hdestroy(_r)` as specified in https://man7.org/linux/man-pages/man3/hsearch.3.html.\r\n\r\nNotice that `neon/asimd` extension is not yet added in this patch. \r\n\r\n- The implementation is largely simplified from rust's [`hashbrown`](https://github.com/rust-lang/hashbrown/blob/master/src/raw/mod.rs) as we only consider fix-sized insertion-only hashtables. Technical details are provided in code comments.\r\n\r\n- This patch also contains a portable string hash function, which is derived from [`aHash`](https://github.com/tkaitchuck/aHash)'s fallback routine. Not using any SIMD acceleration, it has a good enough quality (passing all SMHasher tests) and is not too bad in speed.\r\n\r\n- Some general functionalities are added, such as `memory_size`, `offset_to`(alignment), `next_power_of_two`, `is_power_of_two`. `ctz/clz` are extended to support shorter integers.", "feature_layers": ["ast"], "feature_directives": ["master", "simd"], "files_changed": [{"filename": "libc/src/__support/HashTable/generic/bitmask_impl.inc", "functions": ["load", "match_byte", "repeat_byte", "mask_available"]}, {"filename": "libc/src/__support/HashTable/sse2/bitmask_impl.inc", "functions": ["match_byte", "load", "mask_available"]}, {"filename": "libc/test/src/__support/hash_test.cpp", "functions": ["popcnt", "mem", "counters", "offset"]}]}
{"pr_number": 73851, "url": "https://github.com/llvm/llvm-project/pull/73851", "title": "[RISCV] Minor improvements/cleanup to target attribute handling. NFC", "body": "Use ArrayRef to avoid a vector copy.\r\nReplace a push_back loop with a call to std::vector::insert.", "feature_layers": [], "feature_directives": ["target"], "files_changed": [{"filename": "clang/lib/Basic/Targets/RISCV.cpp", "functions": ["FeaturesNeedOverride", "ResolvedFeature"]}]}
{"pr_number": 70515, "url": "https://github.com/llvm/llvm-project/pull/70515", "title": "[LLVM][DWARF] Add support for monolithic types in .debug_names", "body": "Enable Type Units with DWARF5 accelerator tables for monolithic DWARF.\nImplementation relies on linker to tombstone offset in LocalTU list to -1 when\nit deduplciates type units using COMDAT.\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp", "functions": ["getUniqueTags", "ID", "getTagFromAbbreviationTag", "OffsetVal", "emitTUList", "populateAbbrevsMap", "CompUnitCount"]}, {"filename": "llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp", "functions": ["DwarfUnit"]}, {"filename": "llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp", "functions": ["DIEUnit", "DwarfUnit"]}]}
{"pr_number": 69266, "url": "https://github.com/llvm/llvm-project/pull/69266", "title": "[clang][CodeGen] Handle template parameter objects with explicit address spaces", "body": "For certain cases (e.g. when their address is observable at run time) it is necessary to provide physical backing for non-type template parameter objects. Said backing comes in the form of a global variable. For certain targets (e.g. AMDGPU), which use a non-default address space for globals, this can lead to an issue when referencing said global in address space agnostic languages (such as HIP), for example when passing them to a function. \n\nThis patch addresses this issue by inserting an address space cast iff there is an address space mismatch between the type of a reference expression and the address space of the backing global. A test is also added.", "feature_layers": ["codegen", "ir", "ast"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "clang/lib/CodeGen/CGExpr.cpp", "functions": ["MakeAddrLValue"]}, {"filename": "clang/test/CodeGenCXX/template-param-objects-address-space.cpp", "functions": ["observable_addr"]}]}
{"pr_number": 66716, "url": "https://github.com/llvm/llvm-project/pull/66716", "title": "[clang][CodeGen] Emit annotations for function declarations.", "body": "Previously, annotations were only emitted for function definitions. With this change annotations are also emitted for declarations. Also, emitting function annotations is now deferred until the end so that the most up to date declaration is used which will have any inherited annotations.", "feature_layers": ["codegen"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CodeGen/annotations-decl-use-decl.c", "functions": ["__attribute__", "foo"]}, {"filename": "clang/test/CodeGen/annotations-decl-use-define.c", "functions": ["__attribute__", "foo"]}, {"filename": "clang/test/CodeGen/annotations-declaration.c", "functions": ["foo", "main"]}, {"filename": "clang/test/CodeGenCXX/attr-annotate-destructor.cpp", "functions": ["m"]}]}
{"pr_number": 68443, "url": "https://github.com/llvm/llvm-project/pull/68443", "title": "[mlir][Vector] Add narrow type emulation pattern for vector.maskedload", "body": "", "feature_layers": ["ir"], "feature_directives": ["for", "masked"], "files_changed": [{"filename": "mlir/lib/Dialect/Vector/Transforms/VectorEmulateNarrowType.cpp", "functions": ["failure", "success"]}]}
{"pr_number": 73882, "url": "https://github.com/llvm/llvm-project/pull/73882", "title": "Fix hooks on realloc", "body": " `realloc` may involve both allocation and deallocation. Given that the\r\n  reporting the events is not atomic and which may lead the hook user to a\r\n  false case that the double-use pattern happens. In general, this can be\r\n  resolved on the hook side. To alleviate the task of handling it, we add\r\n  two new hooks to mark the range and reorder the reporting.\r\n", "feature_layers": [], "feature_directives": ["task", "atomic"], "files_changed": [{"filename": "compiler-rt/lib/scudo/standalone/tests/combined_test.cpp", "functions": ["Run"]}, {"filename": "compiler-rt/lib/scudo/standalone/tests/tsd_test.cpp", "functions": ["testRegistry", "stressCache", "TSD"]}, {"filename": "compiler-rt/lib/scudo/standalone/tests/wrappers_c_test.cpp", "functions": ["invalidateHookPtrsAs", "verifyReallocHooksScope", "invalidateAllocHookPtrAs"]}, {"filename": "compiler-rt/lib/scudo/standalone/wrappers_c.inc", "functions": ["reportReallocBegin", "reportReallocEnd"]}]}
{"pr_number": 73048, "url": "https://github.com/llvm/llvm-project/pull/73048", "title": "[mlir][vector] Add patterns to simplify chained reductions", "body": "Chained reductions get created during vector unrolling. These patterns simplify them into a series of adds followed by a final reductions.\r\n\r\nThis is preferred on GPU targets like SPIR-V/Vulkan where vector reduction gets lowered into subgroup operations that are generally more expensive than simple vector additions.\r\n\r\nFor now, only the `add` combining kind is handled.", "feature_layers": ["ir"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "mlir/lib/Dialect/Vector/Transforms/VectorTransforms.cpp", "functions": ["failure", "success"]}, {"filename": "mlir/test/lib/Dialect/Vector/TestVectorTransforms.cpp", "functions": ["getDescription", "getArgument", "runOnOperation", "patterns"]}]}
{"pr_number": 73583, "url": "https://github.com/llvm/llvm-project/pull/73583", "title": "[mlir][transform] Fix and improve \"cached names\" check", "body": "When running with \"expensive checks\", the transform dialect interpreter\r\nmaintains a payload `Operation *` -> `OperationName` cache. This cache\r\nis used to detect invalid API usage such as missing/incorrect handle\r\nconsumption/production side effects and/or payload IR modifications that\r\nbypass the rewriter.\r\n\r\nThere was a bug in the check that can cause issues such as #72931.\r\n(#72986 was just a workaround and did not really fix the underlying\r\nissue.)\r\n\r\n- Payload ops mapped to newly produced handles are now added to the\r\n  cache. This is in addition to adding/checking all mapped payload ops\r\n  at the beginning of each transform op, for extra safety.\r\n- Remove consumed ops (and their children) before applying the transform\r\n  op. This used to happen after applying the transform op, which is\r\n  incorrect in cases such as: (1) transform op replaces a consumed\r\n  payload op with another op, (2) the new op reuses the same memory\r\n  pointer and (3) the new op is added to a newly produced handle. In\r\n  such a case the previous implementation removed the newly created op\r\n  from the cache.\r\n- No assumptions can be made about whether an op should be in the cache\r\n  or not. The code previously reported an error when an op was not found\r\n  in the cache. E.g., this is problematic in cases such as: (1) the\r\n  transform op consumes the handle mapped to a payload op A and (2) the\r\n  implementation of the payload op removes/replaces a nested op with A,\r\n  which is mapped to another handle. This triggers a listener\r\n  notification, which removes the nested op from the cache. However,\r\n  because consumed ops (and their children) are removed from the cache\r\n  before applying the transform op, the nested op will not be in cache\r\n  and making such an assumption would be incorrect.\r\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Transform/IR/TransformInterfaces.cpp", "functions": ["emitError"]}]}
{"pr_number": 73709, "url": "https://github.com/llvm/llvm-project/pull/73709", "title": "[clang-offload-bundler] Add support for -check-input-archive", "body": "In this patch, we add support for checking a heterogeneous archive. We also significantly improve the clang-offload-bundler documentation.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Driver/OffloadBundler.cpp", "functions": ["createFileError", "forEachBundle", "createStringError"]}]}
{"pr_number": 73863, "url": "https://github.com/llvm/llvm-project/pull/73863", "title": "[BOLT] Create .text.warm for 3-way splitting", "body": "This commit explicitly adds a warm code section, .text.warm, when -split-functions -split-strategy=cdsplit is used. This replaces the previous approach of using .text.cold.0 as warm and .text.cold.1 as cold in 3-way function splitting. NFC.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "bolt/lib/Passes/SplitFunctions.cpp", "functions": ["Cold", "Main", "Warm"]}]}
{"pr_number": 73781, "url": "https://github.com/llvm/llvm-project/pull/73781", "title": "[X86][MC][CodeGen] Support EGPR for KMOV", "body": "KMOV is essential for copy between k-registers and GPRs.\r\nR16-R31 was added into GPRs in #70958, so we extend KMOV for these new\r\nregisters first.\r\n\r\nThis patch\r\n1.  Promotes KMOV instructions from VEX space to EVEX space\r\n2.  Emits prefix {evex} for the EVEX variants\r\n3.  Prefers EVEX variant than VEX variant in ISEL and optimizations for better RA\r\n\r\nEVEX variants will be compressed to VEX variants by existing EVEX2VEX pass if no EGPR is used.\r\n\r\nRFC: https://discourse.llvm.org/t/rfc-design-for-apx-feature-egpr-and-ndd-support/73031/4\r\nTAG: llvm-test-suite && CPU2017 can be built with feature egpr successfully.\r\n", "feature_layers": ["codegen", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/X86/MCTargetDesc/X86InstPrinterCommon.cpp", "functions": ["if"]}]}
{"pr_number": 73657, "url": "https://github.com/llvm/llvm-project/pull/73657", "title": "[mlir][docgen] Add ops source link", "body": "This patch suggests to change two things. Firstly, it adds a source link above the generated operations docs (above the `emitOpDoc` calls). This link will point directly to the source TableGen file for the group of operations. For example, for the current [`amdgpu`](https://mlir.llvm.org/docs/Dialects/AMDGPU/) page, the link will add a source link below the \"Operation definition\" heading pointing to [`mlir/include/mlir/Dialect/AMDGPU/IR/AMDGPU.td`](https://github.com/llvm/llvm-project/blob/main/mlir/include/mlir/Dialect/AMDGPU/IR/AMDGPU.td). The link is wrapped in a \"op-definitions-source-link\" class which could allow for custom styling, but it also looks reasonable without custom styling I think:\r\n\r\n![afbeelding](https://github.com/llvm/llvm-project/assets/20724914/7c0e59b9-b14b-4f5d-a671-c87e857a7b03)\r\n\r\nSecondly, this patch simplifies the header names such as \"Operation definition\" and \"Attribute definition\" to \"Operations\" and \"Attributes\" respectively. This is in line with manually defined subheadings on pages such as the one for the [`vector`](https://mlir.llvm.org/docs/Dialects/Vector/#operations) dialect.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/tools/mlir-tblgen/OpDocGen.cpp", "functions": ["emitSourceLink"]}]}
{"pr_number": 72977, "url": "https://github.com/llvm/llvm-project/pull/72977", "title": "Refactor ASTContext::getDeclAlign() (NFC)", "body": "@efriedma-quic\r\n@rjmccall\r\n\r\nWhile working on this (with the other patch: 72886), I found this refactoring at the top of the function which I like. What do you think?\r\n", "feature_layers": ["ast"], "feature_directives": [], "files_changed": [{"filename": "clang/lib/AST/ASTContext.cpp", "functions": ["if"]}]}
{"pr_number": 73770, "url": "https://github.com/llvm/llvm-project/pull/73770", "title": "[clang] Use current rounding mode for float inc/dec", "body": "Increment and decrement are equivalent to adding or subtracting 1. For the floating-point values these operations depend on the current rounding mode. Teach constant evaluator to perform ++ and -- according to the current floating-point environment.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/SemaCXX/rounding-math.cpp", "functions": ["incr_up", "incr_down"]}, {"filename": "clang/lib/AST/ExprConstant.cpp", "functions": ["checkFloatingPointResult"]}]}
{"pr_number": 73253, "url": "https://github.com/llvm/llvm-project/pull/73253", "title": "[mlir][ArmSME] Switch to an attribute-based tile allocation scheme", "body": "This reworks the ArmSME dialect to use attributes for tile allocation. This has a number of advantages and corrects some issues with the previous approach:\r\n\r\n * Tile allocation can now be done ASAP (i.e. immediately after `-convert-vector-to-arm-sme`)\r\n * SSA form for control flow is now supported (e.g.`scf.for` loops that yield tiles)\r\n * ArmSME ops can be converted to intrinsics very late (i.e. after lowering to control flow)\r\n * Tests are simplified by removing constants and casts\r\n * Avoids correctness issues with representing LLVM `immargs` as MLIR values\r\n    - The tile ID on the SME intrinsics is an `immarg` (so is required to be a compile-time constant), `immargs` should be mapped to MLIR attributes (this is already the case for intrinsics in the LLVM dialect)\r\n    - Using MLIR values for `immargs` can lead to invalid LLVM IR being generated (and passes such as -cse making incorrect optimizations)\r\n\r\nAs part of this patch we bid farewell to the following operations:\r\n\r\n```mlir\r\narm_sme.get_tile_id : i32\r\narm_sme.cast_tile_to_vector : i32 to vector<[4]x[4]xi32>\r\narm_sme.cast_vector_to_tile : vector<[4]x[4]xi32> to i32\r\n```\r\n\r\nThese are now replaced with:\r\n```mlir\r\n// Allocates a new tile with (indeterminate) state:\r\narm_sme.get_tile : vector<[4]x[4]xi32>\r\n// A placeholder operation for lowering ArmSME ops to intrinsics:\r\narm_sme.materialize_ssa_tile : vector<[4]x[4]xi32>\r\n```\r\n\r\nThe new tile allocation works by operations implementing the `ArmSMETileOpInterface`. This interface says that an operation needs to be assigned a tile ID, and may conditionally allocate a new SME tile.\r\n\r\nOperations allocate a new tile by implementing...\r\n```c++\r\nstd::optional<arm_sme::ArmSMETileType> getAllocatedTileType()\r\n```\r\n...and returning what type of tile the op allocates (ZAB, ZAH, etc).\r\n\r\nOperations that don't allocate a tile return `std::nullopt` (which is the default behaviour).\r\n\r\nCurrently the following ops are defined as allocating:\r\n```mlir\r\narm_sme.get_tile\r\narm_sme.zero\r\narm_sme.tile_load\r\narm_sme.outerproduct // (if no accumulator is specified)\r\n```\r\n\r\nAllocating operations become the roots for the tile allocation pass, which currently just (naively) assigns all transitive uses of a root operation the same tile ID. However, this is enough to handle current use cases.\r\n\r\nOnce tile IDs have been allocated subsequent rewrites can forward the tile IDs to any newly created operations.", "feature_layers": ["ir", "ast"], "feature_directives": ["for", "allocate"], "files_changed": [{"filename": "mlir/lib/Conversion/ArmSMEToLLVM/ArmSMEToLLVM.cpp", "functions": ["getTileIdOrError"]}, {"filename": "mlir/lib/Dialect/ArmSME/IR/ArmSME.cpp", "functions": ["failure", "success"]}, {"filename": "mlir/lib/Dialect/ArmSME/Transforms/TileAllocation.cpp", "functions": ["failure", "getMasks", "success", "target"]}, {"filename": "mlir/lib/Dialect/ArmSME/Utils/Utils.cpp", "functions": ["getSMETileSliceMinNumElts", "getSMETileType", "isValidSMETileElementType", "isValidSMETileVectorType"]}, {"filename": "mlir/lib/Dialect/ArmSME/IR/Utils.cpp", "functions": ["success", "verifyOperationHasValidTileId"]}]}
{"pr_number": 73777, "url": "https://github.com/llvm/llvm-project/pull/73777", "title": "[AArch64] Assembly support for the Checked Pointer Arithmetic Extension", "body": "This introduces assembly support for the Checked Pointer Arithmetic Extension (FEAT_CPA), annouced as part of the Armv9.5-A architecture version.\r\n\r\nThe changes include:\r\n* New subtarget feature for FEAT_CPA\r\n* New scalar instruction for pointer arithmetic\r\n  * ADDPT, SUBPT, MADDPT, and MSUBPT\r\n* New SVE instructions for pointer arithmetic\r\n  * ADDPT (vectors, predicated), ADDPT (vectors, unpredicated)\r\n  * SUBPT (vectors, predicated), SUBPT (vectors, unpredicated)\r\n  * MADPT and MLAPT\r\n* New ID_AA64ISAR3_EL1 system register\r\n\r\nMode details about the extension can be found at:\r\n* https://community.arm.com/arm-community-blogs/b/architectures-and-processors-blog/posts/arm-a-profile-architecture-developments-2023\r\n* https://developer.arm.com/documentation/ddi0602/2023-09/\r\n\r\nChanges by me and @rgwott .", "feature_layers": [], "feature_directives": ["for", "target"], "files_changed": [{"filename": "llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp", "functions": ["isLSLImm3Shift", "addLSLImm3ShifterOperands"]}]}
{"pr_number": 73776, "url": "https://github.com/llvm/llvm-project/pull/73776", "title": "[Abandoned][AArch64] Assembly support for the Checked Pointer Arithmetic Extension", "body": "", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp", "functions": ["isLSLImm3Shift", "addLSLImm3ShifterOperands"]}]}
{"pr_number": 72356, "url": "https://github.com/llvm/llvm-project/pull/72356", "title": "[RISCV] Implement RISCVInstrInfo::isAddImmediate", "body": "This hook is called by the target-independent implementation of TargetInstrInfo::describeLoadedValue. I've opted to test it via a C++ unit test, which although fiddly to set up seems the right way to test a function with such clear intended semantics (rather than testing the impact indirectly).\r\n\r\nisAddImmediate will never recognise ADDIW as an add immediate which I _think_ is conservatively correct, as the caller may not understand its semantics vs ADDI.\r\n\r\nNote that although the doc comment for isAddImmediate specifies its behaviuor solely in terms of physical registers, none of the current in-tree implementations (including this one) bail out on virtual registers.", "feature_layers": ["sema", "ir"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "llvm/unittests/Target/RISCV/RISCVInstrInfoTest.cpp", "functions": ["TT", "M", "SetUpTestSuite"]}]}
{"pr_number": 73149, "url": "https://github.com/llvm/llvm-project/pull/73149", "title": "[DebugInfo][RemoveDIs] Have getInsertionPtAfterDef return an iterator", "body": "Part of the \"RemoveDIs\" project to remove debug intrinsics requires passing block-positions around in iterators rather than as instruction pointers, allowing some debug-info to reside in BasicBlock::iterator. This means getInsertionPointAfterDef has to return an iterator, and as it can return no-instruction that means returning an optional iterator.\r\n\r\nThis patch changes the signature for getInsertionPtAfterDef and then patches up the various places that use it to handle the different type. This would overall be an NFC patch, however in InstCombinerImpl::freezeOtherUses I've started skipping any debug intrinsics at the returned insert-position. This should not have any _meaningful_ effect on the compiler output: at worst it means variable assignments that are skipped will now cover the freeze instruction and anything inserted before it, which should be inconsequential.\r\n\r\nSadly: this makes the function signature ugly. This is probably the ugliest piece of fallout for the \"RemoveDIs\" work, but it serves the overall purpose of improving compile times and not allowing `-g` to affect compiler output, so should be worthwhile in the end.", "feature_layers": ["ir"], "feature_directives": ["for", "requires"], "files_changed": [{"filename": "llvm/lib/Transforms/Scalar/GuardWidening.cpp", "functions": ["FreezeInst"]}, {"filename": "llvm/lib/IR/Instruction.cpp", "functions": ["getParent"]}, {"filename": "llvm/lib/Transforms/Coroutines/CoroFrame.cpp", "functions": ["if"]}]}
{"pr_number": 73365, "url": "https://github.com/llvm/llvm-project/pull/73365", "title": "[mlir][vector] Fix a `target-rank=0` unrolling", "body": "Fixes https://github.com/llvm/llvm-project/issues/64269.\r\n\r\nWith this patch, calling `mlir-opt \"-convert-vector-to-scf=full-unroll target-rank=0\"` on\r\n```mlir\r\nfunc.func @main(%vec : vector<2xi32>) {\r\n  %alloc = memref.alloc() : memref<4xi32>\r\n  %c0 = arith.constant 0 : index\r\n  vector.transfer_write %vec, %alloc[%c0] : vector<2xi32>, memref<4xi32>\r\n  return\r\n}\r\n```\r\nwill result in\r\n```mlir\r\nmodule {\r\n  func.func @main(%arg0: vector<2xi32>) {\r\n    %c0 = arith.constant 0 : index\r\n    %c1 = arith.constant 1 : index\r\n    %alloc = memref.alloc() : memref<4xi32>\r\n    %0 = vector.extract %arg0[0] : i32 from vector<2xi32>\r\n    %1 = vector.broadcast %0 : i32 to vector<i32>\r\n    vector.transfer_write %1, %alloc[%c0] : vector<i32>, memref<4xi32>\r\n    %2 = vector.extract %arg0[1] : i32 from vector<2xi32>\r\n    %3 = vector.broadcast %2 : i32 to vector<i32>\r\n    vector.transfer_write %3, %alloc[%c1] : vector<i32>, memref<4xi32>\r\n    return\r\n  }\r\n}\r\n```\r\n\r\nI've also tried to proactively find other `target-rank=0` bugs, but couldn't find any. `options.targetRank` is only used 8 times throughout the `mlir` folder, all inside `VectorToSCF.cpp`. None of the other uses look like they could cause a crash. I've also tried\r\n\r\n```mlir\r\nfunc.func @main(%vec : vector<2xi32>) -> vector<2xi32> {\r\n  %alloc = memref.alloc() : memref<4xindex>\r\n  %c0 = arith.constant 0 : index\r\n  %out = vector.transfer_read %alloc[%c0], %c0 : memref<4xindex>, vector<2xi32>\r\n  return %out : vector<2xi32>\r\n}\r\n```\r\nwith `\"--convert-vector-to-scf=full-unroll target-rank=0\"` and that also didn't crash. (Maybe obvious. I have to admit that I'm not very familiar with these ops.)", "feature_layers": ["ir", "ast"], "feature_directives": ["target"], "files_changed": [{"filename": "mlir/lib/Conversion/VectorToSCF/VectorToSCF.cpp", "functions": ["failure"]}]}
{"pr_number": 73671, "url": "https://github.com/llvm/llvm-project/pull/73671", "title": "[DebugInfo][RemoveDIs] Have LICM insert at iterator positions", "body": "Because we're storing some extra debug-info information in the iterator class, we need to insert new LICM-created stores using such iterators. Switch LICM to storing iterators instead of pointers when it promotes variables in loops, add a test for the desired behaviour, and enable RemoveDIs instrumentation on a variety of other LICM tests for good measure.\r\n\r\n(This would appear to be the only pass in LLVM that needs to store iterators on the heap).", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/IR/Instructions.cpp", "functions": ["StoreInst", "Instruction"]}]}
{"pr_number": 73910, "url": "https://github.com/llvm/llvm-project/pull/73910", "title": "Rematerialize load RISCV backend", "body": "Re materializing load is disabled for RISCV back end, and this can bring performance issues like this. https://discourse.llvm.org/t/how-to-copy-propagate-physical-register-introduced-before-ra/74828\r\n\r\nHere I tried to enable the re materialization to fulfill the use case discussed in the above thread.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVInstrInfo.cpp", "functions": ["UseItr", "DefItr"]}]}
{"pr_number": 73758, "url": "https://github.com/llvm/llvm-project/pull/73758", "title": "MachineVerifier: Reject extra non-register operands on instructions", "body": "We were allowing extra immediate arguments, and only bothering to check if registers were implicit or not.\r\n\r\nAlso consolidate extra operand checks in verifier, to make this testable. We had 3 different places checking if you were trying to build an instruction with more operands than allowed by the definition. We had an assertion in addOperand, a direct check in the MIRParser to avoid the assertion, and the machine verifier checks. Remove the assert and parser check so the verifier can provide a consistent verification experience, which will also handle instructions modified in place.", "feature_layers": ["parse", "ir", "parser"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/CodeGen/MIRParser/MIParser.cpp", "functions": ["error"]}]}
{"pr_number": 69407, "url": "https://github.com/llvm/llvm-project/pull/69407", "title": "[libc++][NFC] Refactor the core logic of operator new into helper functions", "body": "This will make it easier to implement new(nothrow) without calling the throwing version of new when exceptions are disabled. See https://llvm.org/D150610 for the full discussion.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "libcxx/src/new.cpp", "functions": ["new", "operator_new_impl", "operator_new_aligned_impl"]}, {"filename": "libcxxabi/src/stdlib_new_delete.cpp", "functions": ["new", "operator_new_impl", "operator_new_aligned_impl"]}]}
{"pr_number": 73182, "url": "https://github.com/llvm/llvm-project/pull/73182", "title": "[SLP][NFC] Unify code for cost estimation/codegen for buildvector, NFC.", "body": "This just moves towards reusing same function for both cost\nestimation/codegen for buildvector.\n", "feature_layers": ["codegen"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp", "functions": ["add"]}]}
{"pr_number": 73660, "url": "https://github.com/llvm/llvm-project/pull/73660", "title": "[DebugInfo][RemoveDIs] Support maintaining DPValues in CodeGenPrepare", "body": "CodeGenPrepare needs to support the maintenence of DPValues, the non-instruction replacement for dbg.value intrinsics. This means there are a few functions we need to duplicate or replicate the functionality of:\r\n * fixupDbgValue for setting users of sunk addr GEPs,\r\n * The remains of placeDbgValues needs a DPValue implementation for sinking\r\n * Rollback of RAUWs needs to update DPValues\r\n * Rollback of instruction removal needs supporting (see github #73350)\r\n * A few places where we have to use iterators rather than instructions.\r\n\r\nThere are three places where we have to use the setHeadBit call on iterators to indicate which portion of debug-info records we're about to splice around. This is because CodeGenPrepare, unlike other optimisation passes, is very much concerned with which block an operation occurs in and where in the block instructions are because it's preparing things to be in a format that's good for SelectionDAG.\r\n\r\nThere isn't a large amount of test coverage for debuginfo behaviours in this pass, hence I've added some more.", "feature_layers": ["codegen"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/CodeGen/CodeGenPrepare.cpp", "functions": ["DbgInserterHelper", "placeDPValues"]}]}
{"pr_number": 72675, "url": "https://github.com/llvm/llvm-project/pull/72675", "title": "[RISCV] Add combines to form binop from tail insert idioms", "body": "This patch contains two related combines:\r\n1) If we have an scalar vector insert into the result of a concat_vector,\r\n   sink the insert into the operand of the concat.\r\n2) If we have a insert of a scalar binop into a vector binop of the\r\n   same opcode and the RHS of both are constant, perform the insert\r\n   and then the binop.\r\n\r\nThe common theme to both is pushing inserts closer to the sources of the computation graph.  The goal is to enable forming vector bin ops from inserts of scalar binops at the end of another vector.\r\n\r\nFor RISCV specifically, the concat_vector transform will push inserts to smaller vectors.  This will have the effect of reducing lmul for the vslides, and usually doesn't require an additional vsetvli since\r\nthe source vectors are already working in the narrower VL.   I tried\r\nthat one as a target independent combine first, and it doesn't appear\r\nprofitable on all targets.\r\n\r\nThis is only one approach to the problem.  Another idea would be to aggressively form build_vectors and subvector inserts from the individual scalar inserts, and then have a transform which sunk a subvector_insert down through the concat.  The advantage of the alternate approach is that we expose parallelism in the insert sequence, even if the source vector isn't a concat_vector.  If reviewers are okay with it, I'd like to start with this approach, and then explore that direction in a follow up patch.", "feature_layers": ["ir"], "feature_directives": ["parallel", "for", "target"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVISelLowering.cpp", "functions": ["SDValue", "DL"]}]}
{"pr_number": 73062, "url": "https://github.com/llvm/llvm-project/pull/73062", "title": "[RISCV][GISEL] legalize, regbankselect, and instruction-select G_PTRMASK", "body": "This is done in instruction-select instead of in legalization for the sake of alias analysis.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/GISel/RISCVLegalizerInfo.cpp", "functions": ["legalizePtrMask"]}, {"filename": "llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp", "functions": ["lowerPtrMask"]}]}
{"pr_number": 73063, "url": "https://github.com/llvm/llvm-project/pull/73063", "title": "[RISCV][GISEL] Legalize G_VASTART using custom legalization", "body": "", "feature_layers": ["ast"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/Target/RISCV/GISel/RISCVLegalizerInfo.cpp", "functions": ["legalizeVAStart"]}]}
{"pr_number": 73064, "url": "https://github.com/llvm/llvm-project/pull/73064", "title": "[RISCV][GISEL] lowerFormalArguments for variadic arguments", "body": "", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/GISel/RISCVCallLowering.cpp", "functions": ["ArgRegs"]}]}
{"pr_number": 73879, "url": "https://github.com/llvm/llvm-project/pull/73879", "title": "[clang][NFC] Refactor expected directives in C++ DRs 1-99", "body": "This patch converts (almost) every expected directive in `test/CXX/drs/dr0xx.cpp` into either `@-1` form (when directive immediately follow the line diagnostic is pointing out to), or `@#<marker>` form (when directive is placed away from the line diagnostic is pointing out to). It also converts directive to match exactly one diagnostic, as opposed to matching multiple. Error messages are expanded to exactly match compiler output. `#if __cplusplus` guarding directives are replaced with respective prefixes (e.g. `since-cxx17`).\r\n\r\nAll aforementioned changes serve a purpose of making it easier to reconstruct expected compiler output, which should also make it a bit easier to grasp the gist of those already non-trivial tests due to their nature of testing corner cases of the language.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CXX/drs/dr0xx.cpp", "functions": ["g", "z", "dr29_f0", "g2", "R1", "get1", "dr4_g", "f", "delete", "h", "dr29_f7", "dr29_f8"]}]}
{"pr_number": 73881, "url": "https://github.com/llvm/llvm-project/pull/73881", "title": "[mlir][sparse] move all COO related methods into SparseTensorType", "body": "This centralizes all COO methods, and provides a cleaner API. Note that the \"enc\" only constructor is a temporary workaround the need for COO methods inside the \"enc\" only storage specifier.", "feature_layers": ["parse", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/IR/SparseTensorDialect.cpp", "functions": ["isCOOType"]}]}
{"pr_number": 73943, "url": "https://github.com/llvm/llvm-project/pull/73943", "title": "[AArch64][SVE] Added optimisation for SVE intrinsics for no active lanes", "body": "Closes #56573 \r\n\r\nThis patch introduces optimisations for SVE intrinsic function calls which have all false predicates.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp", "functions": ["instCombineSVEVectorSubU", "instCombineSVEAllOrNoActive", "instCombineSVEAllActive", "instCombineSVEVectorAddU"]}]}
{"pr_number": 73747, "url": "https://github.com/llvm/llvm-project/pull/73747", "title": "[CodeGen] Port SafeStack to new pass manager", "body": "Just copy the `runOnFunction` method from `SafeStackLegacyPass` and remove the workaround for computing analysis lazily, the analysis result in new pass manager is computed lazily by default.", "feature_layers": ["codegen"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/CodeGen/SafeStack.cpp", "functions": ["DTU"]}]}
{"pr_number": 72310, "url": "https://github.com/llvm/llvm-project/pull/72310", "title": "[flang][openacc] Disable CUDA argument checks in OpenACC regions", "body": "Checks for CUDA Fortran data attribute compatibility don't need to be applied in OpenACC regions.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Semantics/resolve-names.cpp", "functions": ["Pre", "Post"]}]}
{"pr_number": 73856, "url": "https://github.com/llvm/llvm-project/pull/73856", "title": "[clang][OpenMP] Fix missing DI for __kmpc_global_thread_num", "body": "", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/OpenMP/debug-info-kmpc.cpp", "functions": ["foo", "bar"]}]}
{"pr_number": 73972, "url": "https://github.com/llvm/llvm-project/pull/73972", "title": "[flang] Update to: Adjust checks of ICHAR/IACHAR argument length", "body": "When applying ICHAR/IACHAR to a character constant with length greater than one, resize the character constant to its first character.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "flang/lib/Evaluate/fold-integer.cpp", "functions": ["FromInt64"]}]}
{"pr_number": 73871, "url": "https://github.com/llvm/llvm-project/pull/73871", "title": "[mlir][vector] Add support for vector.maskedstore sub-type emulation.", "body": "The idea is similar to vector.maskedload + vector.store emulation. What the emulation does is:\r\n\r\n1. Get a compressed mask and load the data from destination.\r\n2. Bitcast the data to original vector type.\r\n3. Select values between `op.valueToStore` and the data from load using original mask.\r\n4. Bitcast the new value and store it to destination using compressed masked.", "feature_layers": ["ir", "ast"], "feature_directives": ["for", "masked"], "files_changed": [{"filename": "mlir/lib/Dialect/Vector/Transforms/VectorEmulateNarrowType.cpp", "functions": ["newMaskOperands", "newMaskDimSizes"]}]}
{"pr_number": 73965, "url": "https://github.com/llvm/llvm-project/pull/73965", "title": "Revert \"[CodeGen] Port SafeStack to new pass manager (#73747)\"", "body": "This reverts commit a4d5fd4d2ee9470e55345a9540f6b6fb6faf66e1.\r\n\r\nThe above commit breaks greendragon lldb bots:\r\nLink to failing builds:\r\nhttps://green.lab.llvm.org/green/view/LLDB/job/lldb-cmake/63300/ https://green.lab.llvm.org/green/view/LLDB/job/as-lldb-cmake/10345/\r\n\r\nI found this PR to be the offending one after using git bisect with the cmake invocation:\r\n\r\ncmake -G Ninja ../llvm -DCMAKE_BUILD_TYPE=Release\r\n-DCMAKE_EXPORT_COMPILE_COMMANDS=ON\r\n'-DLLVM_TARGETS_TO_BUILD=X86;ARM;AArch64'\r\n-DLLVM_ENABLE_ASSERTIONS:BOOL=TRUE\r\n-DLLVM_ENABLE_MODULES=On\r\n-DLLVM_ENABLE_PROJECTS='clang;lld;lldb;cross-project-tests' -DLLVM_VERSION_PATCH=99\r\n'-DLLVM_ENABLE_RUNTIMES=libcxx;libcxxabi;compiler-rt'\r\n\r\nand running\r\nninja lib/CodeGen/CMakeFiles/LLVMCodeGen.dir/CodeGenPassBuilder.cpp.o", "feature_layers": ["codegen", "runtime", "ir"], "feature_directives": ["target"], "files_changed": [{"filename": "llvm/lib/CodeGen/SafeStack.cpp", "functions": ["DTU"]}]}
{"pr_number": 72704, "url": "https://github.com/llvm/llvm-project/pull/72704", "title": "[flang] Improve procedure interface compatibility checking for dummy \u2026", "body": "\u2026arrays\r\n\r\nWhen comparing dummy array extents, cope with references to symbols better (including references to other dummy arguments), and emit warnings in dubious cases that are not equivalent but not provably incompatible.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Evaluate/characteristics.cpp", "functions": ["ShapesAreCompatible", "AreCompatibleDummyDataObjectShapes"]}, {"filename": "flang/lib/Evaluate/tools.cpp", "functions": ["GetBoundSymbol", "constexpr", "GetDummyArgumentNumber"]}]}
{"pr_number": 72991, "url": "https://github.com/llvm/llvm-project/pull/72991", "title": "[mlir][Vector] Add a rewrite pattern for gather over a strided memref", "body": "This patch adds a rewrite pattern for `vector.gather` over a strided memref like the following:\r\n\r\n```mlir\r\n%subview = memref.subview %arg0[0, 0] [100, 1] [1, 1] :\r\n    memref<100x3xf32> to memref<100xf32, strided<[3]>>\r\n%gather = vector.gather %subview[%c0] [%idxs], %cst_0, %cst :\r\n    memref<100xf32, strided<[3]>>, vector<4xindex>, vector<4xi1>, vector<4xf32>\r\n    into vector<4xf32>\r\n```\r\n\r\n```mlir\r\n%collapse_shape = memref.collapse_shape %arg0 [[0, 1]] :\r\n    memref<100x3xf32> into memref<300xf32>\r\n%1 = arith.muli %arg3, %cst : vector<4xindex>\r\n%gather = vector.gather %collapse_shape[%c0] [%1], %cst_1, %cst_0 :\r\n    memref<300xf32>, vector<4xindex>, vector<4xi1>, vector<4xf32>\r\n    into vector<4xf32>\r\n```\r\n\r\nFixes https://github.com/openxla/iree/issues/15364.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Vector/Transforms/LowerVectorGather.cpp", "functions": ["failure"]}]}
{"pr_number": 73987, "url": "https://github.com/llvm/llvm-project/pull/73987", "title": "[mlir][sparse] bug fix on all-dense lex insertion", "body": "Fixes a bug that appended values after insertion completed. Also slight optimization by avoiding all-Dense computation for every lexInsert call", "feature_layers": ["parse", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/ExecutionEngine/SparseTensor/Storage.cpp", "functions": ["isAllDense"]}]}
{"pr_number": 73841, "url": "https://github.com/llvm/llvm-project/pull/73841", "title": "[flang][openacc] Support early return in acc.loop", "body": "Early return is accepted in OpenACC loop not directly nested in a compute construct. Since acc.loop operation has a region, the `func.return` operation cannot be directly used inside the region.\r\nAn early return is materialized by an `acc.yield` operation returning a `true` value. The standard end of the `acc.loop` region yield a `false` value in this case. \r\nA conditional branch operation on the `acc.loop` result will branch to the `finalBlock` or just to the continue block whether an early exit was produce in the acc.loop. \r\n", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "flang/lib/Lower/OpenACC.cpp", "functions": ["hasEarlyReturn", "constexpr"]}]}
{"pr_number": 73877, "url": "https://github.com/llvm/llvm-project/pull/73877", "title": "Allow for mixing source/no-source DIFiles in one CU", "body": "The DWARF proposal that the DW_LNCT_LLVM_source extension is based on\r\n(https://dwarfstd.org/issues/180201.1.html) allows to mix source and\r\nnon-source files in the same CU by storing an empty string as a\r\nsentinel value.\r\n\r\nThis patch implements this feature.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/IR/Verifier.cpp", "functions": ["verifySourceDebugInfo"]}, {"filename": "llvm/lib/DebugInfo/DWARF/DWARFDebugLine.cpp", "functions": ["if"]}]}
{"pr_number": 73994, "url": "https://github.com/llvm/llvm-project/pull/73994", "title": "[OpenMP][NFC] Separate Envar (environment variable) handling", "body": "", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "openmp/libomptarget/src/device.cpp", "functions": ["OMPX_ReplaySaveOutput", "OMPX_RecordKernel"]}]}
{"pr_number": 68757, "url": "https://github.com/llvm/llvm-project/pull/68757", "title": "[AMDGPU] Rework dot4 signedness checks", "body": "Rely on AMDGPUISD::*_MUL for most cases -- as signedness semantics have already been calculated and encoded into these ops.\r\n\r\nIn cases where we have an ISD::MUL, try harder to reason about the semantics given the signedness info in the ByteProvider.\r\n\r\nSolves some edge cases.", "feature_layers": ["sema"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/SIISelLowering.cpp", "functions": ["calculateSrcByte", "calculateByteProvider"]}]}
{"pr_number": 72189, "url": "https://github.com/llvm/llvm-project/pull/72189", "title": "[mlir] Expose type and attribute names in the MLIRContext and abstract type/attr classes", "body": "This patch expose the type and attribute names in C++ as methods in the `AbstractType` and `AbstractAttribute` classes, and keep a map of names to `AbstractType` and `AbstractAttribute` in the `MLIRContext`. Type and attribute names should be unique.\r\n\r\nIt adds support in ODS to generate the `getName` methods in `AbstractType` and `AbstractAttribute`, through the use of two new variables, `typeName` and `attrName`. It also adds names to C++-defined type and attributes.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/tools/mlir-tblgen/AttrOrTypeDefGen.cpp", "functions": ["emitName"]}, {"filename": "mlir/unittests/IR/TypeTest.cpp", "functions": ["getTypeName"]}, {"filename": "mlir/unittests/Interfaces/DataLayoutInterfacesTest.cpp", "functions": ["getAttrName"]}, {"filename": "mlir/lib/IR/MLIRContext.cpp", "functions": ["lookup"]}, {"filename": "mlir/unittests/IR/TypeAttrNamesTest.cpp", "functions": ["Dialect", "getDialectNamespace"]}]}
{"pr_number": 73986, "url": "https://github.com/llvm/llvm-project/pull/73986", "title": "[mlir][sparse] refactoring: using util functions to query the index to load from position array for slice-driven loop.", "body": "", "feature_layers": ["parse", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/Transforms/LoopEmitter.cpp", "functions": ["ADDI", "genAlloca", "genIndexLoad"]}]}
{"pr_number": 73997, "url": "https://github.com/llvm/llvm-project/pull/73997", "title": "[ThinLTO] Fix assembly dumping of vtable type ids", "body": "With RTTI, a C++ class type info will get two entries in the summary\nindex: a gv and a typeidCompatibleVTable, both sharing the same GUID.\nEnsure we use different namespaces to generate the entry slot numbers\nfor these two different summary entries.\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/IR/AsmWriter.cpp", "functions": ["getTypeIdCompatibleVtableSlot", "CreateTypeIdCompatibleVtableSlot"]}]}
{"pr_number": 74032, "url": "https://github.com/llvm/llvm-project/pull/74032", "title": "[BOLT] CDSplit main logic part 2/2", "body": "This diff implements the main splitting logic of CDSplit. CDSplit processes functions in a binary in parallel. For each function BF, it assumes that all other functions are hot-cold split. For each possible hot-warm split point of BF, it computes its corresponding SplitScore, and chooses the split point with the best SplitScore. The SplitScore of each split point is computed in the following way: each call edge or jump edge has an edge score that is proportional to its execution count, and inversely proportional to its distance. The SplitScore of a split point is a sum of edge scores over a fixed set of edges whose distance can change due to hot-warm splitting BF. This set contains all cover calls in the form of X->Y or Y->X given function order [... X ... BF ... Y ...]; we refer to the sum of edge scores over the set of cover calls as CoverCallScore. This set also contains all jump edges (branches) within BF as well as all call edges originated from BF; we refer to the sum of edge scores over this set of edges as LocalScore. CDSplit finds the split index maximizing CoverCallScore + LocalScore.", "feature_layers": [], "feature_directives": ["parallel", "for"], "files_changed": [{"filename": "bolt/lib/Passes/SplitFunctions.cpp", "functions": ["computeCallScore", "computeJumpScore"]}]}
{"pr_number": 74027, "url": "https://github.com/llvm/llvm-project/pull/74027", "title": "Reland \"[CodeGen] Port SafeStack to new pass manager", "body": "Forgot to update related code in `CodeGenPassBuilder.h`, also update it for `CallBrPreparePass`.\r\nFix build when `LLVM_ENABLE_MODULES:BOOL=ON`.", "feature_layers": ["codegen"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/CodeGen/SafeStack.cpp", "functions": ["DTU"]}]}
{"pr_number": 73909, "url": "https://github.com/llvm/llvm-project/pull/73909", "title": "[RISCV] Move AVL coalescing logic upwards into computeInfoForInstr. NFC", "body": "There is an optimisation in transferBefore where if a VSETVLIInfo uses the AVL\nof a defining vsetvli, it uses that vsetvli's AVL provided VLMAX is the same.\n\nThis patch moves it out of transferBefore and up into computeInfoForInstr to\nshow how it isn't affected by the other optimisations in transferBefore, and to\nsimplify the control flow by removing an early return.\n\nThis should make #72352 easier to reason about.\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp", "functions": ["getInfoForVSETVLI"]}]}
{"pr_number": 72352, "url": "https://github.com/llvm/llvm-project/pull/72352", "title": "[RISCV] Minimally modify incoming state in transferBefore", "body": "transferBefore currently takes an incoming state and an instruction, computes\r\nthe new state needed for the instruction, and then modifies that new state to\r\nbe more similar to the incoming state.\r\n\r\nThis patch reverses the approach by instead taking the incoming state and\r\nmodifying only the bits that are demanded by the instruction.\r\n\r\nIt is currently NFC, but later patches would rework adjustIncoming to bring back the improvements from earlier revisions of this PR.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp", "functions": ["getMaskAgnostic", "getTailAgnostic"]}]}
{"pr_number": 65755, "url": "https://github.com/llvm/llvm-project/pull/65755", "title": "[RISCV] Make InitUndef handle undef operand", "body": "https://github.com/llvm/llvm-project/issues/65704.\r\n\r\n---\r\n\r\nWhen operand be mark as undef, the InitUndef will miss this case. \r\n\r\nThis patch\r\n\r\n1. support the undef operand case\r\n2. Merge the code for `handleImplictDef` and `fixupUndefOperandOnly` to reduce the searching logic.\r\n\r\n\r\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVRVVInitUndef.cpp", "functions": ["fixupUndefOperandOnly", "fixupIllOperand", "handleReg", "findImplictDefMIFromReg"]}]}
{"pr_number": 73355, "url": "https://github.com/llvm/llvm-project/pull/73355", "title": "[clang] Use the materialized temporary's type while creating the APValue", "body": "See https://github.com/llvm/llvm-project/issues/72025 for the bug and its diagnosis.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/SemaCXX/pr72025.cpp", "functions": ["V"]}]}
{"pr_number": 69041, "url": "https://github.com/llvm/llvm-project/pull/69041", "title": "[clang] Additional FP classification functions", "body": "C language standard defined library functions `iszero`, `issignaling` and `issubnormal`, which did not have counterparts among clang builtin functions. This change adds new functions:\r\n\r\n    __builtin_iszero\r\n    __builtin_issubnormal\r\n    __builtin_issignaling\r\n\r\nThey provide builtin implementation for the missing standard functions.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/CodeGen/CGBuiltin.cpp", "functions": ["FPOptsRAII"]}, {"filename": "clang/lib/AST/ExprConstant.cpp", "functions": ["Val", "EvaluateFloat"]}, {"filename": "clang/lib/AST/Interp/InterpBuiltin.cpp", "functions": ["retInt"]}]}
{"pr_number": 73806, "url": "https://github.com/llvm/llvm-project/pull/73806", "title": "[mlir] notify insertion of parent op first when cloning", "body": "When cloning an operation with a region, the builder was currently notifying about the insertion of the cloned operations inside the region before the cloned operation itself.\r\n\r\nWhen using cloning inside rewrite pass, this could cause issues if a pattern is expected to be applied on a cloned parent operation before trying to apply patterns on the cloned operations it contains (the patterns are attempted in order of notifications for the cloned operations).", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/IR/Builders.cpp", "functions": ["insert"]}, {"filename": "mlir/test/lib/IR/TestClone.cpp", "functions": ["notifyOperationInserted"]}]}
{"pr_number": 73577, "url": "https://github.com/llvm/llvm-project/pull/73577", "title": "[GlobalIsel] Transform build_vector(binop(_, C), ...) -> binop(bv, constant bv)", "body": "test plan: ninja check-llvm-codegen\r\n\r\nPort of https://github.com/llvm/llvm-project/pull/67358\r\n\r\nThe almost duplicated code is caused by the distinction of integers and floats.\r\n\r\nTransforms a build vector of identically binops where the RHS is always a constant into a binop of two build vectors. The second is a constant build vector. Instead of O(n) binops, we take one vector binop and gain one constant build vector. The constant build vector might trigger other combines.\r\n\r\nDifferences: constants are not immediates but G_CONSTANT resp. G_FCONSTANT. Thus the hit rate may be higher, e.g., the constant might be hidden behind a COPY.\r\n\r\nCredits: @preames", "feature_layers": ["codegen"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/CodeGen/GlobalISel/MachineIRBuilder.cpp", "functions": ["buildInstr"]}]}
{"pr_number": 69447, "url": "https://github.com/llvm/llvm-project/pull/69447", "title": "[Driver] Add ExclusiveGroup feature to multilib.yaml.", "body": "This allows a YAML-based multilib configuration to specify explicitly that a subset of its library directories are alternatives to each other, i.e. at most one of that subset should be selected.\r\n\r\nSo if you have multiple sysroots each including a full set of headers and libraries, you can mark them as members of the same ExclusiveGroup, and then you'll be sure that only one of them is selected, even if two or more are compatible with the compile options.\r\n\r\nThis is particularly important in multilib setups including the libc++ headers, where selecting the include directories from two different sysroots can cause an actual build failure. This occurs when including <stdio.h>, for example: libc++'s stdio.h is included first, and will try to use `#include_next` to fetch the underlying libc's version. But if there are two include directories from separate multilibs, then both of their C++ include directories will end up on the include path first, followed by both the C directories. So the `#include_next` from the first libc++ stdio.h will include the second libc++ stdio.h, which will do nothing because it has the same include guard macro, and the libc header won't ever be included at all.\r\n\r\nIf more than one of the options in an ExclusiveGroup matches the given flags, the last one wins.", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Driver/Multilib.cpp", "functions": ["enumeration", "mapping"]}]}
{"pr_number": 74061, "url": "https://github.com/llvm/llvm-project/pull/74061", "title": "[clang][NFC] Refactor expected directives in C++ DRs 100-199", "body": "This patch continues the work started with ea5b1ef016d020c37f903d6c7d4f623be975dab8. See that commit and its corresponding PR for details.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CXX/drs/dr1xx.cpp", "functions": ["g", "b2", "fp", "char", "z", "x", "A", "B", "hr", "i", "hp", "ep", "er", "f", "fr", "delete", "nr", "h"]}]}
{"pr_number": 71649, "url": "https://github.com/llvm/llvm-project/pull/71649", "title": "[JITLink][AArch32] Add dynamic lookup for relocation fixup infos", "body": "Specifying relocation fixup constants with name and type facilitates readability and compile-time checks. The `FixupInfo<EdgeKind>` facade organizes the information into entries per relocation type and provides uniform access across Arm and Thumb relocations. Since it uses template specializations, it doesn't limit potential entries. We cannot access the entries dynamically though, because `EdgeKind` must be given as a compile-time constant. It's a drawback that this patch aims to compensate for.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/ExecutionEngine/JITLink/aarch32.cpp", "functions": ["populateEntries", "hasOpcode", "constexpr"]}]}
{"pr_number": 74038, "url": "https://github.com/llvm/llvm-project/pull/74038", "title": "[mlir][vector] Fix unit dim dropping pattern for masked writes", "body": "This does the same as #72142 for vector.transfer_write. Previously the pattern would silently drop the mask.", "feature_layers": ["ir"], "feature_directives": ["for", "masked"], "files_changed": [{"filename": "mlir/lib/Dialect/Vector/Transforms/VectorTransferOpTransforms.cpp", "functions": ["getReducedShape", "inBounds", "failure"]}]}
{"pr_number": 72715, "url": "https://github.com/llvm/llvm-project/pull/72715", "title": "[mlir][tosa] Improve tosa-infer-shapes for ops consumed by non-TOSA operators", "body": "TOSA operators consumed by non-TOSA ops generally do not have their types inferred, as that would alter the types expected by their consumers. This prevents type refinement on many TOSA operators when the IR contains a mix of dialects.\r\n\r\nThis change modifies tosa-infer-shapes to update the types of all TOSA operators during inference. When a consumer of that TOSA op is not safe to update, a tensor.cast is inserted back to the original type. This behavior is similar to how TOSA ops consumed by func.return are handled.\r\n\r\nThis allows for more type refinement of TOSA ops, and the additional tensor.cast operators may be removed by later canonicalizations.", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Tosa/Transforms/TosaInferShapes.cpp", "functions": ["rewriter"]}]}
{"pr_number": 74071, "url": "https://github.com/llvm/llvm-project/pull/74071", "title": "[clang][ExtractAPI] Ensure LocationFileChecker doesn't try to traverse VFS when determining file path", "body": "As part of https://reviews.llvm.org/D154130 the logic of LocationFileChecker changed slightly to try and get the absolute external file path instead of the name as requested when the file was openened which would be before VFS mappings in our usage. Ensure that we only check against the name as requested instead of trying to generate the external canonical file path.\r\n\r\nrdar://115195433", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/ExtractAPI/ExtractAPIConsumer.cpp", "functions": ["getRelativeIncludeName"]}]}
{"pr_number": 73034, "url": "https://github.com/llvm/llvm-project/pull/73034", "title": "[RISCV][GISel] Lower G_FCONSTANT to constant pool load without F or D.", "body": "I used an IR test because it was easier than constructing different MIR test for each type of addressing.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp", "functions": ["selectAddr"]}]}
{"pr_number": 71447, "url": "https://github.com/llvm/llvm-project/pull/71447", "title": "Report pass name when -llvm-verify-each reports breakage", "body": "Update the string reported to include the pass name of last pass when running verifier after each pass.", "feature_layers": ["ast"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/Passes/PassBuilder.cpp", "functions": ["name"]}]}
{"pr_number": 74005, "url": "https://github.com/llvm/llvm-project/pull/74005", "title": "[mlir][tensor] Fold padding_value away for pack ops when possible.", "body": "If we can infer statically that there are no incomplete tiles, we can remove the optional padding operand.\r\n\r\nFixes https://github.com/openxla/iree/issues/15417", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Tensor/IR/TensorOps.cpp", "functions": ["paddingIsNotNeeded", "success", "failure"]}]}
{"pr_number": 73071, "url": "https://github.com/llvm/llvm-project/pull/73071", "title": "[FIX] Fix undefined-behaviour in regex engine.", "body": "Running the `mlir-text-parser-fuzzer` on a random corpus discovers a path that causes application of offset to a null pointer (UB) in the regex engine.\r\n\r\nThis patch adds a check.\r\n\r\nInput:\r\nBinary input, generated by fuzzer.\r\n\r\nOutput:\r\n```\r\n/Users/tsachan/Documents/llvm-project/llvm/lib/Support/regengine.inc:152:18: runtime error: applying zero offset to null pointer\r\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /Users/tsachan/Documents/llvm-project/llvm/lib/Support/regengine.inc:152:18 in\r\n==35858== ERROR: libFuzzer: deadly signal\r\n    #0 0x10424236c in __sanitizer_print_stack_trace+0x28 (libclang_rt.asan_osx_dynamic.dylib:arm64+0x5e36c)\r\n    #1 0x1030c1ce0 in fuzzer::PrintStackTrace()+0x2c (mlir-text-parser-fuzzer:arm64+0x100b4dce0)\r\n    #2 0x1030b43b4 in fuzzer::Fuzzer::CrashCallback()+0x54 (mlir-text-parser-fuzzer:arm64+0x100b403b4)\r\n    #3 0x1940aaa20 in _sigtramp+0x34 (libsystem_platform.dylib:arm64+0x3a20)\r\n    #4 0xeb4900019407bc24  (<unknown module>)\r\n    #5 0x6b3b000193f89ae4  (<unknown module>)\r\n    #6 0x824c80010425c834  (<unknown module>)\r\n    #7 0x10425bfa0 in __sanitizer::Die()+0xcc (libclang_rt.asan_osx_dynamic.dylib:arm64+0x77fa0)\r\n    #8 0x104271334 in __ubsan_handle_pointer_overflow_abort+0x24 (libclang_rt.asan_osx_dynamic.dylib:arm64+0x8d334)\r\n    #9 0x102be79c8 in llvm_regexec+0x4df8 (mlir-text-parser-fuzzer:arm64+0x1006739c8)\r\n    #10 0x102bf98a8 in llvm::Regex::match(llvm::StringRef, llvm::SmallVectorImpl<llvm::StringRef>*, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>*) const+0x608 (mlir-text-parser-fuzzer:arm64+0x1006858a8)\r\n    #11 0x102c31880 in mlir::Dialect::isValidNamespace(llvm::StringRef)+0xf0 (mlir-text-parser-fuzzer:arm64+0x1006bd880)\r\n    #12 0x102b7d748 in mlir::OpaqueType::verify(llvm::function_ref<mlir::InFlightDiagnostic ()>, mlir::StringAttr, llvm::StringRef)+0x13c (mlir-text-parser-fuzzer:arm64+0x100609748)\r\n    #13 0x102b76280 in mlir::OpaqueType::getChecked(llvm::function_ref<mlir::InFlightDiagnostic ()>, mlir::StringAttr, llvm::StringRef)+0x158 (mlir-text-parser-fuzzer:arm64+0x100602280)\r\n    #14 0x102f91368 in mlir::detail::Parser::parseExtendedType()+0xe00 (mlir-text-parser-fuzzer:arm64+0x100a1d368)\r\n    #15 0x10300ea00 in mlir::detail::Parser::parseNonFunctionType()+0x420 (mlir-text-parser-fuzzer:arm64+0x100a9aa00)\r\n    #16 0x102fb6944 in mlir::parseAsmSourceFile(llvm::SourceMgr const&, mlir::Block*, mlir::ParserConfig const&, mlir::AsmParserState*, mlir::AsmParserCodeCompleteContext*)+0x1668 (mlir-text-parser-fuzzer:arm64+0x100a42944)\r\n    #17 0x102ebe8e8 in mlir::parseSourceFile(llvm::SourceMgr const&, mlir::Block*, mlir::ParserConfig const&, mlir::LocationAttr*)+0x2b0 (mlir-text-parser-fuzzer:arm64+0x10094a8e8)\r\n    #18 0x102ec0144 in mlir::parseSourceString(llvm::StringRef, mlir::Block*, mlir::ParserConfig const&, llvm::StringRef, mlir::LocationAttr*)+0x258 (mlir-text-parser-fuzzer:arm64+0x10094c144)\r\n    #19 0x1025773e4 in mlir::OwningOpRef<mlir::ModuleOp> mlir::parseSourceString<mlir::ModuleOp>(llvm::StringRef, mlir::ParserConfig const&, llvm::StringRef)+0x160 (mlir-text-parser-fuzzer:arm64+0x1000033e4)\r\n    #20 0x102576ed4 in LLVMFuzzerTestOneInput+0x578 (mlir-text-parser-fuzzer:arm64+0x100002ed4)\r\n    #21 0x1030b57ec in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long)+0x138 (mlir-text-parser-fuzzer:arm64+0x100b417ec)\r\n    #22 0x1030a6558 in fuzzer::RunOneTest(fuzzer::Fuzzer*, char const*, unsigned long)+0xd0 (mlir-text-parser-fuzzer:arm64+0x100b32558)\r\n    #23 0x1030ab974 in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long))+0x1a98 (mlir-text-parser-fuzzer:arm64+0x100b37974)\r\n    #24 0x1030c25d4 in main+0x24 (mlir-text-parser-fuzzer:arm64+0x100b4e5d4)\r\n    #25 0x193d23f24  (<unknown module>)\r\n    #26 0x121afffffffffffc  (<unknown module>)\r\n\r\nNOTE: libFuzzer has rudimentary signal handlers.\r\n      Combine libFuzzer with AddressSanitizer or similar for better crash reports.\r\nSUMMARY: libFuzzer: deadly signal\r\n```", "feature_layers": ["parse", "runtime", "ir", "parser"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/unittests/Support/RegexTest.cpp", "functions": ["r"]}]}
{"pr_number": 73810, "url": "https://github.com/llvm/llvm-project/pull/73810", "title": "[DebugInfo][RemoveDIs] Handle a debug-info splicing corner case", "body": "A large amount of complexity when it comes to shuffling DPValue objects around is pushed into BasicBlock::spliceDebugInfo, and it gets comprehensive testing there via the unit tests. It turns out that there's a corner case though: splicing instructions and debug-info to the end() iterator requires blocks of DPValues to be concatenated, but the DPValues don't behave normally as they're dangling at the end of a block. While this splicing-to-an-empty-block case is rare, and it's even rarer for it to contain debug-info, it does happen occasionally.\r\n\r\nFix this by wrapping spliceDebugInfo with an outer layer that removes any dangling DPValues in the destination block -- that way the main splicing function (renamed to spliceDebugInfoImpl) doesn't need to worry about that scenario. See the diagram in the added function for more info.", "feature_layers": ["ir"], "feature_directives": ["for", "requires"], "files_changed": [{"filename": "llvm/lib/IR/BasicBlock.cpp", "functions": ["begin"]}]}
{"pr_number": 72779, "url": "https://github.com/llvm/llvm-project/pull/72779", "title": "[mlir][tensor] Add a tensor.concat operation", "body": "This adds an operation for concatenating ranked tensors along a static dimension, as well as a decomposition mirroring the existing lowering from TOSA to Tensor. This offers a convergence point for \"input\" like dialects that include various lowerings for concatenation operations, easing later analysis. In the future, this op can implement the necessary interfaces for tiling, as well as potentially add conversions to some kind of linalg and/or memref counterpart.\r\n\r\nThis patch adds the op, the decomposition, and some basic folding/canonicalization. Replacing lowerings with the op (such as the TOSA lowering) will come as a follow up.\r\n\r\nSee https://discourse.llvm.org/t/rfc-tensor-add-a-tensor-concatenate-operation/74858", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Tensor/IR/TensorOps.cpp", "functions": ["sizes"]}, {"filename": "mlir/lib/Dialect/Tensor/Transforms/ConcatOpPatterns.cpp", "functions": ["failure", "strides", "offsets", "success"]}, {"filename": "mlir/test/lib/Dialect/Tensor/TestTensorTransforms.cpp", "functions": ["patterns", "applyDecomposeConcatPatterns"]}, {"filename": "mlir/lib/Dialect/MemRef/IR/MemRefOps.cpp", "functions": ["asSize", "offset", "asStride", "size", "stride", "asOffset"]}]}
{"pr_number": 68754, "url": "https://github.com/llvm/llvm-project/pull/68754", "title": "[asan][win][msvc] override new and delete and seperate TUs", "body": "Migrated from: https://reviews.llvm.org/D155879, with some of the suggestions applied.\r\n\r\nPR Description copied from above:\r\n\r\nCurrently asan simply exports each overridden new/delete function from the DLL, this works fine normally, but fails if the user is overriding some, but not all, of these functions. In this case the non-overridden functions still come from the asan DLL, but they can't correctly call the user provided override (for example sized op delete should fall back to scalar op delete, if a scalar op delete is provided). Things were also broken in the static build because all the asan overrides were exported from the same TU, and so if you overrode one but not all of them then you'd get ODR violations. This PR should fix both of these cases, but the static case isn't really tested (and indeed one such test does fail) because linking asan statically basically doesn't work on windows right now with LLVM's version of asan. In fact, while we did fix this in our fork, it was a huge mess and we've now made the dynamic version work in all situations (/MD, /MT, /MDd, /MTd, etc) instead.\r\n\r\nThe following is the description from the internal PR that implemented most of this feature.\r\n\r\n> Previously, operator new/delete were provided as DLL exports when linking dynamically and wholearchived when linked statically. Both scenarios were broken. When linking statically, the user could not define their own op new/delete, because they were already brought into the link by ASAN. When dynamically linking, if the user provided some but not all of the overloads, new and delete would be partially hooked. For example, if the user defined scalar op delete, but the program then called sized op delete, the sized op delete would still be the version provided by ASAN instead of falling back to the user-defined scalar op delete, like the standard requires.\r\n\r\n> The change <internal PR number>: ASAN operator new/delete fallbacks in the ASAN libraries fixes this moving all operator new/delete definitions to be statically linked. However, this still won't work if /InferAsanLibs still whole-archives everything since then all the op new/deletes would always be provided by ASAN, which is why these changes are necessary.\r\n\r\n> With these changes, we will no longer wholearchive all of ASAN and will leave the c++ parts (the op new/delete definitions) to be included as a default library. However, it is also necessary to ensure that the asan library with op new/delete will be searched before the corresponding CRT library with the same op new/delete definitions. To accomplish this, we make sure to add the asan library to the beginning of the default lib list, or move it explicitly to the front if it's already in the list. If the C runtime library is explicitly provided, we make sure to warn the user if the current linker line will result in operator new/delete not being provided by ASAN.\r\n\r\nNote that the rearrangement of defaultlibs is not in this diff.", "feature_layers": ["runtime", "ir"], "feature_directives": ["for", "requires"], "files_changed": [{"filename": "compiler-rt/lib/asan/asan_win_delete_array_align_thunk.cpp", "functions": ["delete"]}, {"filename": "compiler-rt/lib/asan/asan_win_delete_array_thunk.cpp", "functions": ["delete"]}, {"filename": "compiler-rt/lib/asan/asan_win_delete_scalar_align_nothrow_thunk.cpp", "functions": ["delete"]}, {"filename": "compiler-rt/lib/asan/asan_win_delete_scalar_align_thunk.cpp", "functions": ["delete"]}, {"filename": "compiler-rt/lib/asan/asan_win_delete_scalar_nothrow_thunk.cpp", "functions": ["delete"]}, {"filename": "compiler-rt/lib/asan/asan_win_delete_scalar_size_align_thunk.cpp", "functions": ["delete"]}, {"filename": "compiler-rt/lib/asan/asan_win_delete_scalar_size_thunk.cpp", "functions": ["delete"]}, {"filename": "compiler-rt/lib/asan/asan_win_delete_scalar_thunk.cpp", "functions": ["delete"]}, {"filename": "compiler-rt/lib/asan/asan_win_new_array_align_nothrow_thunk.cpp", "functions": ["__asan_new_array_align_nothrow"]}, {"filename": "compiler-rt/lib/asan/asan_win_new_array_align_thunk.cpp", "functions": ["__asan_new_array_align"]}, {"filename": "compiler-rt/lib/asan/asan_win_new_array_nothrow_thunk.cpp", "functions": ["__asan_new_array_nothrow"]}, {"filename": "compiler-rt/lib/asan/asan_win_new_array_thunk.cpp", "functions": ["__asan_new_array"]}, {"filename": "compiler-rt/lib/asan/asan_win_new_scalar_align_nothrow_thunk.cpp", "functions": ["__asan_new_align_nothrow"]}, {"filename": "compiler-rt/lib/asan/asan_win_new_scalar_align_thunk.cpp", "functions": ["__asan_new_align"]}, {"filename": "compiler-rt/lib/asan/asan_win_new_scalar_nothrow_thunk.cpp", "functions": ["__asan_new_nothrow"]}, {"filename": "compiler-rt/lib/asan/asan_win_new_scalar_thunk.cpp", "functions": ["new", "__asan_new"]}, {"filename": "compiler-rt/test/asan/TestCases/Windows/new_delete_mfc_already_defined.cpp", "functions": ["main"]}, {"filename": "compiler-rt/test/asan/TestCases/Windows/new_delete_mfc_already_defined_dbg.cpp", "functions": ["main"]}]}
{"pr_number": 74149, "url": "https://github.com/llvm/llvm-project/pull/74149", "title": "[scudo] Fix realloc hooks behavior", "body": "`realloc` may involve both allocation and deallocation. Given that the reporting the events is not atomic and which may lead the hook user to a false case that the double-use pattern happens, we always report the old pointer is released and report the new allocation afterward (even it's the same pointer).\r\n\r\nThis also fixes that we didn't report the new size when it doesn't need to allocate a new space.", "feature_layers": [], "feature_directives": ["atomic", "allocate"], "files_changed": [{"filename": "compiler-rt/lib/scudo/standalone/tests/wrappers_c_test.cpp", "functions": ["invalidateHookPtrs", "invalidateAllocHookPtrAs"]}]}
{"pr_number": 73691, "url": "https://github.com/llvm/llvm-project/pull/73691", "title": "[Clang][Lex] Fix parsing of nested requirement to prevent flowing off the end of token stream", "body": "Currently when parsing a nested requirement we attempt to balance parens if we have a parameter list. This will fail in some cases of ill-formed code and keep going until we fall off the token stream and crash. This fixes the hand parsing by using SkipUntil which will properly flag if we don't find the expected tokens.\r\n\r\nFixes: https://github.com/llvm/llvm-project/issues/73112", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/Parser/cxx2a-concepts-requires-expr.cpp", "functions": ["f"]}]}
{"pr_number": 74084, "url": "https://github.com/llvm/llvm-project/pull/74084", "title": "[NFC][asan] clang-format for asan_init change", "body": "Stacked PR a part of #74086 \r\nOriginal conversation: #71833 ", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "compiler-rt/lib/asan/asan_interceptors.cpp", "functions": ["REAL"]}]}
{"pr_number": 69590, "url": "https://github.com/llvm/llvm-project/pull/69590", "title": "[libc++][test] add more benchmarks for `stop_token`", "body": "", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "libcxx/benchmarks/stop_token.bench.cpp", "functions": ["reg_counts", "loop_counts", "BM_stop_token_single_thread_polling_stop_requested", "BM_stop_token_multi_thread_polling_stop_requested", "loop_count"]}]}
{"pr_number": 72885, "url": "https://github.com/llvm/llvm-project/pull/72885", "title": "[mlir][tensor] Fix insert and extract slice canonicalization", "body": "Fixes #71150 by checking for non-negative dimensions during the `InsertSliceOpSourceCastInserter` and `ExtractSliceOp` canonicalizations. Also refactored the logic into one function so that we don't have to write a comment each time.", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Tensor/IR/TensorOps.cpp", "functions": ["failure"]}, {"filename": "mlir/lib/Dialect/Utils/StaticValueUtils.cpp", "functions": ["hasNegativeDimension"]}]}
{"pr_number": 73406, "url": "https://github.com/llvm/llvm-project/pull/73406", "title": "[BBUtils][NFC] Delete SplitLandingPadPredecessors with DT", "body": "Function is marked for deprecation. There is only one consumer which is converted to use DomTreeUpdater.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp", "functions": ["DTU"]}]}
{"pr_number": 73593, "url": "https://github.com/llvm/llvm-project/pull/73593", "title": "[BPI] Reuse the AsmWriter's BB naming scheme in BranchProbabilityPrinterPass", "body": "When using `BranchProbabilityPrinterPass`, if a BB has no name, we get pretty unusable information like `edge  ->  has probability...` (i.e. we have no idea what the vertices of that edge are).\r\n\r\nThis patch uses `printAsOperand`, which uses the same naming scheme as `Function::dump`, so for example during debugging sessions, the IR obtained from a function and the names used by `BranchProbabilityPrinterPass` will match.\r\n\r\nA shortcoming is that `printAsOperand` will result in the numbering algorithm re-running for every edge and every vertex (when `BranchProbabilityPrinterPass` is run on a function). If, for the given scenario, this is a problem, we can revisit this subsequently.\r\n\r\nAnother nuance is that the entry basic block will be numbered, which may be slightly confusing when it's anonymous, but it's easily identifiable - the first edge would have it as source (and the number should be easily recognizable)", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/IR/AsmWriter.cpp", "functions": ["printBasicBlock"]}]}
{"pr_number": 74115, "url": "https://github.com/llvm/llvm-project/pull/74115", "title": "[TextAPI] Introduce Records & RecordSlice Types", "body": "`Record`'s hold target triple specific information about APIs and symbols. This holds information about the relationship between ObjC symbols and their linkage properties. It will be used to compare and run significant operations between the frontend representation of symbols in AST and symbol information extracted from Mach-O binaries. This differs from the lighter weight Symbol and SymbolSet class where they are deduplicated across targets and only represent exported symbols, that class is mostly used for serializing.", "feature_layers": ["ir", "ast", "frontend"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "llvm/lib/TextAPI/RecordsSlice.cpp", "functions": ["getIVar", "StringRef", "if", "addObjCInterface", "addGlobal", "addObjCIVar"]}, {"filename": "llvm/lib/TextAPI/Symbol.cpp", "functions": ["parseSymbol"]}, {"filename": "llvm/unittests/TextAPI/RecordTests.cpp", "functions": ["T", "Slice"]}]}
{"pr_number": 74184, "url": "https://github.com/llvm/llvm-project/pull/74184", "title": "[libc++][test] Avoid truncation warnings from `double` to `float`", "body": "Found while running libc++'s test suite with MSVC's STL, where we use both MSVC's compiler and Clang/LLVM.\r\n\r\nMSVC really enjoys emitting \"warning C4305: 'initializing': truncation from 'double' to 'float'\". It might look repetitive, but `T(value)` avoids this warning. (According to my understanding, the compiler looks at the immediate context, and if it's a functional-style cast, it's satisfied that the truncation was intentional. Not even the direct-initialization context of `T unexpected(-9999.99)` is enough to activate that \"ok, the programmer knows what they're getting\" codepath.)\r\n\r\nI usually prefer to use `static_cast` instead of functional-style casts, but I chose to remain consistent with the surrounding code.\r\n\r\nBy the way, you might notice that `1.5` doesn't need these changes. This is because it's exactly representable as both a `double` and a `float`. Values like `3.125` instead of `3.1` would similarly avoid truncation warnings without the need for casts, but I didn't want to intrusively change the test code.", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "libcxx/test/std/atomics/atomics.types.generic/atomics.types.float/assign.pass.cpp", "functions": ["a"]}, {"filename": "libcxx/test/std/atomics/atomics.types.generic/atomics.types.float/compare_exchange_strong.pass.cpp", "functions": ["desired", "unexpected", "expected"]}, {"filename": "libcxx/test/std/atomics/atomics.types.generic/atomics.types.float/compare_exchange_weak.pass.cpp", "functions": ["desired", "unexpected", "expected"]}, {"filename": "libcxx/test/std/atomics/atomics.types.generic/atomics.types.float/exchange.pass.cpp", "functions": ["a"]}, {"filename": "libcxx/test/std/atomics/atomics.types.generic/atomics.types.float/fetch_add.pass.cpp", "functions": ["a"]}, {"filename": "libcxx/test/std/atomics/atomics.types.generic/atomics.types.float/fetch_sub.pass.cpp", "functions": ["a"]}, {"filename": "libcxx/test/std/atomics/atomics.types.generic/atomics.types.float/load.pass.cpp", "functions": ["a"]}, {"filename": "libcxx/test/std/atomics/atomics.types.generic/atomics.types.float/operator.float.pass.cpp", "functions": ["a"]}, {"filename": "libcxx/test/std/atomics/atomics.types.generic/atomics.types.float/operator.minus_equals.pass.cpp", "functions": ["a"]}, {"filename": "libcxx/test/std/atomics/atomics.types.generic/atomics.types.float/operator.plus_equals.pass.cpp", "functions": ["a"]}, {"filename": "libcxx/test/std/atomics/atomics.types.generic/atomics.types.float/store.pass.cpp", "functions": ["a"]}]}
{"pr_number": 71366, "url": "https://github.com/llvm/llvm-project/pull/71366", "title": "[clangd] Carefully handle PseudoObjectExprs for inlay hints", "body": "This closes https://github.com/clangd/clangd/issues/1813.\r\n\r\nNot all subexpressions for a PseudoObjectExpr are interesting, and they probably mess up inlay hints.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang-tools-extra/clangd/InlayHints.cpp", "functions": ["TraversePseudoObjectExpr", "dataTraverseStmtPre"]}, {"filename": "clang-tools-extra/clangd/unittests/InlayHintTests.cpp", "functions": ["Work", "PutX"]}]}
{"pr_number": 74042, "url": "https://github.com/llvm/llvm-project/pull/74042", "title": "[OpenMP] return empty stmt for `nothing`", "body": "- `nothing` directive was effecting the `if` block structure which it should not. So return an empty statement instead of an error statement while parsing to avoid this.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Parse/ParseOpenMP.cpp", "functions": ["StmtEmpty"]}, {"filename": "clang/test/OpenMP/nothing_ast_print.cpp", "functions": ["foo", "main"]}, {"filename": "openmp/runtime/test/misc_bugs/omp_nothing.c", "functions": ["foo", "main"]}]}
{"pr_number": 74243, "url": "https://github.com/llvm/llvm-project/pull/74243", "title": "[clang][NFC] Refactor expected directives in C++ DRs 300-399", "body": "This patch continues the work started with ea5b1ef016d020c37f903d6c7d4f623be975dab8. See that commit and its corresponding PR for details.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CXX/drs/dr3xx.cpp", "functions": ["g", "g2", "i", "qr", "h1", "a", "f", "both", "int", "h", "arg", "f2", "b"]}]}
{"pr_number": 70401, "url": "https://github.com/llvm/llvm-project/pull/70401", "title": " [OpenMP] Introduce the KernelLaunchEnvironment as implicit argument", "body": "The KernelEnvironment is for compile time information about a kernel. It\r\nallows the compiler to feed information to the runtime. The\r\nKernelLaunchEnvironment is for dynamic information *per* kernel launch.\r\nIt allows the rutime to feed information to the kernel that is not\r\nshared with other invocations of the kernel. The first use case is to\r\nreplace the globals that synchronize teams reductions with per-launch\r\nversions. This allows concurrent teams reductions. More uses cases will\r\nfollow, e.g., per launch memory pools.\r\n\r\nFixes: https://github.com/llvm/llvm-project/issues/70249", "feature_layers": ["runtime", "ir"], "feature_directives": ["for", "teams"], "files_changed": [{"filename": "openmp/libomptarget/DeviceRTL/src/Kernel.cpp", "functions": ["__kmpc_target_init"]}, {"filename": "openmp/libomptarget/plugins-nextgen/common/PluginInterface/PluginInterface.cpp", "functions": ["synchronizeImpl"]}]}
{"pr_number": 74182, "url": "https://github.com/llvm/llvm-project/pull/74182", "title": "[libc++][test] Make filesystem tests more portable to Windows", "body": "Found while running libc++'s test suite with MSVC's STL.\r\n\r\n* `filesystem_test_helper.h` directly contains `#include <windows.h>`, so it should defend against `windows.h` macroizing `max()`. The easiest defense is to add extra parentheses, which has no effect on non-cursed platforms. This fixes:\r\n\r\n```\r\nfilesystem_test_helper.h(234,58): error: too few arguments provided to function-like macro invocation\r\n```\r\n\r\n* Similarly, `directory_entry.mods/refresh.pass.cpp`, `directory_entry.obs/last_write_time.pass.cpp`, and `fs.op.last_write_time/last_write_time.pass.cpp` have `min()` and `max()` calls that need defenses against the evil macros.\r\n\r\n* Use `_getcwd`, `_stat`, `_fileno`, `_chdir` on Windows.\r\n\r\nOur MSVC configuration doesn't provide the `meow` POSIX names by default (as they are Microsoft-deprecated); instead the `_meow` names should be used. For readability, I'm extracting `const int fd`. This fixes:\r\n\r\n```\r\nfilesystem_test_helper.h(139,23): error: no member named 'getcwd' in the global namespace; did you mean '_getcwd'?\r\nfilesystem_test_helper.h(145,18): error: no struct named 'stat' in the global namespace\r\nfilesystem_test_helper.h(253,17): error: use of undeclared identifier 'fileno'; did you mean '_fileno'?\r\nfilesystem_test_helper.h(471,17): error: no member named 'chdir' in the global namespace; did you mean '_chdir'?\r\n```\r\n", "feature_layers": ["ir", "ast"], "feature_directives": ["for", "declare"], "files_changed": [{"filename": "libcxx/test/std/input.output/filesystems/fs.op.funcs/fs.op.last_write_time/last_write_time.pass.cpp", "functions": ["if"]}]}
{"pr_number": 69061, "url": "https://github.com/llvm/llvm-project/pull/69061", "title": "Remove warnings from -Wchar-subscripts for known positive constants", "body": "This is to address https://github.com/llvm/llvm-project/issues/18763\r\n\r\nit removes warnings from using a signed char as an array bound if the char is a known positives constant.\r\n\r\nThis goes one step farther than gcc does.\r\n\r\nFor example given the following code\r\n```c++\r\nchar upper[300];\r\n\r\nint main() {\r\n  upper['a'] = 'A';\r\n  char b = 'a';\r\n  upper[b] = 'A';\r\n  const char c = 'a';\r\n  upper[c] = 'A';\r\n  constexpr char d = 'a';\r\n  upper[d] = 'A';\r\n  char e = -1;\r\n  upper[e] = 'A';\r\n  const char f = -1;\r\n  upper[f] = 'A';\r\n  constexpr char g = -1;\r\n  upper[g] = 'A';\r\n  return 1;\r\n}\r\n```\r\n\r\nclang currently gives warnings for all cases, while gcc gives warnings for all cases except for 'a' (https://godbolt.org/z/5ahjETTv3)\r\n\r\nwith the change there is no longer any warning for 'a', 'c', or 'd'.\r\n\r\n```\r\n../test.cpp:7:8: warning: array subscript is of type 'char' [-Wchar-subscripts]\r\n    7 |   upper[b] = 'A';\r\n      |        ^~\r\n../test.cpp:13:8: warning: array subscript is of type 'char' [-Wchar-subscripts]\r\n   13 |   upper[e] = 'A';\r\n      |        ^~\r\n../test.cpp:15:8: warning: array subscript is of type 'char' [-Wchar-subscripts]\r\n   15 |   upper[f] = 'A';\r\n      |        ^~\r\n../test.cpp:17:8: warning: array subscript is of type 'char' [-Wchar-subscripts]\r\n   17 |   upper[g] = 'A';\r\n      |        ^~\r\n../test.cpp:15:3: warning: array index -1 is before the beginning of the array [-Warray-bounds]\r\n   15 |   upper[f] = 'A';\r\n      |   ^     ~\r\n../test.cpp:1:1: note: array 'upper' declared here\r\n    1 | char upper[300];\r\n      | ^\r\n../test.cpp:17:3: warning: array index -1 is before the beginning of the array [-Warray-bounds]\r\n   17 |   upper[g] = 'A';\r\n      |   ^     ~\r\n../test.cpp:1:1: note: array 'upper' declared here\r\n    1 | char upper[300];\r\n      | ^\r\n6 warnings generated.\r\n```\r\n\r\nThis pull request is my first change and I would appreciate any comments or suggestions.", "feature_layers": ["ir"], "feature_directives": ["for", "declare"], "files_changed": [{"filename": "clang/test/Sema/warn-char-subscripts.c", "functions": ["t13", "t14", "t12", "t11"]}, {"filename": "clang/test/Sema/warn-char-subscripts.cpp", "functions": ["t9", "t1", "t13", "t5", "t2", "t15", "t6", "t3", "t8", "t11", "t7", "t12", "t16", "t14", "returnsChar", "t10", "t4"]}]}
{"pr_number": 74247, "url": "https://github.com/llvm/llvm-project/pull/74247", "title": "[mlir][llvm] Fix verifier for const float", "body": "Fixes one of the cases of https://github.com/llvm/llvm-project/issues/56962.\r\n\r\nThis PR basically moves some code from `mlir::LLVM::detail::getLLVMConstant` ([source](https://github.com/llvm/llvm-project/blob/9f78edbd20ed922cced9482f7791deb9899a6d82/mlir/lib/Target/LLVMIR/ModuleTranslation.cpp#L354-L371)) over to the verifier of `LLVM::ConstantOp`. For now, I focused just on the case where the attribute is a float and ignored the integer case of https://github.com/llvm/llvm-project/issues/56962. Note that without this patch, both added tests will crash inside `getLLVMConstant` during `mlir-translate -mlir-to-llvmir`.", "feature_layers": ["ir"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "mlir/lib/Dialect/LLVMIR/IR/LLVMDialect.cpp", "functions": ["emitOpError"]}]}
{"pr_number": 73860, "url": "https://github.com/llvm/llvm-project/pull/73860", "title": "[clang][dataflow] Add synthetic fields to `RecordStorageLocation`", "body": "Synthetic fields are intended to model the internal state of a class (e.g. the value stored in a `std::optional`) without having to depend on that class's implementation details.\r\n\r\nToday, this is typically done with properties on `RecordValue`s, but these have several drawbacks:\r\n\r\n*  Care must be taken to call `refreshRecordValue()` before modifying a property so that the modified property values aren\u2019t seen by other environments that may have access to the same `RecordValue`.\r\n\r\n*  Properties aren\u2019t associated with a storage location. If an analysis needs to associate a location with the value stored in a property (e.g. to model the reference returned by `std::optional::value()`), it needs to manually add an indirection using a `PointerValue`. (See for example the way this is done in UncheckedOptionalAccessModel.cpp, specifically in `maybeInitializeOptionalValueMember()`.)\r\n\r\n*  Properties don\u2019t participate in the builtin compare, join, and widen operations. If an analysis needs to apply these operations to properties, it needs to override the corresponding methods of `ValueModel`.\r\n\r\n*  Longer-term, we plan to eliminate `RecordValue`, as by-value operations on records aren\u2019t really \u201ca thing\u201d in C++ (see https://discourse.llvm.org/t/70086#changed-structvalue-api-14). This would obviously eliminate the ability to set properties on `RecordValue`s.\r\n\r\nTo demonstrate the advantages of synthetic fields, this patch converts UncheckedOptionalAccessModel.cpp to synthetic fields. This greatly simplifies the implementation of the check.\r\n\r\nThis PR is pretty big; to make it easier to review, I have broken it down into a stack of three commits, each of which contains a set of logically related changes. I considered submitting each of these as a separate PR, but the commits only really make sense when taken together.\r\n\r\nTo review, I suggest first looking at the changes in UncheckedOptionalAccessModel.cpp. This gives a flavor for how the various API changes work together in the context of an analysis. Then, review the rest of the changes.\r\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp", "functions": ["Environment", "DACtx"]}, {"filename": "clang/lib/Analysis/FlowSensitive/TypeErasedDataflowAnalysis.cpp", "functions": ["initializeEnvironment"]}, {"filename": "clang/lib/Analysis/FlowSensitive/DataflowAnalysisContext.cpp", "functions": ["arena", "createRecordStorageLocation", "getKeys"]}, {"filename": "clang/lib/Analysis/FlowSensitive/Models/UncheckedOptionalAccessModel.cpp", "functions": ["valueTypeFromOptionalType", "setHasValue", "isNulloptConstructor", "isNonEmptyOptional", "cxxConstructExpr", "hasAnyOptionalType", "isEmptyOptional"]}, {"filename": "clang/unittests/Analysis/FlowSensitive/UncheckedOptionalAccessModelTest.cpp", "functions": ["UncheckedOptionalAccessModel"]}]}
{"pr_number": 73958, "url": "https://github.com/llvm/llvm-project/pull/73958", "title": "[AMDGPU] Set debug info on CFG annotation instructions.", "body": "This fixes incorrect source location in ASAN diagnostics for https://github.com/llvm/llvm-project/pull/72247.\r\n\r\ncc @b-sumner ", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/SIAnnotateControlFlow.cpp", "functions": ["CreateBreak", "IRB"]}]}
{"pr_number": 74063, "url": "https://github.com/llvm/llvm-project/pull/74063", "title": "[mlir][ArmSME] Move vector.print -> ArmSME lowering to VectorToArmSME", "body": "This moves the SME tile vector.print lowering from `-convert-arm-sme-to-scf` to `-convert-vector-to-arm-sme`. This seems like a more logical place, as this is lowering a vector op to ArmSME, and it also prevents vector.print from blocking tile allocation.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Conversion/ArmSMEToSCF/ArmSMEToSCF.cpp", "functions": ["failure", "success"]}, {"filename": "mlir/lib/Conversion/VectorToArmSME/VectorToArmSME.cpp", "functions": ["failure", "success"]}]}
{"pr_number": 74144, "url": "https://github.com/llvm/llvm-project/pull/74144", "title": "[llvm-exegesis] Disable core dumps in subprocess", "body": "Core dumps are currently enabled within the llvm-exegesis subprocess executor. This can create a lot of core dumps when going through different snippets that might segfault when experimenting with memory annotations. These core dumps are not really needed as the information about the segfault is reported directly to the user.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/tools/llvm-exegesis/lib/BenchmarkRunner.cpp", "functions": ["disableCoreDumps"]}]}
{"pr_number": 74066, "url": "https://github.com/llvm/llvm-project/pull/74066", "title": "[AArch64][SME2] Add intrinsics & builtins for S/URSHL (single, multi)", "body": "Patch by: Kerry McLaughlin <kerry.mclaughlin@arm.com>", "feature_layers": [], "feature_directives": ["for", "single"], "files_changed": [{"filename": "clang/test/CodeGen/aarch64-sme2-intrinsics/acle_sme2_vector_rshl.c", "functions": ["test_svrshl_multi_u64_x4", "test_svrshl_single_u64_x2", "test_svrshl_multi_u8_x2", "test_svrshl_single_u32_x2", "test_svrshl_multi_u8_x4", "test_svrshl_single_u8_x2", "test_svrshl_multi_s8_x4", "test_svrshl_single_s8_x2", "test_svrshl_single_s64_x2", "test_svrshl_multi_s64_x4", "test_svrshl_single_u64_x4", "test_svrshl_single_s16_x2", "test_svrshl_multi_u16_x2", "test_svrshl_multi_s32_x4", "test_svrshl_single_s64_x4", "test_svrshl_single_u16_x2", "test_svrshl_single_u8_x4", "test_svrshl_single_s32_x4", "test_svrshl_single_s16_x4", "test_svrshl_multi_s16_x2", "test_svrshl_multi_s64_x2", "test_svrshl_multi_u32_x4", "test_svrshl_multi_s32_x2", "test_svrshl_multi_s8_x2", "test_svrshl_single_s32_x2", "SVE_ACLE_FUNC", "test_svrshl_single_u16_x4", "test_svrshl_multi_s16_x4", "test_svrshl_single_u32_x4", "test_svrshl_multi_u16_x4", "test_svrshl_single_s8_x4", "test_svrshl_multi_u32_x2", "test_svrshl_multi_u64_x2"]}]}
{"pr_number": 74311, "url": "https://github.com/llvm/llvm-project/pull/74311", "title": " [clang][NFC] Refactor expected directives in C++ DRs 400-499", "body": "This patch continues the work started with ea5b1ef016d020c37f903d6c7d4f623be975dab8. See that commit and its corresponding PR for details.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CXX/drs/dr4xx.cpp", "functions": ["g", "test5", "z", "void", "decltype", "test1", "test6", "testE", "delete", "f", "test2", "f2", "testD"]}]}
{"pr_number": 74122, "url": "https://github.com/llvm/llvm-project/pull/74122", "title": "[AMDGPU][True16][GISel] Support v_add_f16 codegen.", "body": "", "feature_layers": ["codegen"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/SIRegisterInfo.cpp", "functions": ["getVGPRClassForBitWidth"]}]}
{"pr_number": 74057, "url": "https://github.com/llvm/llvm-project/pull/74057", "title": "[mlir][nvvm] Introduce `nvvm.fence.proxy`", "body": "This PR introduce `nvvm.fence.proxy` OP for the following cases:\r\n\r\n```\r\nnvvm.fence.proxy { kind = #nvvm.proxy_kind<alias>}\r\n\r\nnvvm.fence.proxy { kind = #nvvm.proxy_kind<async>}\r\n\r\nnvvm.fence.proxy { kind = #nvvm.proxy_kind<async.global>}\r\n\r\nnvvm.fence.proxy { kind = #nvvm.proxy_kind<async.shared>, space = #nvvm.shared_space<cta>}\r\n\r\nnvvm.fence.proxy { kind = #nvvm.proxy_kind<async.shared>, space = #nvvm.shared_space<cluster>}\r\n```", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/LLVMIR/IR/NVVMDialect.cpp", "functions": ["emitOpError", "success"]}]}
{"pr_number": 73639, "url": "https://github.com/llvm/llvm-project/pull/73639", "title": "[mlir][ArmSME] Remove ArmSMETypeConverter (and configure LLVM one instead)", "body": "This patch removes the ArmSMETypeConverter, and instead updates `populateArmSMEToLLVMConversionPatterns()` to add an ArmSME vector type conversion to the existing LLVMTypeConverter. This makes it easier to add these patterns to an existing `-to-llvm` lowering pass.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Conversion/ArmSMEToLLVM/ArmSMEToLLVM.cpp", "functions": ["converter"]}, {"filename": "mlir/lib/Dialect/ArmSME/Transforms/ArmSMETypeConverter.cpp", "functions": ["LLVMTypeConverter"]}, {"filename": "mlir/unittests/Dialect/ArmSME/TileTypeConversionTest.cpp", "functions": ["llvmConvererWithArmSMEConversion", "llvmConverer", "llvmConverterWithArmSMEConversion", "llvmConverter"]}]}
{"pr_number": 72180, "url": "https://github.com/llvm/llvm-project/pull/72180", "title": "[clang][llvm][fatlto] Avoid cloning modules in FatLTO", "body": "https://github.com/llvm/llvm-project/issues/70703 pointed out that cloning LLVM modules could lead to miscompiles when using FatLTO.\r\n\r\nThis is due to an existing issue when cloning modules with labels (see #55991 and #47769). Since this can lead to miscompilation, we can avoid cloning the LLVM modules, which was desirable anyway.\r\n\r\nThis patch modifies the EmbedBitcodePass to no longer clone the module or run an input pipeline over it. Further, it make FatLTO always perform UnifiedLTO, so we can still defer the Thin/Full LTO decision to link-time. Lastly, it removes dead/obsolete code related to now defunct options that do not work with the EmbedBitcodePass implementation any longer.", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Passes/PassBuilder.cpp", "functions": ["parseEmbedBitcodePassOptions"]}, {"filename": "llvm/lib/Passes/PassBuilderPipelines.cpp", "functions": ["buildLTOPreLinkDefaultPipeline"]}]}
{"pr_number": 73367, "url": "https://github.com/llvm/llvm-project/pull/73367", "title": "[mlir] Add support for DIGlobalVariable and DIGlobalVariableExpression", "body": "This PR introduces DIGlobalVariableAttr and DIGlobalVariableExpressionAttr so that ModuleTranslation can emit the required metadata needed for debug information about global variable. The translator implementation for debug metadata needed to be refactored in order to allow translation of nodes based on MDNode (DIGlobalVariableExpressionAttr and DIExpression) in addition to DINode-based nodes.\r\n\r\nA DIGlobalVariableExpressionAttr can now be passed to the GlobalOp operation directly and ModuleTranslation will create the respective DIGlobalVariable and DIGlobalVariableExpression nodes. The compile unit that DIGlobalVariable is expected to be configured with will be updated with the created DIGlobalVariableExpression.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/LLVMIR/IR/LLVMAttrs.cpp", "functions": ["success", "get"]}, {"filename": "mlir/lib/Target/LLVMIR/DebugImporter.cpp", "functions": ["translateImpl"]}]}
{"pr_number": 74351, "url": "https://github.com/llvm/llvm-project/pull/74351", "title": "[mlir][llvm] Fix attribute printer warning", "body": "This commit fixes a compilation warning caused by the printExpressionArg that returns LogicalResult instead of void.\r\n\r\nThe warning has been introduce by commit 6da578c.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/LLVMIR/IR/LLVMAttrs.cpp", "functions": ["success"]}]}
{"pr_number": 73194, "url": "https://github.com/llvm/llvm-project/pull/73194", "title": "[sanitizer_symbolizer] RenderContextual elements for symbolizer markup.", "body": "This is part of a stack of PRs to add support for symbolizer\r\nmarkup in linux.\r\n\r\nRender contextual symbolizer markup elements. For Fuchsia it is not\r\nnecessary to emit any context given that Fuchsia's logging\r\ninfrastructure already handles emitting it when necessary.\r\n\r\nFor more information about contextual symbolizer markup elements:\r\nhttps://llvm.org/docs/SymbolizerMarkupFormat.html#contextual-elements\r\n", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "compiler-rt/lib/sanitizer_common/sanitizer_stacktrace_printer.cpp", "functions": ["new"]}, {"filename": "compiler-rt/lib/sanitizer_common/sanitizer_symbolizer_markup.cpp", "functions": ["new", "RenderNeedsSymbolization"]}, {"filename": "compiler-rt/lib/sanitizer_common/sanitizer_symbolizer_markup_fuchsia.cpp", "functions": ["new"]}, {"filename": "compiler-rt/test/sanitizer_common/TestCases/print-stack-trace-markup.cpp", "functions": ["Foo", "Bar", "main", "Baz"]}]}
{"pr_number": 73842, "url": "https://github.com/llvm/llvm-project/pull/73842", "title": "[mlir][mesh] Add TableGen deffinitions of more collective ops", "body": "Add definitions for\r\nbroadcast, gather, receive, reduce, scatter, send and shift.\r\n\r\nI will add verification and canonicalization in another PR. I wanted to see if the signature of the operations is sensible.\r\n", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Mesh/IR/MeshOps.cpp", "functions": ["failure"]}]}
{"pr_number": 74349, "url": "https://github.com/llvm/llvm-project/pull/74349", "title": "Use Address for CGBuilder's CreateAtomicRMW and CreateAtomicCmpXchg.", "body": "Update all callers to pass through the Address.\r\n\r\nFor the older builtins such as `__sync_*` and MSVC `_Interlocked*`, natural alignment of the atomic access is _assumed_. This change preserves that behavior. It will pass through greater-than-required alignments, however.", "feature_layers": ["ir"], "feature_directives": ["for", "atomic"], "files_changed": [{"filename": "clang/test/CodeGen/ms-intrinsics-underaligned.c", "functions": ["test_InterlockedExchange8", "test_InterlockedDecrement16", "_InterlockedCompareExchange", "_InterlockedExchange8", "test_InterlockedCompareExchange", "_InterlockedCompareExchange64", "test_InterlockedAdd", "_InterlockedDecrement16", "_InterlockedCompareExchangePointer", "test_InterlockedExchange16", "_InterlockedExchange16", "test_InterlockedCompareExchange8", "_InterlockedExchange", "test_InterlockedIncrement", "test_InterlockedCompareExchange16", "test_InterlockedExchange", "_InterlockedCompareExchange16", "test_InterlockedCompareExchange64", "_InterlockedAdd", "test_InterlockedExchange64", "_InterlockedCompareExchange8", "_InterlockedIncrement", "_InterlockedExchangePointer", "_InterlockedExchange64"]}, {"filename": "clang/lib/CodeGen/CGBuiltin.cpp", "functions": ["CheckAtomicAlignment"]}]}
{"pr_number": 73522, "url": "https://github.com/llvm/llvm-project/pull/73522", "title": "[mlir][Vector] Update patterns for flattening vector.xfer Ops (1/N)", "body": "Updates \"flatten vector\" patterns to support more cases, namely Ops that\r\nread/write vectors with leading unit dims. For example:\r\n\r\n```mlir\r\n%0 = vector.transfer_read %arg0[%c0, %c0, %c0, %c0] ... :\r\n  memref<5x4x3x2xi8, strided<[24, 6, 2, 1], offset: ?>>, vector<1x1x2x2xi8>\r\n```\r\n\r\nCurrently, the `vector.transfer_read` above would not be flattened. With this\r\nchange, it will be rewritten as follows:\r\n```mlir\r\n%collapse_shape = memref.collapse_shape %arg0 [[0, 1, 2, 3]] :\r\n  memref<5x4x3x2xi8, strided<[24, 6, 2, 1], offset: ?>>\r\n  into memref<120xi8, strided<[1], offset: ?>>\r\n%0 = vector.transfer_read %collapse_shape[%c0] ... :\r\n  memref<120xi8, strided<[1], offset: ?>>, vector<4xi8>\r\n%1 = vector.shape_cast %0 : vector<4xi8> to vector<1x1x2x2xi8>\r\n```\r\n\r\n`hasMatchingInnerContigousShape` is generalised and renamed as\r\n`isContiguousSlice` to better match the updated functionality. A few\r\ntest names are updated to better highlight what case is being exercised.\r\n", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Vector/Transforms/VectorTransferOpTransforms.cpp", "functions": ["isContiguousSlice"]}]}
{"pr_number": 73254, "url": "https://github.com/llvm/llvm-project/pull/73254", "title": "[flang] Pass Argv0 to getIntriniscDir and getOpenMPHeadersDir", "body": "The `llvm::sys::fs::getMainExecutable(nullptr, nullptr)` is not able to obtain the correct executable path on AIX without Argv0 due to the lack of a current process on AIX's  `proc` filesystem. This causes a build failure on AIX as intrinsic module directory is missing. ", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "flang/lib/Frontend/CompilerInvocation.cpp", "functions": ["getIntrinsicDir", "getOpenMPHeadersDir"]}]}
{"pr_number": 73872, "url": "https://github.com/llvm/llvm-project/pull/73872", "title": "[LLVM][DWARF] Add support for .debug_names with split dwarf", "body": "Enables Type Units with DWARF5 accelerator tables for split dwarf. It is still\nunder discussion what is the best way to implement support for de-duplication in\nDWP. This will be in follow up PR.\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp", "functions": ["if"]}]}
{"pr_number": 74235, "url": "https://github.com/llvm/llvm-project/pull/74235", "title": "[clang-format] Remove duplicates in @property using std::set", "body": "Re-implement ObjCPropertyAttributeOrder using std::set for sorting and removing duplicates. (We can't use llvm::SmallSet because it's unordered.)", "feature_layers": [], "feature_directives": ["for", "ordered"], "files_changed": [{"filename": "clang/lib/Format/ObjCPropertyAttributeOrderFixer.cpp", "functions": ["SortIndex", "isObjCPropertyAttribute"]}]}
{"pr_number": 74374, "url": "https://github.com/llvm/llvm-project/pull/74374", "title": "[OpenMP] Ensure `Devices` is accessed exlusively", "body": "We accessed the `Devices` container most of the time while holding the RTLsMtx, but not always. Sometimes we used the mutex for the size query, but then accessed Devices again unguarded. From now we properly encapsulate the container in a ProtectedObj which ensures exclusive accesses. We also hide the \"isReady\" part in the `getDevice` accessor and use an `llvm::Expected` to allow to return errors.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "openmp/libomptarget/src/PluginManager.cpp", "functions": ["createStringError"]}, {"filename": "openmp/libomptarget/src/api.cpp", "functions": ["AsyncInfo"]}, {"filename": "openmp/libomptarget/src/device.cpp", "functions": ["deviceIsReady"]}, {"filename": "openmp/libomptarget/src/interface.cpp", "functions": ["AsyncInfo", "TargetAsyncInfo"]}]}
{"pr_number": 74271, "url": "https://github.com/llvm/llvm-project/pull/74271", "title": "[mlir][Complex] Fix bug in `MergeComplexBitcast`", "body": "When two `complex.bitcast` ops are folded and the resulting bitcast is a non-complex -> non-complex bitcast, an `arith.bitcast` should be generated. Otherwise, the generated `complex.bitcast` op is invalid.\r\n\r\nAlso remove a pattern that convertes non-complex -> non-complex `complex.bitcast` ops to `arith.bitcast`. Such `complex.bitcast` ops are invalid and should not appear in the input.\r\n\r\nNote: This bug can only be triggered by running with `-debug` (which will should intermediate IR that does not verify) or with `MLIR_ENABLE_EXPENSIVE_PATTERN_API_CHECKS` (#74270).", "feature_layers": ["ir", "ast"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/Complex/IR/ComplexOps.cpp", "functions": ["failure", "emitOpError", "success"]}]}
{"pr_number": 72749, "url": "https://github.com/llvm/llvm-project/pull/72749", "title": "[clang] Reject incomplete type arguments for __builtin_dump_struct", "body": "We used to assume that the CXXRecordDecl passed to the 1st argument always had a definition. This is not true since a pointer to an incomplete type was not excluded.\r\n\r\nFixes https://github.com/llvm/llvm-project/issues/63506", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Sema/SemaChecking.cpp", "functions": ["ExprError"]}]}
{"pr_number": 74159, "url": "https://github.com/llvm/llvm-project/pull/74159", "title": "[mlir][bufferization] Fix op dominance bug in rewrite pattern", "body": "Fixes a bug in `SplitDeallocWhenNotAliasingAnyOther`. This pattern used to generate invalid IR (op dominance error). We never noticed this bug in existing test cases because other patterns and/or foldings were applied afterwards and those rewrites \"fixed up\" the IR again. (The bug is visible when running `mlir-opt -debug`.) Also add additional comments to the implementation and simplify the code a bit.\r\n\r\nApart from the fixed dominance error, this change is NFC. Without this change, buffer deallocation tests will fail when running with #74270.\r\n", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/Bufferization/Transforms/BufferDeallocationSimplification.cpp", "functions": ["success"]}]}
{"pr_number": 71494, "url": "https://github.com/llvm/llvm-project/pull/71494", "title": "AMDGPU: Return legal addressmode correctly for flat scratch", "body": "Depends on #70634 for test changes.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/SIISelLowering.cpp", "functions": ["isLegalFlatAddressingMode", "isLegalMUBUFAddressingMode"]}]}
{"pr_number": 74226, "url": "https://github.com/llvm/llvm-project/pull/74226", "title": "[IR][TRE] Support associative intrinsics", "body": "There is support for intrinsics in Instruction::isCommunative, but there\r\nis no equivalent implementation for isAssociative. This patch builds\r\nsupport for associative intrinsics with TRE as an application. TRE can\r\nnow have associative intrinsics as an accumulator. For example:\r\n```\r\nstruct Node {\r\n  Node *next;\r\n  unsigned val;\r\n}\r\n\r\nunsigned maxval(struct Node *n) {\r\n  if (!n) return 0;\r\n  return std::max(n->val, maxval(n->next));\r\n}\r\n```\r\nCan be transformed into:\r\n```\r\nunsigned maxval(struct Node *n) {\r\n  struct Node *head = n;\r\n  unsigned max = 0; // Identity of unsigned std::max\r\n  while (true) {\r\n    if (!head) return max;\r\n    max = std::max(max, head->val);\r\n    head = head->next;\r\n  }\r\n  return max;\r\n}\r\n```\r\nThis example results in about 5x speedup in local runs.\r\n\r\nWe conservatively only consider min/max and as associative for this\r\npatch to limit testing scope. There are probably other intrinsics that\r\ncould be considered associative. There are a few consumers of\r\nisAssociative() that could be impacted. Testing has only required to\r\nReassociate pass be updated.\r\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/IR/Constants.cpp", "functions": ["getIntrinsicIdentity", "getBinOpIdentity"]}]}
{"pr_number": 74046, "url": "https://github.com/llvm/llvm-project/pull/74046", "title": "[CGP][AArch64] Rebase the common base offset for better ISel", "body": " When all the large const offsets masked with the same value from bit-12 to bit-23  (low imm12 will be encoded in load/store instructions).\r\n  Fold \r\n```\r\n      add     x8, x0, #2031, lsl #12\r\n      add     x8, x8, #960\r\n      ldr     x9, [x8, x8]\r\n      ldr     x8, [x8, #2056]\r\n```\r\n  into\r\n```\r\n      add     x8, x0, #2031, lsl #12\r\n      ldr     x9, [x8, #960]\r\n      ldr     x8, [x8, #3016]\r\n```\r\n\r\nFix the multi-use scenes for https://github.com/llvm/llvm-project/issues/71917", "feature_layers": [], "feature_directives": ["for", "masked"], "files_changed": [{"filename": "llvm/lib/CodeGen/CodeGenPrepare.cpp", "functions": ["if", "NewBaseBuilder"]}]}
{"pr_number": 74373, "url": "https://github.com/llvm/llvm-project/pull/74373", "title": " [clang][NFC] Refactor expected directives in C++ DRs 500-599", "body": "This patch continues the work started with ea5b1ef016d020c37f903d6c7d4f623be975dab8. See that commit and its corresponding PR for details.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CXX/drs/dr5xx.cpp", "functions": ["b2a", "g", "const", "f3", "g2", "j", "new", "i", "f", "g3", "h", "sanity", "d", "f2", "b"]}]}
{"pr_number": 73523, "url": "https://github.com/llvm/llvm-project/pull/73523", "title": "[mlir][Vector] Update patterns for flattening vector.xfer Ops (2/N)", "body": "Updates patterns for flattening `vector.transfer_read` by relaxing the\r\nrequirement that the \"collapsed\" indices are all zero. This enables\r\ncollapsing cases like this one:\r\n\r\n```mlir\r\n  %2 = vector.transfer_read %arg4[%c0, %arg0, %arg1, %c0] ... :\r\n    memref<1x43x4x6xi32>, vector<1x2x6xi32>\r\n```\r\n\r\nPreviously only the following case would be consider for collapsing:\r\n\r\n```mlir\r\n  %2 = vector.transfer_read %arg4[%c0, %c0, %c0, %c0] ... :\r\n    memref<1x43x4x6xi32>, vector<1x2x6xi32>\r\n```\r\n\r\nAlso adds some new comments and renames the `firstContiguousInnerDim` parameter\r\nas `firstDimToCollapse` (the latter better matches the actual meaning).\r\n\r\nSimilar updates for `vector.transfer_write` will be implemented in a\r\nfollow-up patch.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Vector/Transforms/VectorTransferOpTransforms.cpp", "functions": ["failure"]}]}
{"pr_number": 74428, "url": "https://github.com/llvm/llvm-project/pull/74428", "title": "[mlir][IR] Make verifyDominanceOfContainedRegions iterative", "body": "This commit refactors `verifyDominanceOfContainedRegions` to iterative algorithms similar to https://reviews.llvm.org/D154925 to fix stack overflow for deeply nested regions (e.g. https://github.com/llvm/circt/issues/5316). There should be no functional change except that this could result in slightly different order of verification. The original order could be used with a few tweaks (using reverse iterator and split the inner most loop into two loops) but I just kept the implementation simple so LMK if it's important to preserve the exact verification order. \r\n\r\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/IR/Verifier.cpp", "functions": ["failure"]}]}
{"pr_number": 72145, "url": "https://github.com/llvm/llvm-project/pull/72145", "title": "[MLIR] Add support for frame pointers in MLIR", "body": "Add support for frame pointers in MLIR.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/LLVMIR/IR/LLVMDialect.cpp", "functions": ["failure"]}]}
{"pr_number": 74312, "url": "https://github.com/llvm/llvm-project/pull/74312", "title": "[MLIR] Add support for frame pointers in MLIR ", "body": "", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/LLVMIR/IR/LLVMDialect.cpp", "functions": ["failure"]}]}
{"pr_number": 72521, "url": "https://github.com/llvm/llvm-project/pull/72521", "title": "[lld][COFF] Support .pdata section on ARM64EC targets.", "body": "ARM64EC needs to handle both ARM and x86_64 exception tables. This is achieved by separating their chunks and sorting them separately. EXCEPTION_TABLE directory references x86_64 variant, while ARM variant is exposed using CHPE metadata, which references __arm64x_extra_rfe_table and __arm64x_extra_rfe_table_size symbols.\r\n\r\nDepends on #72518.\r\n\r\ncc @bylaws ", "feature_layers": ["ir"], "feature_directives": ["target"], "files_changed": [{"filename": "lld/COFF/Writer.cpp", "functions": ["setECSymbols"]}]}
{"pr_number": 74141, "url": "https://github.com/llvm/llvm-project/pull/74141", "title": "[analyzer] Let the checkers query upper and lower bounds on symbols", "body": "This commit extends the class `SValBuilder` with the methods `getMinValue()` and `getMaxValue()` to that work like `SValBuilder::getKnownValue()` but return the minimal/maximal possible value the `SVal` is not perfectly constrained.\r\n\r\nThis extension of the ConstraintManager API is discussed at: https://discourse.llvm.org/t/expose-the-inferred-range-information-in-warning-messages/75192\r\n\r\nAs a simple proof-of-concept application of this new API, this commit extends a message from `core.BitwiseShift` with some range information that reports the assumptions of the analyzer.\r\n\r\nMy main motivation for adding these methods is that I'll also want to use them in `ArrayBoundCheckerV2` to make the error messages less awkward, but I'm starting with this simpler and less important usecase because I want to avoid merge conflicts with my other commit https://github.com/llvm/llvm-project/pull/72107 which is currently under review.\r\n\r\nThe testcase `too_large_right_operand_compound()` shows a situation where querying the range information does not work (and the extra information is not added to the error message). This also affects the debug utility `clang_analyzer_value()`, so the problem isn't in the fresh code. I'll do some investigations to resolve this, but I think that this commit is a step forward even with this limitation.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/Analysis/bitwise-shift-common.c", "functions": ["clang_analyzer_value"]}]}
{"pr_number": 74340, "url": "https://github.com/llvm/llvm-project/pull/74340", "title": "[mlir][llvm] Fix verifier for const int and dense", "body": "Continuation of https://github.com/llvm/llvm-project/pull/74247 to fix https://github.com/llvm/llvm-project/issues/56962. Fixes verifier for (Integer Attr):\r\n```mlir\r\nllvm.mlir.constant(1 : index) : f32\r\n```\r\nand (Dense Attr):\r\n```mlir\r\nllvm.mlir.constant(dense<100.0> : vector<1xf64>) : f32\r\n```\r\n\r\n## Integer Attr\r\n\r\nThe addition that this PR makes to `LLVM::ConstantOp::verify` is meant to be exactly verifying the code in `mlir::LLVM::detail::getLLVMConstant`:\r\n\r\nhttps://github.com/llvm/llvm-project/blob/9f78edbd20ed922cced9482f7791deb9899a6d82/mlir/lib/Target/LLVMIR/ModuleTranslation.cpp#L350-L353\r\n\r\nOne failure mode is when the `type` (`llvm.mlir.constant(<value>) : <type>`) is not an `Integer`, because then the `cast` in `getIntegerBitWidth` will crash:\r\n\r\nhttps://github.com/llvm/llvm-project/blob/dca432cb7b1c282f5dc861095813c4f40f109619/llvm/include/llvm/IR/DerivedTypes.h#L97-L99\r\n\r\nSo that's now caught in the verifier.\r\n\r\nApart from that, I don't see anything we could check for. `sextOrTrunc` means \"Sign extend or truncate to width\" and that one is quite permissive. For example, the following doesn't have to be caught in the verifier as it doesn't crash during `mlir-translate -mlir-to-llvmir`:\r\n\r\n```mlir\r\nllvm.func @main() -> f32 {\r\n  %cst = llvm.mlir.constant(100 : i64) : f32\r\n  llvm.return %cst : f32\r\n}\r\n```\r\n\r\n## Dense Attr\r\n\r\nCrash if not either a MLIR Vector type or one of these:\r\n\r\nhttps://github.com/llvm/llvm-project/blob/9f78edbd20ed922cced9482f7791deb9899a6d82/mlir/lib/Target/LLVMIR/ModuleTranslation.cpp#L375-L391", "feature_layers": ["ir", "ast"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "mlir/lib/Dialect/LLVMIR/IR/LLVMDialect.cpp", "functions": ["emitOpError"]}]}
{"pr_number": 74105, "url": "https://github.com/llvm/llvm-project/pull/74105", "title": "[Clang][OpenMP] Fix private variables registration in `simd`", "body": "Fix #69214 \r\nIn `emitOMPSimdRegion`, the `EmitOMPPrivateLoopCounters` should be after `EmitOMPPrivateClause`. \r\nIf not, the private variables will be registered too early, which is not allowed by `EmitOMPPrivateClause`.", "feature_layers": [], "feature_directives": ["simd"], "files_changed": [{"filename": "clang/test/OpenMP/simd_private_taskloop_codegen.cpp", "functions": ["T", "main", "tmain"]}]}
{"pr_number": 74112, "url": "https://github.com/llvm/llvm-project/pull/74112", "title": "[LV]Support dropping of nneg flag for zext widencast recipes.", "body": "Compiler crashes when the assertion triggered for zext nneg instruction,\nthat checks that the instruction cannot produce poison. Changed the base\nclass for widencast recipe to handle dropping nneg flag to avoid\ncompiler crash.\n", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Vectorize/LoopVectorize.cpp", "functions": ["VPWidenCastRecipe", "toVPRecipeResult"]}]}
{"pr_number": 72107, "url": "https://github.com/llvm/llvm-project/pull/72107", "title": "[analyzer] Switch to PostStmt callbacks in ArrayBoundV2", "body": "...instead of the currently used, more abstract Location callback. The main advantage of this change is that after it the checker will check `array[index].field` while the previous implementation ignored this situation (because here the ElementRegion is wrapped in a FieldRegion object). This improvement fixes PR #70187.\r\n\r\nNote that after this change `&array[idx]` will be handled as an access to the `idx`th element of `array`, which is technically incorrect but matches the programmer intuitions. In my opinion it's more helpful if the report points to the source location where the indexing happens (instead of the location where a pointer is finally dereferenced).\r\n\r\nThis change introduces false positives in the exceptional corner case when the past-the-end pointer of an array is formed as `&arr[length]`. I think this is just unimportant pedantery (because it's cleaner to write the past-the-end pointer as `(arr+length)` and that form isn't affected by this checker), but if it does appear in real code, then we could introduce a special case for it.\r\n\r\nIn addition to this primary improvement, this change tweaks the message for the tainted index/offset case (using the more concrete information that's available now) and clarifies/improves a few testcases.\r\n\r\nThe main change of this commit (replacing `check::Location` with `check::PostStmt<...>` callbacks) was already proposed in my change https://reviews.llvm.org/D150446 and https://reviews.llvm.org/D159107 by steakhal. Those reviews were both abandoned, but the problems that led to abandonment were unrelated to the change that is introduced in this PR.", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/StaticAnalyzer/Checkers/ArrayBoundCheckerV2.cpp", "functions": ["isInAddressOf"]}, {"filename": "clang/test/Analysis/out-of-bounds-diagnostics.c", "functions": ["useAfterTheEndPtr"]}, {"filename": "clang/test/Analysis/out-of-bounds-new.cpp", "functions": ["test_reference_that_might_be_after_the_end"]}]}
{"pr_number": 74148, "url": "https://github.com/llvm/llvm-project/pull/74148", "title": "[mlir][Linalg] Fix foldFillPackIntoFillOp to work for general cases", "body": "", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Linalg/IR/LinalgOps.cpp", "functions": ["failure", "guard", "dom", "clone"]}]}
{"pr_number": 73134, "url": "https://github.com/llvm/llvm-project/pull/73134", "title": "[SystemZ] Properly support 16 byte atomic int/fp types and ops.", "body": "- Clang FE now has MaxAtomicPromoteWidth and MaxAtomicInlineWidth with a value of 128. It now produces IR instead of calls to __atomic instrinsics for 16 bytes as well. FP loads are first loaded as i128 and then casted to fp128.\r\n- Atomic __int128 (and long double) variables are aligned to 16 bytes (like gcc 14).\r\n- AtomicExpand pass now expands also 16 byte operations.\r\n\r\n- tests for __atomic builtins for all integer widths, with test for i128 in both align=8 and align=16 cases.\r\n- Resulting behavior of __atomic_is_lock_free / __atomic_always_lock_free / __c11_atomic_is_lock_free is tested in gnu-atomic_is_lock_free.c\r\n- shouldExpandAtomicRMWInIR() was already returning true for any FP type. Now that the backend is acepting 16 byte atomics, 16 byte FP atomicrmw:s now also get expanded by AtomicExpand. The default (and used) shouldCastAtomicRMWIInIR() says that if the type is FP, it is casted to integer (see atomicrmw-xchg-07.ll).\r\n- TODO: AtomicExpand pass handles with this patch expansion of i128 atomicrmw:s. As a next step smaller integer types should also be possible to handle this way instead of in backend.\r\n\r\nOriginal patch rebased.\r\nRemove the regalloc handling for CDSG loops.\r\nTests improved.", "feature_layers": ["ir", "ast"], "feature_directives": ["for", "atomic"], "files_changed": [{"filename": "clang/test/CodeGen/SystemZ/atomic-alignment.c", "functions": ["f1", "f2"]}, {"filename": "clang/test/CodeGen/SystemZ/gnu-atomic-builtins-i128-16Al.c", "functions": ["f7", "__atomic_nand_fetch", "f8", "f11", "f16", "f18", "f1", "f6", "f4", "f2", "__atomic_xor_fetch", "__atomic_fetch_nand", "__atomic_fetch_and", "__atomic_sub_fetch", "f14", "__atomic_fetch_sub", "__atomic_fetch_xor", "f12", "f13", "__atomic_fetch_add", "f17", "__attribute__", "f15", "__atomic_or_fetch", "f19", "__atomic_load_n", "__atomic_fetch_or", "f3", "f9", "f5", "f10", "f20", "__atomic_and_fetch", "__atomic_add_fetch", "__atomic_exchange_n"]}, {"filename": "clang/test/CodeGen/SystemZ/gnu-atomic-builtins-i128-8Al.c", "functions": ["f7", "__atomic_nand_fetch", "f8", "f11", "f16", "f18", "f1", "f6", "f4", "f2", "__atomic_xor_fetch", "__atomic_fetch_nand", "__atomic_fetch_and", "__atomic_sub_fetch", "f14", "__atomic_fetch_sub", "__atomic_fetch_xor", "f12", "f13", "__atomic_fetch_add", "f17", "f19", "f15", "__atomic_or_fetch", "__atomic_load_n", "__atomic_fetch_or", "f3", "f9", "f5", "f10", "f20", "__atomic_and_fetch", "__atomic_add_fetch", "__atomic_exchange_n"]}, {"filename": "clang/test/CodeGen/SystemZ/gnu-atomic-builtins-i16.c", "functions": ["f7", "__atomic_nand_fetch", "f8", "f11", "f16", "f18", "f1", "f6", "f4", "f2", "__atomic_xor_fetch", "__atomic_fetch_nand", "__atomic_fetch_and", "__atomic_sub_fetch", "f14", "__atomic_fetch_sub", "__atomic_fetch_xor", "f12", "f13", "__atomic_fetch_add", "f17", "f19", "f15", "__atomic_or_fetch", "__atomic_load_n", "__atomic_fetch_or", "f3", "f9", "f5", "f10", "f20", "__atomic_and_fetch", "__atomic_add_fetch", "__atomic_exchange_n"]}, {"filename": "clang/test/CodeGen/SystemZ/gnu-atomic-builtins-i32.c", "functions": ["f7", "__atomic_nand_fetch", "f8", "f11", "f16", "f18", "f1", "f6", "f4", "f2", "__atomic_xor_fetch", "__atomic_fetch_nand", "__atomic_fetch_and", "__atomic_sub_fetch", "f14", "__atomic_fetch_sub", "__atomic_fetch_xor", "f12", "f13", "__atomic_fetch_add", "f17", "f19", "f15", "__atomic_or_fetch", "__atomic_load_n", "__atomic_fetch_or", "f3", "f9", "f5", "f10", "f20", "__atomic_and_fetch", "__atomic_add_fetch", "__atomic_exchange_n"]}, {"filename": "clang/test/CodeGen/SystemZ/gnu-atomic-builtins-i64.c", "functions": ["f7", "__atomic_nand_fetch", "f8", "f11", "f16", "f18", "f1", "f6", "f4", "f2", "__atomic_xor_fetch", "__atomic_fetch_nand", "__atomic_fetch_and", "__atomic_sub_fetch", "f14", "__atomic_fetch_sub", "__atomic_fetch_xor", "f12", "f13", "__atomic_fetch_add", "f17", "f19", "f15", "__atomic_or_fetch", "__atomic_load_n", "__atomic_fetch_or", "f3", "f9", "f5", "f10", "f20", "__atomic_and_fetch", "__atomic_add_fetch", "__atomic_exchange_n"]}, {"filename": "clang/test/CodeGen/SystemZ/gnu-atomic-builtins-i8.c", "functions": ["f7", "__atomic_nand_fetch", "f8", "f11", "f16", "f18", "f1", "f6", "f4", "f2", "__atomic_xor_fetch", "__atomic_fetch_nand", "__atomic_fetch_and", "__atomic_sub_fetch", "f14", "__atomic_fetch_sub", "__atomic_fetch_xor", "f12", "f13", "__atomic_fetch_add", "f17", "f19", "f15", "__atomic_or_fetch", "__atomic_load_n", "__atomic_fetch_or", "f3", "f9", "f5", "f10", "f20", "__atomic_and_fetch", "__atomic_add_fetch", "__atomic_exchange_n"]}, {"filename": "clang/test/CodeGen/SystemZ/gnu-atomic_is_lock_free-i128-16Al.c", "functions": ["fun4", "fun_noptr_always_lock_free", "fun_c11_is_lock_free", "fun1", "fun0", "fun_PtrAl16_is_lock_free", "fun3", "fun_PtrAl16_always_lock_free", "fun_noptr_is_lock_free", "fun2"]}, {"filename": "clang/test/CodeGen/SystemZ/gnu-atomic_is_lock_free-i128-8Al.c", "functions": ["__attribute__", "__atomic_always_lock_free", "fun1", "fun0", "__atomic_is_lock_free"]}, {"filename": "clang/test/CodeGen/SystemZ/atomic_is_lock_free-i128.c", "functions": ["fun8", "fun7", "fun4", "__attribute__", "fun6", "__c11_atomic_is_lock_free", "__atomic_always_lock_free", "fun1", "fun5", "fun0", "fun9", "fun3", "atomic_is_lock_free", "__atomic_is_lock_free", "fun2"]}, {"filename": "clang/test/CodeGen/SystemZ/atomic_is_lock_free.c", "functions": ["fun8", "fun7", "fun11", "fun4", "__attribute__", "fun6", "fun10", "__atomic_always_lock_free", "fun1", "fun5", "fun0", "__c11_atomic_is_lock_free", "fun9", "fun3", "atomic_is_lock_free", "__atomic_is_lock_free", "fun2"]}]}
{"pr_number": 74416, "url": "https://github.com/llvm/llvm-project/pull/74416", "title": "[flang] Fix issue with lookup in the binding table", "body": "This patch is fixing two issue relative to the dynamic dispatch for polymorphic entities.\r\n\r\n1. Fix the `requireDispatchCall` function. It was checking for the first symbol of the component but this is not the one to be checked. Instead the last symbol of the base of the component object is the one to check to know if it is polymorphic object with a dispatch call or not. This is demonstrated in the new added test in `flang/test/Lower/dispatch.f90` where the first symbol would point to `q` which is monomorphic and would result in a simple `fir.call`\r\n2. Fix the pass object in a no pass situation. In a no pass situation the pass object is lowered anyway to be able to do the lookup in the binding table. It was previously lowered wrongly an lead to unresolved lookup. The base of the component is the passed object and should be lowered. To achieve this, the `gen(DataRef)` entry point is exposed form `ConvertExprToHLFIR` through a `convertDataRefToValue` function. The same test added in `flang/test/Lower/dispatch.f90` is checking for the correct passed object.\r\n\r\nIn addition couple of tests were updated to HLFIR since the lowering used only works with it. \r\n\r\n", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Lower/ConvertExprToHLFIR.cpp", "functions": ["convertToValue"]}]}
{"pr_number": 74403, "url": "https://github.com/llvm/llvm-project/pull/74403", "title": "[mlir][sparse] minor refactoring of sparsification file", "body": "Removed obsoleted TODOs and NOTEs, formatting, removed unused parameter", "feature_layers": ["parse", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/Transforms/Sparsification.cpp", "functions": ["env", "genExp"]}]}
{"pr_number": 74389, "url": "https://github.com/llvm/llvm-project/pull/74389", "title": "[XCore] Set MaxAtomicSizeInBitsSupported to 0", "body": "XCore does not appear to have any support for atomicrmw or cmpxchg.\r\n\r\nThis will result in all atomic operations getting expanded to __atomic_* libcalls via AtomicExpandPass, which matches what Clang already does in the frontend.\r\n\r\nAdditionally, remove the code which handles atomic load/store, as it will no longer be used.", "feature_layers": ["frontend"], "feature_directives": ["for", "atomic"], "files_changed": [{"filename": "llvm/lib/Target/XCore/XCoreISelLowering.cpp", "functions": ["LowerATOMIC_FENCE"]}]}
{"pr_number": 74367, "url": "https://github.com/llvm/llvm-project/pull/74367", "title": "[tosa] Fix crash in shape inference for `tosa.transpose`", "body": "Fixes a crash in `TransposeOp::inferReturnTypeComponents()` when the supplied permutation tensor is rank-0.\r\nAlso removes some dead code from the type inference function.\r\n\r\nFix https://github.com/llvm/llvm-project/issues/74237", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Tosa/IR/TosaOps.cpp", "functions": ["failure", "success"]}]}
{"pr_number": 74430, "url": "https://github.com/llvm/llvm-project/pull/74430", "title": "[libc++][test] Fix assumptions that `std::array` iterators are pointers", "body": "Found while running libc++'s tests with MSVC's STL, where `std::array` iterators are never pointers.\r\n\r\nMost of these changes are reasonably self-explanatory (the `std::array`s are right there, and the sometimes-slightly-wrapped raw pointer types are a short distance away). A couple of changes are less obvious:\r\n\r\n---\r\n\r\nIn `libcxx/test/std/containers/from_range_helpers.h`, `wrap_input()` is called with `Iter` types that are constructible from raw pointers. It's also sometimes called with an `array` as the `input`, so the first overload was implicitly assuming that `array` iterators are pointers. We can fix this assumption by providing a dedicated overload for `array`, just like the one for `vector` immediately below. Finally, `from_range_helpers.h` should explicitly include both `<array>` and `<vector>`, even though they were apparently being dragged in already.\r\n\r\n---\r\n\r\nIn `libcxx/test/std/containers/views/views.span/span.cons/iterator_sentinel.pass.cpp`, fix `throw_operator_minus`. The error was pretty complicated, caused by the concepts machinery noticing that `value_type` and `element_type` were inconsistent. In the template instantiation context, you can see the critical detail that `throw_operator_minus<std::_Array_iterator>` is being formed.\r\n\r\n<details><summary>Click to expand error:</summary>\r\n\r\n```\r\nD:\\GitHub\\STL\\llvm-project\\libcxx\\test\\std\\containers\\views\\views.span\\span.cons\\iterator_sentinel.pass.cpp(128,8): error: no matching constructor for initialization of 'std::span<int>'\r\n        (std::span<int>{throw_operator_minus{a.begin()}, throw_operator_minus{a.end()}}));\r\n        ^             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\nD:\\GitHub\\STL\\llvm-project\\libcxx\\test\\support\\assert_macros.h(129,27): note: expanded from macro 'TEST_VALIDATE_EXCEPTION'\r\n        static_cast<void>(EXPR);                                                                                       \\\r\n                            ^~~~\r\nD:\\GitHub\\STL\\out\\x64\\out\\inc\\span(328,51): note: candidate constructor template not viable: no known conversion from 'throw_operator_minus<_Array_iterator<int, 1>>' (aka 'throw_operator_minus<std::_Array_iterator<int, 1>>') to 'size_type' (aka 'unsigned long long') for 2nd argument\r\n    constexpr explicit(_Extent != dynamic_extent) span(_It _First, size_type _Count) noexcept // strengthened\r\n                                                    ^\r\nD:\\GitHub\\STL\\out\\x64\\out\\inc\\span(339,51): note: candidate template ignored: constraints not satisfied [with _It = throw_operator_minus<_Array_iterator<int, 1>>, _Sentinel = throw_operator_minus<_Array_iterator<int, 1>>]\r\n    constexpr explicit(_Extent != dynamic_extent) span(_It _First, _Sentinel _Last)\r\n                                                    ^\r\nD:\\GitHub\\STL\\out\\x64\\out\\inc\\span(338,15): note: because '_Span_compatible_iterator<throw_operator_minus<std::_Array_iterator<int, 1> >, element_type>' evaluated to false\r\n    template <_Span_compatible_iterator<element_type> _It, _Span_compatible_sentinel<_It> _Sentinel>\r\n                ^\r\nD:\\GitHub\\STL\\out\\x64\\out\\inc\\span(243,37): note: because 'throw_operator_minus<std::_Array_iterator<int, 1>>' does not satisfy 'contiguous_iterator'\r\nconcept _Span_compatible_iterator = contiguous_iterator<_It>\r\n                                    ^\r\nD:\\GitHub\\STL\\out\\x64\\out\\inc\\xutility(815,31): note: because 'throw_operator_minus<std::_Array_iterator<int, 1>>' does not satisfy 'random_access_iterator'\r\nconcept contiguous_iterator = random_access_iterator<_It>\r\n                                ^\r\nD:\\GitHub\\STL\\out\\x64\\out\\inc\\xutility(803,34): note: because 'throw_operator_minus<std::_Array_iterator<int, 1>>' does not satisfy 'bidirectional_iterator'\r\nconcept random_access_iterator = bidirectional_iterator<_It>\r\n                                    ^\r\nD:\\GitHub\\STL\\out\\x64\\out\\inc\\xutility(796,34): note: because 'throw_operator_minus<std::_Array_iterator<int, 1>>' does not satisfy 'forward_iterator'\r\nconcept bidirectional_iterator = forward_iterator<_It> && derived_from<_Iter_concept<_It>, bidirectional_iterator_tag>\r\n                                    ^\r\nD:\\GitHub\\STL\\out\\x64\\out\\inc\\xutility(792,28): note: because 'throw_operator_minus<std::_Array_iterator<int, 1>>' does not satisfy 'input_iterator'\r\nconcept forward_iterator = input_iterator<_It> && derived_from<_Iter_concept<_It>, forward_iterator_tag>\r\n                            ^\r\nD:\\GitHub\\STL\\out\\x64\\out\\inc\\xutility(781,59): note: because 'throw_operator_minus<std::_Array_iterator<int, 1>>' does not satisfy 'indirectly_readable'\r\nconcept input_iterator = input_or_output_iterator<_It> && indirectly_readable<_It>\r\n                                                            ^\r\nD:\\GitHub\\STL\\out\\x64\\out\\inc\\xutility(694,31): note: because 'remove_cvref_t<throw_operator_minus<_Array_iterator<int, 1>>>' (aka 'throw_operator_minus<std::_Array_iterator<int, 1>>') does not satisfy '_Indirectly_readable_impl'\r\nconcept indirectly_readable = _Indirectly_readable_impl<remove_cvref_t<_It>>;\r\n                                ^\r\nD:\\GitHub\\STL\\out\\x64\\out\\inc\\__msvc_iter_core.hpp(163,1): note: because 'typename iter_value_t<_It>' would be invalid: no type named 'value_type' in 'std::indirectly_readable_traits<throw_operator_minus<std::_Array_iterator<int, 1>>>'\r\nusing iter_value_t = conditional_t<_Is_from_primary<iterator_traits<remove_cvref_t<_Ty>>>,\r\n^\r\nD:\\GitHub\\STL\\out\\x64\\out\\inc\\span(353,15): note: candidate constructor template not viable: requires single argument '_Arr', but 2 arguments were provided\r\n    constexpr span(type_identity_t<element_type> (&_Arr)[_Size]) noexcept : _Mybase(_Arr, _Size) {}\r\n                ^\r\nD:\\GitHub\\STL\\out\\x64\\out\\inc\\span(358,15): note: candidate constructor template not viable: requires single argument '_Arr', but 2 arguments were provided\r\n    constexpr span(array<_OtherTy, _Size>& _Arr) noexcept : _Mybase(_Arr.data(), _Size) {}\r\n                ^\r\nD:\\GitHub\\STL\\out\\x64\\out\\inc\\span(363,15): note: candidate constructor template not viable: requires single argument '_Arr', but 2 arguments were provided\r\n    constexpr span(const array<_OtherTy, _Size>& _Arr) noexcept : _Mybase(_Arr.data(), _Size) {}\r\n                ^\r\nD:\\GitHub\\STL\\out\\x64\\out\\inc\\span(366,51): note: candidate constructor template not viable: requires single argument '_Range', but 2 arguments were provided\r\n    constexpr explicit(_Extent != dynamic_extent) span(_Rng&& _Range)\r\n                                                    ^\r\nD:\\GitHub\\STL\\out\\x64\\out\\inc\\span(380,5): note: candidate constructor template not viable: requires single argument '_Other', but 2 arguments were provided\r\n    span(const span<_OtherTy, _OtherExtent>& _Other) noexcept\r\n    ^\r\nD:\\GitHub\\STL\\out\\x64\\out\\inc\\span(297,7): note: candidate constructor (the implicit copy constructor) not viable: requires 1 argument, but 2 were provided\r\nclass span : private _Span_extent_type<_Ty, _Extent> {\r\n        ^\r\nD:\\GitHub\\STL\\out\\x64\\out\\inc\\span(297,7): note: candidate constructor (the implicit move constructor) not viable: requires 1 argument, but 2 were provided\r\nD:\\GitHub\\STL\\out\\x64\\out\\inc\\span(325,15): note: candidate constructor not viable: requires 0 arguments, but 2 were provided\r\n    constexpr span() noexcept requires (_Extent == 0 || _Extent == dynamic_extent) = default;\r\n                ^\r\n```\r\n</details>\r\n\r\nFortunately, the fix is extremely simple. To produce `element_type` (which retains any cv-qualification, unlike `value_type`), we shouldn't attempt to `remove_pointer` with the iterator type `It`. Instead, we've already obtained the `reference` type, so we can `remove_reference_t`. (This is modern code, where we have access to the alias templates, so I saw no reason to use the older verbose form.)", "feature_layers": ["ir", "ast"], "feature_directives": ["for", "single", "critical", "requires"], "files_changed": [{"filename": "libcxx/test/std/algorithms/alg.sorting/alg.three.way/lexicographical_compare_three_way.pass.cpp", "functions": ["decltype"]}, {"filename": "libcxx/test/std/algorithms/alg.sorting/alg.three.way/lexicographical_compare_three_way_comp.pass.cpp", "functions": ["decltype"]}]}
{"pr_number": 74372, "url": "https://github.com/llvm/llvm-project/pull/74372", "title": "[MLIR][LLVM] Fix CallOp asm parser for attr-dict", "body": "Currently the parser & printer of `CallOp` do not match when both varargs and attr-dict are present (round tripping is broken). This fixes the parser so that it conforms to the written asm format in the comments.", "feature_layers": ["parse", "ir", "parser"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/LLVMIR/IR/LLVMDialect.cpp", "functions": ["failure"]}]}
{"pr_number": 73896, "url": "https://github.com/llvm/llvm-project/pull/73896", "title": "[libc] [search] improve hsearch robustness ", "body": "Following up the discussion at https://github.com/llvm/llvm-project/pull/73469#discussion_r1409593911 by @nickdesaulniers.\r\n\r\nAccording to FreeBSD implementation (https://android.googlesource.com/platform/bionic/+/refs/heads/main/libc/upstream-freebsd/lib/libc/stdlib/hcreate.c), `hsearch` is able to handle the cases where the global table is not properly initialized. To do this, FreeBSD actually allows hash table to be dynamically resized. If the global table is uninitialized at the first call, the table will be initialized with a minimal size; hence subsequent insertion will be reasonable as the table grows automatically.\r\n\r\nThis patch mimic such behaviors. More precisely, this patch introduces:\r\n\r\n1. a full table iterator that scans each element in the table,\r\n2. a resize routine that is automatically triggered whenever the load factor is reached where it iterates the old table and insert the entries into a new one,\r\n3. more tests that cover the growth of the table.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "libc/src/__support/HashTable/generic/bitmask_impl.inc", "functions": ["load_aligned", "load"]}, {"filename": "libc/src/__support/HashTable/sse2/bitmask_impl.inc", "functions": ["load_aligned", "load"]}]}
{"pr_number": 71433, "url": "https://github.com/llvm/llvm-project/pull/71433", "title": "[LLD][COFF] Add -build-id flag to generate .buildid section.", "body": "[RFC](https://discourse.llvm.org/t/rfc-add-build-id-flag-to-lld-link/74661)\r\n\r\nBefore, lld-link only generate the debug directory containing guid when generating PDB with the hash of PDB content.\r\n\r\nWith this change, lld-link can generate the debug directory when only `/build-id` is given:\r\n1. If generating PDB, `/build-id` is ignored. Same behaviour as before.\r\n2. Not generating PDB, using hash of the binary.\r\n   - Not under MinGW, the debug directory is still in `.rdata` section.\r\n   - Under MinGW, place the debug directory into new `.buildid` section.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "lld/COFF/Writer.cpp", "functions": ["writeRepro", "records", "addRecord"]}, {"filename": "lld/MinGW/Driver.cpp", "functions": ["if"]}]}
{"pr_number": 71706, "url": "https://github.com/llvm/llvm-project/pull/71706", "title": "[Clang]  Fix linker error for function multiversioning", "body": "Currently target_clones attribute results in a linker error when there are no multi-versioned function declarations in the calling TU.\r\n\r\nIn the calling TU, the call is generated with the \u2018normal\u2019 assembly name. This does not match any of the versions or the ifunc, since version mangling includes a .versionstring, and the ifunc includes .ifunc suffix. The linker error is not seen with GCC since the mangling for the ifunc symbol in GCC is the \u2018normal\u2019 assembly name for function i.e. no ifunc suffix.\r\n\r\nThis PR removes the .ifunc suffix to match GCC. It also adds alias with the .ifunc suffix so as to ensure backward compatibility.\r\n\r\nThe changes exclude aarch64 target because the mangling for default versions on aarch64 does not include a .default suffix and is the 'normal' assembly name, unlike other targets. It is not clear to me what the correct behavior for this target is.\r\n\r\nOld Phabricator review - https://reviews.llvm.org/D158666", "feature_layers": [], "feature_directives": ["for", "target"], "files_changed": [{"filename": "clang/lib/CodeGen/CodeGenModule.cpp", "functions": ["if"]}]}
{"pr_number": 67839, "url": "https://github.com/llvm/llvm-project/pull/67839", "title": "[clang][tidy] Ensure rewriter has the correct CWD", "body": "This patch replaces use of the deprecated `FileEntry::getName()` with `FileEntryRef::getName()`. This means the code now uses the path that was used to register file entry in `SourceManager` instead of the absolute path that happened to be used in the last call to `FileManager::getFile()` some place else.\r\n\r\nThis caused some test failures due to the fact that some paths can be relative and thus rely on the VFS CWD. The CWD can change for each TU, so when we run `clang-tidy` on a compilation database and try to perform all the replacements at the end, relative paths won't resolve the same. This patch takes care to reinstate the correct CWD and make the path reported by `FileEntryRef` absolute before passing it to `llvm::writeToOutput()`.", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Rewrite/Rewriter.cpp", "functions": ["Path"]}, {"filename": "clang-tools-extra/clang-tidy/ClangTidy.cpp", "functions": ["Rewrite"]}]}
{"pr_number": 74438, "url": "https://github.com/llvm/llvm-project/pull/74438", "title": "[mlir][shape] Turn `ShapeOfOp` folding into canonicalization pattern", "body": "The `ShapeOfOp` folder used to generate invalid IR.\r\n\r\nInput:\r\n```\r\n%0 = shape.shape_of %arg1 : tensor<index> -> tensor<?xindex>\r\n```\r\n\r\nOutput:\r\n```\r\n%0 = \"shape.const_shape\"() <{shape = dense<> : tensor<0xindex>}> : () -> tensor<?xindex>\r\nerror: 'shape.const_shape' op inferred type(s) 'tensor<0xindex>' are incompatible with return type(s) of operation 'tensor<?xindex>'\r\n```\r\n\r\nThis rewrite cannot be implemented as a folder because the result type may have to change. In the above example, the original `shape.shape_of` op had a return type of `tensor<?xindex>`, but the folded attribute (materialized as a `shape.const_shape` op) must have a type of `tensor<0xf32>` to be valid.\r\n\r\nThis commit fixes tests such as `mlir/test/Dialect/Shape/canonicalize.mlir` when verifying the IR after each pattern application (#74270).", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/Shape/IR/Shape.cpp", "functions": ["builder", "success", "failure"]}]}
{"pr_number": 69931, "url": "https://github.com/llvm/llvm-project/pull/69931", "title": "[BasicAA] Make isNotCapturedBeforeOrAt() check for calls more precise", "body": "For calls, we are only interested in captures before the call, not captures by the call itself -- arguments that get passed to the call are checked explicitly.\r\n\r\nIn particular, the current implementation is not optimal if the pointer is captured via a readonly argument -- in that case, we know that even if the argument is captured, the call will not modify the argument (at least not via that argument).\r\n\r\nMake this more precise by renaming to isCapturedBefore() and adding an OrAt argument that allows us to toggle whether to consider captures in the instruction itself or not.", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Analysis/BasicAliasAnalysis.cpp", "functions": ["Succs", "isNotInCycle"]}]}
{"pr_number": 74200, "url": "https://github.com/llvm/llvm-project/pull/74200", "title": "[mlir] Fix a zero stride canonicalizer crash", "body": "This PR fixes https://github.com/llvm/llvm-project/issues/73383 and is another shot at the refactoring proposed in https://github.com/llvm/llvm-project/pull/72885.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/Tensor/IR/TensorOps.cpp", "functions": ["failure"]}, {"filename": "mlir/lib/Dialect/Utils/StaticValueUtils.cpp", "functions": ["hasValidSizesOffsets", "hasValidStrides", "foldDynamicStrideList", "hasNegativeDimension"]}]}
{"pr_number": 71285, "url": "https://github.com/llvm/llvm-project/pull/71285", "title": "[MLIR][LLVM] Remove typed pointers from the LLVM dialect", "body": "This commit removes the support for typed pointers from the LLVM dialect. Typed pointers have been deprecated for a while and thus this removal was announced in a PSA:\r\nhttps://discourse.llvm.org/t/psa-removal-of-typed-pointers-from-the-llvm-dialect/74502\r\n\r\nThis change includes:\r\n- Changing the ` LLVMPointerType`\r\n- Removing remaining usages of the builders and the now removed element type\r\n- Fixing assembly formats that require fully qualified pointer types\r\n- Updating ODS pointer constraints", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/LLVMIR/IR/LLVMDialect.cpp", "functions": ["verifyStructIndices"]}, {"filename": "mlir/lib/Dialect/LLVMIR/IR/LLVMTypes.cpp", "functions": ["success", "isCompatibleOuterType", "failure", "isCompatible", "emitError"]}, {"filename": "mlir/lib/Dialect/LLVMIR/Transforms/TypeConsistency.cpp", "functions": ["failure"]}, {"filename": "mlir/lib/Dialect/OpenACC/IR/OpenACC.cpp", "functions": ["verifyCommon", "getElementType", "verifyRegionsCommon"]}, {"filename": "mlir/lib/Dialect/OpenMP/IR/OpenMPDialect.cpp", "functions": ["getElementType", "verifyRegionsCommon"]}]}
{"pr_number": 74290, "url": "https://github.com/llvm/llvm-project/pull/74290", "title": "[mlir][transform] TrackingListener: Improve dead handles detection", "body": "The tracking listener should not report op replacement errors for payload ops that are not mapped to any live handles. The handle liveless analysis did not work properly with transform IR that has named sequences.\r\n\r\nA handle is live if it has a user after the transform op that is currently being applied. With named sequences, we need to maintain a stack of currently applied transform ops. That stack already exists (`regionStack`), the only thing that's missing is the current transform op for each stack frame.\r\n\r\nThis commit fixes #72931.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Transform/IR/TransformInterfaces.cpp", "functions": ["trackingListener", "happensBefore"]}]}
{"pr_number": 74517, "url": "https://github.com/llvm/llvm-project/pull/74517", "title": "[llvm-c] Add support for setting/getting new disjoint flag on or instructions", "body": "Follows #73952 doing the same thing for the nneg flag on zext (i.e., exposing support in the C API).", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/IR/Core.cpp", "functions": ["LLVMSetIsDisjoint", "LLVMGetIsDisjoint"]}]}
{"pr_number": 74215, "url": "https://github.com/llvm/llvm-project/pull/74215", "title": "[clang-tidy] readability-container-contains literal suffixes", "body": "Before this PR, readability-container-contains fix-its did not handle integer literal suffixes correctly. It e.g. changed\r\n```\r\n  MyMap.count(2) != 0U;\r\n```\r\ninto\r\n```\r\n  MyMap.contains(2)U;\r\n```\r\n\r\nWith this PR, it correctly changes it to\r\n```\r\n  MyMap.contains(2);\r\n```", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang-tools-extra/test/clang-tidy/checkers/readability/container-contains.cpp", "functions": ["testDifferentIntegerLiteralSuffixes"]}]}
{"pr_number": 73360, "url": "https://github.com/llvm/llvm-project/pull/73360", "title": "[OpenMPIRBuilder] Add support for target workshare loops", "body": "The workshare loop for target region uses the new OpenMP device runtime. The code generation scheme for the new device runtime is presented below:\r\n\r\nInput code:\r\n```\r\nworkshare-loop {\r\n  loop-body\r\n}\r\n```\r\n\r\nOutput code:\r\nhelper function:\r\n```\r\nfunction-loop-body(counter, loop-body-args) {\r\n  loop-body\r\n}\r\n```\r\nworkshare-loop is replaced by the proper device runtime call:\r\n```\r\ncall __kmpc_new_worksharing_rtl(function-loop-body, loop-body-args,\r\n                                                     loop-tripcount, ...)\r\n```\r\nThis PR depends on: https://github.com/llvm/llvm-project/pull/73225\r\n", "feature_layers": ["runtime", "ir"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp", "functions": ["FunctionCallee", "Users"]}, {"filename": "llvm/unittests/Frontend/OpenMPIRBuilderTest.cpp", "functions": ["OMPBuilder", "Builder", "Loc"]}]}
{"pr_number": 74477, "url": "https://github.com/llvm/llvm-project/pull/74477", "title": " [clang][NFC] Refactor expected directives in C++ DRs 600-699", "body": "[clang][NFC] Refactor expected directives in C++ DRs 600-699\r\n\r\nThis patch continues the work started with https://github.com/llvm/llvm-project/commit/ea5b1ef016d020c37f903d6c7d4f623be975dab8. See that commit and its corresponding PR for details.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CXX/drs/dr6xx.cpp", "functions": ["g", "accept", "j", "i", "alignas", "a", "f", "E", "delete", "h", "C", "use"]}]}
{"pr_number": 73951, "url": "https://github.com/llvm/llvm-project/pull/73951", "title": "[mlir][Vector] Add fold transpose(shape_cast) -> shape_cast", "body": "This folds transpose(shape_cast) into a new shape_cast, when the transpose just permutes a unit dim from the result of the shape_cast.\r\n\r\nExample:\r\n\r\n```\r\n%0 = vector.shape_cast %vec : vector<[4]xf32> to vector<[4]x1xf32>\r\n%1 = vector.transpose %0, [1, 0] : vector<[4]x1xf32> to vector<1x[4]xf32>\r\n```\r\n\r\nFolds to:\r\n```\r\n%0 = vector.shape_cast %vec : vector<[4]xf32> to vector<1x[4]xf32>\r\n```\r\n\r\nThis is an (alternate) fix for lowering matmuls to ArmSME.", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Vector/IR/VectorOps.cpp", "functions": ["failure"]}]}
{"pr_number": 74579, "url": "https://github.com/llvm/llvm-project/pull/74579", "title": "Revert \"[mlir][Vector] Add fold transpose(shape_cast) -> shape_cast (#73951)\"", "body": "This reverts commit f42b7615b862bb5f77981f619f92877eb20adf54.\r\n\r\nThe fold pattern is incorrect, because it does not even look at the permutation of non-unit dims and is happy to replace a pattern such as\r\n```\r\n%22 = vector.shape_cast %21 : vector<1x256x256xf32> to vector<256x256xf32>\r\n%23 = vector.transpose %22, [1, 0] : vector<256x256xf32> to vector<256x256xf32>\r\n```\r\nwith\r\n```\r\n%22 = vector.shape_cast %21 : vector<1x256x256xf32> to vector<256x256xf32>\r\n```\r\nwhich is obviously incorrect.", "feature_layers": ["ir", "ast"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/Vector/IR/VectorOps.cpp", "functions": ["success"]}]}
{"pr_number": 73301, "url": "https://github.com/llvm/llvm-project/pull/73301", "title": "[flang] Updating drivers to create data layout before semantics", "body": "Preliminary patch to change lowering/code generation to use llvm::DataLayout information instead of generating \"sizeof\" GEP (see https://github.com/llvm/llvm-project/issues/71507).\r\n\r\nFortran Semantic analysis needs to know about the target type size and alignment to deal with common blocks, and intrinsics like C_SIZEOF/TRANSFER. This information should be obtained from the llvm::DataLayout so that it is consistent during the whole compilation flow.\r\n\r\nThis change is changing flang-new and bbc drivers to:\r\n1. Create the llvm::TargetMachine so that the data layout of the target can be obtained before semantics.\r\n2. Sharing bbc/flang-new set-up of the SemanticConstext.targetCharateristics from the llvm::TargetMachine. For now, the actual part that set-up the Fortran type size and alignment from the llvm::DataLayout is left TODO so that this change is mostly an NFC impacting the drivers.\r\n3. Let the lowering bridge set-up the mlir::Module datalayout attributes since it is doing it for the target attribute, and that allows the llvm data layout information to be available during lowering.\r\n\r\nFor flang-new, the changes are code shuffling: the `llvm::TargetMachine` instance is moved to `CompilerInvocation` class so that it can be used to set-up the semantic contexts. `setMLIRDataLayout` is moved to `flang/Optimizer/Support/DataLayout.h` (it will need to be used from codegen pass for fir-opt target independent testing.)), and the code setting-up semantics targetCharacteristics is moved to `Tools/TargetSetup.h` so that it can be shared with bbc.\r\n\r\nAs a consequence, LLVM targets must be registered when running semantics, and it is not possible to run semantics for a target that is not registered with the -triple option (hence the power pc specific modules can only be built if the PowerPC target is available, @DanielCChen and @kkwli , I think I got it right, but you may want to double check the `tools/f18/CMakeLists.txt` change).", "feature_layers": ["sema", "codegen", "ir"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "flang/lib/Frontend/CompilerInstance.cpp", "functions": ["triple", "userKeyString", "getExplicitAndImplicitAMDGPUTargetFeatures", "getExplicitAndImplicitNVPTXTargetFeatures"]}, {"filename": "flang/lib/Frontend/FrontendActions.cpp", "functions": ["triple", "getExplicitAndImplicitAMDGPUTargetFeatures", "pb", "getTargetFeatures", "userKeyString", "getExplicitAndImplicitNVPTXTargetFeatures"]}, {"filename": "flang/lib/Optimizer/Support/DataLayout.cpp", "functions": ["llvmDataLayout"]}, {"filename": "flang/tools/tco/tco.cpp", "functions": ["printModuleBody", "printModule"]}]}
{"pr_number": 74532, "url": "https://github.com/llvm/llvm-project/pull/74532", "title": "[OpenMP][FIX] Ensure we allow shared libraries without kernels", "body": "This fixes two bugs and adds a test for them:\r\n- A shared library with declare target functions but without kernels should not error out due to missing globals.\r\n- Enabling LIBOMPTARGET_INFO=32 should not deadlock in the presence of indirect declare targets.", "feature_layers": ["ir"], "feature_directives": ["for", "target", "declare"], "files_changed": [{"filename": "openmp/libomptarget/test/Inputs/declare_indirect_func.c", "functions": ["func"]}, {"filename": "openmp/libomptarget/test/offloading/shared_lib_fp_mapping.c", "functions": ["func", "int", "main"]}]}
{"pr_number": 74596, "url": "https://github.com/llvm/llvm-project/pull/74596", "title": "Irdl2", "body": "", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "clang/lib/Sema/SemaChecking.cpp", "functions": ["Diag"]}, {"filename": "clang/test/Driver/dfp-enablement-lang.c", "functions": ["__attribute__"]}, {"filename": "clang/test/Sema/dfp-types.c", "functions": ["test_generic", "__attribute", "__attribute__", "test_d64", "test_builtin_complex", "test_d32", "test_d128"]}, {"filename": "clang/test/SemaCXX/dfp-types.cpp", "functions": ["__attribute"]}, {"filename": "clang/test/Driver/dfp-enablement-target.c", "functions": ["__attribute__"]}, {"filename": "llvm/lib/IR/Type.cpp", "functions": ["getDecimal32Ty", "getDecimal64Ty", "getDecimal128Ty"]}, {"filename": "llvm/lib/IR/DataLayout.cpp", "functions": ["if"]}, {"filename": "llvm/lib/Target/X86/X86TargetMachine.cpp", "functions": ["computeDataLayout"]}]}
{"pr_number": 73922, "url": "https://github.com/llvm/llvm-project/pull/73922", "title": "[mlir][ArmSME] More precisely model dataflow in ArmSME to SCF lowerings", "body": "Since #73253, loops over tiles in SSA form (i.e. loops that take `iter_args` and yield a new tile) are supported, so this patch updates ArmSME lowerings to this form. This is a NFC, as it still lowers to the same intrinsics, but this makes IR less 'surprising' at a higher-level, and may be recognised by more transforms.\r\n\r\n\r\nExample:\r\n\r\nIR before:\r\n```mlir\r\nscf.for %tile_slice_index = %c0 to %num_tile_slices step %c1 \r\n{\r\n   arm_sme.move_vector_to_tile_slice \r\n     %broadcast_to_1d, %tile, %tile_slice_index : \r\n     vector<[4]xi32> into vector<[4]x[4]xi32>\r\n}\r\n// ... later use %tile\r\n```\r\nIR now:\r\n```mlir\r\n%broadcast_to_tile = scf.for %tile_slice_index = %c0 to %num_tile_slices\r\n    step %c1 iter_args(%iter_tile = %init_tile) -> (vector<[4]x[4]xi32>)\r\n{\r\n   %tile_update = arm_sme.move_vector_to_tile_slice\r\n      %broadcast_to_1d, %iter_tile, %tile_slice_index :\r\n      vector<[4]xi32> into vector<[4]x[4]xi32>\r\n  scf.yield %tile_update : vector<[4]x[4]xi32>\r\n}\r\n// ... later use %broadcast_to_tile\r\n```\r\n\r\n\r\n", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Conversion/VectorToArmSME/VectorToArmSME.cpp", "functions": ["g"]}]}
{"pr_number": 74324, "url": "https://github.com/llvm/llvm-project/pull/74324", "title": "[OpenACC] Implement 'cache' construct parsing", "body": "The 'cache' construct takes a list of 'vars', which are array-section style definitions. This patch implements the parsing, leaving the lower bound and length of the bound as expressions, so that we can validate they are the correct 'thing' in sema.", "feature_layers": ["sema"], "feature_directives": [], "files_changed": [{"filename": "clang/test/ParserOpenACC/parse-cache-construct.c", "functions": ["func"]}, {"filename": "clang/test/ParserOpenACC/parse-cache-construct.cpp", "functions": ["func", "use"]}]}
{"pr_number": 74597, "url": "https://github.com/llvm/llvm-project/pull/74597", "title": "Irdl2", "body": "", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "clang/lib/Sema/SemaChecking.cpp", "functions": ["Diag"]}, {"filename": "clang/test/Driver/dfp-enablement-lang.c", "functions": ["__attribute__"]}, {"filename": "clang/test/Sema/dfp-types.c", "functions": ["test_generic", "__attribute", "__attribute__", "test_d64", "test_builtin_complex", "test_d32", "test_d128"]}, {"filename": "clang/test/SemaCXX/dfp-types.cpp", "functions": ["__attribute"]}, {"filename": "clang/test/Driver/dfp-enablement-target.c", "functions": ["__attribute__"]}, {"filename": "llvm/lib/IR/Type.cpp", "functions": ["getDecimal32Ty", "getDecimal64Ty", "getDecimal128Ty"]}, {"filename": "llvm/lib/IR/DataLayout.cpp", "functions": ["if"]}, {"filename": "llvm/lib/Target/X86/X86TargetMachine.cpp", "functions": ["computeDataLayout"]}]}
{"pr_number": 73304, "url": "https://github.com/llvm/llvm-project/pull/73304", "title": "[SME2] Add LUTI2 and LUTI4 single Builtins and Intrinsics", "body": "See https://github.com/ARM-software/acle/pull/217\r\n\r\nPatch by: Hassnaa Hamdi <hassnaa.hamdi@arm.com>", "feature_layers": [], "feature_directives": ["single"], "files_changed": [{"filename": "clang/test/CodeGen/aarch64-sme2-intrinsics/acle_sme2_luti2_lane_zt.c", "functions": ["svluti2_lane_zt_s32", "test_svluti2_lane_zt_bf16", "svluti2_lane_zt_u8", "svluti2_lane_zt_u16", "svluti2_lane_zt_f16", "svluti2_lane_zt_bf16", "test_svluti2_lane_zt_f32", "test_svluti2_lane_zt_f16", "svluti2_lane_zt_f32", "test_svluti2_lane_zt_s32", "svluti2_lane_zt_s16", "test_svluti2_lane_zt_u32", "svluti2_lane_zt_u32", "test_svluti2_lane_zt_s16", "svluti2_lane_zt_s8", "test_svluti2_lane_zt_u16", "test_svluti2_lane_zt_s8"]}, {"filename": "clang/test/CodeGen/aarch64-sme2-intrinsics/acle_sme2_luti4_lane_zt.c", "functions": ["test_svluti4_lane_zt_s8", "test_svluti4_lane_zt_u16", "test_svluti4_lane_zt_f16", "svluti4_lane_zt_bf16", "svluti4_lane_zt_u8", "svluti4_lane_zt_s32", "test_svluti4_lane_zt_s32", "svluti4_lane_zt_s16", "test_svluti4_lane_zt_u32", "svluti4_lane_zt_u32", "test_svluti4_lane_zt_f32", "svluti4_lane_zt_f32", "test_svluti4_lane_zt_s16", "svluti4_lane_zt_f16", "svluti4_lane_zt_u16", "test_svluti4_lane_zt_bf16", "svluti4_lane_zt_s8"]}, {"filename": "clang/test/Sema/aarch64-sme2-intrinsics/acle_sme2_imm.cpp", "functions": ["test_svluti2_lane_zt", "test_svluti4_lane_zt"]}]}
{"pr_number": 74043, "url": "https://github.com/llvm/llvm-project/pull/74043", "title": "[ThinLTO] Add tail call flag to call edges in summary", "body": "This adds support for a HasTailCall flag on function call edges in the\nThinLTO summary. It is intended for use in aiding discovery of missing\nframes from tail calls in profiled call stacks for MemProf of profiled\nbinaries that did not disable tail call elimination. A follow on change\nwill add the use of this new flag during MemProf context disambiguation.\n\nThe new flag is encoded in the bitcode along with either the hotness\nflag from the profile, or the relative block frequency under the\n-write-relbf-to-summary flag when there is no profile data.\nBecause we now will always have some additional call edge information, I\nhave removed the non-profile function summary record format, and we\nsimply encode the tail call flag along with a hotness type of none when\nthere is no profile information or relative block frequency. The change\nof record format and name caused most of the test case changes.\n\nI have added explicit testing of generation of the new tail call flag\ninto the bitcode and IR assembly format as part of the changes to\nllvm/test/Bitcode/thinlto-function-summary-refgraph.ll. I have also\nadded round trip testing through assembly and bitcode to\nllvm/test/Assembler/thinlto-summary.ll.\n", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/AsmParser/LLParser.cpp", "functions": ["tokError", "error"]}, {"filename": "llvm/lib/Bitcode/Writer/BitcodeWriter.cpp", "functions": ["if", "getEncodedRelBFCallEdgeInfo", "getEncodedHotnessCallEdgeInfo"]}, {"filename": "llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp", "functions": ["CI"]}]}
{"pr_number": 74589, "url": "https://github.com/llvm/llvm-project/pull/74589", "title": "Irdl", "body": "", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "clang/lib/Sema/SemaChecking.cpp", "functions": ["Diag"]}, {"filename": "clang/test/Driver/dfp-enablement-lang.c", "functions": ["__attribute__"]}, {"filename": "clang/test/Sema/dfp-types.c", "functions": ["test_generic", "__attribute", "__attribute__", "test_d64", "test_builtin_complex", "test_d32", "test_d128"]}, {"filename": "clang/test/SemaCXX/dfp-types.cpp", "functions": ["__attribute"]}, {"filename": "clang/test/Driver/dfp-enablement-target.c", "functions": ["__attribute__"]}, {"filename": "llvm/lib/IR/Type.cpp", "functions": ["getDecimal32Ty", "getDecimal64Ty", "getDecimal128Ty"]}, {"filename": "llvm/lib/IR/DataLayout.cpp", "functions": ["if"]}, {"filename": "llvm/lib/Target/X86/X86TargetMachine.cpp", "functions": ["computeDataLayout"]}]}
{"pr_number": 74569, "url": "https://github.com/llvm/llvm-project/pull/74569", "title": "[NFC] Replace CallInst with FunctionType in VFABI, VFShape API", "body": "This minor simplification was applied to VFShape::getScalarShape, VFShape::get, and VFABI::tryDemangleForVFABI methods.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/tools/vfabi-demangle-fuzzer/vfabi-demangler-fuzzer.cpp", "functions": ["CI"]}]}
{"pr_number": 70917, "url": "https://github.com/llvm/llvm-project/pull/70917", "title": "[flang ]GETLOG runtime and extension implementation: get login username", "body": "Get login username, ussage:\r\n```c++\r\nCHARACTER(32) :: login\r\nCALL getlog(login)\r\nWRITE(*,*) login\r\n```\r\n\r\ngetlog is required for an exascale proxyapp.\r\nhttps://proxyapps.exascaleproject.org/app/minismac2d/\r\nhttps://github.com/Mantevo/miniSMAC/blob/f90446714226eeef650b78bce06ca4967792e74d/ref/smac2d.f#L615\r\nhttps://github.com/Mantevo/miniSMAC/blob/f90446714226eeef650b78bce06ca4967792e74d/ref/smac2d.f#L1570", "feature_layers": ["runtime", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Optimizer/Builder/Runtime/Execute.cpp", "functions": ["isAbsent"]}, {"filename": "flang/runtime/execute.cpp", "functions": ["ToErrmsg", "FillWithSpaces"]}, {"filename": "flang/unittests/Runtime/CommandTest.cpp", "functions": ["IntDescriptor", "spaces"]}]}
{"pr_number": 74602, "url": "https://github.com/llvm/llvm-project/pull/74602", "title": "[DebugInfo][RemoveDIs] Maintain DPValues on skipped instrs in CGP", "body": "It turns out that CodeGenPrepare will skip over consecutive select instructions as it knows it can optimise them all at the same time. This is unfortunate for the RemoveDIs project to remove intrinsic-based debug-info, because that means debug-info attached to those skipped instructions doesn't get seen by optimizeInst and so updated. Add code to handle debug-info on those skipped instructions manually.\r\n\r\nThis code will also have been slower when it had dbg.values stuffed in between instructions, but with RemoveDIs it'll go faster because the dbg.values won't break up the select sequence.", "feature_layers": ["codegen", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/CodeGen/CodeGenPrepare.cpp", "functions": ["fixupDPValuesOnInst"]}]}
{"pr_number": 68698, "url": "https://github.com/llvm/llvm-project/pull/68698", "title": "[AArch64][SVE] Teach compiler to use information that there are no ac\u2026", "body": "\u2026tive lanes\r\n\r\nThis patch optimizes SVE intrinsic calls which predicate is all false.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp", "functions": ["instCombineSVEAllOrNoActive", "instCombineSVEAllActive"]}]}
{"pr_number": 73261, "url": "https://github.com/llvm/llvm-project/pull/73261", "title": "[mlir] Fix TileUsingForOp attr-dict printing/parsing", "body": "Reland https://github.com/llvm/llvm-project/pull/72745\r\nfixed the failing test\r\n\r\nOriginal message:\r\n[mlir] Fix TileUsingForOp attr-dict printing/parsing (https://github.com/llvm/llvm-project/pull/72745)\r\n`TileUsingForOp` has an optional Attribute `interchange` which was given\r\nin curly braces like this: `{interchange = [...]}`. The way this was\r\nparsed meant that no normal `attr-dict` could be attached to the Op.\r\nThis patch adds printing / parsing of an `attr-dict` to the Op and treats\r\nthe `interchange` Attribute as part of that dictionary for now.", "feature_layers": ["parse", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Linalg/TransformOps/LinalgTransformOps.cpp", "functions": ["failure", "success"]}]}
{"pr_number": 71953, "url": "https://github.com/llvm/llvm-project/pull/71953", "title": "Add SME2 builtins for pfalse and ptrue", "body": "Extend pfalse and ptrue builtins with svcount_t return types to be enabled for sve2p1 and sme2\r\n\r\nSee https://github.com/ARM-software/acle/pull/217", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CodeGen/aarch64-sme2-intrinsics/acle_sme2_ptrue_pfalse_attr.c", "functions": ["test_svptrue_c8_attr", "test_svpfalse_c_attr", "svptrue_c8", "svpfalse_c"]}, {"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_pfalse.c", "functions": ["test_svpfalse_c", "SVE_ACLE_FUNC", "svpfalse_c"]}, {"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_ptrue.c", "functions": ["test_svptrue_c16", "test_svptrue_c8", "test_svptrue_c64", "test_svptrue_c32"]}]}
{"pr_number": 71430, "url": "https://github.com/llvm/llvm-project/pull/71430", "title": "[MLIR] Enable GPU Dialect to SYCL runtime integration", "body": "GPU Dialect lowering to SYCL runtime is driven by spirv.target_env attached to gpu.module. As a result of this, spirv.target_env remains as an input to LLVMIR Translation.\r\nA SPIRVToLLVMIRTranslation without any actual translation is added to avoid an unregistered error in mlir-cpu-runner.\r\nSelectObjectAttr.cpp is updated to\r\n1) Pass binary size argument to getModuleLoadFn\r\n2) Pass parameter count to getKernelLaunchFn\r\nThis change does not impact CUDA and ROCM usage since both mlir_cuda_runtime and mlir_rocm_runtime are already updated to accept and ignore the extra arguments.", "feature_layers": ["runtime", "ir"], "feature_directives": ["target"], "files_changed": [{"filename": "mlir/lib/Target/LLVMIR/Dialect/GPU/SelectObjectAttr.cpp", "functions": ["getBinarySizeIdentifier"]}]}
{"pr_number": 74550, "url": "https://github.com/llvm/llvm-project/pull/74550", "title": "[Libomptarget] Add a utility function for checking existence of symbols", "body": "Summary:\nThere are now a few cases that check if a symbol is present before\ncontinuing, effectively making them optional features if present in the\nimage. This was done in at least three locations and required an ugly\noperation to consume the error. This patch makes a utility function to\nhandle that instead.\n", "feature_layers": ["ir", "ast"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "openmp/libomptarget/plugins-nextgen/amdgpu/src/rtl.cpp", "functions": ["Global"]}, {"filename": "openmp/libomptarget/plugins-nextgen/common/src/RPC.cpp", "functions": ["Global"]}, {"filename": "openmp/libomptarget/plugins-nextgen/cuda/src/rtl.cpp", "functions": ["Global"]}]}
{"pr_number": 74654, "url": "https://github.com/llvm/llvm-project/pull/74654", "title": "[mlir][sparse] cleanup ldx/idx/depth/at usage", "body": "This adds a consistent usage with `at` for everything that refers to the current loop nesting. This cleans up some redundant legacy code from when we were still using topSort inside sparsifier code.", "feature_layers": ["parse", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/Transforms/Sparsification.cpp", "functions": ["genCoIteration", "isInvariantAffine", "isParallelFor"]}]}
{"pr_number": 74256, "url": "https://github.com/llvm/llvm-project/pull/74256", "title": "[libc++][test] Fix more MSVC warnings", "body": "Found while running libc++'s test suite with MSVC's STL.\r\n\r\n* Fix MSVC \"warning C4285: return type for '`WithNonCopyableIterator::iterator::operator ->`' is recursive if applied using infix notation\".\r\n  + This warning is valid - the return type is super squirrelly :chipmunk: - even though the operator is never defined. This test doesn't care about this return type, and it appears to have been a simple typo. Changing it to `XYPoint*`, like `WithArrowOperator` immediately above, fixes the warning.\r\n* Fix MSVC \"warning C4389: '`==`': signed/unsigned mismatch\".\r\n  + This warning is valid-ish. MSVC is seeing a `repeat_view`'s `size()` being compared with the `int` return value of a function, and a negative value would undergo a value-modifying conversion, so it warns. This happens because MSVC is *exceptionally* lazy about `constexpr` function calls, so it's calling `std::numeric_limits<int>::max()` at runtime and doesn't realize that it's a positive constant. By extracting this into a `constexpr` variable, MSVC is satisfied that `int_max` will undergo a value-preserving conversion. This costs an extra line but slightly reduces the repetition of `std::numeric_limits<int>::max()` so I hope it's acceptable.\r\n* Fix MSVC \"warning C4244: 'argument': conversion from '`unsigned __int64`' to '`unsigned int`', possible loss of data\".\r\n  + An allocator's `deallocate()` should be able to take its size type. In these tests, MSVC is instantiating enough of the allocator machinery to emit this warning. These test allocators weren't intentionally trying to make `deallocate()` have a weird parameter type - these tests are interested in POCS etc. and the `allocate()`/`deallocate()` are just stubs.\r\n", "feature_layers": ["runtime", "ir"], "feature_directives": ["for", "allocate"], "files_changed": [{"filename": "libcxx/test/std/input.output/string.streams/stringbuf/stringbuf.assign/member_swap_noexcept.pass.cpp", "functions": ["deallocate"]}, {"filename": "libcxx/test/std/input.output/string.streams/stringbuf/stringbuf.assign/nonmember_swap_noexcept.pass.cpp", "functions": ["deallocate"]}]}
{"pr_number": 74571, "url": "https://github.com/llvm/llvm-project/pull/74571", "title": "[libc++][test] Drop unnecessary `typename` and `template` for `layout_meow::mapping`", "body": "This is a pure syntax cleanup, I don't need it for running libc++'s tests with MSVC's STL.\r\n\r\nThis is possible because `std::layout_meow` and `layout_wrapping_integral<1729>` aren't dependent types. We only need `typename` and `template` when reaching *into* a dependent type, like `typename OtherLayout::template mapping<E2>` or `typename layout_wrapping_integral<Wraps>::template mapping<Extents>`.\r\n\r\n* Drop unnecessary `typename` and `template` disambiguators for `std::layout_meow::mapping`.\r\n  + This is a pure regex replacement from `(?:typename )?std::layout_(left|right|stride)::template mapping` to `std::layout_$1::mapping`.\r\n* Similarly for `layout_wrapping_integral`.\r\n  + This is a pure regex replacement from `(?:typename )?(layout_wrapping_integral<\\d+>)::template mapping` to `$1::mapping`.\r\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "libcxx/test/std/containers/views/mdspan/layout_stride/comparison.pass.cpp", "functions": ["map"]}, {"filename": "libcxx/test/std/containers/views/mdspan/mdspan/swap.pass.cpp", "functions": ["map_a"]}]}
{"pr_number": 74656, "url": "https://github.com/llvm/llvm-project/pull/74656", "title": "[mlir][sparse] use \"current\" and \"curr\" consistently", "body": "Removes at in favor of curr; also makes method delegates consistent", "feature_layers": ["parse", "ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/Transforms/Sparsification.cpp", "functions": ["isInvariantAffine", "isParallelFor"]}]}
{"pr_number": 74580, "url": "https://github.com/llvm/llvm-project/pull/74580", "title": "[clang][DebugInfo] Revert \"emit definitions for constant-initialized static data-members\"", "body": "This commit reverts the changes in https://github.com/llvm/llvm-project/pull/71780 and all of its follow-up patches.\r\n\r\nWe got reports of the `.debug_names/.debug_gnu_pubnames/gdb_index/etc.` sections growing by a non-trivial amount for some large projects. While GCC emits definitions for static data member constants into the Names index, they do so *only* for explicitly `constexpr` members. We were indexing *all* constant-initialized const-static members, which is likely where the significant size difference comes from. However, only emitting explicitly `constexpr` variables into the index doesn't seem like a good way forward, since from clang's perspective `const`-static integrals are `constexpr` too, and that shouldn't be any different in the debug-info component. Also, as new code moves to `constexpr` instead of `const` static for constants, such solution would just delay the growth of the Names index.\r\n\r\nTo prevent the size regression we revert to not emitting definitions for static data-members that have no location.\r\n\r\nTo support access to such constants from LLDB we'll most likely have to have to make LLDB find the constants by looking at the containing class first.", "feature_layers": ["ir"], "feature_directives": ["for", "sections"], "files_changed": [{"filename": "clang/test/CodeGenCXX/debug-info-static-inline-member.cpp", "functions": ["func", "main"]}]}
{"pr_number": 74360, "url": "https://github.com/llvm/llvm-project/pull/74360", "title": " [OpenMP][NFC] Remove `DelayedBinDesc`", "body": "Remove `DelayedBinDesc` as it is not necessary since https://github.com/llvm/llvm-project/commit/bc4e0c048aa3cd940b0cea787014c7e8680e5040.\r\nSee https://github.com/llvm/llvm-project/pull/74360#issuecomment-1843603736 for details.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "openmp/libomptarget/test/offloading/bug60119.c", "functions": ["main"]}]}
{"pr_number": 74669, "url": "https://github.com/llvm/llvm-project/pull/74669", "title": "[OpenMP][FIX] Ensure we do not read outside the device image", "body": "Before we expected all symbols in the device image to be backed up with data that we could read. However, uninitialized values are not. We now check for this case and avoid reading random memory.\r\n\r\nThis also replaces the correct readGlobalFromImage call with a isSymbolInImage check after\r\nhttps://github.com/llvm/llvm-project/pull/74550 picked the wrong one.\r\n\r\nFixes: https://github.com/llvm/llvm-project/issues/74582", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "openmp/libomptarget/test/offloading/bug74582.c", "functions": ["__attribute__", "main"]}]}
{"pr_number": 74551, "url": "https://github.com/llvm/llvm-project/pull/74551", "title": "[mlir][SCF] Retire SCF-specific `to_memref`/`to_tensor` canonicalization patterns", "body": "The partial bufferization framework has been replaced with One-Shot Bufferize. SCF-specific canonicalization patterns for `to_memref`/`to_tensor` are no longer needed.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/SCF/IR/SCF.cpp", "functions": ["failure", "success"]}]}
{"pr_number": 74679, "url": "https://github.com/llvm/llvm-project/pull/74679", "title": "Revert \" [OpenMP][NFC] Remove `DelayedBinDesc`\"", "body": "Reverts llvm/llvm-project#74360\r\n\r\nAs I wrote in the analysis of #74360:\r\n\r\nSince https://github.com/llvm/llvm-project/commit/bc4e0c048aa3cd940b0cea787014c7e8680e5040 we will not add PluginAdaptors into the container of all plugin adaptors before the plugin is not ready. The error is thereby gone. When and old HSA loads other libraries they can call register_image but that will simply not register the image with the plugin we are currently initializing. That seems like reasonable behavior, thought it is good to keep in mind if we ever want a kernel library (@jhuber6 @mjklemm). We can still have a standalone kernel library though or load it late after all plugins are setup (which seems reasonable).\r\n\r\nI did not expect one our tests actually doing exactly what this will not allow anymore, at least when you use rocm <5.5.0. Need to figure out if we want this behavior (for rocm <5.5.0).\r\n", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "openmp/libomptarget/test/offloading/bug60119.c", "functions": ["main"]}]}
{"pr_number": 74435, "url": "https://github.com/llvm/llvm-project/pull/74435", "title": "[CodeGen] Port WasmEHPrepare to new pass manager", "body": "Port `WasmEHPrepare` to new pass manager, also rename `wasmehprepare` to `wasm-eh-prepare`.", "feature_layers": ["codegen"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/CodeGen/WasmEHPrepare.cpp", "functions": ["P", "runOnFunction"]}]}
{"pr_number": 74265, "url": "https://github.com/llvm/llvm-project/pull/74265", "title": "[clang] Exclude non-template classes when checking if constraint refers to containing template arguments", "body": "When checking if the constraint uses any enclosing template parameters for [temp.friend]p9, if a containing record is used as argument, we assume that the constraint depends on enclosing template parameters without checking if the record is templated. The reproducer from the bug is included as a test case.\r\n\r\nI would appreciate if someone could double check my interpretation of the standard here as I'm not the most experienced with it.\r\n\r\nFixes #71595", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/SemaTemplate/GH71595.cpp", "functions": ["g", "h", "f"]}]}
{"pr_number": 74564, "url": "https://github.com/llvm/llvm-project/pull/74564", "title": "[mlir][complex] Allow integer element types in `complex.constant` ops", "body": "The op used to support only float element types. This was inconsistent with `ConstantOp::isBuildableWith`, which allows integer element types. The complex type allows any float/integer element type.\r\n\r\nNote: The other complex dialect ops do not support non-float element types yet. The main purpose of this change to fix `Tensor/canonicalize.mlir`, which is currently failing when verifying the IR after each pattern application (#74270).\r\n\r\n```\r\nwithin split at mlir/test/Dialect/Tensor/canonicalize.mlir:231 offset :8:15: error: 'complex.constant' op result #0 must be complex type with floating-point elements, but got 'complex<i32>'\r\n  %complex1 = tensor.extract %c1[] : tensor<complex<i32>>\r\n              ^\r\nwithin split at mlir/test/Dialect/Tensor/canonicalize.mlir:231 offset :8:15: note: see current operation: %0 = \"complex.constant\"() <{value = [1 : i32, 2 : i32]}> : () -> complex<i32>\r\n\"func.func\"() <{function_type = () -> tensor<3xcomplex<i32>>, sym_name = \"extract_from_elements_complex_i\"}> ({\r\n  %0 = \"complex.constant\"() <{value = [1 : i32, 2 : i32]}> : () -> complex<i32>\r\n  %1 = \"arith.constant\"() <{value = dense<(3,2)> : tensor<complex<i32>>}> : () -> tensor<complex<i32>>\r\n  %2 = \"arith.constant\"() <{value = dense<(1,2)> : tensor<complex<i32>>}> : () -> tensor<complex<i32>>\r\n  %3 = \"tensor.extract\"(%1) : (tensor<complex<i32>>) -> complex<i32>\r\n  %4 = \"tensor.from_elements\"(%0, %3, %0) : (complex<i32>, complex<i32>, complex<i32>) -> tensor<3xcomplex<i32>>\r\n  \"func.return\"(%4) : (tensor<3xcomplex<i32>>) -> ()\r\n}) : () -> ()\r\n```", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/Complex/IR/ComplexOps.cpp", "functions": ["emitOpError"]}]}
{"pr_number": 69695, "url": "https://github.com/llvm/llvm-project/pull/69695", "title": "[PowerPC] redesign the target flags", "body": "Redesign how PPC target set the target specific flags. With this patch, all ppc target flags are direct flags. No bitmask flag in PPC anymore. 12 bit is not enough for PPC's target specific flags. If 8 bit for the bitmask flags, 4 bit for the direct mask, PPC can total have 16 direct mask and 8 bitmask. Not enough for PPC, see this issue in https://github.com/llvm/llvm-project/pull/66316\r\n\r\nReducing the bitmask's 8 bit to a smaller value would be also workable, but that is not robust if we continue to add more target specific flags.\r\n\r\nIncreasing the size of `SubReg_TargetFlags` in `MachineOperand` is also workable, but that will increase memory usage for all targets. I think this should be avoided.\r\n\r\nThis patch aligns with some targets like X86 which also has many target specific flags.\r\n\r\nThe patch also fixes a bug related to flag `MO_TLSGDM_FLAG` and `MO_LO`. They are the same value and the test case changes in this PR shows the bug.", "feature_layers": ["ir"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp", "functions": ["hasTLSFlag"]}, {"filename": "llvm/lib/Target/PowerPC/PPCInstrInfo.cpp", "functions": ["ArrayRef"]}, {"filename": "llvm/lib/Target/PowerPC/PPCMCInstLower.cpp", "functions": ["if"]}]}
{"pr_number": 70642, "url": "https://github.com/llvm/llvm-project/pull/70642", "title": "[XCOFF][obj2yaml] support parsing auxiliary symbols for XCOFF", "body": "This PR adds the support for parsing auxiliary symbols of XCOFF object file for obj2yaml.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/tools/obj2yaml/xcoff2yaml.cpp", "functions": ["if"]}]}
{"pr_number": 73921, "url": "https://github.com/llvm/llvm-project/pull/73921", "title": "[clang-tidy] performance-unnecessary-copy-init: Add a hook...", "body": "... so that derived checks can derived checks can observe for which variables a warning has been emitted. Does nothing by default, which makes this  an NFC.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang-tools-extra/clang-tidy/performance/UnnecessaryCopyInitialization.cpp", "functions": ["Var", "Context"]}]}
{"pr_number": 74499, "url": "https://github.com/llvm/llvm-project/pull/74499", "title": "[AArch64] Optimise MOVI + CMGT to CMGE", "body": "This fixes a regression that occured for a pattern of MOVI + CMGT instructions, which can be optimised to CMGE. I.e., when the signed greater than compare has -1 as an operand, we can rewrite that as a compare greater equal than 0, which is what CMGE does.\r\n\r\nFixes #61836", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AArch64/AArch64ISelLowering.cpp", "functions": ["UndefBits", "CnstBits"]}]}
{"pr_number": 74568, "url": "https://github.com/llvm/llvm-project/pull/74568", "title": "[mlir][tensor] `tensor.generate`: do not verify dynamic sizes", "body": "Op verifiers should verify only local properties of an op. The dynamic sizes of a `tensor.generate` op should not be verified. Dynamic sizes that have a negative constant value should not prevent the `tensor.generate` op from verifying.\r\n\r\nAlso share some code between the `tensor.empty` and `tensor.generate` \"dynamic dim -> static dim\" canonicalization patterns.\r\n\r\nRemove the `invalid-canonicalize.mlir` file and move the test case to `canonicalize.mlir`. Canonicalization no longer produces IR that does not verify (and leaves the op as is).", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/Tensor/IR/TensorOps.cpp", "functions": ["failure", "staticShape", "emitError"]}]}
{"pr_number": 74335, "url": "https://github.com/llvm/llvm-project/pull/74335", "title": "[clang] Substitute alias templates from correct context", "body": "Current context set to where alias was met, not where it is declared caused incorrect access check in case alias referenced private members of the parent class.\r\n\r\nFixes https://github.com/llvm/llvm-project/issues/41693", "feature_layers": [], "feature_directives": ["declare"], "files_changed": [{"filename": "clang/lib/Sema/SemaTemplate.cpp", "functions": ["SavedContext"]}, {"filename": "clang/test/SemaCXX/alias-template.cpp", "functions": ["Impl", "foo"]}]}
{"pr_number": 74508, "url": "https://github.com/llvm/llvm-project/pull/74508", "title": "[mlir][LLVM] Add nsw and nuw flags", "body": "The implementation of these are modeled after the existing fastmath flags for floating point arithmetic.", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/LLVMIR/IR/LLVMDialect.cpp", "functions": ["processIntOverflowAttr"]}]}
{"pr_number": 74076, "url": "https://github.com/llvm/llvm-project/pull/74076", "title": "Implement SoftPromoteHalf for FFREXP.", "body": "`llvm/test/CodeGen/RISCV/llvm.frexp.ll` and `llvm/test/CodeGen/X86/llvm.frexp.ll` contain a number of disabled tests for unimplemented functionality. This implements one missing part of it.", "feature_layers": ["codegen"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/CodeGen/SelectionDAG/LegalizeFloatTypes.cpp", "functions": ["dl"]}]}
{"pr_number": 70564, "url": "https://github.com/llvm/llvm-project/pull/70564", "title": "[libc++] add floating point type check for uniform real distribution", "body": "Created a PR to fix this issue - https://github.com/llvm/llvm-project/issues/62433", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "libcxx/test/libcxx/numerics/rand/rand.req.urng/valid_real_type.verify.cpp", "functions": ["test"]}]}
{"pr_number": 74660, "url": "https://github.com/llvm/llvm-project/pull/74660", "title": "[SPIR-V] Remove deleted functions", "body": "Remove references to functions that were deleted in #74521 which are causing SPIR-V backend build failures.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/Target/SPIRV/SPIRVGlobalRegistry.cpp", "functions": ["getOpTypeOpaque", "getOpTypeStruct"]}]}
{"pr_number": 74692, "url": "https://github.com/llvm/llvm-project/pull/74692", "title": "[OpenMP] Fix runtime problem due to wrong map size.", "body": "Currently we are missing set up-boundary address for FinalArraySection as highests elements in partial struct data.\r\n\r\nCurrently for:\r\n\\#pragma omp target map(D.a) map(D.b[:2])\r\nThe size is:\r\n  %a = getelementptr inbounds %struct.DataTy, ptr %D, i32 0, i32 0\r\n  %b = getelementptr inbounds %struct.DataTy, ptr %D, i32 0, i32 1\r\n  %arrayidx = getelementptr inbounds [2 x float], ptr %b, i64 0, i64 0\r\n  %2 = getelementptr float, ptr %arrayidx, i32 1\r\n  %3 = ptrtoint ptr %2 to i64\r\n  %4 = ptrtoint ptr %a to i64\r\n  %5 = sub i64 %3, %4\r\n  %6 = sdiv exact i64 %5, ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64)\r\n\r\nWhere %2 is wrong for (D.b[:2]) is pointer to first element of array section.  It should pointe to last element of array section.\r\n  \r\nThe fix is to emit the pointer to the last element of array section and use this pointer as the highest element in partial struct data.\r\n\r\nAfter change IR:\r\n  %a = getelementptr inbounds %struct.DataTy, ptr %D, i32 0, i32 0\r\n  %b = getelementptr inbounds %struct.DataTy, ptr %D, i32 0, i32 1\r\n  %arrayidx = getelementptr inbounds [2 x float], ptr %b, i64 0, i64 0\r\n  %b1 = getelementptr inbounds %struct.DataTy, ptr %D, i32 0, i32 1\r\n  %arrayidx2 = getelementptr inbounds [2 x float], ptr %b1, i64 0, i64 1\r\n  %1 = getelementptr float, ptr %arrayidx2, i32 1\r\n  %2 = ptrtoint ptr %1 to i64\r\n  %3 = ptrtoint ptr %a to i64\r\n  %4 = sub i64 %2, %3\r\n  %5 = sdiv exact i64 %4, ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64)", "feature_layers": ["runtime", "ir", "ast"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "openmp/libomptarget/test/offloading/target_map_for_member_data.cpp", "functions": ["main"]}]}
{"pr_number": 66139, "url": "https://github.com/llvm/llvm-project/pull/66139", "title": "[clang-tidy] Add performance-move-smart-pointer-contents check.", "body": "This check detects moves of the contents of a smart pointer as opposed to the smart pointer itself. For unique_ptr this is a performance issue, as the underlying type is presumably not cheap to move, but for shared_ptr it's actually dangerous as other code that also has access to the shared_ptr is probably not expecting the move.\r\n\r\nThe set of \"unique\" and \"shared\" pointer classes are configurable via options to allow individual projects to add additional classes of each type.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang-tools-extra/clang-tidy/performance/MoveSmartPointerContentsCheck.cpp", "functions": ["ClangTidyCheck"]}, {"filename": "clang-tools-extra/test/clang-tidy/checkers/performance/move-smart-pointer-contents.cpp", "functions": ["configWorksShared", "bool", "reset", "multiStarsShared", "aliasedSharedType", "simpleFindingShared", "correctShared"]}]}
{"pr_number": 72280, "url": "https://github.com/llvm/llvm-project/pull/72280", "title": "[Clang] Introduce scoped variants of GNU atomic functions", "body": "Summary:\r\nThe standard GNU atomic operations are a very common way to target\r\nhardware atomics on the device. With more heterogenous devices being\r\nintroduced, the concept of memory scopes has been in the LLVM language\r\nfor awhile via the `syncscope` modifier. For targets, such as the GPU,\r\nthis can change code generation depending on whether or not we only need\r\nto be consistent with the memory ordering with the entire system, the\r\nsingle GPU device, or lower.\r\n\r\nPreviously these scopes were only exported via the `opencl` and `hip`\r\nvariants of these functions. However, this made it difficult to use\r\noutside of those languages and the semantics were different from the\r\nstandard GNU versions. This patch introduces a `__scoped_atomic` variant\r\nfor the common functions. There was some discussion over whether or not\r\nthese should be overloads of the existing ones, or simply new variants.\r\nI leant towards new variants to be less disruptive.\r\n\r\nThe scope here can be one of the following\r\n\r\n```\r\n__MEMORY_SCOPE_SYSTEM // All devices and systems\r\n__MEMORY_SCOPE_DEVICE // Just this device\r\n__MEMORY_SCOPE_WRKGRP // A 'work-group' AKA CUDA block\r\n__MEMORY_SCOPE_WVFRNT // A 'wavefront' AKA CUDA warp\r\n__MEMORY_SCOPE_SINGLE // A single thread.\r\n```\r\nNaming consistency was attempted, but it is difficult to capture to full\r\nspectrum with no many names. Suggestions appreciated.\r\n", "feature_layers": ["sema", "ir"], "feature_directives": ["for", "single", "atomic", "target"], "files_changed": [{"filename": "clang/test/CodeGen/scoped-atomic-ops.c", "functions": ["fi6a", "fi5c", "fi5b", "fi3a", "fi6e", "fi4a", "fi5d", "fi5a", "fi7b", "fi7d", "fi6b", "fi4e", "fi1a", "fi4b", "fi7e", "fi3b", "fi4c", "fi6d", "fi3e", "fi4d", "fi7c", "fi6c", "fi5e", "fi3d", "fi2a", "fi7a", "fi2b", "fi1b", "fi3c"]}, {"filename": "clang/test/Sema/scoped-atomic-ops.c", "functions": ["fi4a", "fi5a", "fi3d", "fi1a", "fi2a", "fi6a", "fi2b", "fi7a", "fi3b", "fi3a", "fi1b", "fi3c"]}]}
{"pr_number": 74750, "url": "https://github.com/llvm/llvm-project/pull/74750", "title": "[mlir][sparse] optimize memory load to SSA value when generating spar\u2026", "body": "\u2026se conv kernel.", "feature_layers": ["parse", "ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/Transforms/LoopEmitter.cpp", "functions": ["genIndexLoad"]}]}
{"pr_number": 74755, "url": "https://github.com/llvm/llvm-project/pull/74755", "title": "[SPIR-V] Partial revert of d40eb0a", "body": "This part of the #74660 patch was incorrect and shouldn't have been changed since this usage of `isOpaque()` is not one of `PointerType`'s functions.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/Target/SPIRV/SPIRVGlobalRegistry.cpp", "functions": ["getOpTypeOpaque", "getOpTypeStruct"]}]}
{"pr_number": 74353, "url": "https://github.com/llvm/llvm-project/pull/74353", "title": "[scudo] Add hooks to mark the range of realloc", "body": "`realloc` may involve both allocation and deallocation. Given that the reporting the events is not atomic and which may lead the hook user to a false case that the double-use pattern happens. In general, this can be resolved on the hook side. To alleviate the task of handling it, we add two new hooks to mark the range so that the hook user can combine those calls together.", "feature_layers": [], "feature_directives": ["task", "atomic"], "files_changed": [{"filename": "compiler-rt/lib/scudo/standalone/tests/wrappers_c_test.cpp", "functions": ["verifyReallocHooksScope", "verifyReallocHookPtrs"]}, {"filename": "compiler-rt/lib/scudo/standalone/wrappers_c.inc", "functions": ["if"]}]}
{"pr_number": 74644, "url": "https://github.com/llvm/llvm-project/pull/74644", "title": "[mlir][affine] implement inferType for delinearize", "body": "Mostly just for the sake of nicer python bindings.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Affine/IR/AffineOps.cpp", "functions": ["success"]}]}
{"pr_number": 74687, "url": "https://github.com/llvm/llvm-project/pull/74687", "title": "Fix a stall in running `quit` while a live  process is running", "body": "We need to generate events when finalizing, or we won't know that we succeeded in stopping the process to detach/kill.  Instead, we stall and then after our 20 interrupt timeout, we kill the process (even if we were supposed to detach) and exit.\r\n\r\nOTOH, we have to not generate events when the Process is being destructed because shared_from_this has already been torn down, and using it will cause crashes.", "feature_layers": [], "feature_directives": ["detach"], "files_changed": [{"filename": "lldb/test/API/driver/quit_speed/main.c", "functions": ["main"]}]}
{"pr_number": 74754, "url": "https://github.com/llvm/llvm-project/pull/74754", "title": "[mlir] Extend CombineTransferReadOpTranspose pattern to handle extf ops.", "body": "This patch modifies the CombineTransferReadOpTranspose pattern to handle extf ops. Also adds a test which shows the transpose getting folded into the transfer_read.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Conversion/VectorToGPU/VectorToGPU.cpp", "functions": ["if"]}]}
{"pr_number": 74107, "url": "https://github.com/llvm/llvm-project/pull/74107", "title": "[SHT_LLVM_BB_ADDR_MAP] Deprecate SHT_LLVM_BB_ADDR_MAP versions 0 and 1.", "body": "Old versions are stale (more than 9 months old) and can be deprecated from tools and codegen.", "feature_layers": ["codegen"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/MC/MCSectionELF.cpp", "functions": ["if"]}, {"filename": "llvm/lib/Object/ELF.cpp", "functions": ["createError"]}, {"filename": "llvm/unittests/Object/ELFObjectFileTest.cpp", "functions": ["DeprecatedVersionYamlString"]}]}
{"pr_number": 73710, "url": "https://github.com/llvm/llvm-project/pull/73710", "title": "[AMDGPU] [IGLP]: Fix assert", "body": "We can also re-enter IGLP mutation via later `SchedStage`s in the `GCNMaxOccupancySchedStrategy` . This is sort of NFC in that there is no changed behavior for the only current client of `IsReentry`", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp", "functions": ["if", "createIGroupLPDAGMutation"]}]}
{"pr_number": 70835, "url": "https://github.com/llvm/llvm-project/pull/70835", "title": "[Attributes][HLSL] Teach EnumArgument to refer to an external enum", "body": "Rather than write a bunch of logic to shepherd between enums with the same sets of values, add the ability for EnumArgument to refer to an external enum in the first place.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/utils/TableGen/ClangAttrEmitter.cpp", "functions": ["getLowerName", "getAttrName", "Argument", "getUpperName"]}]}
{"pr_number": 74752, "url": "https://github.com/llvm/llvm-project/pull/74752", "title": "[OpenACC] Implement 'wait' construct parsing", "body": "The 'wait' construct comes in two forms: one with no parens, the second with a 'wait-argument'. This implements both forms for constructs.\r\n\r\nAdditionally, the 'wait-argument' parsing is split into its own function because the 'wait clause' can also take the same 'wait-argument'.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/ParserOpenACC/parse-wait-construct.c", "functions": ["func"]}, {"filename": "clang/lib/Parse/ParseOpenACC.cpp", "functions": ["isOpenACCSpecialToken"]}]}
{"pr_number": 74268, "url": "https://github.com/llvm/llvm-project/pull/74268", "title": "[SimplifyCFG] Not folding branch in loop header with constant iterations", "body": "[SimplifyCFG] Not folding branch in constant loops which expected unroll\r\n\r\n    Constant iteration loop with unroll hint usually expected do unroll\r\n    by consumers, folding branches in such loop header at SimplifyCFG will\r\n    break unroll optimization.\r\n\r\nfor example:\r\n #program unroll\r\n for (int I = 0; I < ConstNum; ++I) { // ConstNum > 1\r\n    if (Cond2) {\r\n       break;\r\n     }\r\n      xxx loop body;\r\n  }\r\n Folding these conditional branches may break loop unroll.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Utils/SimplifyCFG.cpp", "functions": ["GetUnrollMetadata", "hasUnrollHint", "isConstantLoopWithUnrollHint"]}]}
{"pr_number": 74772, "url": "https://github.com/llvm/llvm-project/pull/74772", "title": "[lldb][Symbol] Make sure we decrement PC before checking location list", "body": "When stopping in optimized code, we can end up with the return address being the next instruction in a different block. If we are dealing with location lists, we want to decrement the PC value so it's within the calling block range that we're checking against the loclists.\r\n\r\nThis was addressed in https://reviews.llvm.org/D124597 (`6e56c4961a106b8fde69ffcf9f803fe0890722fa`), by introducing a `GetFrameCodeAddressForSymbolication`. This fixed `frame variable`, but `expr` calls into `Variable::LocationIsValidForFrame`, where this new API wasn't used yet.\r\n\r\nSo in the associated test-case, running `frame var this` works, but `expr this` doesn't. With `dwim-print` this makes the situation more surprising for the user because `p this`, `v this` and `v *this` work, but `p *this` doesn't because it falls back onto `expr` (due to the dereference).\r\n\r\nThis patch makes sure we lookup loclists using the correct PC by using this new `GetFrameCodeAddressForSymbolication` API.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "lldb/test/API/functionalities/location-list-lookup-cpp-member/main.cpp", "functions": ["func", "bar", "main"]}, {"filename": "lldb/test/API/functionalities/location-list-lookup/main.c", "functions": ["foo", "main"]}, {"filename": "lldb/test/API/functionalities/location-list-lookup/main.cpp", "functions": ["bar"]}]}
{"pr_number": 73027, "url": "https://github.com/llvm/llvm-project/pull/73027", "title": "[mlir][affine] Remove `isValidAffineIndexOperand`", "body": "The function\r\n```cpp\r\nstatic bool isValidAffineIndexOperand(Value value, Region *region) {\r\n  return isValidDim(value, region) || isValidSymbol(value, region);\r\n}\r\n```\r\nis redundant because `isValidDim` is defined as\r\n```cpp\r\nbool mlir::affine::isValidDim(Value value, Region *region) {\r\n  // The value must be an index type.\r\n  if (!value.getType().isIndex())\r\n    return false;\r\n\r\n  // All valid symbols are okay.\r\n  if (isValidSymbol(value, region))\r\n    return true;\r\n\r\n  auto *op = value.getDefiningOp();\r\n  if (!op) {\r\n    // This value has to be a block argument for an affine.for or an\r\n    // affine.parallel.\r\n    auto *parentOp = llvm::cast<BlockArgument>(value).getOwner()->getParentOp();\r\n    return isa<AffineForOp, AffineParallelOp>(parentOp);\r\n  }\r\n\r\n  // Affine apply operation is ok if all of its operands are ok.\r\n  if (auto applyOp = dyn_cast<AffineApplyOp>(op))\r\n    return applyOp.isValidDim(region);\r\n  // The dim op is okay if its operand memref/tensor is defined at the top\r\n  // level.\r\n  if (auto dimOp = dyn_cast<ShapedDimOpInterface>(op))\r\n    return isTopLevelValue(dimOp.getShapedValue());\r\n  return false;\r\n}\r\n```\r\nand `isValidSymbol` is defined as\r\n```cpp\r\nbool mlir::affine::isValidSymbol(Value value, Region *region) {\r\n  // The value must be an index type.\r\n  if (!value.getType().isIndex())\r\n    return false;\r\n\r\n  // Check that the value is a top level value.\r\n  if (isTopLevelValue(value))\r\n    return true;\r\n\r\n  if (auto *defOp = value.getDefiningOp())\r\n    return isValidSymbol(value, getAffineScope(defOp));\r\n\r\n  return false;\r\n}\r\n```\r\n\r\nTo see that the function is redundant, consider the following cases:\r\n\r\n- `isValidDim(value, region)` is true, then `isValidDim(value, region) || isValidSymbol(value, region)` must be true.\r\n- `isValidDim(value, region)` is false, then either `value.getType().isIndex()` is false, which means that both `isValidDim` and `isValidSymbol` must be false, or `value.getType().isIndex()` is true, but then `isValidSymbol` must be false too or `isValidDim(value, region)` wouldn't be false.\r\n\r\nOr, put differently, consider the following cases:\r\n\r\n- Assume `value.getType().isIndex()` is false, then both `isValidDim(value, region) || isValidSymbol(value, region)` are false.\r\n- Assume `value.getType().isIndex()` is true. Also assume `isValidDim` is false, then `isValidSymbol` must be false or `isValidDim` must be true which means that `isValidDim(value, region) || isValidSymbol(value, region)` must be true.\r\n\r\nIn all cases, `isValidDim(value, region) || isValidSymbol(value, region)` is equivalent to `isValidDim(value, region)`.", "feature_layers": ["ir", "ast"], "feature_directives": ["parallel", "for"], "files_changed": [{"filename": "mlir/lib/Dialect/Affine/IR/AffineOps.cpp", "functions": ["isValidAffineIndexOperand", "isValidDim"]}]}
{"pr_number": 74767, "url": "https://github.com/llvm/llvm-project/pull/74767", "title": " [clang][NFC] Refactor expected directives in C++ DRs 700-1999", "body": "This patch continues the work started with ea5b1ef016d020c37f903d6c7d4f623be975dab8. See that commit and its corresponding PR for details.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CXX/drs/dr10xx.cpp", "functions": ["g", "f"]}, {"filename": "clang/test/CXX/drs/dr11xx.cpp", "functions": ["set"]}, {"filename": "clang/test/CXX/drs/dr12xx.cpp", "functions": ["g", "e", "k", "b"]}, {"filename": "clang/test/CXX/drs/dr13xx.cpp", "functions": ["B", "x", "a", "f", "e", "d", "c", "b"]}, {"filename": "clang/test/CXX/drs/dr14xx.cpp", "functions": ["b2", "g2", "f", "g1", "f1", "f2"]}, {"filename": "clang/test/CXX/drs/dr15xx.cpp", "functions": ["x", "__typeof", "Eat", "f1", "D", "f2", "Z0", "GenericMoveOnly", "B", "f", "g0", "h", "Z", "k", "g1", "A", "g2", "f0", "C"]}, {"filename": "clang/test/CXX/drs/dr16xx.cpp", "functions": ["g", "A", "a", "f", "T", "b"]}, {"filename": "clang/test/CXX/drs/dr17xx.cpp", "functions": ["e", "l", "E", "s"]}, {"filename": "clang/test/CXX/drs/dr18xx.cpp", "functions": ["f"]}, {"filename": "clang/test/CXX/drs/dr19xx.cpp", "functions": ["b2", "B", "new", "a", "h", "b"]}, {"filename": "clang/test/CXX/drs/dr412.cpp", "functions": ["new", "delete"]}, {"filename": "clang/test/CXX/drs/dr7xx.cpp", "functions": ["f"]}, {"filename": "clang/test/CXX/drs/dr8xx.cpp", "functions": ["f"]}]}
{"pr_number": 73119, "url": "https://github.com/llvm/llvm-project/pull/73119", "title": "[clang-tidy] Add check hicpp-ignored-remove-result", "body": "This check implements the [rule 17.5.1](https://www.perforce.com/resources/qac/high-integrity-cpp-coding-standard/standard-library) of the HICPP standard which states:\r\n\r\n- Do not ignore the result of std::remove, std::remove_if or std::unique\r\n\r\n  The mutating algorithms std::remove, std::remove_if and both overloads of std::unique operate by swapping or moving elements of the range they are operating over. On completion, they return an iterator to the last valid element. In the majority of cases the correct behavior is to use this result as the first operand in a call to std::erase.\r\n\r\nThis check is based on `bugprone-unused-return-value` but with a fixed set of functions.\r\n\r\nSuppressing issues by casting to `void` is enabled by default, but can be disabled by setting `AllowCastToVoid` option to `false`.", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang-tools-extra/clang-tidy/hicpp/HICPPTidyModule.cpp", "functions": ["getModuleOptions"]}, {"filename": "clang-tools-extra/test/clang-tidy/checkers/hicpp/ignored-remove-result.cpp", "functions": ["optionalWarning", "errorFunc"]}, {"filename": "clang-tools-extra/clang-tidy/bugprone/UnusedReturnValueCheck.cpp", "functions": ["ClangTidyCheck", "UnusedReturnValueCheck"]}]}
{"pr_number": 74317, "url": "https://github.com/llvm/llvm-project/pull/74317", "title": "[InstCombine] Generalize folds for inversion of icmp operands", "body": "We have a bunch of folds that basically perform X pred Y to ~Y pred ~X for various special cases where this saves an instruction.\r\n\r\nGeneralize these folds to use isFreeToInvert(). We have to make sure that we consume an instruction in either of the inversions, otherwise we're just going to swap the icmp back and forth.\r\n\r\nFixes https://github.com/llvm/llvm-project/issues/74302.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp", "functions": ["ICmpInst"]}]}
{"pr_number": 74422, "url": "https://github.com/llvm/llvm-project/pull/74422", "title": "[AMDGPU] Fix GCNUpwardRPTracker: max register pressure on defs.", "body": "Treat a defined register as fully live \"at\" the instruction and update maximum pressure accordingly. \r\n\r\nFixes https://github.com/llvm/llvm-project/pull/73786. First part from https://github.com/llvm/llvm-project/pull/74328.\r\n\r\nTests will be presubmitted separately, please take a look at https://github.com/llvm/llvm-project/commit/6223a029b6800049c689a2468d0f8781447c14de for the diff.\r\n\r\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/GCNRegPressure.cpp", "functions": ["max"]}]}
{"pr_number": 74594, "url": "https://github.com/llvm/llvm-project/pull/74594", "title": "[Clang][SVE2p1]Add svboolx2 and svboolx4 types for svcreate, svget, s\u2026", "body": "\u2026vset\r\n\r\nAccording to the PR#257[1]\r\n\r\n[1]ARM-software/acle#257\r\n\r\nCo-authored by: Matthew Devereau <matthew.devereau@arm.com>", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_create2_bool.c", "functions": ["test_svcreate2_s8", "SVE_ACLE_FUNC"]}, {"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_create4_bool.c", "functions": ["test_svcreate4_b8", "SVE_ACLE_FUNC"]}, {"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_get2_bool.c", "functions": ["SVE_ACLE_FUNC", "test_svget2_b8_0", "test_svget2_b8_1"]}, {"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_get4_bool.c", "functions": ["test_svget4_b8_1", "test_svget4_b8_3", "SVE_ACLE_FUNC", "test_svget4_b8_0"]}, {"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_set2_bool.c", "functions": ["test_svset2_b8_1", "test_svset2_b8_0", "SVE_ACLE_FUNC"]}, {"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_set4_bool.c", "functions": ["test_svset4_b8_3", "test_svset4_b8_1", "SVE_ACLE_FUNC", "test_svset4_b8_0"]}, {"filename": "clang/test/Sema/aarch64-sve2p1-intrinsics/acle_sve2p1_imm.cpp", "functions": ["test_svget_svset_b", "test_svget_b"]}]}
{"pr_number": 74699, "url": "https://github.com/llvm/llvm-project/pull/74699", "title": "[Flang] [MLIR] [OpenMP] Add initial MLIR op support for OMP TARGET UPDATE directive", "body": "Add initial MLIR op support for OMP TARGET UPDATE directive. Motion clauses TO and FROM are not fully implemented in this patch.", "feature_layers": ["ir"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "mlir/lib/Dialect/OpenMP/IR/OpenMPDialect.cpp", "functions": ["success"]}]}
{"pr_number": 74789, "url": "https://github.com/llvm/llvm-project/pull/74789", "title": "[SystemZ] Simplify handling of AtomicRMW instructions.", "body": "Let the AtomicExpand pass do more of the job of expanding AtomicRMWInst:s in order to simplify the handling in the backend.\r\n\r\nThe only cases that the backend needs to handle itself are those of subword size (8/16 bits) and those directly corresponding to a target instruction.\r\n\r\nTests updated with some codegen changes for z10 that are hopefully ok. The min/max and nand tests are not run for later cpus and should also be relevant for them. One thing noted is that the IfConverter now fails to produce a CondReturn in the min/max tests. Some tests that seemed to test different immediate instructions now get a different codegen which should be correct,\r\neven though perhaps some of the testing done is now redundant.\r\n", "feature_layers": ["codegen", "ir"], "feature_directives": ["for", "atomic", "target"], "files_changed": [{"filename": "llvm/lib/Target/SystemZ/SystemZISelLowering.cpp", "functions": ["emitAtomicLoadBinary", "if", "emitAtomicLoadMinMax"]}]}
{"pr_number": 74720, "url": "https://github.com/llvm/llvm-project/pull/74720", "title": "[AArch64][SME2] Add builtins to cast svbool from/to svcount.", "body": "Add builtin: 'svreinterpret_b' to cast from svcount_t to svbool_t.\r\nAdd builtin: 'svreinterpret_c'  to cast from svbool_t  to svcount_t.\r\n\r\nPatch by: Hassnaa Hamdi <hassnaa.hamdi@arm.com>", "feature_layers": ["ast"], "feature_directives": [], "files_changed": [{"filename": "clang/test/CodeGen/aarch64-sme2-intrinsics/acle_sme2_reinterpret_svcount_svbool.c", "functions": ["SVE_ACLE_FUNC", "test_svreinterpret_svbool_svcnt", "test_svreinterpret_svcnt_svbool"]}]}
{"pr_number": 74787, "url": "https://github.com/llvm/llvm-project/pull/74787", "title": "[mlir][sparse] optimize memory loads to SSA values when generating sp\u2026", "body": "\u2026arse conv.", "feature_layers": ["parse", "ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/Transforms/LoopEmitter.cpp", "functions": ["ADDI", "genIndexLoad", "loadSlicePosPtr", "guard"]}]}
{"pr_number": 73065, "url": "https://github.com/llvm/llvm-project/pull/73065", "title": "[RISCV][GISEL] Legalize G_VAARG through expansion.", "body": "G_VAARG can be expanded similiar to SelectionDAG::expandVAArg through LegalizerHelper::lower. This patch implements the lowering through this style of expansion.\r\n\r\nThe expansion gets the head of the va_list by loading the pointer to va_list. Then, the head of the list is adjusted depending on argument alignment information. This gives a pointer to the element to be read out of the va_list. Next, the head of the va_list is bumped to the next element in the list. The new head of the list is stored back to the original pointer to the head of the va_list so that subsequent G_VAARG instructions get the next element in the list. Lastly, the element is loaded from the alignment adjusted pointer constructed earlier.\r\n\r\nThis change is stacked on #73062.", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp", "functions": ["A", "MA"]}]}
{"pr_number": 74020, "url": "https://github.com/llvm/llvm-project/pull/74020", "title": "Thread safety analysis: Fix a bug in handling temporary constructors", "body": "The commit 54bfd04846156dbd5e0a6b88f539c3d4569a455f introduces general handling of constructor and destructor calls.  Consider a pair of TEMPORARY constructor and destructor calls of a \"SCOPED_CAPABILITY\" object.  At the constructor call, a resource representing the object itself is added to the state.  But since it is a temporary object, the analyzer may not be able to find an AST part to identify the resource (As opposed to the normal case of using `VarDecl` as an identifier). Later at the destructor call, the resource needs to be removed from the state.  Since the resource cannot be identified by anything other than itself, the analyzer maintains a map from constructor calls to their created resources so that the analyzer could get the proper resource for removal at the destructor call via look up the map.  The issue is that the map lives within a CFG block.  That means in case the pair of temporary constructor and destructor calls are not in one CFG block, the analyzer is not able to remove the proper resource at the destructor call.  Although the two calls stay in one CFG block usually, they separate in the following example:\r\n\r\n```\r\nif (f(MutexLock{lock}) || x) { // <-- the temporary Ctor and Dtor of MutexLock are in different CFG blocks\r\n\r\n}\r\n```\r\n\r\nThe fix is simple. It extends the life of the map to that of the entire CFG.", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/SemaCXX/warn-thread-safety-analysis.cpp", "functions": ["temporary_cfg", "lock2Bool"]}]}
{"pr_number": 74761, "url": "https://github.com/llvm/llvm-project/pull/74761", "title": "[VPlan] Initial modeling of VF * UF as VPValue.", "body": "This patch starts initial modeling of VF * UF in VPlan.\r\nInitially, introduce a dedicated VFxUF VPValue, which is then\r\npopulated during VPlan::prepareToExecute. Initially, the VF * UF\r\napplies only to the main vector loop region. Once we extend the\r\nscope of VPlan in the future, we may want to associate different VFxUFs\r\nwith different vector loop regions (e.g. the epilogue vector loop)\r\n\r\nThis allows explicitly parameterizing recipes that rely on the\r\nVF * UF, like the canonical induction increment. At the moment, this\r\nmainly helps to avoid generating some duplicated calls to vscale with\r\nscalable vectors. It should also allow using EVL as induction increments\r\nexplicitly in D99750. Referring to VF * UF is also needed in other\r\nplaces that we plan to migrate to VPlan, like the minimum trip count\r\ncheck during skeleton creation.\r\n\r\nThe first version creates the value for VF * UF directly in\r\nprepareToExecute to limit the scope of the patch. A follow-on patch will\r\nmodel VF * UF computation explicitly in VPlan using recipes.\r\n\r\nMoved from Phabricator (https://reviews.llvm.org/D157322)\r\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp", "functions": ["Guard"]}]}
{"pr_number": 73066, "url": "https://github.com/llvm/llvm-project/pull/73066", "title": "[GISEL][RISCV] Legalize llvm.vacopy intrinsic", "body": "In the future, we can consider adding a G_VACOPY opcode instead of going\r\nthrough the GIntrinsic for all targets. We do the approach in this patch because\r\nthat is what other targets do today.", "feature_layers": [], "feature_directives": ["for", "target"], "files_changed": [{"filename": "llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp", "functions": ["lowerVACopy"]}]}
{"pr_number": 73826, "url": "https://github.com/llvm/llvm-project/pull/73826", "title": "[mlir][mesh] Use tensor shape notation for the shape of a cluster", "body": "Examle:\r\n\r\nsubstitute\r\n```\r\nmesh.cluster @mesh0(rank = 2, dim_sizes = [0, 4])\r\n```\r\n\r\nwith\r\n```\r\nmesh.cluster @mesh0(rank = 2, dim_sizes = ?x4)\r\n```\r\n\r\nThe only difference is for 0-rank shapes.\r\nWith tensors you would have something like `tensor<f32>`. Here to avoid matching an empty string a 0-rank shape is denoted by `[]`.\r\n\r\n-----\r\n\r\nI am not quite happy with the 0-rank special case. An alternative is to use the same notation as arrays but handle `?` for dynamic dimensions. For example `[1, 2, ?]`. But then it would be different from the notation of the `tensor` type.\r\n\r\nI wanted to rename the attribute `dim_sizes` to `shape`, but did not do that in this PR to avoid clutter.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Mesh/IR/MeshOps.cpp", "functions": ["isMeshDimensionDynamic"]}, {"filename": "mlir/lib/IR/BuiltinAttributes.cpp", "functions": ["success"]}, {"filename": "mlir/lib/IR/AsmPrinter.cpp", "functions": ["success"]}]}
{"pr_number": 74892, "url": "https://github.com/llvm/llvm-project/pull/74892", "title": "[clang] NFCI: Make `ModuleFile::File` non-optional", "body": "AFAICT, `ModuleFile::File` can be `std::nullopt` only for PCM files loaded from the standard input. This patch starts setting that variable to `FileManager::getSTDIN()` in that case, which makes it possible to remove the optionality, and also simplifies code that actually reads the file.\r\n\r\nThis is part of an effort to get rid of `Optional{File,Directory}EntryRefDegradesTo{File,Directory}EntryPtr`.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Serialization/ModuleManager.cpp", "functions": ["Buf"]}]}
{"pr_number": 74850, "url": "https://github.com/llvm/llvm-project/pull/74850", "title": "[mlir][Pass] Move PassExecutionAction to Pass.h, NFC.", "body": "This patch moves PassExecutionAction to Pass.h so that it can be used by the action framework to introspect and intercede in pass managers that might be set up opaquely. This provides for a very particular use case, which essentially involves being able to intercede in a PassManager and skip or apply individual passes. Because of this, this patch also adds a test for this use case to verify that it could in fact work.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Pass/Pass.cpp", "functions": ["Base"]}, {"filename": "mlir/unittests/Pass/PassManagerTest.cpp", "functions": ["builder", "runOnOperation", "module", "executionCtx"]}]}
{"pr_number": 74921, "url": "https://github.com/llvm/llvm-project/pull/74921", "title": "[clang][NFC] Refactor expected directives in C++ DRs 2000-2799", "body": "This patch continues the work started with ea5b1ef016d020c37f903d6c7d4f623be975dab8. See that commit and its corresponding PR for details.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CXX/drs/dr20xx.cpp", "functions": ["bar", "foo"]}, {"filename": "clang/test/CXX/drs/dr21xx.cpp", "functions": ["int"]}, {"filename": "clang/test/CXX/drs/dr2354.cpp", "functions": ["alignas"]}, {"filename": "clang/test/CXX/drs/dr23xx.cpp", "functions": ["alignas", "wrong_value"]}, {"filename": "clang/test/CXX/drs/dr2406.cpp", "functions": ["g", "fallthrough"]}, {"filename": "clang/test/CXX/drs/dr24xx.cpp", "functions": ["g", "fallthrough"]}, {"filename": "clang/test/CXX/drs/dr25xx.cpp", "functions": ["g", "f"]}, {"filename": "clang/test/CXX/drs/dr26xx.cpp", "functions": ["foo", "f"]}]}
{"pr_number": 74762, "url": "https://github.com/llvm/llvm-project/pull/74762", "title": "[VPlan] Compute scalable VF in preheader for induction increment.", "body": "UF * VF is loop invariant and can be computed directly in the preheader.\nThis prepares the code for #74333 and reduces the test changes.\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp", "functions": ["Guard"]}]}
{"pr_number": 74932, "url": "https://github.com/llvm/llvm-project/pull/74932", "title": "[clang] Fix '__cdecl' CC is not supported for this target", "body": "Fixes regression introduced in b3e6ff331925dde24a4707452d657da0fdf7f588\r\n\r\n    .---command stderr------------\r\n    | error: 'supported-warning' diagnostics seen but not expected:\r\n    |   File C:\\buildbot\\as-builder-1\\x-armv7l\\llvm-project\\clang\\test\\SemaCXX\\ms-constexpr-new.cpp Line 7: '__cdecl' calling convention is not supported for this target\r\n    | 1 error generated.\r\n    `-----------------------------", "feature_layers": ["sema"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "clang/test/SemaCXX/ms-constexpr-new.cpp", "functions": ["new"]}]}
{"pr_number": 74815, "url": "https://github.com/llvm/llvm-project/pull/74815", "title": "[VP][RISCV] Introduce llvm.experimental.vp.compress/expand and RISC-V support.", "body": "This patch introduces llvm.experimental.vp.compress/expand which are similar to llvm.masked.compressstore/expandload but have evl operand and reads/writes to vectors instead of memory.\r\nThis patch does not support DAG nodes for llvm.experimental.vp.compress/expand, since it may be impossible for DAG to split and expand them.", "feature_layers": [], "feature_directives": ["for", "masked"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVISelLowering.cpp", "functions": ["lowerVPExpandExperimental", "convertFromScalableVector", "lowerVPCompressExperimental", "DL"]}]}
{"pr_number": 74492, "url": "https://github.com/llvm/llvm-project/pull/74492", "title": "[GISel][TableGen] Fix accidental operand name clashes in patterns", "body": "When importing instruction selection patterns into GlobalISel, the operands matched in the \"source\" DAG are copied into corresponding operands of the \"destination\" DAG according to their names (such as Rd). If multiple operands in the source DAG share the same name, a GIM_CheckIsSameOperand predicate makes instruction selector check the corresponding operands for equality (at compiler run-time) as part of matching the source pattern.\r\n\r\nThe Def operands of the root node of the destination DAG are handled specially. The operands of the instruction corresponding to the root node are taken and GIM_CheckRegBankForClass predicates are tablegen-erated accordingly. If by coincidence the Def operand in question has the same name as one of the named operands in the pattern, a GIM_CheckIsSameOperand predicate is automatically added that is likely to prevent matching the source of otherwise applicable selection pattern at compiler run-time.\r\n\r\nThis patch mangles the Def operand names taken from the instruction corresponding to the root of the destination DAG (for example, \"Rd\" becomes \"DstI[Rd]\") preventing unexpected name clashes with pattern's named operands.\r\n\r\nThe patch consists of three sets of changes:\r\n* changes to the GlobalISelEmitter.cpp file are the actual fix\r\n* a test case is added to GlobalISelEmitter.td file as a regression test\r\n* everything else is the biggest and least interesting part - updates to the existing test cases: renames of the form Rd -> DstI[Rd] inside the inline comments in tablegen-erated code", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/utils/TableGen/GlobalISelEmitter.cpp", "functions": ["if", "getMangledRootDefName"]}]}
{"pr_number": 74904, "url": "https://github.com/llvm/llvm-project/pull/74904", "title": "[CodeGen] Port `InterleavedAccess` to new pass manager", "body": "", "feature_layers": ["codegen"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/CodeGen/InterleavedAccessPass.cpp", "functions": ["Impl", "getPassName", "getAnalysisUsage", "runOnFunction", "DT"]}]}
{"pr_number": 74962, "url": "https://github.com/llvm/llvm-project/pull/74962", "title": "[libc++][test] Fix MSVC warnings with `static_cast`s", "body": "Found while running libc++'s tests with MSVC's STL.\r\n\r\n* `libcxx/test/std/algorithms/alg.modifying.operations/alg.unique/ranges_unique_copy.pass.cpp`\r\n  + Fix MSVC \"warning C4389: '`==`': signed/unsigned mismatch\".\r\n  + This was x86-specific for me. The LHS is `int` and the RHS is `size_t`. We know the `array`'s size, so `static_cast<int>` is certainly safe, and this matches the following `numberOfProj` comparisons.\r\n* `libcxx/test/std/containers/sequences/insert_range_sequence_containers.h`\r\n  + Fix MSVC \"warning C4267: 'argument': conversion from '`size_t`' to '`const int`', possible loss of data\".\r\n  + `test_case.index` is `size_t`: https://github.com/llvm/llvm-project/blob/b85f1f9b182234ba366d78ae2174a149e44d08c1/libcxx/test/std/containers/insert_range_helpers.h#L65-L68\r\n  + But the container's `difference_type` is `int`: https://github.com/llvm/llvm-project/blob/b85f1f9b182234ba366d78ae2174a149e44d08c1/libcxx/test/support/test_allocator.h#L65-L76\r\n  + I introduced an alias `D` to make the long line more readable.\r\n* `libcxx/test/std/containers/unord/unord.map/eq.different_hash.pass.cpp`\r\n* `libcxx/test/std/containers/unord/unord.multimap/eq.different_hash.pass.cpp`\r\n* `libcxx/test/std/containers/unord/unord.multiset/eq.different_hash.pass.cpp`\r\n* `libcxx/test/std/containers/unord/unord.set/eq.different_hash.pass.cpp`\r\n  + Fix MSVC \"warning C6297: Arithmetic overflow.  Results might not be an expected value.\"\r\n  + This warning is almost annoying enough to outright disable, but we use similar `static_cast`s to deal with sign/truncation warnings elsewhere, because there's some value in ensuring that product code is clean with respect to these warnings. If there were many more occurrences, then disabling the warning would be appropriate.\r\n  + Cleanup: Change 2 inconsistently unqualified occurrences of `size_t` to `std::size_t`.\r\n* `libcxx/test/std/containers/views/mdspan/layout_stride/index_operator.pass.cpp`\r\n  + Fix MSVC \"warning C4244: 'initializing': conversion from '`__int64`' to '`size_t`', possible loss of data\".\r\n  + This was x86-specific for me. The `args` are indeed `int64_t`, and we're storing the result in `size_t`, so we should cast.\r\n* `libcxx/test/std/ranges/range.utility/range.utility.conv/container.h`\r\n  + Fix MSVC \"warning C4244: 'initializing': conversion from '`ptrdiff_t`' to '`int`', possible loss of data\".\r\n  + Fix MSVC \"warning C4267: 'initializing': conversion from '`size_t`' to '`int`', possible loss of data\".\r\n  + We're initializing `int size_`, so we should explicitly cast from pointer subtraction and `std::ranges::size`.\r\n* `libcxx/test/std/utilities/memory/util.smartptr/util.smartptr.shared/util.smartptr.shared.create/allocate_shared_for_overwrite.pass.cpp`\r\n* `libcxx/test/std/utilities/memory/util.smartptr/util.smartptr.shared/util.smartptr.shared.create/make_shared_for_overwrite.pass.cpp`\r\n* `libcxx/test/std/utilities/smartptr/unique.ptr/unique.ptr.create/make_unique_for_overwrite.default_init.pass.cpp`\r\n  + Fix MSVC \"warning C4309: 'initializing': truncation of constant value\".\r\n  + MSVC emits this warning because `0xDE` is outside the range of `char` (signed by default in our implementation).\r\n* `libcxx/test/support/concat_macros.h`\r\n  + Fix MSVC \"warning C4244: 'argument': conversion from '`char16_t`' to '`const char`', possible loss of data\".\r\n  + Fix MSVC \"warning C4244: 'argument': conversion from '`unsigned int`' to '`const char`', possible loss of data\".\r\n  + This code was very recently introduced by @mordante in #73395.\r\n", "feature_layers": ["ast"], "feature_directives": ["for", "allocate"], "files_changed": [{"filename": "libcxx/test/std/containers/unord/unord.set/eq.different_hash.pass.cpp", "functions": ["hash_scale", "hash_even"]}]}
{"pr_number": 74965, "url": "https://github.com/llvm/llvm-project/pull/74965", "title": "[libc++][test] Fix more MSVC and Clang warnings", "body": "Found while running libc++'s tests with MSVC's STL.\r\n\r\nAs usual, I'm trying to strike a balance between avoiding \"grab bag\" PRs and creating a trillion PRs. After gathering the `static_cast` warning fixes in #74962, I believe that these changes are small enough to group together. Please let me know if you'd like me to decompose this further.\r\n\r\n* `libcxx/test/std/algorithms/alg.sorting/alg.heap.operations/sort.heap/ranges_sort_heap.pass.cpp`\r\n  + Fix Clang `-Wunused-variable`, because `LIBCPP_ASSERT` expands to nothing for MSVC's STL.\r\n  + This is the same \"always void-cast\" change that #73437 applied to the neighboring `complexity.pass.cpp`. I missed that `ranges_sort_heap.pass.cpp` was also affected because we had disabled this test.\r\n* `libcxx/test/std/input.output/file.streams/fstreams/ifstream.members/buffered_reads.pass.cpp`\r\n* `libcxx/test/std/input.output/file.streams/fstreams/ofstream.members/buffered_writes.pass.cpp`\r\n  + Fix MSVC \"warning C4244: '`=`': conversion from '`__int64`' to '`_Ty`', possible loss of data\".\r\n  + This is a valid warning, possibly the best one that MSVC found in this entire saga. We're accumulating a `std::vector<std::streamsize>` and storing the result in `std::streamsize total_size` but we actually have to start with `std::streamsize{0}` or we'll truncate.\r\n* `libcxx/test/std/input.output/filesystems/fs.enum/enum.path.format.pass.cpp`\r\n  + Fix Clang `-Wunused-local-typedef` because the following usage is libc++-only.\r\n  + I'm just expanding it at the point of use, and using the dedicated `LIBCPP_STATIC_ASSERT` to keep the line length down.\r\n* `libcxx/test/std/input.output/syncstream/syncbuf/syncstream.syncbuf.assign/swap.pass.cpp`\r\n  + Fix MSVC \"warning C4242: 'argument': conversion from '`int`' to '`const _Elem`', possible loss of data\".\r\n  + This is a valid warning (possibly the second-best) as `sputc()` returns `int_type`. If `sputc()` returns something unexpected, we want to know, so we should separately say `expected.push_back(CharT('B'))`.\r\n* `libcxx/test/std/language.support/support.dynamic/new.delete/new.delete.single/new.size_align_nothrow.pass.cpp`\r\n* `libcxx/test/std/language.support/support.dynamic/new.delete/new.delete.single/new.size_nothrow.pass.cpp`\r\n  + Fix MSVC \"warning C6001: Using uninitialized memory '`x`'.\"\r\n  + [N4964](https://wg21.link/N4964) \\[new.delete.single\\]/12:\r\n    > *Effects:* The deallocation functions (\\[basic.stc.dynamic.deallocation\\]) called by a *delete-expression* (\\[expr.delete\\]) to render the value of `ptr` invalid.\r\n  + \\[basic.stc.general\\]/4:\r\n    > When the end of the duration of a region of storage is reached, the values of all pointers representing the address of any part of that region of storage become invalid pointer values (\\[basic.compound\\]). Indirection through an invalid pointer value and passing an invalid pointer value to a deallocation function have undefined behavior. Any other use of an invalid pointer value has implementation-defined behavior.\r\n  + In certain configurations, after `delete x;` MSVC will consider `x` to be radioactive (and in other configurations, it'll physically null out `x` as a safety measure). We can copy it into `old_x` before deletion, which the implementation finds acceptable.\r\n* `libcxx/test/std/ranges/range.adaptors/range.elements/general.pass.cpp`\r\n* `libcxx/test/std/ranges/range.adaptors/range.elements/iterator/deref.pass.cpp`\r\n  + Fix MSVC \"warning C4242: 'initializing': conversion from '`_Ty`' to '`_Ty`', possible loss of data\".\r\n  + This was being emitted in `pair` and `tuple`'s perfect forwarding constructors. Passing `short{1}` allows MSVC to see that no truncation is happening.\r\n* `libcxx/test/std/ranges/range.adaptors/range.elements/iterator/member_types.compile.pass.cpp`\r\n  + Fix MSVC \"warning C4242: 'initializing': conversion from '`_Ty`' to '`_Ty2`', possible loss of data\".\r\n  + Similarly, this was being emitted in `pair`'s perfect forwarding constructor. After passing `short{1}`, I reduced repetition by relying on CTAD. (I can undo that cleanup if it's stylistically undesirable.)\r\n* `libcxx/test/std/utilities/function.objects/refwrap/refwrap.const/type_conv_ctor.pass.cpp`\r\n  + Fix MSVC \"warning C4930: '`std::reference_wrapper<int> purr(void)`': prototyped function not called (was a variable definition intended?)\".\r\n  + There's no reason for `purr()` to be locally declared (aside from isolating it to a narrow scope, which has minimal benefits); it can be declared like `meow()` above. :smile_cat:\r\n* `libcxx/test/std/utilities/memory/util.smartptr/util.smartptr.shared/util.smartptr.shared.create/make_shared_for_overwrite.pass.cpp`\r\n* `libcxx/test/std/utilities/smartptr/unique.ptr/unique.ptr.create/make_unique_for_overwrite.default_init.pass.cpp`\r\n  + Fix MSVC static analysis warnings when replacing `operator new`:\r\n    ```\r\n    warning C28196: The requirement that '(_Param_(1)>0)?(return!=0):(1)' is not satisfied. (The expression does not evaluate to true.)\r\n    warning C6387: 'return' could be '0':  this does not adhere to the specification for the function 'new'.\r\n    warning C6011: Dereferencing NULL pointer 'reinterpret_cast<char *>ptr+i'.\r\n    ```\r\n  + All we need is a null check, which appears in other `operator new` replacements: https://github.com/llvm/llvm-project/blob/b85f1f9b182234ba366d78ae2174a149e44d08c1/libcxx/test/std/language.support/support.dynamic/new.delete/new.delete.single/new.size.replace.pass.cpp#L27-L28\r\n", "feature_layers": ["ir", "ast"], "feature_directives": ["for", "single", "declare"], "files_changed": [{"filename": "libcxx/test/std/utilities/function.objects/refwrap/refwrap.const/type_conv_ctor.pass.cpp", "functions": ["main"]}]}
{"pr_number": 74970, "url": "https://github.com/llvm/llvm-project/pull/74970", "title": "[NFC][InstrProf] Refactor InstrProfiling lowering pass", "body": "Akin other passes - refactored the name to `InstrProfilingLoweringPass` to better communicate what it does, and split the pass part and the transformation part to avoid needing to initialize object state during `::run`.\r\n\r\nA subsequent PR will move `InstrLowering` to the .cpp file and rename it to `InstrLowerer`.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp", "functions": ["DB", "Lowerer", "GlobalVariable", "IRB"]}]}
{"pr_number": 74350, "url": "https://github.com/llvm/llvm-project/pull/74350", "title": "[MLIR][SCF] Add support for pipelining dynamic loops", "body": "Support loops without static boundaries. Since the number of iteration is not known we need to predicate prologue and epilogue in case the number of iterations is smaller than the number of stages.\r\n\r\nThis patch includes work from @chengjunlu", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/SCF/Transforms/LoopPipelining.cpp", "functions": ["predicates"]}]}
{"pr_number": 74773, "url": "https://github.com/llvm/llvm-project/pull/74773", "title": "[SymbolFileDWARF][NFC] Remove duplicated code checking for type tags", "body": "There was duplicated (and complex) code querying whether tags were type-like tags (i.e. class or struct); this has been factored out into a helper function.\r\n\r\nThere was also a comment about not comparing identical DIEs without ever performing that check; this comment has been removed. It was likely a result of copy paste from another function in this same file which actually does that check.", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "lldb/source/Plugins/SymbolFile/DWARF/SymbolFileDWARF.cpp", "functions": ["IsTypeTag", "IsStructOrClassTag"]}]}
{"pr_number": 74999, "url": "https://github.com/llvm/llvm-project/pull/74999", "title": "[BPF][GlobalISel] add initial gisel support for BPF", "body": "This adds initial codegen support for BPF backend.\r\n\r\nOnly implemented ir-translator for \"RET\" (but not support isel).\r\n\r\nDepends on: #74998", "feature_layers": ["codegen", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/BPF/BPFTargetMachine.cpp", "functions": ["addGlobalInstructionSelect", "addLegalizeMachineIR", "addRegBankSelect", "addIRTranslator"]}, {"filename": "llvm/lib/Target/BPF/GISel/BPFCallLowering.cpp", "functions": ["CallLowering"]}, {"filename": "llvm/lib/Target/BPF/GISel/BPFInstructionSelector.cpp", "functions": ["select", "BPFInstructionSelector", "TII", "selectImpl"]}, {"filename": "llvm/lib/Target/BPF/GISel/BPFRegisterBankInfo.cpp", "functions": ["BPFGenRegisterBankInfo"]}]}
{"pr_number": 72863, "url": "https://github.com/llvm/llvm-project/pull/72863", "title": "[Clang][Sema] Diagnose friend function specialization definitions", "body": "Per [[class.friend]p6](http://eel.is/c++draft/class.friend#6) a friend function shall not be defined if its name isn't unqualified. A _template-id_ is not a name, meaning that a friend function specialization does not meet this criteria and cannot be defined. \r\n\r\nGCC, MSVC, and EDG all consider friend function specialization definitions to be invalid de facto explicit specializations and diagnose them as such. \r\n\r\nInstantiating a dependent friend function specialization definition [currently sets off an assert](https://godbolt.org/z/Krqdq95hY) in `FunctionDecl::setFunctionTemplateSpecialization`. This happens because we do not set the `TemplateSpecializationKind` of the `FunctionDecl` created by template argument deduction to `TSK_ExplicitSpecialization` for friend functions [here](https://github.com/llvm/llvm-project/blob/main/clang/lib/Sema/SemaTemplate.cpp#L9600). I changed the assert condition because I believe this is the correct behavior. \r\n", "feature_layers": ["sema"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CXX/class.access/class.friend/p6.cpp", "functions": ["f3", "f4"]}]}
{"pr_number": 74879, "url": "https://github.com/llvm/llvm-project/pull/74879", "title": "[Profile] Disable continuous mode when reset to default.profraw due to malformed LLVM_PROFILE_FILE.", "body": "When LLVM_PROFILE_FILE is set incorrectly (e.g. multiple %c) and it falls back to use `default.profraw` name, but continuous mode is still set. This might cause signal bus in the following scenario.\r\n\r\nLLVM_PROFILE_FILE is set incorrectly (with \"%c%c\") for process A and B. Suppose A starts first and falls back to use `default.profraw` and mmaped its file content to memory.  Later B starts and also falls back to use `default.profraw`, but it will truncate the file because online merging is disable when reseting to `default.profraw`. When A tries to update counter via mmaped memory, signal bus will occur.\r\n\r\nThis fixes it by disabling continuous mode when reset to default.profraw. ", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "compiler-rt/lib/profile/InstrProfilingBuffer.c", "functions": ["__llvm_profile_disable_continuous_mode"]}, {"filename": "compiler-rt/test/profile/ContinuousSyncMode/reset-default-profile.c", "functions": ["main", "f"]}]}
{"pr_number": 75037, "url": "https://github.com/llvm/llvm-project/pull/75037", "title": "[libc][NFC] Fix mixed up biased/unbiased exponent", "body": "According to [wikipedia](https://en.wikipedia.org/wiki/Exponent_bias) the \"biased exponent\" is the encoded form that is always positive whereas the unbiased form is the actual \"real\" exponent that can be positive or negative.\n`FPBits` seems to be using `unbiased_exponent` to describe the encoded form (unsigned). This patch simply use `biased` instead of `unbiased`.\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "libc/src/math/generic/powf.cpp", "functions": ["DoubleBits"]}]}
{"pr_number": 73915, "url": "https://github.com/llvm/llvm-project/pull/73915", "title": "[mlir][vector] Make `TransposeOpLowering` configurable", "body": "Following the discussion here:\r\n\r\n  * https://github.com/llvm/llvm-project/pull/72105\r\n\r\nthis patch makes the `TransposeOpLowering` configurable so that one can select\r\nwhether to favour `vector.shape_cast` over `vector.transpose`.\r\n\r\nAs per the discussion in #72105, using `vector.shape_cast` is very beneficial\r\nand desirable when targeting `LLVM IR` (CPU lowering), but won't work when\r\ntargeting `SPIR-V` today (GPU lowering). Hence the need for a mechanism to be\r\nable to disable/enable the pattern introduced in #72105. This patch proposes one\r\nsuch mechanism.\r\n\r\nWhile this should solve the problem that we are facing today, it's understood to\r\nbe a temporary workaround. It should be removed once support for lowering\r\n`vector.shape_cast` to SPIR-V is added. Also, (once implemented) the following\r\nproposal might make this workaround redundant:\r\n\r\n  * https://discourse.llvm.org/t/improving-handling-of-unit-dimensions-in-the-vector-dialect/\r\n", "feature_layers": ["ir", "ast"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "mlir/lib/Dialect/Vector/Transforms/LowerVectorTranspose.cpp", "functions": ["success"]}]}
{"pr_number": 72827, "url": "https://github.com/llvm/llvm-project/pull/72827", "title": "[AArch64][SME2] Add PEXT, PSEL builtins for SME2", "body": "This change enables PEXT, PSEL builtins for SME2 target.", "feature_layers": [], "feature_directives": ["for", "target"], "files_changed": [{"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_pext.c", "functions": ["test_svpext_lane_c32_0", "test_svpext_lane_c64_x2_1", "test_svpext_lane_c16_3", "test_svpext_lane_c16_x2_0", "test_svpext_lane_c64_3", "test_svpext_lane_c16_0", "test_svpext_lane_c32_3", "test_svpext_lane_c8_x2_0", "test_svpext_lane_c16_x2_1", "test_svpext_lane_c8_x2_1", "test_svpext_lane_c32_x2_0", "test_svpext_lane_c64_x2_0", "test_svpext_lane_c32_x2_1", "test_svpext_lane_c8_0", "test_svpext_lane_c8_3", "test_svpext_lane_c64_0"]}, {"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_psel.c", "functions": ["test_svpsel_lane_b16", "test_svpsel_lane_b8", "test_svpsel_lane_c16", "test_svpsel_lane_c32", "test_svpsel_lane_b64", "test_svpsel_lane_b32", "test_svpsel_lane_c8", "test_svpsel_lane_c64"]}]}
{"pr_number": 75032, "url": "https://github.com/llvm/llvm-project/pull/75032", "title": "[mlir][CAPI] Add mlirOpOperandGetValue", "body": "", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/CAPI/IR/IR.cpp", "functions": ["mlirOpOperandGetValue", "wrap"]}]}
{"pr_number": 74898, "url": "https://github.com/llvm/llvm-project/pull/74898", "title": "[mlir][sparse] fix bug in custom reduction scalarization code", "body": "Bug found with BSR of \"spy\" SDDMM method", "feature_layers": ["parse", "ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/Transforms/Sparsification.cpp", "functions": ["genTensorLoad"]}]}
{"pr_number": 73257, "url": "https://github.com/llvm/llvm-project/pull/73257", "title": "[llvm-c] Expose debug support for LLJIT in Orc C-API bindings", "body": "Allow C-API users to debug their JITed code. The new API function `LLVMOrcObjectLayerRegisterPluginJITLoaderGDB()` adds the required plugin to provide GDB JIT Interface support. This initial patch covers the ELF use-case by installing the DebugObjectManagerPlugin. It should be easy to add support for other object formats later on.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/ExecutionEngine/Orc/OrcV2CBindings.cpp", "functions": ["LLVMOrcLLJITEnableDebugSupport", "wrap"]}, {"filename": "llvm/unittests/ExecutionEngine/Orc/OrcCAPITest.cpp", "functions": ["linkComponents"]}, {"filename": "llvm/lib/ExecutionEngine/Orc/Debugging/LLJITUtilsCBindings.cpp", "functions": ["LLVMOrcLLJITEnableDebugSupport", "wrap"]}]}
{"pr_number": 74158, "url": "https://github.com/llvm/llvm-project/pull/74158", "title": "[flang] Correct definability checking for INTENT(IN) pointers", "body": "An INTENT(IN) attribute on a pointer dummy argument prevents modification of the pointer itself only, not modification of any component of its target.  Fix this case without breaking definability checking for pointer components of non-pointer INTENT(IN) dummy arguments.", "feature_layers": [], "feature_directives": ["for", "target"], "files_changed": [{"filename": "flang/lib/Semantics/definable.cpp", "functions": ["WhyNotDefinableBase", "WhyNotDefinableLast"]}]}
{"pr_number": 74621, "url": "https://github.com/llvm/llvm-project/pull/74621", "title": "[flang][runtime] Delete CharacterAssign()", "body": "Lowering doesn't use it, and won't need it in the future; it emits in-line code for conversions and for assignments to scalars, and uses the general Assign() routine for arrays.", "feature_layers": ["runtime"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/runtime/character.cpp", "functions": ["RTNAME"]}]}
{"pr_number": 74683, "url": "https://github.com/llvm/llvm-project/pull/74683", "title": "[flang][runtime] Fix fixed-width field internal wide character input", "body": "There was some confusion about units (bytes vs characters) in the handling of the amount of input remaining in fixed-width formatted input fields.  Clarify that any variable or parameter counting \"remaining\" space in a field in the I/O runtime is always in units of bytes, and make it so where it wasn't.\r\n\r\nFixes the bug(s) in llvm-test-suite/Fortran/gfortran/regression/char4_iunit_2.f03, although the test still won't pass due to its dependence on gfortran's list-directed output spacing.", "feature_layers": ["runtime", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/runtime/edit-input.cpp", "functions": ["EditListDirectedCharacterInput"]}]}
{"pr_number": 71862, "url": "https://github.com/llvm/llvm-project/pull/71862", "title": "[-Wunsafe-buffer-usage] Add FixableGadget for AddAssign in UnspecifiedUntypedContext", "body": "", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Analysis/UnsafeBufferUsage.cpp", "functions": ["FixableGadget"]}, {"filename": "clang/test/SemaCXX/warn-unsafe-buffer-usage-fixits-add-assign.cpp", "functions": ["expr_test", "add_assign_test"]}]}
{"pr_number": 74827, "url": "https://github.com/llvm/llvm-project/pull/74827", "title": "[NVPTX] Custom lower integer<->bf16 conversions for sm_80", "body": "sm_80 only has f32->bf16 conversions, the remaining integer conversions arrived with sm_90. Use a two-step conversion for sm_80.\r\n\r\nThere doesn't seem to be a way to express this promotion directly within the legalization framework, so fallback on Custom lowering.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp", "functions": ["LowerFP_TO_INT", "Loc", "LowerINT_TO_FP"]}]}
{"pr_number": 75049, "url": "https://github.com/llvm/llvm-project/pull/75049", "title": "[CodeGen] Port `JMCInstrumenter` to new pass manager", "body": "", "feature_layers": ["codegen"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/CodeGen/JMCInstrumenter.cpp", "functions": ["runImpl", "runOnModule"]}]}
{"pr_number": 74911, "url": "https://github.com/llvm/llvm-project/pull/74911", "title": "[X86] Handle ifuncs in TargetMachine::isLargeGlobalObject()", "body": "isLargeGlobalObject() didn't handle GlobalIFuncs, resulting in crashes.\r\n\r\nTreat ifuncs the same as normal Functions.\r\n", "feature_layers": [], "feature_directives": ["target"], "files_changed": [{"filename": "llvm/lib/Target/TargetMachine.cpp", "functions": ["getCodeModel"]}]}
{"pr_number": 68873, "url": "https://github.com/llvm/llvm-project/pull/68873", "title": "[AArch64] Fix tryMergeAdjacentSTG function in PrologEpilog pass", "body": "The tryMergeAdjacentSTG function tries to merge multiple stg/st2g/stg_loop instructions. It doesn't verify the liveness of NZCV flag before moving around STGloop which also alters NZCV flags. This was not issue before the patch 5e612bc291347d364f1d47c37f0d34eb6474b9b5 as these stack tag stores does not alter the NZCV flags. But after the change, this merge function leads to miscompilation because of control flow change in instructions. Added the check to to see if the first instruction after insert point reads or writes to NZCV flag and it's liveout state. This check happens after the filling of merge list just before merge and bails out if necessary.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AArch64/AArch64FrameLowering.cpp", "functions": ["LR", "LiveRegs"]}]}
{"pr_number": 66576, "url": "https://github.com/llvm/llvm-project/pull/66576", "title": "[libcxx] Allow string to use SSO in constant evaluation.", "body": "Previously, libcxx forced all strings created during constant evaluation to point to allocated memory. That was done due to implementation difficultites, but it turns out not to be necessary. This patch permits the use of SSO strings during constant evaluation, and also simplifies the implementation.\r\n\r\nThis does have a downside in terms of enabling users to accidentally write non-portable code, however, which I've documented in UsingLibcxx.rst.\r\n\r\nIn particular, whether `constinit std::string x = \"...\";` will successfully compile now depends on whether the string is smaller than the SSO capacity -- in libc++, up to 22 bytes on 64-bit platforms, and up to 10 bytes on 32-bit platforms. By comparison, libstdc++ and MSVC have an SSO capacity of 15 bytes, except that in libstdc++, constant-initialized strings cannot be used as function-locals because the object contains a pointer to itself.", "feature_layers": [], "feature_directives": ["for", "allocate"], "files_changed": [{"filename": "libcxx/test/libcxx/strings/basic.string/string.cons/constinit_sso_string.compile.pass.cpp", "functions": ["fn"]}, {"filename": "libcxx/test/std/utilities/template.bitset/bitset.members/to_string.pass.cpp", "functions": ["test_to_string_wchar"]}]}
{"pr_number": 74956, "url": "https://github.com/llvm/llvm-project/pull/74956", "title": "[llvm] Use StringRef::{starts,ends}_with (NFC)", "body": "This patch replaces uses of StringRef::{starts,ends}with with\nStringRef::{starts,ends}_with for consistency with\nstd::{string,string_view}::{starts,ends}_with in C++20.\n\nI'm planning to deprecate and eventually remove\nStringRef::{starts,ends}with.\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/ExecutionEngine/Orc/IndirectionUtils.cpp", "functions": ["if"]}, {"filename": "llvm/lib/IR/PassInstrumentation.cpp", "functions": ["any_of"]}, {"filename": "llvm/lib/LTO/LTOModule.cpp", "functions": ["if", "StringRef"]}, {"filename": "llvm/lib/ObjCopy/ELF/ELFObjcopy.cpp", "functions": ["StringRef"]}, {"filename": "llvm/lib/ObjectYAML/ELFEmitter.cpp", "functions": ["if"]}, {"filename": "llvm/lib/ProfileData/InstrProfCorrelator.cpp", "functions": ["StringRef"]}, {"filename": "llvm/lib/ProfileData/ItaniumManglingCanonicalizer.cpp", "functions": ["if"]}, {"filename": "llvm/lib/Target/ARM/ARMTargetMachine.cpp", "functions": ["if"]}, {"filename": "llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp", "functions": ["if"]}, {"filename": "llvm/lib/Target/AVR/AVRAsmPrinter.cpp", "functions": ["if"]}, {"filename": "llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp", "functions": ["if"]}, {"filename": "llvm/lib/Target/PowerPC/PPCTargetMachine.cpp", "functions": ["if"]}, {"filename": "llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp", "functions": ["if"]}, {"filename": "llvm/lib/TargetParser/ARMTargetParserCommon.cpp", "functions": ["if"]}, {"filename": "llvm/tools/dsymutil/BinaryHolder.cpp", "functions": ["isArchive"]}, {"filename": "llvm/tools/llc/llc.cpp", "functions": ["if"]}, {"filename": "llvm/tools/llvm-cxxdump/llvm-cxxdump.cpp", "functions": ["if"]}, {"filename": "llvm/tools/llvm-nm/llvm-nm.cpp", "functions": ["if"]}, {"filename": "llvm/tools/llvm-stress/llvm-stress.cpp", "functions": ["if"]}, {"filename": "llvm/tools/yaml2obj/yaml2obj.cpp", "functions": ["if"]}]}
{"pr_number": 67519, "url": "https://github.com/llvm/llvm-project/pull/67519", "title": "[Clang][InstrProf] Allow mix-up of absolute path with relative path on command line when using -fprofile-list=", "body": "When we have file names in fun.list file in absolute path and relative path are on the command line, -fprofile-list= did not work.\r\n\r\nFor example -\r\n\r\n$ clang++ -O2  -fprofile-instr-generate -fcoverage-mapping -fprofile-list=/home/user/llvm-project/fun.list main.cpp calculator.cpp -o calculator\r\n$ cat fun.list\r\nsource:/home/user/llvm-project/main.cpp=skip\r\n\r\nHere main.cpp is relative on clang command line but absolute in fun.list\r\n\r\nHaving a way to give an absolute path can help to reduce ambiguity as other people also tried using the full path https://discourse.llvm.org/t/fprofile-list-flag/70866. ", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Basic/ProfileList.cpp", "functions": ["CanonicalFileName"]}]}
{"pr_number": 68843, "url": "https://github.com/llvm/llvm-project/pull/68843", "title": "[MLIR][NVVM] Enable nvvm intrinsics import  ", "body": "", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Target/LLVMIR/Dialect/NVVM/LLVMIRToNVVMTranslation.cpp", "functions": ["getSupportedIntrinsicsImpl", "args", "convertIntrinsicImpl", "llvmOperands", "getSupportedIntrinsics", "failure", "isConvertibleIntrinsic"]}]}
{"pr_number": 75023, "url": "https://github.com/llvm/llvm-project/pull/75023", "title": "[CodeGen] Port `SjLjEHPrepare` to new pass manager", "body": "`doInitialization` in `SjLjEHPrepare` is trivial.\r\n\r\nThis is the last pass suffix with `ehprepare`.", "feature_layers": ["codegen", "ast"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/CodeGen/SjLjEHPrepare.cpp", "functions": ["FunctionPass", "Impl", "getPassName", "getAnalysisUsage", "runOnFunction", "SjLjEHPrepare", "SjLjEHPrepareImpl", "doInitialization"]}]}
{"pr_number": 74584, "url": "https://github.com/llvm/llvm-project/pull/74584", "title": "Implement acos operator in MLIR Math Dialect", "body": "Required for torch-mlir.\r\nCf. llvm/torch-mlir#2604 \"Implement torch.aten.acos\".", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Math/IR/MathOps.cpp", "functions": ["APFloat"]}]}
{"pr_number": 73326, "url": "https://github.com/llvm/llvm-project/pull/73326", "title": "[Clang] Emit TBAA info for enums in C", "body": "When emitting TBAA information for enums in C code we currently just treat the data as an 'omnipotent char'. However, with C strict aliasing this means we fail to optimise certain cases. For example, in the SPEC2017 xz benchmark there are structs that contain arrays of enums, and clang pessmistically assumes that accesses to those enums could alias with other struct members that have a different type.\r\n\r\nAccording to\r\n\r\nhttps://en.cppreference.com/w/c/language/enum\r\n\r\nenums should be treated as 'int' types unless explicitly specified (C23) or if 'int' would not be large enough to hold all the enumerated values. In the latter case the compiler is free to choose a suitable integer that would hold all such values.\r\n\r\nWhen compiling C code this patch generates TBAA information for the enum by using an equivalent integer of the size clang has already chosen for the enum. I have ignored C++ for now because the rules are more complex.\r\n\r\nNew test added here:\r\n\r\n  clang/test/CodeGen/tbaa.c", "feature_layers": ["codegen"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/CodeGen/CodeGenTBAA.cpp", "functions": ["getTypeInfo"]}, {"filename": "clang/test/CodeGen/tbaa.c", "functions": ["g1", "g3", "g2", "g0"]}]}
{"pr_number": 73283, "url": "https://github.com/llvm/llvm-project/pull/73283", "title": "[SelectionDAG] Add instantiated OPC_CheckType", "body": "The most common type is i32 or i64 so we add `OPC_CheckTypeI32` and\n`OPC_CheckTypeI64` to save one byte.\n\nOverall this reduces the llc binary size with all in-tree targets by\nabout 29K.\n", "feature_layers": [], "feature_directives": ["target"], "files_changed": [{"filename": "llvm/utils/TableGen/DAGISelMatcherEmitter.cpp", "functions": ["getEnumName"]}]}
{"pr_number": 73293, "url": "https://github.com/llvm/llvm-project/pull/73293", "title": "[SelectionDAG] Add space-optimized forms of OPC_EmitCopyToReg", "body": "These new opcodes implicitly indicate the RecNo.\r\n\r\nThe old `OPC_EmitCopyToReg2` is renamed to `OPC_EmitCopyToRegTwoByte`.\r\n\r\nOverall this reduces the llc binary size with all in-tree targets by\r\nabout 33K (most are from RISCV target).\r\n", "feature_layers": [], "feature_directives": ["for", "target"], "files_changed": [{"filename": "llvm/utils/TableGen/DAGISelMatcherEmitter.cpp", "functions": ["getQualifiedName"]}]}
{"pr_number": 73297, "url": "https://github.com/llvm/llvm-project/pull/73297", "title": "[SelectionDAG] Add instantiated OPC_CheckChildType", "body": "The most common type is i32 or i64 so we add `OPC_CheckChildTypeI32`\r\nand `OPC_CheckChildTypeI64` to save one byte.\r\n\r\nOverall this reduces the llc binary size with all in-tree targets by\r\nabout 70K.\r\n\r\nThis PR is stacked on #73283.\r\n\r\n\r\n", "feature_layers": [], "feature_directives": ["target"], "files_changed": [{"filename": "llvm/utils/TableGen/DAGISelMatcherEmitter.cpp", "functions": ["getEnumName"]}]}
{"pr_number": 69597, "url": "https://github.com/llvm/llvm-project/pull/69597", "title": "[clang][Interp] Implement inc/dec for IntegralAP", "body": "The tests are commented out and I can't merge this yet, since it creates memory leaks when the interpretation is aborted midway through.\r\n\r\nThis problem also exists with floating-point values:\r\n\r\n```c++\r\nconstexpr long double a() {\r\n  long double A = __LDBL_MAX__;\r\n  throw;\r\n  return A;\r\n}\r\n```\r\n\r\nWe will allocate a `APFloat` into the stack frame and not call its destructor later.\r\n", "feature_layers": [], "feature_directives": ["for", "allocate"], "files_changed": [{"filename": "clang/test/AST/Interp/intap.cpp", "functions": ["inc1", "maxPlus1", "dec1"]}]}
{"pr_number": 73502, "url": "https://github.com/llvm/llvm-project/pull/73502", "title": "[SelectionDAG] Add space-optimized forms of OPC_EmitNode/OPC_MorphNodeTo", "body": "If there is only one bit set in EmitNodeInfo, then we can encode it\nimplicitly to save one byte.\n\nOverall this reduces the llc binary size with all in-tree targets by\nabout 168K.\n", "feature_layers": [], "feature_directives": ["for", "target"], "files_changed": [{"filename": "llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp", "functions": ["if"]}]}
{"pr_number": 73643, "url": "https://github.com/llvm/llvm-project/pull/73643", "title": "[SelectionDAG] Add OPC_MoveSibling", "body": "There are a lot of operations to move current node to parent and\r\nthen move to another child.\r\n\r\nSo `OPC_MoveSibling` and its space-optimized forms are added to do\r\nthis \"move to sibling\" operations.\r\n\r\nThese new operations will be generated when optimizing matcher in\r\n`ContractNodes`. Currently `MoveParent+MoveChild` will be optimized\r\nto `MoveSibling` and sequences `MoveParent+RecordChild+MoveChild`\r\nwill be transformed into `MoveSibling+RecordNode`.\r\n\r\nOverall this reduces the llc binary size with all in-tree targets by\r\nabout 30K.\r\n", "feature_layers": [], "feature_directives": ["for", "target"], "files_changed": [{"filename": "llvm/utils/TableGen/DAGISelMatcherOpt.cpp", "functions": ["ContractNodes"]}]}
{"pr_number": 71510, "url": "https://github.com/llvm/llvm-project/pull/71510", "title": "[mlir][llvm] Add llvm.target_features features attribute", "body": "This patch adds a target_features (TargetFeaturesAttr) to the LLVM dialect to allow setting and querying the features in use on a function.\r\n\r\nThe motivation for this comes from the Arm SME dialect where we would like a convenient way to check what variants of an operation are available based on the CPU features.\r\n\r\nIntended usage:\r\n\r\nThe target_features attribute is populated manually or by a pass:\r\n\r\n```mlir\r\nfunc.func @example() attributes {\r\n   target_features = #llvm.target_features<[\"+sme\", \"+sve\", \"+sme-f64f64\"]>\r\n} {\r\n // ...\r\n}\r\n```\r\n\r\nThen within a later rewrite the attribute can be checked, and used to make lowering decisions.\r\n\r\n```c++\r\n// Finds the \"target_features\" attribute on the parent\r\n// FunctionOpInterface.\r\nauto targetFeatures = LLVM::TargetFeaturesAttr::featuresAt(op);\r\n\r\n// Check a feature.\r\n// Returns false if targetFeatures is null or the feature is not in\r\n// the list.\r\nif (!targetFeatures.contains(\"+sme-f64f64\"))\r\n    return failure();\r\n```\r\n\r\nFor now, this is rather simple just checks if the exact feature is in the list, though it could be possible to extend with implied features using information from LLVM.", "feature_layers": ["ir"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "mlir/lib/Dialect/LLVMIR/IR/LLVMAttrs.cpp", "functions": ["features", "success", "get", "emitError"]}]}
{"pr_number": 72660, "url": "https://github.com/llvm/llvm-project/pull/72660", "title": "[clang][Interp] Decay arrays to the first element", "body": "I _think_ this makes sense to do here. This way we have a pointer to the first element on the stack.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "clang/test/AST/Interp/arrays.cpp", "functions": ["getSomeInt"]}]}
{"pr_number": 74718, "url": "https://github.com/llvm/llvm-project/pull/74718", "title": "[clang][Interp] Reject static lambdas with captures", "body": "Static lambdas cannot have captures. They may still end up in the constant evaluator though. They've been diagnosted appropriately before, so just reject them here.\r\n\r\nThis is similar to #74661, but for the new constant expression interpreter.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/AST/Interp/cxx23.cpp", "functions": ["static_capture_constexpr", "capture_constexpr"]}]}
{"pr_number": 69422, "url": "https://github.com/llvm/llvm-project/pull/69422", "title": "[lldb] colorize symbols in image lookup with a regex pattern", "body": "Fixes https://github.com/llvm/llvm-project/issues/57372\r\n\r\nPreviously some work has already been done on this. A PR was generated but it remained in review:\r\nhttps://reviews.llvm.org/D136462\r\n\r\nIn short previous approach was following:\r\nChanging the symbol names (making the searched part colorized) -> printing them -> restoring the symbol names back in their original form.\r\n\r\nThe reviewers suggested that instead of changing the symbol table, this colorization should be done in the dump functions itself. Our strategy involves passing the searched regex pattern to the existing dump functions responsible for printing information about the searched symbol. This pattern is propagated until it reaches the line in the dump functions responsible for displaying symbol information on screen.\r\n\r\nAt this point, we've introduced a new function called \"PutCStringColorHighlighted,\" which takes the searched pattern and the expected output and applies colorization to highlight the pattern in the output. This approach aims to streamline the symbol search process to improve readability of search results.\r\n\r\nCo-authored-by: Jos\u00e9 Junior [josejunior@10xengineers.ai](mailto:josejunior@10xengineers.ai)", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "lldb/source/Core/Address.cpp", "functions": ["Dump"]}, {"filename": "lldb/source/Utility/Stream.cpp", "functions": ["reg_pattern"]}]}
{"pr_number": 74829, "url": "https://github.com/llvm/llvm-project/pull/74829", "title": "[flang] Add struct passing target rewrite hooks and partial X86-64 impl", "body": "In the context of C/Fortran interoperability (BIND(C)), it is possible to give the VALUE attribute to a BIND(C) derived type dummy, which according to Fortran 2018 18.3.6 - 2. (4) implies that it must be passed like the equivalent C structure value. The way C structure value are passed is ABI dependent.\r\n\r\nLLVM does not implement the C struct ABI passing for LLVM aggregate type arguments. It is up to the front-end, like clang is doing, to split the struct into registers or pass the struct on the stack (llvm \"byval\") as required by the target ABI.\r\nSo the logic for C struct passing sits in clang. Using it from flang requires setting up a lot of clang context and to bridge FIR/MLIR representation to clang AST representation for function signatures (in both directions). It is a non trivial task.\r\nSee https://stackoverflow.com/questions/39438033/passing-structs-by-value-in-llvm-ir/75002581#75002581.\r\n\r\nSince BIND(C) struct are rather limited as opposed to generic C struct (e.g. no bit fields). It is easier to provide a limited implementation of it for the case that matter to Fortran.\r\n\r\nThis patch:\r\n- Updates the generic target rewrite pass to keep track of both the new argument type and attributes. The motivation for this is to be able to tell if a previously marshalled argument is passed in memory (it is a C pointer), or if it is being passed on the stack (has the byval llvm attributes).\r\n- Adds an entry point in the target specific codegen to marshal struct arguments, and use it in the generic target rewrite pass.\r\n- Implements limited support for the X86-64 case. So far, the support allows telling if a struct must be passed in register or on the stack, and to deal with the stack case. The register case is left TODO in this patch.\r\n\r\nThe X86-64 ABI implemented is the System V ABI for AMD64 version 1.0", "feature_layers": ["codegen", "ir", "ast"], "feature_directives": ["task", "for", "target", "requires"], "files_changed": [{"filename": "flang/lib/Optimizer/CodeGen/Target.cpp", "functions": ["passOnTheStack", "mergeClass", "if", "getSizeAndAlignment", "postMerge"]}, {"filename": "flang/lib/Optimizer/CodeGen/TargetRewrite.cpp", "functions": ["setMembers", "doComplexArg", "clearMembers", "lowerComplexSignatureArg"]}]}
{"pr_number": 69101, "url": "https://github.com/llvm/llvm-project/pull/69101", "title": "[lld] Add support for EC code map.", "body": "This is a refreshed version of https://reviews.llvm.org/D157148 and depends on #69100. More info about my findings is here: https://wiki.winehq.org/ARM64ECToolchain#Code_layout\r\n\r\ncc @bylaws ", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "lld/COFF/Writer.cpp", "functions": ["createECChunks", "createECCodeMap"]}]}
{"pr_number": 74436, "url": "https://github.com/llvm/llvm-project/pull/74436", "title": "[Flang] Add a HLFIR Minloc intrinsic", "body": "The adds a hlfir minloc intrinsic, similar to the minval intrinsic already added, to help in the lowering of minloc. The idea is to later add maxloc too, and from there add a simplification for producing minloc with inlined elemental and hopefully less temporaries.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Optimizer/HLFIR/IR/HLFIROps.cpp", "functions": ["emitWarning"]}, {"filename": "flang/lib/Optimizer/HLFIR/Transforms/LowerHLFIRIntrinsics.cpp", "functions": ["lowerArguments"]}]}
{"pr_number": 75112, "url": "https://github.com/llvm/llvm-project/pull/75112", "title": "[X86] Set MaxAtomicSizeInBitsSupported.", "body": "This will result in larger atomic operations getting expanded to `__atomic_*` libcalls via AtomicExpandPass, which matches what Clang already does in the frontend.", "feature_layers": ["frontend"], "feature_directives": ["atomic"], "files_changed": [{"filename": "llvm/lib/Target/X86/X86ISelLowering.cpp", "functions": ["if"]}]}
{"pr_number": 66033, "url": "https://github.com/llvm/llvm-project/pull/66033", "title": "[libc++] P2770R0: \"Stashing stashing iterators for proper flattening\"", "body": "* Parially implements [P2770R0: \"Stashing stashing iterators for proper flattening\"](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2770r0.html)\r\n* Fixes [LWG3698](https://wg21.link/lwg3698), [LWG3700](https://wg21.link/lwg3700), and [LWG3791](https://wg21.link/lwg3791)\r\n* `join_with_view` hasn't been done yet since this type isn't implemented yet\r\n* Rename `test/libcxx/ranges/range.adaptors/range.adaptor.tuple` directory to `test/libcxx/ranges/range.adaptors/range.adaptor.helpers` to match the standard: http://eel.is/c++draft/range.adaptor.helpers (this change happened in P2770R0, see point 3 of wording).\r\n* Rename `libcxx\\test\\std\\ranges\\range.adaptors\\range.join.view` to `libcxx\\test\\std\\ranges\\range.adaptors\\range.join` to match the standard", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "libcxx/test/libcxx/ranges/range.adaptors/range.adaptor.helpers/as-lvalue.verify.cpp", "functions": ["decltype"]}, {"filename": "libcxx/test/std/ranges/range.adaptors/range.join.view/iterator/ctor.parent.outer.pass.cpp", "functions": ["test", "main", "jv"]}, {"filename": "libcxx/test/std/ranges/range.adaptors/range.join/range.join.iterator/ctor.default.pass.cpp", "functions": ["test_non_default_constructible"]}, {"filename": "libcxx/test/std/ranges/range.adaptors/range.join/range.join.iterator/ctor.other.pass.cpp", "functions": ["jv"]}, {"filename": "libcxx/test/libcxx/ranges/range.adaptors/range.adaptor.helpers/as-lvalue.lifetimebound.verify.cpp", "functions": ["test"]}, {"filename": "libcxx/test/libcxx/ranges/range.adaptors/range.adaptor.helpers/as-lvalue.pass.cpp", "functions": ["decltype"]}, {"filename": "libcxx/test/std/ranges/range.adaptors/range.join/lwg3698.pass.cpp", "functions": ["main"]}, {"filename": "libcxx/test/libcxx/ranges/range.adaptors/range.join/range.join.iterator/ctor.parent.outer.pass.cpp", "functions": ["r"]}, {"filename": "libcxx/test/libcxx/ranges/range.adaptors/range.join/range.join.iterator/ctor.parent.pass.cpp", "functions": ["test", "main", "jv"]}]}
{"pr_number": 70753, "url": "https://github.com/llvm/llvm-project/pull/70753", "title": "[X86][GlobalISel] Add instruction selection for G_SELECT", "body": "", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/X86/GISel/X86InstructionSelector.cpp", "functions": ["selectSelect"]}]}
{"pr_number": 71750, "url": "https://github.com/llvm/llvm-project/pull/71750", "title": "Implements PGOBBAddrMap in Object and ObjectYAML with tests [1/5]", "body": "A part of [RFC - PGO Accuracy Metrics: Emitting and Evaluating Branch and Block Analysis](https://discourse.llvm.org/t/rfc-pgo-accuracy-metrics-emitting-and-evaluating-branch-and-block-analysis/73902).\r\n\r\nThis PR adds the PGOBBAddrMap data structure and implements encoding and decoding through Object and ObjectYAML along with associated tests.\r\n\r\n## Design Alternative\r\nThe current implementation makes an effort to avoid modifying the original BBAddrMap data structure. This keeps the API the same as before for all pre-existing code and avoids unnecessary fields for regular BBAddrMap usage. It comes with the cost of some complexity in sharing encoding/decoding code.\r\n\r\nAlternatively, we could just place all new fields into BBAddrMap. This makes the encoding/decoding code simpler. It has the cost of changing some behavior in the original API. It also adds unnecessary fields for anyone wanting to just use the regular BBAddrMap.\r\n\r\nPlease let us know if you feel that the alternate design of placing new fields into BBAddrMap is preferable.\r\n\r\n## PR Series\r\n\r\nThe current code for PGOBBAddrMap to be upstreamed is split into five PRs:\r\n1. Object and ObjectYAML - (this one) https://github.com/red1bluelost/llvm-project/tree/pgo-bb-addr-map--object\r\n2. AsmPrinter - https://github.com/red1bluelost/llvm-project/pull/1 or https://github.com/red1bluelost/llvm-project/tree/pgo-bb-addr-map--asm-printer\r\n3. llvm-readobj - https://github.com/red1bluelost/llvm-project/pull/2 or https://github.com/red1bluelost/llvm-project/tree/pgo-bb-addr-map--llvm-readobj\r\n4. llvm-objdump - https://github.com/red1bluelost/llvm-project/tree/pgo-bb-addr-map--llvm-objdump\r\n5. llvm obj2yaml - https://github.com/red1bluelost/llvm-project/tree/pgo-bb-addr-map--llvm-obj2yaml\r\n\r\nIf you would like to try testing PGOBBAddrMap locally on a program, PR-3 llvm-readobj is likely the minimum code needed to meaningfully use this feature.\r\n\r\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/MC/MCParser/ELFAsmParser.cpp", "functions": ["if"]}, {"filename": "llvm/lib/MC/MCSectionELF.cpp", "functions": ["if"]}, {"filename": "llvm/lib/Object/ELF.cpp", "functions": ["uint8_t"]}, {"filename": "llvm/lib/Object/ELFObjectFile.cpp", "functions": ["readBBAddrMapImpl", "readPGOBBAddrMapImpl"]}, {"filename": "llvm/lib/ObjectYAML/ELFEmitter.cpp", "functions": ["SHeader", "writeEntry", "Base"]}, {"filename": "llvm/lib/ObjectYAML/ELFYAML.cpp", "functions": ["mapBBAddrMapCommonBase", "sectionMapping"]}, {"filename": "llvm/unittests/Object/ELFObjectFileTest.cpp", "functions": ["E2", "E1"]}]}
{"pr_number": 75123, "url": "https://github.com/llvm/llvm-project/pull/75123", "title": "[C API] Add getters and setters for fast-math flags on relevant instructions", "body": "These flags are usable on floating point arithmetic, as well as call, select, and phi instructions whose resulting type is floating point, or a vector of, or an array of, a valid type. Whether or not the flags are valid for a given instruction can be checked with the new LLVMGetCanUseFastMathFlags function\r\n\r\nThese are exposed using a new LLVMFastMathFlags type, which is an alias for unsigned. An anonymous enum defines the bit values for it\r\n\r\nTests are added in echo.ll for select/phil/call, and the floating point types in the new float_ops.ll bindings test\r\n\r\nSelect and the floating point arithmetic instructions were not implemented in llvm-c-test/echo.cpp, so they were added as well", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/IR/Core.cpp", "functions": ["LLVMGetCanUseFastMathFlags", "LLVMCanValueUseFastMathFlags"]}]}
{"pr_number": 74860, "url": "https://github.com/llvm/llvm-project/pull/74860", "title": "[RegAllocFast] NFC cleanups", "body": "- use more range for\n- avoid capturing lambda\n- prefer Register type to unsigned\n- remove braces around single statement if\n", "feature_layers": ["ast"], "feature_directives": ["for", "single"], "files_changed": [{"filename": "llvm/lib/CodeGen/RegAllocFast.cpp", "functions": ["isTiedToNotUndef", "useVirtReg"]}]}
{"pr_number": 74938, "url": "https://github.com/llvm/llvm-project/pull/74938", "title": "[libc++][chrono] Fixes year_month year wrapping.", "body": "Adding months to a year_month should wrap the year when the month becomes greater than twelve or less than one.\r\n\r\nThis fixes the issue for year_month. Other classes with a year and month do not have this issue. This has been verified and tests are added to avoid possible regressions.\r\n\r\nAlso fixes some variable copy-paste errors in the tests.\r\n\r\nFixes https://github.com/llvm/llvm-project/issues/73162", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "libcxx/test/std/time/time.cal/time.cal.ymdlast/time.cal.ymdlast.members/plus_minus_equal_month.pass.cpp", "functions": ["ymdl", "ym"]}, {"filename": "libcxx/test/std/time/time.cal/time.cal.ymwdlast/time.cal.ymwdlast.members/plus_minus_equal_month.pass.cpp", "functions": ["ymwd", "ymwdl"]}]}
{"pr_number": 75122, "url": "https://github.com/llvm/llvm-project/pull/75122", "title": "[mlir][vector] Allow vector distribution with multiple written elements", "body": "Add a configuration option to allow vector distribution with multiple elements written by a single lane.\r\n\r\nThis is so that we can perform vector multi-reduction with multiple results per workgroup.", "feature_layers": ["ir"], "feature_directives": ["for", "single"], "files_changed": [{"filename": "mlir/lib/Dialect/Vector/Transforms/VectorDistribute.cpp", "functions": ["failure"]}]}
{"pr_number": 73150, "url": "https://github.com/llvm/llvm-project/pull/73150", "title": "[mlir][mesh] Add endomorphism simplification for all-reduce", "body": "Does transformations like\r\n`all_reduce(x) + all_reduce(y) -> all_reduce(x + y)`\r\n\r\n`max(all_reduce(x), all_reduce(y)) -> all_reduce(max(x, y))`\r\nwhen the `all_reduce` element-wise op is `max`.\r\n\r\nIn this PR I added a general rewrite pattern `EndomorphismSimplification` where I tried to isolate the general rewrite algorithm. I can split this in 2 PRs.\r\nI see a path to generalize this to homomorphisms to allow for generalizing patterns like\r\n`exp(x)*exp(y) -> exp(x + y)`,\r\nbut have not done it in this PR.\r\n**Update:**\r\nI made the endomorphism rewrite pattern derive from homomorphism rewrite pattern.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Mesh/Transforms/Simplifications.cpp", "functions": ["populateSimplificationPatterns"]}, {"filename": "mlir/test/lib/Dialect/Mesh/TestSimplifications.cpp", "functions": ["runOnOperation", "getArgument", "patterns", "registerTestMeshSimplificationsPass", "getDependentDialects", "getDescription"]}, {"filename": "mlir/tools/mlir-opt/mlir-opt.cpp", "functions": ["registerTestMeshSimplificationsPass"]}]}
{"pr_number": 75097, "url": "https://github.com/llvm/llvm-project/pull/75097", "title": "[AMDGPU] add utils for common usage", "body": "This PR generalizes helper functions for the common usage in swizzling implementation for AMDGPU and NVGPU Dialects.  ", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/AMDGPU/IR/AMDGPUDialect.cpp", "functions": ["isSharedMemoryAddressSpace"]}]}
{"pr_number": 74414, "url": "https://github.com/llvm/llvm-project/pull/74414", "title": "[lldb] Correctly check and report error states in StackFrame.cpp", "body": "This commits fixes a few subtle bugs where the method:\r\n1. Declares a local `Status error` which eclipses the method's parameter `Status &error`.\r\n\t- The method then sets the error state to the local `error` and returns without ever touching the parameter `&error`.\r\n\t- This effectively traps the error state and its message from ever reaching the caller.\r\n\t- I also threw in a null pointer check in case the callee doesn't set its `Status` parameter but returns `0`/`nullptr`.\r\n\r\n2. Declares a local `Status deref_error` (good), passes it to the `Dereference` method (also good), but then checks the status of the method's `Status &error` parameter (not good).\r\n\t- The fix checks `deref_error` instead and also checks for a `nullptr` return value.\r\n\t- There's a good opportunity here for a future PR that changes the `Dereference` method to fold an error state into the `ValueObject` return value's `m_error` instead of using a parameter.\r\n\r\n3. Declares another local `Status error`, which it doesn't pass to a method (because there isn't a parameter for it), and then checks for an error condition that never happens. \r\n\t- The fix just checks the callee's return value, because that's all it has to go on.\r\n\t- This likely comes from a copy/paste from issue 1 above.\r\n\r\n\r\nrdar://119155810", "feature_layers": ["ast"], "feature_directives": ["for", "declare"], "files_changed": [{"filename": "lldb/source/Target/StackFrame.cpp", "functions": ["temp"]}]}
{"pr_number": 74690, "url": "https://github.com/llvm/llvm-project/pull/74690", "title": "[mlir][SparseTensor] Fix invalid API usage in patterns", "body": "Rewrite patterns must return `success` if the IR was modified. This commit fixes sparse tensor tests such as `SparseTensor/sparse_fusion.mlir`, `SparseTensor/CPU/sparse_reduce_custom.mlir`, `SparseTensor/CPU/sparse_semiring_select.mlir` when running with `MLIR_ENABLE_EXPENSIVE_PATTERN_API_CHECKS`.", "feature_layers": ["parse", "ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/Transforms/SparseReinterpretMap.cpp", "functions": ["failure", "success"]}]}
{"pr_number": 75000, "url": "https://github.com/llvm/llvm-project/pull/75000", "title": "[libc++][module] Fixes std::string UDL.", "body": "The fix changes the way the validation script determines the qualified name of a declaration. Inline namespaces without a reserved name are now always part of the name. The Clang code only does this when the names are ambigious. This method is often used for the operator\"\"foo for UDLs.\r\n\r\nAdjusted the newly flagged issue and removed a work-around in the test code that is no longer required.\r\n\r\nFixes https://github.com/llvm/llvm-project/issues/72427", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "libcxx/test/tools/clang_tidy_checks/header_exportable_declarations.cpp", "functions": ["is_reserved_name"]}]}
{"pr_number": 74387, "url": "https://github.com/llvm/llvm-project/pull/74387", "title": "[asan] Switch initialization to \"double-checked locking\"", "body": "This allows to remove `asan_init_is_running` which likely had a data\r\nrace.\r\n\r\nSimplifies https://github.com/llvm/llvm-project/pull/74086 and reduces a difference between platforms.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "compiler-rt/lib/asan/asan_rtl.cpp", "functions": ["SetAsanInitIsRunning", "AsanInitIsRunning", "SetAsanInited", "AsanInitInternal", "lock", "AsanInited", "atomic_load"]}]}
{"pr_number": 74557, "url": "https://github.com/llvm/llvm-project/pull/74557", "title": "[CommandLine] Show '[subcommand]' in the help for less than 3 subcommands", "body": "When a tool defines only one or two subcommands, the `[subcommand]` part is not displayed in the `USAGE` help line. Note that a similar issue with printing the list of the subcommands has been fixed in https://reviews.llvm.org/D25463.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/unittests/Support/CommandLineTest.cpp", "functions": ["Stdout", "Opt", "SC2", "TestOption", "SC2Opt", "interceptStdout", "SC1Opt", "SC1"]}]}
{"pr_number": 75085, "url": "https://github.com/llvm/llvm-project/pull/75085", "title": "[AArch64]: Added code for generating XAR instruction", "body": "cc @davemgreen for review.\r\n\r\nFixes #61584", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp", "functions": ["trySelectXAR"]}]}
{"pr_number": 75006, "url": "https://github.com/llvm/llvm-project/pull/75006", "title": "[TextAPI] Add DylibReader", "body": "Add support for reading binary Mach-o dynamic libraries. It uses libObject APIs for extracting information relavant to TAPI and tbd files. This includes but is not limited to load commands encode data like install names, current/compat versions and symbols.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/TextAPI/DylibReader.cpp", "functions": ["readMachOHeader", "constructTriples"]}]}
{"pr_number": 75257, "url": "https://github.com/llvm/llvm-project/pull/75257", "title": "[sanitizer] Pre-commit disabled test for fork", "body": "", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "compiler-rt/test/sanitizer_common/TestCases/Posix/fork_threaded.cpp", "functions": ["ShouldNotDeadlock", "CanDeadLock"]}]}
{"pr_number": 75260, "url": "https://github.com/llvm/llvm-project/pull/75260", "title": "[test][sanitizer] Allow fork_threaded test on Msan, Tsan, Ubsan", "body": "They already include workarounds.\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "compiler-rt/test/sanitizer_common/TestCases/Posix/fork_threaded.cpp", "functions": ["ShouldNotDeadlock", "CanDeadLock"]}]}
{"pr_number": 75282, "url": "https://github.com/llvm/llvm-project/pull/75282", "title": "Revert \"[coroutines] Use DILocation from new storage for hoisted dbg.declare\"", "body": "Reverts llvm/llvm-project#75104\r\n\r\nOriginal commit causes clang to generate invalid IR:\r\n```\r\nmismatched subprogram between llvm.dbg.declare variable and !dbg attachment\r\n  call void @llvm.dbg.declare(metadata ptr %4, metadata !34468, metadata !DIExpression(DW_OP_plus_uconst, 176)), !dbg !34467\r\n```", "feature_layers": ["ir"], "feature_directives": ["for", "declare"], "files_changed": [{"filename": "llvm/lib/Transforms/Coroutines/CoroFrame.cpp", "functions": ["if"]}]}
{"pr_number": 74972, "url": "https://github.com/llvm/llvm-project/pull/74972", "title": "[CodeGen] Add analyses to help for porting GC passes", "body": "- `CollectorMetadataAnalysis` provides `GCStrategyMap`.\r\n- `GCFunctionAnalysis` provides `GCFunctionInfo`.\r\n\r\n`GCStrategyMap` owns `GCStrategy` pointers and this\r\npass is used by `AsmPrinter` to iterate all GC strategies.\r\n\r\nMost passes that require `GCModuleInfo` actually require the `GCFunctionInfo`,\r\nso add `GCFunctionAnalysis` for convenience.", "feature_layers": ["codegen", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/CodeGen/GCMetadata.cpp", "functions": ["Info"]}]}
{"pr_number": 75287, "url": "https://github.com/llvm/llvm-project/pull/75287", "title": "[CodeGen] Port `IndirectBrExpand` to new pass manager", "body": "", "feature_layers": ["codegen", "ir"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/CodeGen/IndirectBrExpandPass.cpp", "functions": ["DTU", "runImpl"]}]}
{"pr_number": 74050, "url": "https://github.com/llvm/llvm-project/pull/74050", "title": "[CodeGen] Port ExpandMemCmp to new pass manager", "body": "", "feature_layers": ["codegen"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/CodeGen/ExpandMemCmp.cpp", "functions": ["runImpl"]}]}
{"pr_number": 70843, "url": "https://github.com/llvm/llvm-project/pull/70843", "title": "[MLIR][Presburger] Add Gram-Schmidt", "body": "Implement Gram-Schmidt orthogonalisation for the FracMatrix class.\r\nThis requires dotProduct, which has been added as a util.", "feature_layers": ["ir"], "feature_directives": ["for", "requires"], "files_changed": [{"filename": "mlir/lib/Analysis/Presburger/Matrix.cpp", "functions": ["orth"]}]}
{"pr_number": 75104, "url": "https://github.com/llvm/llvm-project/pull/75104", "title": "[coroutines] Use DILocation from new storage for hoisted dbg.declare", "body": "Make the hoisted dbg.declare inherent the DILocation scope from the new storage.\r\n\r\nAfter hoisting, the dbg.declare is moved into the block that defines the new storage. This could create an inconsistency in the debug location scope hierarchy where the scope of hoisted dbg.declare (i.e. DILexicalBlock) is enclosed with the scope of the block (i.e. DISubprogram). This confuses LiveDebugValues pass to think that the hoisted dbg.declare is killed in that block and does not generate DBG_VALUE in other blocks. Debugger won't be able to track its value anymore.", "feature_layers": [], "feature_directives": ["for", "declare"], "files_changed": [{"filename": "llvm/lib/Transforms/Coroutines/CoroFrame.cpp", "functions": ["if"]}]}
{"pr_number": 75304, "url": "https://github.com/llvm/llvm-project/pull/75304", "title": "Revert \"[libc][NFC] Implement `FPBits` in terms of `FloatProperties` to reduce clutter\"", "body": "Reverts llvm/llvm-project#75196\r\n\r\nGCC complains about change of meaning for `FPBits`\r\n```\r\n/home/llvm-libc-buildbot/buildbot-worker/libc-x86_64-debian-fullbuild/libc-x86_64-debian-gcc-fullbuild-dbg/llvm-project/libc/src/__support/FPUtil/generic/FMod.h:188:9: error: declaration of \u2018using FPBits = struct __llvm_libc_18_0_0_git::fputil::FPBits<T>\u2019 changes meaning of \u2018FPBits\u2019 [-fpermissive]\r\n  188 |   using FPBits = FPBits<T>;\r\n      |         ^~~~~~\r\n```\r\n\r\nI'll reland with a different name.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "libc/src/math/generic/acoshf.cpp", "functions": ["xbits"]}, {"filename": "libc/src/math/generic/asinhf.cpp", "functions": ["xbits"]}, {"filename": "libc/src/math/generic/log.cpp", "functions": ["xbits"]}, {"filename": "libc/src/math/generic/log10.cpp", "functions": ["xbits"]}, {"filename": "libc/src/math/generic/log1p.cpp", "functions": ["FPBits", "xbits", "xhi_bits", "FPBits_t"]}, {"filename": "libc/src/math/generic/log2.cpp", "functions": ["xbits"]}, {"filename": "libc/src/math/generic/sinhf.cpp", "functions": ["FPBits"]}]}
{"pr_number": 75218, "url": "https://github.com/llvm/llvm-project/pull/75218", "title": "[MLIR] Flatten fused locations when merging constants.", "body": "[PR 74670](https://github.com/llvm/llvm-project/pull/74670) added support for merging locations at constant folding time. We have discovered that in some cases, the number of locations grows so big as to cause a compilation process to OOM. In that case, many of the locations end up appearing several times in nested fused locations.\r\n\r\nWe add here a helper that always flattens fused locations in order to eliminate duplicates in the case of nested fused locations.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Transforms/Utils/FoldUtils.cpp", "functions": ["FlattenFusedLocationRecursively"]}]}
{"pr_number": 67157, "url": "https://github.com/llvm/llvm-project/pull/67157", "title": "[analyzer] Move alpha checker EnumCastOutOfRange to optin", "body": "The checker EnumCastOutOfRange verifies the (helpful, but not standard-mandated) design rule that integer to enum casts should not produce values that don't have a corresponding enumerator. As it was improved and cleaned up by recent changes, this commit renames it from `alpha.cplusplus.EnumCastOutOfRange` to `optin.core.EnumCastOutOfRange` to reflect that it's no longer alpha quality.\r\n\r\nAs this checker handles a basic language feature (which is also present in plain C), I moved it to a \"core\" subpackage within \"optin\".\r\n\r\nIn addition to the renaming, this commit cleans up the documentation in `checkers.rst` and adds the new example code to a test file to ensure that it's indeed producing the behavior claimend in the documentation.", "feature_layers": ["ast"], "feature_directives": [], "files_changed": [{"filename": "clang/test/Analysis/enum-cast-out-of-range.cpp", "functions": ["foo"]}]}
{"pr_number": 75051, "url": "https://github.com/llvm/llvm-project/pull/75051", "title": "[clang][Interp] Don't diagnose undefined functions when checking...", "body": "... for a potential constant expression. They are not defined now, but might be defined later when the function is actually called.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/AST/Interp/functions.cpp", "functions": ["a", "f"]}]}
{"pr_number": 73258, "url": "https://github.com/llvm/llvm-project/pull/73258", "title": "[Clang][AArch64] Add  fix vector types to header into SVE", "body": " This patch is needed for the reduction instructions in sve2.1\r\n It add a new header to sve with all the fixed vector types.\r\n  The new types are only added if neon is not declared.\r\n", "feature_layers": [], "feature_directives": ["for", "declare"], "files_changed": [{"filename": "clang/test/CodeGen/arm-vector_type-params-returns.c", "functions": ["test_ret_v16s8", "test_ret_v64s2", "test_ret_v4f32", "test_ret_v64u2", "test_ret_v8f16", "test_ret_v32u4", "test_ret_v16u8", "test_ret_v8s16", "test_ret_v8u16", "test_ret_v32s4", "test_ret_v8bf16", "test_ret_v2f64"]}, {"filename": "clang/utils/TableGen/NeonEmitter.cpp", "functions": ["runVectorTypes", "runVectorType"]}, {"filename": "clang/test/Sema/arm-vector-types-support.c", "functions": ["__attribute__"]}]}
{"pr_number": 73375, "url": "https://github.com/llvm/llvm-project/pull/73375", "title": "[flang] pass true/false to EditLogicalOutput directly (NFC)", "body": "Using `reinterpret_cast<const char *>(&n)` will cause issue in the big endian environment when `KIND > 1`.", "feature_layers": ["ir", "ast"], "feature_directives": [], "files_changed": [{"filename": "flang/runtime/edit-output.cpp", "functions": ["EditLogicalOutput"]}]}
{"pr_number": 75212, "url": "https://github.com/llvm/llvm-project/pull/75212", "title": "[SystemZ][z/OS] Complete EBCDIC I/O support", "body": "This patch completes the support for EBCDIC I/O support on z/OS using the autoconversion functions.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Support/AutoConvert.cpp", "functions": ["fcntl", "restoreStdHandleAutoConversion", "disableAutoConversion", "enableAutoConversion"]}, {"filename": "llvm/lib/Support/InitLLVM.cpp", "functions": ["ExitOnErr", "CleanupStdHandles"]}, {"filename": "llvm/lib/Support/Unix/Program.inc", "functions": ["disableAutoConversion"]}]}
{"pr_number": 75030, "url": "https://github.com/llvm/llvm-project/pull/75030", "title": "[AMDGPU] Update IEEE and DX10_CLAMP for GFX12", "body": "", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp", "functions": ["Mode"]}, {"filename": "llvm/lib/Target/AMDGPU/AMDGPUTargetTransformInfo.cpp", "functions": ["CallerMode", "Mode", "CalleeMode"]}, {"filename": "llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp", "functions": ["TokError", "Error"]}, {"filename": "llvm/lib/Target/AMDGPU/SIMachineFunctionInfo.cpp", "functions": ["AMDGPUMachineFunction"]}, {"filename": "llvm/lib/Target/AMDGPU/SIProgramInfo.cpp", "functions": ["S_00B848_VGPRS", "getComputePGMRSrc1"]}]}
{"pr_number": 75088, "url": "https://github.com/llvm/llvm-project/pull/75088", "title": "[BPF] improve error handling by custom lowering & fail()", "body": "Currently on mcpu=v3 we do not support sdiv, srem instructions. And the backend crashes with stacktrace & coredump, which is misleading for end users, as this is not a \"bug\"\r\n\r\nAdd llvm bug reporting for sdiv/srem on ISel legalize-op phase.\r\n\r\nFor clang frontend we can get detailed location & bug report.\r\n\r\n    $ build/bin/clang -g -target bpf -c local/sdiv.c\r\n    local/sdiv.c:1:35: error: unsupported signed division, please convert to unsigned div/mod.\r\n        1 | int sdiv(int a, int b) { return a / b; }\r\n          |                                   ^\r\n    1 error generated.\r\n\r\nFixes: #70433\r\nFixes: #48647\r\n\r\nThis also improves error handling for dynamic stack allocation:\r\n\r\n    local/vla.c:2:3: error: unsupported dynamic stack allocation\r\n        2 |   int b[n];\r\n          |   ^\r\n    1 error generated.\r\n\r\nFixes: https://github.com/llvm/llvm-project/issues/57171", "feature_layers": ["frontend"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "llvm/lib/Target/BPF/BPFISelLowering.cpp", "functions": ["LowerDYNAMIC_STACKALLOC", "LowerSDIVSREM", "DL"]}]}
{"pr_number": 75222, "url": "https://github.com/llvm/llvm-project/pull/75222", "title": "[mlir][ArmSME] Add sve streaming compatible attribute", "body": "Following the same path already used for ArmStreaming and ArmLocallyStreaming.\r\n\r\nThis should correspond to clang's __arm_streaming_compatible attribute.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Target/LLVMIR/ModuleImport.cpp", "functions": ["if"]}, {"filename": "mlir/lib/Target/LLVMIR/ModuleTranslation.cpp", "functions": ["if"]}]}
{"pr_number": 74630, "url": "https://github.com/llvm/llvm-project/pull/74630", "title": "[libc++] Fix incomplete user-defined ctype specialization in test", "body": "The specialization was non-conforming because it was missing a bunch of member functions. Those were missing probably just as an oversight coupled with a bit of laziness -- the rule that user-defined specializations need to match the base template is usually OK to take with a grain of salt, but not when the code is supposed to be portable, which our test suite aims to be.\r\n\r\nFixes #74214", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "libcxx/test/std/localization/locale.categories/category.numeric/locale.num.get/user_defined_char_type.pass.cpp", "functions": ["scan_is", "widen", "narrow", "is", "tolower", "scan_not", "toupper", "ctype"]}]}
{"pr_number": 75340, "url": "https://github.com/llvm/llvm-project/pull/75340", "title": "AMDGPU/GlobalISel: add AMDGPUGlobalISelDivergenceLowering pass", "body": "Add empty AMDGPUGlobalISelDivergenceLowering pass. This pass will implement\r\n- selection of divergent i1 phis as lane mask phis, requires lane mask merging in some cases\r\n- lower uses of divergent i1 values outside of the cycle using lane mask merging\r\n- lowering of all cases of temporal divergence:\r\n- lower uses of uniform i1 values outside of the cycle using lane mask merging\r\n- lower uses of uniform non-i1 values outside of the cycle using a copy to vgpr inside of the cycle\r\n\r\nAdd very detailed set of regression tests for cases mentioned above.\r\n\r\npatch 1 from: https://github.com/llvm/llvm-project/pull/73337", "feature_layers": ["ir"], "feature_directives": ["for", "requires"], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/AMDGPUGlobalISelDivergenceLowering.cpp", "functions": ["AMDGPUGlobalISelDivergenceLowering", "getAnalysisUsage", "getPassName", "runOnMachineFunction"]}]}
{"pr_number": 69926, "url": "https://github.com/llvm/llvm-project/pull/69926", "title": "[SVE2.1][Clang][LLVM]Int/FP reduce builtin in Clang and LLVM intrinsic", "body": "This patch implements the builtins in Clang\r\nand the LLVM-IR intrinsic for the following:\r\n\r\n// Variants are also available for:\r\n// _s8, _s16, _u16, _s32, _u32, _s64, _u64,\r\n// _f16, _f32, _f64uint8x16_t svaddqv[_u8](svbool_t pg, svuint8_t zn);\r\n\r\n// Variants are also available for:\r\n// _s8, _u16, _s16, _u32, _s32, _u64, _s64\r\nuint8x16_t svandqv[_u8](svbool_t pg, svuint8_t zn); uint8x16_t sveorqv[_u8](svbool_t pg, svuint8_t zn); uint8x16_t svorqv[_u8](svbool_t pg, svuint8_t zn);\r\n\r\n// Variants are also available for:\r\n// _s8, _u16, _s16, _u32, _s32, _u64, _s64;\r\nuint8x16_t svmaxqv[_u8](svbool_t pg, svuint8_t zn); uint8x16_t svminqv[_u8](svbool_t pg, svuint8_t zn);\r\n\r\n// Variants are also available for _f32, _f64\r\nfloat16x8_t svmaxnmqv[_f16](svbool_t pg, svfloat16_t zn); float16x8_t svminnmqv[_f16](svbool_t pg, svfloat16_t zn);\r\n\r\nAccording to the PR#257[1]\r\n\r\nThe reduction instruction uses scalable vectors as input and fixed vectors as output, therefore we changed SVEEmitter to emit fixed vector types in case the neon header(arm_neon.h) is not present.\r\n\r\n[1]https://github.com/ARM-software/acle/pull/257\r\n\r\nCo-author: Dinar Temirbulatov <dinar.temirbulatov@arm.com>", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_fp_reduce.c", "functions": ["test_svaddqv_f64", "test_svmaxqv_f16", "test_svminnmqv_f64", "test_svmaxqv_f32", "test_svmaxnmqv_f16", "test_svminnmqv_f16", "test_svaddqv_f16", "test_svmaxnmqv_f32", "test_svaddqv_f32", "test_svmaxnmqv_f64", "test_svmaxqv_f64", "test_svminqv_f32", "test_svminqv_f64", "test_svminnmqv_f32", "SVE_ACLE_FUNC", "test_svminqv_f16"]}, {"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_int_reduce.c", "functions": ["test_svorqv_s16", "test_sveorqv_s32", "test_svminqv_s16", "test_svminqv_u64", "test_svaddqv_s64", "test_svminqv_s8", "test_svaddqv_u8", "test_sveorqv_u32", "test_svorqv_u8", "test_svandqv_u64", "test_svmaxqv_u32", "test_svandqv_u16", "test_svandqv_u32", "test_svorqv_u64", "test_sveorqv_s16", "test_svandqv_s8", "test_svorqv_s32", "test_svaddqv_u64", "test_svandqv_s64", "test_svorqv_s8", "test_svandqv_s32", "test_sveorqv_s64", "test_sveorqv_s8", "test_svorqv_u16", "test_svaddqv_s8", "test_svminqv_u8", "test_svmaxqv_u64", "test_svaddqv_u16", "test_svmaxqv_s32", "test_svmaxqv_s8", "test_svmaxqv_u8", "test_svminqv_s32", "test_svminqv_u32", "test_svmaxqv_u16", "test_svorqv_s64", "test_sveorqv_u8", "test_svaddqv_s16", "test_svorqv_u32", "SVE_ACLE_FUNC", "test_sveorqv_u16", "test_svmaxqv_s16", "test_svandqv_s16", "test_sveorqv_u64", "test_svaddqv_u32", "test_svandqv_u8", "test_svminqv_s64", "test_svminqv_u16", "test_svaddqv_s32", "test_svmaxqv_s64"]}, {"filename": "clang/utils/TableGen/SveEmitter.cpp", "functions": ["isFixedLengthVector"]}, {"filename": "clang/test/CodeGen/arm-vector_type-params-returns.c", "functions": ["test_ret_v16s8", "test_ret_v64s2", "test_ret_v4f32", "test_ret_v64u2", "test_ret_v8f16", "test_ret_v32u4", "test_ret_v16u8", "test_ret_v8s16", "test_ret_v8u16", "test_ret_v32s4", "test_ret_v8bf16", "test_ret_v2f64"]}, {"filename": "clang/utils/TableGen/NeonEmitter.cpp", "functions": ["TypedefTypes"]}]}
{"pr_number": 75149, "url": "https://github.com/llvm/llvm-project/pull/75149", "title": "[clang] Use StringRef::{starts,ends}_with (NFC)", "body": "This patch replaces uses of StringRef::{starts,ends}with with\nStringRef::{starts,ends}_with for consistency with\nstd::{string,string_view}::{starts,ends}_with in C++20.\n\nI'm planning to deprecate and eventually remove\nStringRef::{starts,ends}with.\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/ARCMigrate/ObjCMT.cpp", "functions": ["if"]}, {"filename": "clang/lib/AST/Stmt.cpp", "functions": ["if"]}, {"filename": "clang/lib/Analysis/CocoaConventions.cpp", "functions": ["if"]}, {"filename": "clang/lib/Analysis/RetainSummaryManager.cpp", "functions": ["StringRef"]}, {"filename": "clang/lib/CodeGen/CodeGenModule.cpp", "functions": ["if"]}, {"filename": "clang/lib/CodeGen/Targets/SPIR.cpp", "functions": ["if"]}, {"filename": "clang/lib/Driver/ToolChains/AMDGPU.cpp", "functions": ["if"]}, {"filename": "clang/lib/Driver/ToolChains/Arch/ARM.cpp", "functions": ["if"]}, {"filename": "clang/lib/Driver/ToolChains/Clang.cpp", "functions": ["NewArgs"]}, {"filename": "clang/lib/Driver/ToolChains/Darwin.cpp", "functions": ["if"]}, {"filename": "clang/lib/Driver/ToolChains/Hexagon.cpp", "functions": ["if"]}, {"filename": "clang/lib/Edit/RewriteObjCFoundationAPI.cpp", "functions": ["if"]}, {"filename": "clang/lib/Format/Format.cpp", "functions": ["isLikelyXml"]}, {"filename": "clang/lib/Frontend/VerifyDiagnosticConsumer.cpp", "functions": ["if"]}, {"filename": "clang/lib/Sema/SemaChecking.cpp", "functions": ["if"]}, {"filename": "clang/tools/clang-scan-deps/ClangScanDeps.cpp", "functions": ["if"]}, {"filename": "clang/unittests/Driver/MultilibBuilderTest.cpp", "functions": ["StringRef"]}]}
{"pr_number": 72532, "url": "https://github.com/llvm/llvm-project/pull/72532", "title": "[XCOFF] Display branch-absolute targets in hex.", "body": "Branch-absolute instructions are currently printed in decimal, and negative addresses are printed as positive numbers.\r\n\r\nWith this change, addresses are printed in hex and negative addresses are converted to an unsigned 32- or 64-bit address.\r\n", "feature_layers": [], "feature_directives": ["target"], "files_changed": [{"filename": "llvm/lib/Target/PowerPC/MCTargetDesc/PPCInstPrinter.cpp", "functions": ["formatHex"]}]}
{"pr_number": 75255, "url": "https://github.com/llvm/llvm-project/pull/75255", "title": "[mlir][IndexToLLVM] Lower UnrealizedConversionCastOp related to IndexType in IndexToLLVM", "body": "\r\nLower pattern like\r\n```\r\n    %5 = builtin.unrealized_conversion_cast %a : i32 to index\r\n    %6 = builtin.unrealized_conversion_cast %5 : index to i64\r\n```\r\ninto\r\n```\r\n    llvm.zext %a : i32 to i64\r\n```\r\nThis is for https://github.com/llvm/llvm-project/issues/74939", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Conversion/IndexToLLVM/IndexToLLVM.cpp", "functions": ["failure", "if", "success"]}]}
{"pr_number": 74655, "url": "https://github.com/llvm/llvm-project/pull/74655", "title": "[libc++] Fix `take_view::__sentinel`'s `operator==`", "body": "* Fix `take_view::__sentinel`'s `operator==`\r\n* Rename `ranges/range.adaptors/range.take/sentinel/base.pass.cpp` directory to `ranges/range.adaptors/range.take/range.take.sentinel/base.pass.cpp`\r\n* Add ***full*** test coverage for `take_view::__sentinel`'s `operator==`\r\n* Drive-by: fix comment in `base.pass.cpp` test\r\n* Close #55211", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "libcxx/test/std/ranges/range.adaptors/range.take/range.take.sentinel/eq.pass.cpp", "functions": ["decltype", "tv"]}, {"filename": "libcxx/test/std/ranges/range.adaptors/range.take/sentinel/eq.pass.cpp", "functions": ["tvNonConst", "main", "tvConst", "test", "tv"]}]}
{"pr_number": 74670, "url": "https://github.com/llvm/llvm-project/pull/74670", "title": "[MLIR] Fuse locations of merged constants", "body": "When merging constants by the operation folder, the location of the op that remains should be updated to track the new meaning of this op. This way we do not lose track of all possible source locations that the constant op came from, and the final location of the op is less reliant on the order of folding. This will also help debuggers understand how to step these instructions.\r\n\r\nThis PR introduces a helper for operation folder to fuse another location into the location of an op. When an op is deduplicated, fuse the location of the op to be removed into the op that is retained. The retained op now represents both original ops.\r\n\r\nThe FusedLoc will have a string metadata to help understand the reason for the location fusion (motivated by the [example](https://github.com/llvm/llvm-project/blob/71be8f3c23497e28c86f1135f564b16106d8d6fb/mlir/include/mlir/IR/BuiltinLocationAttributes.td#L130) in the docstring of FusedLoc).\r\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Transforms/Utils/FoldUtils.cpp", "functions": ["locations"]}]}
{"pr_number": 75281, "url": "https://github.com/llvm/llvm-project/pull/75281", "title": "[lsan] Install `pthread_atfork`", "body": "This prevents deadlocks in forked process on essencial\nruntime components.\n", "feature_layers": ["runtime"], "feature_directives": ["for"], "files_changed": [{"filename": "compiler-rt/lib/hwasan/hwasan.cpp", "functions": ["__hwasan_get_tag_from_pointer"]}, {"filename": "compiler-rt/test/hwasan/TestCases/tag-ptr.cpp", "functions": ["main"]}]}
{"pr_number": 74817, "url": "https://github.com/llvm/llvm-project/pull/74817", "title": "[mlir][vector] Add pattern to drop unit dim from elementwise(a, b))", "body": "For vectors with either leading or trailing unit dim, replaces:\r\n\r\n    elementwise(a, b)\r\n\r\nwith:\r\n\r\n    sc_a = shape_cast(a)\r\n    sc_b = shape_cast(b)\r\n    res = elementwise(sc_a, sc_b)\r\n    return shape_cast(res)\r\n\r\nThe newly inserted shape_cast Ops fold (before elementwise Op) and then\r\nrestore (after elementwise Op) the unit dim. Vectors `a` and `b` are\r\nrequired to be rank > 1.\r\n\r\nExample:\r\n```mlir\r\n  %mul = arith.mulf %B_row, %A_row : vector<1x[4]xf32>\r\n  %cast = vector.shape_cast %mul : vector<1x[4]xf32> to vector<[4]xf32>\r\n```\r\n\r\ngets converted to:\r\n\r\n```mlir\r\n  %B_row_sc = vector.shape_cast %B_row : vector<1x[4]xf32> to vector<[4]xf32>\r\n  %A_row_sc = vector.shape_cast %A_row : vector<1x[4]xf32> to vector<[4]xf32>\r\n  %mul = arith.mulf %B_row_sc, %A_row_sc : vector<[4]xf32>\r\n  %mul_sc = vector.shape_cast %mul : vector<[4]xf32> to vector<1x[4]xf32>\r\n  %cast = vector.shape_cast %mul_sc : vector<1x[4]xf32> to vector<[4]xf32>\r\n```\r\n\r\nIn practice, the bottom 2 shape_cast(s) will be folded away.", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Vector/Transforms/VectorTransforms.cpp", "functions": ["failure"]}]}
{"pr_number": 75375, "url": "https://github.com/llvm/llvm-project/pull/75375", "title": "[X86][FastISel] Support medium code model in more places", "body": "The medium code model is basically identical to the small code model\nexcept that large objects cannot be referenced with 32-bit offsets.\n", "feature_layers": ["ast"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/Target/X86/X86FastISel.cpp", "functions": ["if"]}]}
{"pr_number": 75280, "url": "https://github.com/llvm/llvm-project/pull/75280", "title": "[test][hwasan] Implement sanitizer_specific for HWASAN", "body": "", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "compiler-rt/lib/hwasan/hwasan.cpp", "functions": ["__hwasan_get_tag_from_pointer"]}, {"filename": "compiler-rt/test/hwasan/TestCases/tag-ptr.cpp", "functions": ["main"]}, {"filename": "compiler-rt/test/sanitizer_common/TestCases/Posix/fork_threaded.cpp", "functions": ["main", "ShouldNotDeadlock"]}]}
{"pr_number": 75291, "url": "https://github.com/llvm/llvm-project/pull/75291", "title": "[hwasan] Improve support of forking with threads", "body": "Lock Lsan and Thread related date at_fork.\n\nClean shadow before thread starts, forked process may reuse already\nmapped stack of 'lost' parent thread for new threads.\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "compiler-rt/lib/asan/asan_fuchsia.cpp", "functions": ["InstallAtForkHandler"]}, {"filename": "compiler-rt/lib/asan/asan_posix.cpp", "functions": ["InstallAtForkHandler"]}, {"filename": "compiler-rt/lib/asan/asan_win.cpp", "functions": ["InstallAtForkHandler"]}, {"filename": "compiler-rt/lib/hwasan/hwasan.cpp", "functions": ["__hwasan_get_tag_from_pointer"]}, {"filename": "compiler-rt/lib/lsan/lsan_common.cpp", "functions": ["UnlockGlobal", "LockGlobal"]}, {"filename": "compiler-rt/lib/lsan/lsan_fuchsia.cpp", "functions": ["InstallAtForkHandler"]}, {"filename": "compiler-rt/lib/lsan/lsan_posix.cpp", "functions": ["InstallAtForkHandler"]}, {"filename": "compiler-rt/test/hwasan/TestCases/tag-ptr.cpp", "functions": ["main"]}]}
{"pr_number": 72677, "url": "https://github.com/llvm/llvm-project/pull/72677", "title": "[ASan][libc++] std::basic_string annotations", "body": "This commit introduces basic annotations for `std::basic_string`, mirroring the approach used in `std::vector` and `std::deque`. Initially, only long strings with the default allocator will be annotated. Short strings (_SSO - short string optimization_) and strings with non-default allocators will be annotated in the near future, with separate commits dedicated to enabling them. The process will be similar to the workflow employed for enabling annotations in `std::deque`.\r\n\r\n**Please note**: these annotations function effectively only when libc++ and libc++abi dylibs are instrumented (with ASan). This aligns with the prevailing behavior of Memory Sanitizer.\r\n\r\nTo avoid breaking everything, this commit also appends `_LIBCPP_INSTRUMENTED_WITH_ASAN` to `__config_site` whenever libc++ is compiled with ASan. If this macro is not defined, string annotations are not enabled. However, linking a binary that does **not** annotate strings with a dynamic library that annotates strings, is not permitted.\r\n\r\nOriginally proposed here: https://reviews.llvm.org/D132769\r\n\r\nRelated patches on Phabricator:\r\n- Turning on annotations for short strings: https://reviews.llvm.org/D147680\r\n- Turning on annotations for all allocators: https://reviews.llvm.org/D146214\r\n\r\nThis PR is a part of a series of patches extending AddressSanitizer C++ container overflow detection capabilities by adding annotations, similar to those existing in `std::vector` and `std::deque` collections. These enhancements empower ASan to effectively detect instances where the instrumented program attempts to access memory within a collection's internal allocation that remains unused. This includes cases where access occurs before or after the stored elements in `std::deque`, or between the `std::basic_string`'s size (including the null terminator) and capacity bounds.\r\n\r\nThe introduction of these annotations was spurred by a real-world software bug discovered by Trail of Bits, involving an out-of-bounds memory access during the comparison of two strings using the `std::equals` function. This function was taking iterators (`iter1_begin`, `iter1_end`, `iter2_begin`) to perform the comparison, using a custom comparison function. When the `iter1` object exceeded the length of `iter2`, an out-of-bounds read could occur on the `iter2` object. Container sanitization, upon enabling these annotations, would effectively identify and flag this potential vulnerability.\r\n\r\nThis Pull Request introduces basic annotations for `std::basic_string`. Long strings exhibit structural similarities to `std::vector` and will be annotated accordingly. Short strings are already implemented, but will be turned on separately in a forthcoming commit. Look at [a comment](https://github.com/llvm/llvm-project/pull/72677#issuecomment-1850554465) below to read about SSO issues at current moment.\r\n\r\nDue to the functionality introduced in [D132522](https://github.com/llvm/llvm-project/commit/dd1b7b797a116eed588fd752fbe61d34deeb24e4), the `__sanitizer_annotate_contiguous_container` function now offers compatibility with all allocators. However, enabling this support will be done in a subsequent commit. For the time being, only strings with the default allocator will be annotated.\r\n\r\nIf you have any questions, please email:\r\n- advenam.tacet@trailofbits.com\r\n- disconnect3d@trailofbits.com", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "libcxx/test/std/strings/basic.string/string.capacity/reserve_size.asan.pass.cpp", "functions": ["short_s1", "test", "main", "short_s2"]}, {"filename": "libcxx/test/std/strings/basic.string/string.modifiers/string_erase/pop_back.asan.pass.cpp", "functions": ["test", "main"]}, {"filename": "libcxx/test/std/strings/basic.string/string.modifiers/string_swap/swap.asan.pass.cpp", "functions": ["long_s", "main", "test", "long_s3", "short_s", "long_s2"]}]}
{"pr_number": 75258, "url": "https://github.com/llvm/llvm-project/pull/75258", "title": "[MLIR] Fuse parent region location when hoisting constants", "body": "Followup on #74670.\r\n\r\nWhen operation folder hoists constants, the constant op that is moved (or materialized elsewhere) should have its location fused with the location of the parent region of its insertion point. This is to reflect the new meaning of this constant op, which is that it is created at the front of the region to be used by any op in the body if it needs such a constant.\r\n\r\nThis is motivated by the same reason as a similar change in LLVM (https://reviews.llvm.org/D38088): Keeping the original location will cause stepping in a debugger to be out of order. If we use the following psuedocode as example, after op folding today, the stepping behavior will be in the order of:\r\n- Line 2: initialization instructions for the constant 8 (assume non-trivial)\r\n- Line 1: instructions for printing `arg`\r\n- Line 2: instructions for printing 8\r\n```\r\nvoid example(int arg) {\r\n    print(arg)    # Line 1\r\n    print(8)      # Line 2\r\n    ...\r\n}\r\n```\r\n\r\nThis implies that whatever code that initializes the constant at the front of this function cannot be considered solely to be the result of line 2. In LLVM, the solution was to merge the location of the insertion point instruction. In this case, it'll return a location corresponding to the parent scope (which is this function). For us, since MLIR allows carrying around multiple locations as a result of optimizations, we can take advantage of that and just fuse the location of the parent region. This will make the hoisted ops look similar to other source-dependent setup code that may exist in the front of a function already, in that they also carry the location of the function. Backends will then be able to differentiate what belongs in the prologue of a function and instruct the debugger accordingly.\r\n\r\nPlease LMK if anything about this isn't clear. Thanks!", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Transforms/Utils/FoldUtils.cpp", "functions": ["FlattenFusedLocationRecursively"]}]}
{"pr_number": 74811, "url": "https://github.com/llvm/llvm-project/pull/74811", "title": "[CommandLine] Better report unknown subcommands", "body": "The patch improves the reporting for the first option in the command line when it looks like a subcommand name but does not match any defined.\r\n\r\nBefore the patch:\r\n```\r\n> prog baz\r\nprog: Unknown command line argument 'baz'.  Try: 'prog --help'\r\n```\r\n\r\nWith the patch:\r\n```\r\n> prog baz\r\nprog: Unknown subcommand 'baz'.  Try: 'prog --help'\r\nprog: Did you mean 'bar'?\r\n```", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Support/CommandLine.cpp", "functions": ["hasNamedSubCommands", "PrintArg"]}, {"filename": "llvm/unittests/Support/CommandLineTest.cpp", "functions": ["SC2", "TopOpt1", "SC2Opt", "OS", "TopOpt2", "SC1Opt", "SC1"]}]}
{"pr_number": 75423, "url": "https://github.com/llvm/llvm-project/pull/75423", "title": "[mlir] Fix loop pipelining when the operand of `yield` is not defined in the loop body", "body": "", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/SCF/Transforms/LoopPipelining.cpp", "functions": ["if"]}]}
{"pr_number": 75289, "url": "https://github.com/llvm/llvm-project/pull/75289", "title": "[clang] Parse attribute [[gnu::no_stack_protector]]", "body": "This commit adds relative TableGen definitions to parse the `[[gnu::no_stack_protector]]` attribute.\r\n\r\nThis PR addresses issue #75235.", "feature_layers": ["parse"], "feature_directives": [], "files_changed": [{"filename": "clang/test/Parser/gnu-attributes.c", "functions": ["test1"]}, {"filename": "clang/test/Parser/gnu-attributes.cpp", "functions": ["test1"]}, {"filename": "clang/test/Sema/no_stack_protector.c", "functions": ["test2", "test1"]}, {"filename": "clang/test/Sema/no_stack_protector.cpp", "functions": ["test2", "test1"]}]}
{"pr_number": 74824, "url": "https://github.com/llvm/llvm-project/pull/74824", "title": "[RISCV] Add support for experimental Zimop extension", "body": "This implements experimental support for the Zimop extension as specified here:\r\nhttps://github.com/riscv/riscv-isa-manual/blob/main/src/zimop.adoc.\r\n\r\nThis change adds intrinsics of mop.r.[n] and mop.rr.[n] instructions for Zimop extension based on \r\nhttps://github.com/riscv-non-isa/riscv-c-api-doc/blob/master/riscv-c-api.md. \r\n", "feature_layers": ["ast"], "feature_directives": ["for", "master"], "files_changed": [{"filename": "clang/lib/Sema/SemaChecking.cpp", "functions": ["SemaBuiltinConstantArgRange"]}, {"filename": "clang/test/CodeGen/RISCV/rvb-intrinsics/zimop.c", "functions": ["moprr_7_32", "__builtin_riscv_mopr_64", "__builtin_riscv_moprr_32", "moprr_7_64", "mopr_31_32", "mopr_0_64", "mopr_31_64", "mopr_0_32", "moprr_0_32", "moprr_0_64", "__builtin_riscv_mopr_32", "__builtin_riscv_moprr_64"]}]}
{"pr_number": 75403, "url": "https://github.com/llvm/llvm-project/pull/75403", "title": "[DebugInfo] Pass string ownership to MarkupFilter", "body": "Last `getline` call destroys `InputString`, and `finish` accesses dead `StringRef`.\r\n\r\nDetected with #72677.\r\n\r\nFixes https://lab.llvm.org/buildbot/#/builders/sanitizer-x86_64-linux-fast", "feature_layers": ["ast"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/DebugInfo/Symbolize/MarkupFilter.cpp", "functions": ["StringRef"]}]}
{"pr_number": 74854, "url": "https://github.com/llvm/llvm-project/pull/74854", "title": "[MLIR][SCFToOpenMP] Add num-threads option", "body": "Add `num-threads` option to the `-convert-scf-to-openmp` pass, allowing to set the number of threads to be used in the `omp.parallel` to a fixed value.", "feature_layers": ["ir"], "feature_directives": ["parallel"], "files_changed": [{"filename": "mlir/lib/Conversion/SCFToOpenMP/SCFToOpenMP.cpp", "functions": ["applyPatterns"]}]}
{"pr_number": 72797, "url": "https://github.com/llvm/llvm-project/pull/72797", "title": "[M68k] Fix ODR violation in GISel code", "body": "It prevents LLVM from being linked with LLD at least on Windows, with errors like this:\r\n\r\n```\r\n  = note: ld.lld: error: duplicate symbol: vtable for llvm::FormalArgHandler\r\n          >>> defined at librustc_llvm-a81737dd65a7c126.rlib(M68kCallLowering.cpp.obj)\r\n          >>> defined at librustc_llvm-a81737dd65a7c126.rlib(PPCCallLowering.cpp.obj)\r\n```\r\n\r\nBinutils linker also complains about this, but only with warnings.\r\n\r\n`FormalArgHandler` has a base class `M68kIncomingValueHandler` which doesn't have a virtual method `markPhysRegUsed` like `IncomingValueHandler`s for all other targets including PPC, so it results in a conflict.\r\nThe simplest fix is to rename the `FormalArgHandler` structure (rather than to add virtual methods for compatibility).\r\n\r\ncc https://github.com/rust-lang/rust/issues/107668", "feature_layers": ["ir", "ast"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "llvm/lib/Target/M68k/GISel/M68kCallLowering.cpp", "functions": ["M68kIncomingValueHandler", "ArgHandler"]}]}
{"pr_number": 74853, "url": "https://github.com/llvm/llvm-project/pull/74853", "title": "[AMDGPU] Update VOP instructions for GFX12", "body": "", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/Disassembler/AMDGPUDisassembler.cpp", "functions": ["if"]}, {"filename": "llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.cpp", "functions": ["getVOPDEncodingFamily", "getVOPDFull"]}]}
{"pr_number": 75326, "url": "https://github.com/llvm/llvm-project/pull/75326", "title": "[AArch64][SME2] Add builtins for SQDMULH", "body": "Patch by: Kerry McLaughlin <kerry.mclaughlin@arm.com>", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CodeGen/aarch64-sme2-intrinsics/acle_sme2_sqdmulh.c", "functions": ["test_svqdmulh_s32_x4", "test_svqdmulh_s8_x4", "test_svqdmulh_single_s8_x2", "test_svqdmulh_single_s64_x2", "test_svqdmulh_single_s8_x4", "test_svqdmulh_single_s32_x4", "test_svqdmulh_s32_x2", "test_svqdmulh_s8_x2", "test_svqdmulh_single_s16_x4", "test_svqdmulh_single_s32_x2", "test_svqdmulh_s16_x2", "test_svqdmulh_s64_x4", "test_svqdmulh_s64_x2", "test_svqdmulh_s16_x4", "test_svqdmulh_single_s16_x2", "test_svqdmulh_single_s64_x4", "SVE_ACLE_FUNC"]}]}
{"pr_number": 75047, "url": "https://github.com/llvm/llvm-project/pull/75047", "title": "[flang][MLIR][OpenMP] Add support for `target update` directive.", "body": "Add an op in the OMP dialect to model the `target update` direcive. This change reuses the `MapInfoOp` used by other device directive to model `map` clauses but verifies that the restrictions imposed by the `target update` directive are respected.", "feature_layers": ["ir"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "mlir/lib/Dialect/OpenMP/IR/OpenMPDialect.cpp", "functions": ["emitError", "verifyMapClause"]}]}
{"pr_number": 75370, "url": "https://github.com/llvm/llvm-project/pull/75370", "title": "[InstCombine] Improve `foldICmpWithDominatingICmp` with DomConditionCache", "body": "This patch uses affected values from DomConditionCache(introduced by #73662), instead of a cheap/incomplete check `getSinglePredecessor`.\r\n\r\nCompile-time impact: http://llvm-compile-time-tracker.com/compare.php?from=930b5b52ffe699dbcf05eea32d12a2861dd2bdf6&to=8032c74ff972786c96251be21b71eefe18c89740&stat=instructions:u", "feature_layers": [], "feature_directives": ["single"], "files_changed": [{"filename": "llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp", "functions": ["Edge0", "Edge1"]}]}
{"pr_number": 75325, "url": "https://github.com/llvm/llvm-project/pull/75325", "title": "[AArch64][SME2] Add SQRSHRN, UQRSHRN, SQRSHRUN builtins for SME2, SVE2p1", "body": "Add SQRSHRN, UQRSHRN, SQRSHRUN builtins for SME2, SVE2p1.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_qrshr.c", "functions": ["test_svqrshrun_u16_s32_x2", "test_svqrshrn_u16_u32_x2", "SVE_ACLE_FUNC", "test_svqrshrn_s16_s32_x2"]}]}
{"pr_number": 69611, "url": "https://github.com/llvm/llvm-project/pull/69611", "title": "[ARM] Do not emit unwind tables when saving LR around outlined call", "body": "In some cases, the machine outliner needs to preserve LR across an\r\noutlined call by pushing it onto the stack. Previously, this also\r\ngenerated unwind table instructions, which is incorrect because EHABI\r\nunwind tables cannot represent different stack frames a different points\r\nin the function, so the extra unwind info applied to the entire\r\nfunction.\r\n\r\nThe outliner code already avoided generating CFI instructions, but EHABI\r\nunwind data is generated later from the actual instructions, so we need\r\nto avoid using the FrameSetup and FrameDestroy flags to prevent unwind\r\ndata being generated.\r\n\r\nThis is my first multi-commit change done through github, it it OK to do this as one PR, or should I raise separate PRs for the two preparatory commits?", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/ARM/ARMMachineFunctionInfo.cpp", "functions": ["LRSpilled"]}]}
{"pr_number": 73859, "url": "https://github.com/llvm/llvm-project/pull/73859", "title": "[SystemZ][z/OS] yaml2obj for header and end records", "body": "This PR implements part 1 of yaml2obj for the GOFF Object File Format. It adds support for the header and end records.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/ObjectYAML/GOFFEmitter.cpp", "functions": ["fillRecord", "write_impl", "makeNewRecord", "current_pos", "binaryBe"]}, {"filename": "llvm/lib/ObjectYAML/yaml2obj.cpp", "functions": ["yaml2goff"]}]}
{"pr_number": 75409, "url": "https://github.com/llvm/llvm-project/pull/75409", "title": "[RISCV][InsertSETVTLI] Handle large immediates in backwards walk", "body": "When doing our backwards walk, we were not handling the case where the AVL was defined by a register whose definition was an ADDI xN, x0, <imm>. Doing so (as we already do in the forward pass) allows us to prune a few more transitions.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp", "functions": ["isNonZeroAVL"]}]}
{"pr_number": 71360, "url": "https://github.com/llvm/llvm-project/pull/71360", "title": "[VPlan] Implement mayHaveSideEffects/mayWriteToMemory for VPInterleav\u2026", "body": "\u2026eRecipe\r\n\r\nThis helps VPlanTransforms::removeDeadRecipes to work on VPInterleaveRecipe", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp", "functions": ["mayWriteToMemory"]}]}
{"pr_number": 74717, "url": "https://github.com/llvm/llvm-project/pull/74717", "title": "[Libomptarget] Move ELF symbol extraction to the ELF utility", "body": "Summary:\nWe shouldn't have the format specific ELF handling in the generic plugin\nmanager. This patch moves that out of the implementation and into the\nELF utilities. This patch changes the SHT_NOBITS case to be a hard\nerror, which should be correct as the existing use already seemed to\nreturn an error if the result was a null pointer.\n\nThis also uses a `const_cast`, which is bad practice. However,\nrebuilding the `constness` of all of this would be a massive overhaul,\nand this matches the previous behaviour (We would take a pointer to the\nimage that is most likely read-only in the ELF).\n", "feature_layers": ["ast"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "openmp/libomptarget/plugins-nextgen/common/src/GlobalHandler.cpp", "functions": ["getGlobalMetadataFromELF"]}, {"filename": "openmp/libomptarget/plugins-nextgen/common/src/Utils/ELF.cpp", "functions": ["createError"]}]}
{"pr_number": 75430, "url": "https://github.com/llvm/llvm-project/pull/75430", "title": "[mlir] Fix type transformation in DropUnitDimFromElementwiseOps", "body": "Use operand and result types to build the corresponding new types in `DropUnitDimFromElementwiseOps`.\r\n\r\nElementwise ops only guarantee to have the same shape on their operands and results, but don't guarantee to have the same element type.\r\n\r\nThis change also enhances the preconditions.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Vector/Transforms/VectorTransforms.cpp", "functions": ["failure"]}]}
{"pr_number": 73126, "url": "https://github.com/llvm/llvm-project/pull/73126", "title": "[X86] X86DAGToDAGISel - attempt to merge XMM/YMM loads with YMM/ZMM loads of the same ptr", "body": "If we are loading the same ptr at different vector widths, then reuse the larger load and just extract the low subvector.\r\n\r\nThis is mainly useful for better constant sharing.\r\n\r\nUnlike the equivalent VBROADCAST_LOAD/SUBV_BROADCAST_LOAD folds which can occur in DAG, we have to wait until DAGISel otherwise we can hit infinite loops if constant folding recreates the original constant value.", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/X86/X86ISelDAGToDAG.cpp", "functions": ["dl"]}]}
{"pr_number": 75381, "url": "https://github.com/llvm/llvm-project/pull/75381", "title": "Revert \"[MLIR] Fuse locations of merged constants (#74670)\"", "body": "This reverts commit 87e2e89019ec4405fa47c3b4585be4e67473b590\nand its follow-up 0d1490f09f23bf204b714c3c6ba5e0aaf4eeed9a (#75218).\n\nWe observed significant OOM/timeout issues due to #74670 to quite a few\nservices including google-research/swirl-lm. The follow-up 75218 does\nnot address the issue. Perhaps this is worth more investigation.\n", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Transforms/Utils/FoldUtils.cpp", "functions": ["locations", "FlattenFusedLocationRecursively"]}]}
{"pr_number": 73686, "url": "https://github.com/llvm/llvm-project/pull/73686", "title": "[llvm] Support IFuncs on Darwin platforms", "body": "... by lowering them as lazy resolve-on-first-use symbol resolvers. Note that\nthis is subtly different timing than on ELF platforms, where ifunc resolution\nhappens at load time.\n\nSince ld64 and ld-prime don't support all the cases we need for these, there is\na manual fallback lowering.\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/IR/Verifier.cpp", "functions": ["T"]}, {"filename": "llvm/lib/Target/AArch64/AArch64AsmPrinter.cpp", "functions": ["emitManualSymbolResolver", "emitLinkerSymbolResolver", "if"]}, {"filename": "llvm/lib/Target/X86/X86AsmPrinter.cpp", "functions": ["if"]}, {"filename": "llvm/lib/CodeGen/GlobalISel/CallLowering.cpp", "functions": ["if"]}]}
{"pr_number": 73687, "url": "https://github.com/llvm/llvm-project/pull/73687", "title": "[clang] Support __attribute__((ifunc(...))) on Darwin platforms", "body": "Unlike ELF targets, MachO does not support the same kind of dynamic symbol\nresolution at load time.  Instead, the corresponding MachO feature resolves\nsymbols lazily on first call.\n", "feature_layers": ["ir"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "llvm/lib/IR/Verifier.cpp", "functions": ["T"]}, {"filename": "llvm/lib/Target/AArch64/AArch64AsmPrinter.cpp", "functions": ["emitManualSymbolResolver", "emitLinkerSymbolResolver", "if"]}, {"filename": "llvm/lib/Target/X86/X86AsmPrinter.cpp", "functions": ["if"]}, {"filename": "clang/test/CodeGen/attr-ifunc.c", "functions": ["f1", "f1a", "__attribute__"]}, {"filename": "llvm/lib/CodeGen/GlobalISel/CallLowering.cpp", "functions": ["if"]}, {"filename": "lldb/test/API/tools/lldb-dap/commands/main.cpp", "functions": ["main"]}, {"filename": "lldb/tools/lldb-dap/DAP.cpp", "functions": ["createRunLLDBCommandsErrorMessage"]}, {"filename": "openmp/runtime/src/kmp_runtime.cpp", "functions": ["abort"]}]}
{"pr_number": 73688, "url": "https://github.com/llvm/llvm-project/pull/73688", "title": "[clang] Function Multi Versioning supports IFunc lowerings on Darwin platforms", "body": "", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/IR/Verifier.cpp", "functions": ["T"]}, {"filename": "llvm/lib/Target/AArch64/AArch64AsmPrinter.cpp", "functions": ["emitManualSymbolResolver", "emitLinkerSymbolResolver", "if"]}, {"filename": "llvm/lib/Target/X86/X86AsmPrinter.cpp", "functions": ["if"]}, {"filename": "clang/test/CodeGen/attr-ifunc.c", "functions": ["f1", "f1a", "__attribute__"]}, {"filename": "llvm/lib/CodeGen/GlobalISel/CallLowering.cpp", "functions": ["if"]}]}
{"pr_number": 74902, "url": "https://github.com/llvm/llvm-project/pull/74902", "title": "[GlobalISel] Always direct-call IFuncs and Aliases", "body": "This is safe because for both cases, the use must be in the same TU as the\ndefinition, and they cannot be forward delcared.\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CodeGen/attr-ifunc.c", "functions": ["f1", "f1a", "__attribute__"]}, {"filename": "compiler-rt/lib/builtins/cpu_model.c", "functions": ["__init_cpu_features_resolver", "isKnownAndSupported"]}, {"filename": "llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp", "functions": ["TextAlign", "if"]}, {"filename": "llvm/lib/IR/Verifier.cpp", "functions": ["T"]}]}
{"pr_number": 69493, "url": "https://github.com/llvm/llvm-project/pull/69493", "title": "[Profile] Add binary profile correlation for code coverage.", "body": "## Motivation\r\nSince we don't need the metadata sections at runtime, we can somehow offload them from memory at runtime. Initially, I explored [debug info correlation](https://discourse.llvm.org/t/instrprofiling-lightweight-instrumentation/59113), which is used for PGO with value profiling disabled. However, it currently only works with DWARF and it's be hard to add such artificial debug info for every function in to CodeView which is used on Windows. So, offloading profile metadata sections at runtime seems to be a platform independent option.\r\n\r\n## Design\r\nThe idea is to use new section names for profile name and data sections and mark them as metadata sections. Under this mode, the new sections are non-SHF_ALLOC in ELF. So, they are not loaded into memory at runtime and can be stripped away as a post-linking step. After the process exits, the generated raw profiles will contains only headers + counters. llvm-profdata can be used correlate raw profiles with the unstripped binary to generate indexed profile.\r\n\r\n## Data\r\nFor chromium base_unittests with code coverage on linux, the binary size overhead due to instrumentation reduced from 64M to 38.8M (39.4%) and the raw profile files size reduce from 128M to 68M (46.9%)\r\n```\r\n$ bloaty out/cov/base_unittests.stripped -- out/no-cov/base_unittests.stripped\r\n    FILE SIZE        VM SIZE\r\n --------------  --------------\r\n  +121% +30.4Mi  +121% +30.4Mi    .text\r\n  [NEW] +14.6Mi  [NEW] +14.6Mi    __llvm_prf_data\r\n  [NEW] +10.6Mi  [NEW] +10.6Mi    __llvm_prf_names\r\n  [NEW] +5.86Mi  [NEW] +5.86Mi    __llvm_prf_cnts\r\n   +95% +1.75Mi   +95% +1.75Mi    .eh_frame\r\n  +108%  +400Ki  +108%  +400Ki    .eh_frame_hdr\r\n  +9.5%  +211Ki  +9.5%  +211Ki    .rela.dyn\r\n  +9.2% +95.0Ki  +9.2% +95.0Ki    .data.rel.ro\r\n  +5.0% +87.3Ki  +5.0% +87.3Ki    .rodata\r\n  [ = ]       0   +13% +47.0Ki    .bss\r\n   +40% +1.78Ki   +40% +1.78Ki    .got\r\n   +12% +1.49Ki   +12% +1.49Ki    .gcc_except_table\r\n  [ = ]       0   +65% +1.23Ki    .relro_padding\r\n   +62% +1.20Ki  [ = ]       0    [Unmapped]\r\n   +13%    +448   +19%    +448    .init_array\r\n  +8.8%    +192  [ = ]       0    [ELF Section Headers]\r\n  +0.0%    +136  +0.0%     +80    [7 Others]\r\n  +0.1%     +96  +0.1%     +96    .dynsym\r\n  +1.2%     +96  +1.2%     +96    .rela.plt\r\n  +1.5%     +80  +1.2%     +64    .plt\r\n  [ = ]       0 -99.2% -3.68Ki    [LOAD #5 [RW]]\r\n  +195% +64.0Mi  +194% +64.0Mi    TOTAL\r\n$ bloaty out/cov-cor/base_unittests.stripped -- out/no-cov/base_unittests.stripped\r\n    FILE SIZE        VM SIZE\r\n --------------  --------------\r\n  +121% +30.4Mi  +121% +30.4Mi    .text\r\n  [NEW] +5.86Mi  [NEW] +5.86Mi    __llvm_prf_cnts\r\n   +95% +1.75Mi   +95% +1.75Mi    .eh_frame\r\n  +108%  +400Ki  +108%  +400Ki    .eh_frame_hdr\r\n  +9.5%  +211Ki  +9.5%  +211Ki    .rela.dyn\r\n  +9.2% +95.0Ki  +9.2% +95.0Ki    .data.rel.ro\r\n  +5.0% +87.3Ki  +5.0% +87.3Ki    .rodata\r\n  [ = ]       0   +13% +47.0Ki    .bss\r\n   +40% +1.78Ki   +40% +1.78Ki    .got\r\n   +12% +1.49Ki   +12% +1.49Ki    .gcc_except_table\r\n   +13%    +448   +19%    +448    .init_array\r\n  +0.1%     +96  +0.1%     +96    .dynsym\r\n  +1.2%     +96  +1.2%     +96    .rela.plt\r\n  +1.2%     +64  +1.2%     +64    .plt\r\n  +2.9%     +64  [ = ]       0    [ELF Section Headers]\r\n  +0.0%     +40  +0.0%     +40    .data\r\n  +1.2%     +32  +1.2%     +32    .got.plt\r\n  +0.0%     +24  +0.0%      +8    [5 Others]\r\n  [ = ]       0 -22.9%    -872    [LOAD #5 [RW]]\r\n -74.5% -1.44Ki  [ = ]       0    [Unmapped]\r\n  [ = ]       0 -76.5% -1.45Ki    .relro_padding\r\n  +118% +38.8Mi  +117% +38.8Mi    TOTAL\r\n```\r\n\r\nA few things to note:\r\n1. llvm-profdata doesn't support filter raw profiles by binary id yet, so when a raw profile doesn't belongs to the binary being digested by llvm-profdata, merging will fail. Once this is implemented, llvm-profdata should be able to only merge raw profiles with the same binary id as the binary and discard the rest (with mismatched/missing binary id). The workflow I have in mind is to have scripts invoke llvm-profdata to get all binary ids for all raw profiles, and selectively choose the raw pnrofiles with matching binary id and the binary to llvm-profdata for merging.\r\n2. Note: In COFF, currently they are still loaded into memory but not used. I didn't do it in this patch because I noticed that `.lcovmap` and `.lcovfunc` are loaded into memory. A separate patch will address it.\r\n3. This should works with PGO when value profiling is disabled as debug info correlation currently doing, though I haven't tested this yet.", "feature_layers": ["runtime"], "feature_directives": ["for", "sections"], "files_changed": [{"filename": "clang/lib/CodeGen/CoverageMappingGen.cpp", "functions": ["TT", "VarName"]}, {"filename": "clang/test/CodeGen/coverage-profile-raw-version.c", "functions": ["main"]}, {"filename": "compiler-rt/lib/profile/InstrProfilingBuffer.c", "functions": ["__llvm_profile_get_name_size"]}, {"filename": "llvm/lib/ProfileData/InstrProfCorrelator.cpp", "functions": ["get", "getCountersSection"]}, {"filename": "llvm/lib/ProfileData/InstrProfReader.cpp", "functions": ["error"]}, {"filename": "llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp", "functions": ["getInstrProfSectionName"]}]}
{"pr_number": 75366, "url": "https://github.com/llvm/llvm-project/pull/75366", "title": "[OptTable] Make new lines in help text respect indentation", "body": "With this changes, new lines in the HelpText defined in OptTable have the same indentation as the first line.\r\n\r\nBefore, the help output will look something like:\r\n\r\n```\r\n--color=<value>       Whether to use color when\r\nsymbolizing log markup: always, auto, never\r\n```\r\n\r\nWith this change:\r\n\r\n```\r\n--color=<value>       Whether to use color when\r\n                      symbolizing log markup: always, auto, never\r\n```", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/unittests/Option/OptionParsingTest.cpp", "functions": ["RSO"]}]}
{"pr_number": 75474, "url": "https://github.com/llvm/llvm-project/pull/75474", "title": "[StandardInstrumentations] add `unwrapIR` to simplify code NFCI", "body": "Use pointer to represent semantic of `optional`.", "feature_layers": ["sema", "ir"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/Passes/StandardInstrumentations.cpp", "functions": ["isInterestingFunction", "moduleContainsFilterPrintFunc", "isFunctionInPrintList", "sccContainsFilterPrintFunc"]}]}
{"pr_number": 73603, "url": "https://github.com/llvm/llvm-project/pull/73603", "title": "[llvm][Support] Add UNIX socket support", "body": "This adds support for UNIX socket communication to work similarly to raw_stream.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Support/raw_ostream.cpp", "functions": ["GetSocketFD", "getLastSocketErrorCode"]}, {"filename": "llvm/unittests/Support/raw_socket_stream_test.cpp", "functions": ["string", "SocketPath"]}]}
{"pr_number": 74015, "url": "https://github.com/llvm/llvm-project/pull/74015", "title": "[mlir][SCF] Add support for peeling the first iteration out of the loop", "body": "There is a use case that we need to peel the first iteration out of the for loop so that the peeled forOp can be canonicalized away and the fillOp can be fused into the inner forall loop. For example, we have nested loops as below\r\n\r\n```\r\n  linalg.fill ins(...) outs(...)\r\n  scf.for %arg = %lb to %ub step %step\r\n    scf.forall ...\r\n```\r\n\r\nAfter the peeling transform, it is expected to be\r\n\r\n```\r\n  scf.forall ...\r\n    linalg.fill ins(...) outs(...)\r\n  scf.for %arg = %(lb + step) to %ub step %step\r\n    scf.forall ...\r\n```\r\n\r\nThis patch makes the most use of the existing peeling functions and adds support for peeling the first iteration out of the loop.\r\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/SCF/Transforms/LoopSpecialization.cpp", "functions": ["failure", "success"]}]}
{"pr_number": 74684, "url": "https://github.com/llvm/llvm-project/pull/74684", "title": "[llvm][NVPTX] Inform that 'DYNAMIC_STACKALLOC' is unsupported", "body": "Catch unsupported path early up, and emit error with information.\r\n\r\nMotivated by the following threads:\r\n* https://discourse.llvm.org/t/nvptx-problems-with-dynamic-alloca/70745\r\n* #64017", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp", "functions": ["LowerDYNAMIC_STACKALLOC"]}]}
{"pr_number": 75069, "url": "https://github.com/llvm/llvm-project/pull/75069", "title": "[clang] Substitute alias templates from correct context", "body": "Current context set to where alias was met, not where it is declared caused incorrect access check in case alias referenced private members of the parent class.\r\nThis is a recommit of 6b1aa31 with a slight modification in order to fix reported regression.\r\n\r\nFixes https://github.com/llvm/llvm-project/issues/41693", "feature_layers": [], "feature_directives": ["declare"], "files_changed": [{"filename": "clang/lib/Sema/SemaTemplate.cpp", "functions": ["SavedContext"]}, {"filename": "clang/test/SemaCXX/alias-template.cpp", "functions": ["Impl", "foo"]}]}
{"pr_number": 75376, "url": "https://github.com/llvm/llvm-project/pull/75376", "title": "[mlir][tosa] Add verifier for `tosa.transpose`", "body": "This patch adds a verifier to `tosa.transpose` which fixes a crash.\r\n\r\nRelated: https://github.com/llvm/llvm-project/pull/74367\r\n\r\nFix https://github.com/llvm/llvm-project/issues/74479", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Tosa/IR/TosaOps.cpp", "functions": ["emitOpError", "success"]}]}
{"pr_number": 75561, "url": "https://github.com/llvm/llvm-project/pull/75561", "title": "Revert \"[RISCV] Support printing immediate of RISCV MCInst in hexadecimal format\"", "body": "Reverts llvm/llvm-project#74053\r\n\r\nBreaks https://lab.llvm.org/buildbot/#/builders/5/builds/39291", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/MCTargetDesc/RISCVInstPrinter.cpp", "functions": ["formatImm"]}]}
{"pr_number": 75436, "url": "https://github.com/llvm/llvm-project/pull/75436", "title": "[AMDGPU][SIInsertWaitcnts] Set initial state for VS_CNT in non-kernel functions", "body": "Split from #72830 ", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp", "functions": ["setNonKernelFunctionInitialState"]}]}
{"pr_number": 74713, "url": "https://github.com/llvm/llvm-project/pull/74713", "title": "[X86][MC] Support Enc/Dec for EGPR for promoted MOVDIR instruction", "body": "R16-R31 was added into GPRs in https://github.com/llvm/llvm-project/pull/70958,\r\nThis patch supports the encoding/decoding for promoted MOVDIR instruction in EVEX space.\r\n\r\nRFC: https://discourse.llvm.org/t/rfc-design-for-apx-feature-egpr-and-ndd-support/73031/4", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/utils/TableGen/X86RecognizableInstr.cpp", "functions": ["if"]}, {"filename": "llvm/utils/TableGen/X86DisassemblerTables.cpp", "functions": ["if"]}]}
{"pr_number": 74836, "url": "https://github.com/llvm/llvm-project/pull/74836", "title": "[AMDGPU] GFX12: Add Split Workgroup Barrier", "body": "", "feature_layers": [], "feature_directives": ["barrier"], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/AMDGPUInstructionSelector.cpp", "functions": ["getNamedBarrierOp", "selectSBarrierSignalIsfirst", "selectNamedBarrierInst", "selectSBarrierLeave"]}, {"filename": "llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp", "functions": ["isSplitBarrier"]}, {"filename": "llvm/lib/Target/AMDGPU/Disassembler/AMDGPUDisassembler.cpp", "functions": ["addOperand", "decodeSrcOp"]}, {"filename": "llvm/lib/Target/AMDGPU/SIISelLowering.cpp", "functions": ["SDValue"]}]}
{"pr_number": 75466, "url": "https://github.com/llvm/llvm-project/pull/75466", "title": "[Flang] Remove kind from CountOp", "body": "The kind is already represented in the return type of the operation. Like we did for minloc, this removes the kind parameter from CountOp.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Optimizer/HLFIR/Transforms/LowerHLFIRIntrinsics.cpp", "functions": ["getKindForType"]}]}
{"pr_number": 75450, "url": "https://github.com/llvm/llvm-project/pull/75450", "title": "[Flang] HLFIR maxloc intrinsic", "body": "Similar to minloc from #74436, this adds a hlfir maxloc intrinsic so that we can keep them symmetrical. It's just a bit of copy and pasting.", "feature_layers": ["ir", "ast"], "feature_directives": [], "files_changed": [{"filename": "flang/lib/Optimizer/HLFIR/IR/HLFIROps.cpp", "functions": ["emitOpError", "verifyResultForMinMaxLoc"]}]}
{"pr_number": 75349, "url": "https://github.com/llvm/llvm-project/pull/75349", "title": "AMDGPU: refactor phi lowering from SILowerI1Copies (NFCI)", "body": "Make abstract class PhiLoweringHelper and expose it for use in GlobalISel path.\r\nSILowerI1Copies implements PhiLoweringHelper as Vreg1LoweringHelper and it is equivalent to SILowerI1Copies.\r\nNotable change that createLaneMaskReg now clones attributes from register that has lane mask attributes instead of creating register with lane mask register class. This is because lane masks have different(more) attributes in GlobalISel.\r\n\r\npatch 2 from: https://github.com/llvm/llvm-project/pull/73337", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/SILowerI1Copies.cpp", "functions": ["lowerPhis", "isLaneMaskReg", "lowerCopiesFromI1", "Reg", "markAsLaneMask", "cleanConstrainRegs", "PhiLoweringHelper", "isConstantLaneMask", "Helper", "lowerCopiesToI1", "insertUndefLaneMask", "MF", "constrainIncomingRegisterTakenAsIs", "createLaneMaskReg"]}]}
{"pr_number": 74834, "url": "https://github.com/llvm/llvm-project/pull/74834", "title": "[mlir][vector] Add emulation patterns for vector masked load/store", "body": "In this patch, it will convert\r\n\r\n```\r\nvector.maskedload %base[%idx_0, %idx_1], %mask, %pass_thru\r\n```\r\n\r\nto\r\n\r\n```\r\n%ivalue = %pass_thru\r\n%m = vector.extract %mask[0]\r\n%result0 = scf.if %m {\r\n  %v = memref.load %base[%idx_0, %idx_1]\r\n  %combined = vector.insert %v, %ivalue[0]\r\n  scf.yield %combined\r\n} else {\r\n  scf.yield %ivalue\r\n}\r\n%m = vector.extract %mask[1]\r\n%result1 = scf.if %m {\r\n  %v = memref.load %base[%idx_0, %idx_1 + 1]\r\n  %combined = vector.insert %v, %result0[1]\r\n  scf.yield %combined\r\n} else {\r\n  scf.yield %result0\r\n}\r\n...\r\n```\r\n\r\nIt will convert\r\n\r\n```\r\nvector.maskedstore %base[%idx_0, %idx_1], %mask, %value\r\n```\r\n\r\nto\r\n\r\n```\r\n%m = vector.extract %mask[0]\r\nscf.if %m {\r\n  %extracted = vector.extract %value[0]\r\n  memref.store %extracted, %base[%idx_0, %idx_1]\r\n}\r\n%m = vector.extract %mask[1]\r\nscf.if %m {\r\n  %extracted = vector.extract %value[1]\r\n  memref.store %extracted, %base[%idx_0, %idx_1 + 1]\r\n}\r\n...\r\n```", "feature_layers": ["ir"], "feature_directives": ["for", "masked"], "files_changed": [{"filename": "mlir/lib/Dialect/Vector/Transforms/VectorEmulateMaskedLoadStore.cpp", "functions": ["success"]}, {"filename": "mlir/test/lib/Dialect/Vector/TestVectorTransforms.cpp", "functions": ["runOnOperation", "getArgument", "patterns", "getDependentDialects", "getDescription"]}]}
{"pr_number": 75454, "url": "https://github.com/llvm/llvm-project/pull/75454", "title": "[Clang][AArch64]Add QCVTN builtin to SVE2.1", "body": " ``` c\r\n   // All the intrinsics below are [SVE2.1 or SME2]\r\n   // Variants are also available for _u16[_s32]_x2 and _u16[_u32]_x2\r\n   svint16_t svqcvtn_s16[_s32_x2](svint32x2_t zn);\r\n   ```\r\n\r\nAccording to PR#257[1]\r\n\r\n[1]https://github.com/ARM-software/acle/pull/257", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_qcvtn.c", "functions": ["test_qcvtn_u16_u32_x2", "test_qcvtn_s16_s32_x2", "test_qcvtn_u16_s32_x2", "SVE_ACLE_FUNC"]}, {"filename": "clang/test/CodeGen/aarch64-sme2-intrinsics/acle_sme2_cvtn.c", "functions": ["test_qcvtn_u16_u32_x2", "test_qcvtn_s16_s32_x2", "test_qcvtn_u16_s32_x2", "SVE_ACLE_FUNC"]}]}
{"pr_number": 74625, "url": "https://github.com/llvm/llvm-project/pull/74625", "title": "[SystemZ] Support i128 as legal type in VRs", "body": "On processors supporting vector registers and SIMD instructions, enable i128 as legal type in VRs.  This allows many operations to be implemented via native instructions directly in VRs (including add, subtract, logical operations and shifts). For a few other operations (e.g. multiply and divide, as well as atomic operations), we need to move the i128 value back to a GPR pair to use the corresponding instruction there.  Overall, this is still beneficial.\r\n\r\nThe patch includes the following LLVM changes:\r\n- Enable i128 as legal type\r\n- Set up legal operations (in SystemZInstrVector.td)\r\n- Custom expansion for i128 add/subtract with carry\r\n- Custom expansion for i128 comparisons and selects\r\n- Support for moving i128 to/from GPR pairs when required\r\n- Handle 128-bit integer constant values everywhere\r\n- Use i128 as intrinsic operand type where appropriate\r\n- Updated and new test cases\r\n\r\nIn addition, clang builtins are updated to reflect the intrinsic operand type changes (which also improves compatibility with GCC).", "feature_layers": ["ir"], "feature_directives": ["for", "atomic", "simd"], "files_changed": [{"filename": "clang/test/CodeGen/SystemZ/builtins-systemz-error2.c", "functions": ["f0", "__attribute__", "__builtin_s390_vaq"]}, {"filename": "llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp", "functions": ["DL", "VCI"]}, {"filename": "llvm/lib/Target/SystemZ/SystemZISelLowering.cpp", "functions": ["isMovedFromParts", "DL", "llvm_unreachable", "SDValue", "getIntrinsicCmp", "emitICmp128Hi"]}]}
{"pr_number": 75489, "url": "https://github.com/llvm/llvm-project/pull/75489", "title": "[libc][NFC] Rename `MANTISSA_WIDTH` in `FRACTION_LEN`", "body": "This one might be a bit controversial since the terminology has been introduced from the start but I think `FRACTION_LEN` is a better name here. AFAICT it really is \"the number of bits after the decimal dot when the number is in normal form.\"\r\n\r\n`MANTISSA_WIDTH` is less precise as it's unclear whether we take the leading bit into account.\r\nThis patch also renames most of the properties to use the `_LEN` suffix and fixes useless casts or variables.", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "libc/test/src/math/exhaustive/sincosf_test.cpp", "functions": ["check"]}, {"filename": "libc/utils/MPFRWrapper/MPFRUtils.cpp", "functions": ["MPFRNumber"]}]}
{"pr_number": 74626, "url": "https://github.com/llvm/llvm-project/pull/74626", "title": "Support for dynamic dimensions in 'tensor.splat'", "body": "This feature had been marked as `TODO` in the `tensor.splat` documentation for a while. This MR includes:\r\n\r\n- Support for dynamically shaped tensors in the return type of `tensor.splat` with the syntax suggested in the `TODO` comment.\r\n\r\n- Updated op documentation.\r\n\r\n- Bufferization support.\r\n\r\n- Updates in op folders affected by the new feature.\r\n\r\n- Unit tests for valid/invalid syntax, valid/invalid folding, and lowering through bufferization.\r\n\r\n- Additional op builders resembling those available in `tensor.empty`.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Tensor/IR/TensorOps.cpp", "functions": ["getDynamicSizes", "emitOpError", "success", "getType"]}]}
{"pr_number": 74905, "url": "https://github.com/llvm/llvm-project/pull/74905", "title": "[mlir][mesh] Add verification and canonicalization for some collectives", "body": "Add verification and canonicalization for\r\nbroadcast, gather, recv, reduce, scatter, send and shift.\r\n\r\nThe canonicalizations only remove trivial collectives with empty mesh_axes attrubutes.", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Mesh/IR/MeshOps.cpp", "functions": ["success", "verifyGatherOperandAndResultShape", "verifyScatterOperandAndResultShape", "failure", "emitError", "verifyAllGatherOperandAndResultShape"]}]}
{"pr_number": 75571, "url": "https://github.com/llvm/llvm-project/pull/75571", "title": "[X86][AVX10] Allow 64-bit mask register used without EVEX512", "body": "This is to reflect new document change that 64-bit mask is support by AVX10 256-bit targets.\r\n\r\nLatest documents can be found in:\r\nhttps://cdrdv2.intel.com/v1/dl/getContent/784267\r\nhttps://cdrdv2.intel.com/v1/dl/getContent/784343", "feature_layers": [], "feature_directives": ["target"], "files_changed": [{"filename": "clang/test/CodeGen/X86/avx512-error.c", "functions": ["_knot_mask64", "k64_verify_2", "k64_verify_ok", "k64_verify_1", "__builtin_ia32_sqrtpd512", "test_knot_mask64"]}]}
{"pr_number": 74653, "url": "https://github.com/llvm/llvm-project/pull/74653", "title": "WIP of allowing OpenMP code to call genFIR from FirConverter", "body": "All commits squashed together to make it easier for me to rebase on top of main.\r\n\r\nAt the moment, this maintains status-quo, i.e. doesn't change any functionality.  The `genOMP` functions don't yet call `genFIR`.  `check-flang` passes for me, but there may be some bugs introduced when I manually rebased the code from an internal branch to main.\r\n\r\nThe main changes so far:\r\n- Separate the definition of the `FirConverter` class into its own header file, keep the member function implementations in `Bridge.cpp`.\r\n- Implement `OpenMPMixin` class, which provides (two) definitions of `genFIR` for OpenMP construct (+declarative construct).  These two functions were originally in `FirConverter`, they were simply moved to the OpenMP mixin. The `FirConverter` class inherits the mixin class and injects these two functions into its own scope.  The idea was to make the generic FIR generator as OpenMP-agnostic as possible.\r\n- Organize the OpenMP code into member functions of the mixin.  Most constructs now have their own `genOMP` functions that serve a similar role to `genFIR` in the converter (i.e. to be visited by `[this](auto &&x) { genOMP(x); }` visitor).\r\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Lower/Bridge.cpp", "functions": ["hasLocalitySpecs", "startNewFunction", "blockIsUnterminated", "isStructured", "bool", "implicitIterationSpace", "lowerModuleDeclScope", "toLocation", "getLoopVariableType", "declareFunction", "lowerBlockData", "symBoxToExtendedValue", "run", "genLocation", "setCurrentPositionAt", "createTypeInfo", "isInsideOp", "isDerivedCategory", "analyzeExplicitSpace", "startBlock", "callee", "isInsideHlfirWhere", "endNewFunction", "genNestedStatement", "analyzeExplicitSpacePop", "filePath", "isLogicalCategory", "genExitRoutine", "genReturnSymbol", "genFIRIncrementLoopEnd", "lowerFunc", "setCurrentPosition", "getSymbolAddress", "cleanupExplicitSpace", "genType", "createIntrinsicModuleDefinitions", "explicitIterationSpace", "FirConverter", "getCurrentLocation", "popActiveConstruct", "if", "genAssignment", "rewriter", "genForallNest", "isInsideHlfirForallOrWhere", "genBranch", "getFunc", "lowerToHighLevelFIR", "impliedDoBinding", "addMaskVariable", "genUnknownLocation", "var", "lookupSymbol", "genFIRIncrementLoopBegin", "isCharacterCategory", "genPointerAssignment", "isFuncResultDesignator", "manageFPEnvironment", "isNumericScalarCategory", "genIfCondition", "maybeStartBlock", "genFIR", "bindHostAssocTuple", "rhs", "createRuntimeTypeInfoGlobals", "finalizeOpenACCLowering", "lowerMod", "genExprAddr", "hasExitCode", "prepareExplicitSpace", "bindIfNewSymbol", "handleLocalitySpecs", "setCurrentEval", "isPresentShallowLookup", "mangleName", "hostAssocTupleValue"]}, {"filename": "flang/lib/Lower/OpenMP.cpp", "functions": ["tiv", "isOpenMPTargetConstruct", "removeStoreOp", "dsp", "if", "modBuilder", "cp", "locs"]}]}
{"pr_number": 74864, "url": "https://github.com/llvm/llvm-project/pull/74864", "title": "[flang] Separate definition of class `FirConverter` into header file", "body": "The order of functions has been preserved, the order in the cpp file matches the order in the header. This was meant to limit the visual differences between the old and the new files.\r\n\r\nSmall functions and templates have their definitions in the header (except `genFIR`).\r\n\r\nAll `genFIR` functions (except those explicitly listed as no-ops) are defined in the cpp file.\r\n\r\nThe semantic changes are\r\n- `FirCoverter` is defined in namespace `Fortran::lower` (was in anonymous namespace before).\r\n- Helper classes `IncrementLoopInfo`, `ConstructContext`, and `TypeInfoConverter` are now nested inside of `FirConverter` (were\r\nin anonymous namespace before).", "feature_layers": ["sema", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Lower/Bridge.cpp", "functions": ["rhs", "genExprAddr", "genUnknownLocation", "symBoxToExtendedValue", "if", "bindIfNewSymbol", "genPointerAssignment", "filePath"]}]}
{"pr_number": 67224, "url": "https://github.com/llvm/llvm-project/pull/67224", "title": "[libc++] Optimize std::find for segmented iterators", "body": "```\r\n--------------------------------------------------------------------------\r\nBenchmark                                              old             new\r\n--------------------------------------------------------------------------\r\nbm_find<std::deque<char>>/1                        6.06 ns         10.6 ns\r\nbm_find<std::deque<char>>/2                        15.5 ns         10.6 ns\r\nbm_find<std::deque<char>>/3                        19.0 ns         10.6 ns\r\nbm_find<std::deque<char>>/4                        20.8 ns         10.6 ns\r\nbm_find<std::deque<char>>/5                        22.0 ns         10.6 ns\r\nbm_find<std::deque<char>>/6                        23.0 ns         10.5 ns\r\nbm_find<std::deque<char>>/7                        24.8 ns         10.7 ns\r\nbm_find<std::deque<char>>/8                        25.7 ns         10.6 ns\r\nbm_find<std::deque<char>>/16                       28.3 ns         10.6 ns\r\nbm_find<std::deque<char>>/64                       44.2 ns         27.0 ns\r\nbm_find<std::deque<char>>/512                       133 ns         37.6 ns\r\nbm_find<std::deque<char>>/4096                      867 ns         53.1 ns\r\nbm_find<std::deque<char>>/32768                    6838 ns          160 ns\r\nbm_find<std::deque<char>>/262144                  52897 ns         1495 ns\r\nbm_find<std::deque<char>>/1048576                215621 ns         6077 ns\r\nbm_find<std::deque<short>>/1                       6.03 ns         6.28 ns\r\nbm_find<std::deque<short>>/2                       15.8 ns         15.8 ns\r\nbm_find<std::deque<short>>/3                       20.5 ns         20.3 ns\r\nbm_find<std::deque<short>>/4                       21.0 ns         21.0 ns\r\nbm_find<std::deque<short>>/5                       23.0 ns         22.1 ns\r\nbm_find<std::deque<short>>/6                       22.6 ns         23.0 ns\r\nbm_find<std::deque<short>>/7                       23.4 ns         23.7 ns\r\nbm_find<std::deque<short>>/8                       24.4 ns         24.9 ns\r\nbm_find<std::deque<short>>/16                      26.6 ns         27.2 ns\r\nbm_find<std::deque<short>>/64                      43.2 ns         40.9 ns\r\nbm_find<std::deque<short>>/512                      124 ns         90.7 ns\r\nbm_find<std::deque<short>>/4096                     845 ns          525 ns\r\nbm_find<std::deque<short>>/32768                   7273 ns         3194 ns\r\nbm_find<std::deque<short>>/262144                 53710 ns        24385 ns\r\nbm_find<std::deque<short>>/1048576               216086 ns        96195 ns\r\nbm_find<std::deque<int>>/1                         6.03 ns         10.3 ns\r\nbm_find<std::deque<int>>/2                         15.6 ns         10.3 ns\r\nbm_find<std::deque<int>>/3                         19.1 ns         10.3 ns\r\nbm_find<std::deque<int>>/4                         22.3 ns         10.3 ns\r\nbm_find<std::deque<int>>/5                         23.5 ns         10.4 ns\r\nbm_find<std::deque<int>>/6                         23.1 ns         10.3 ns\r\nbm_find<std::deque<int>>/7                         23.7 ns         10.2 ns\r\nbm_find<std::deque<int>>/8                         24.5 ns         10.2 ns\r\nbm_find<std::deque<int>>/16                        27.9 ns         26.6 ns\r\nbm_find<std::deque<int>>/64                        42.6 ns         32.2 ns\r\nbm_find<std::deque<int>>/512                        123 ns         43.0 ns\r\nbm_find<std::deque<int>>/4096                       874 ns         93.5 ns\r\nbm_find<std::deque<int>>/32768                     7031 ns          751 ns\r\nbm_find<std::deque<int>>/262144                   57723 ns         6169 ns\r\nbm_find<std::deque<int>>/1048576                 230867 ns        35851 ns\r\nbm_ranges_find<std::deque<char>>/1                 5.97 ns         10.6 ns\r\nbm_ranges_find<std::deque<char>>/2                 16.0 ns         10.5 ns\r\nbm_ranges_find<std::deque<char>>/3                 19.5 ns         10.5 ns\r\nbm_ranges_find<std::deque<char>>/4                 21.1 ns         10.6 ns\r\nbm_ranges_find<std::deque<char>>/5                 22.8 ns         10.5 ns\r\nbm_ranges_find<std::deque<char>>/6                 22.8 ns         10.6 ns\r\nbm_ranges_find<std::deque<char>>/7                 23.4 ns         10.8 ns\r\nbm_ranges_find<std::deque<char>>/8                 24.1 ns         10.5 ns\r\nbm_ranges_find<std::deque<char>>/16                26.9 ns         10.6 ns\r\nbm_ranges_find<std::deque<char>>/64                50.2 ns         27.2 ns\r\nbm_ranges_find<std::deque<char>>/512                126 ns         38.3 ns\r\nbm_ranges_find<std::deque<char>>/4096               868 ns         53.8 ns\r\nbm_ranges_find<std::deque<char>>/32768             6695 ns          161 ns\r\nbm_ranges_find<std::deque<char>>/262144           54411 ns         1497 ns\r\nbm_ranges_find<std::deque<char>>/1048576         241699 ns         6042 ns\r\nbm_ranges_find<std::deque<short>>/1                6.39 ns         6.31 ns\r\nbm_ranges_find<std::deque<short>>/2                15.8 ns         15.9 ns\r\nbm_ranges_find<std::deque<short>>/3                19.0 ns         19.8 ns\r\nbm_ranges_find<std::deque<short>>/4                20.8 ns         20.9 ns\r\nbm_ranges_find<std::deque<short>>/5                21.8 ns         22.1 ns\r\nbm_ranges_find<std::deque<short>>/6                23.0 ns         23.0 ns\r\nbm_ranges_find<std::deque<short>>/7                23.2 ns         23.9 ns\r\nbm_ranges_find<std::deque<short>>/8                23.7 ns         24.4 ns\r\nbm_ranges_find<std::deque<short>>/16               26.6 ns         26.8 ns\r\nbm_ranges_find<std::deque<short>>/64               43.4 ns         39.7 ns\r\nbm_ranges_find<std::deque<short>>/512               131 ns         90.5 ns\r\nbm_ranges_find<std::deque<short>>/4096              851 ns          523 ns\r\nbm_ranges_find<std::deque<short>>/32768            7370 ns         3166 ns\r\nbm_ranges_find<std::deque<short>>/262144          60778 ns        24814 ns\r\nbm_ranges_find<std::deque<short>>/1048576        229288 ns        99273 ns\r\nbm_ranges_find<std::deque<int>>/1                  6.43 ns         10.2 ns\r\nbm_ranges_find<std::deque<int>>/2                  16.6 ns         10.2 ns\r\nbm_ranges_find<std::deque<int>>/3                  19.6 ns         10.2 ns\r\nbm_ranges_find<std::deque<int>>/4                  21.0 ns         10.2 ns\r\nbm_ranges_find<std::deque<int>>/5                  21.9 ns         10.4 ns\r\nbm_ranges_find<std::deque<int>>/6                  22.7 ns         10.2 ns\r\nbm_ranges_find<std::deque<int>>/7                  23.9 ns         10.2 ns\r\nbm_ranges_find<std::deque<int>>/8                  23.8 ns         10.2 ns\r\nbm_ranges_find<std::deque<int>>/16                 27.2 ns         27.1 ns\r\nbm_ranges_find<std::deque<int>>/64                 42.4 ns         32.4 ns\r\nbm_ranges_find<std::deque<int>>/512                 122 ns         43.0 ns\r\nbm_ranges_find<std::deque<int>>/4096                895 ns         93.7 ns\r\nbm_ranges_find<std::deque<int>>/32768              6890 ns          756 ns\r\nbm_ranges_find<std::deque<int>>/262144            54025 ns         6102 ns\r\nbm_ranges_find<std::deque<int>>/1048576          221558 ns        32783 ns\r\n```", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "libcxx/benchmarks/algorithms/find.bench.cpp", "functions": ["vec1"]}, {"filename": "libcxx/test/libcxx/algorithms/ranges_robust_against_copying_projections.pass.cpp", "functions": ["test_deque", "main"]}, {"filename": "libcxx/test/std/algorithms/alg.nonmodifying/alg.find/find.pass.cpp", "functions": ["test_deque"]}, {"filename": "libcxx/test/std/algorithms/alg.nonmodifying/alg.find/ranges.find.pass.cpp", "functions": ["test_deque"]}]}
{"pr_number": 75551, "url": "https://github.com/llvm/llvm-project/pull/75551", "title": "[NFC][mlir][sparse] remove redundant parameter.", "body": "", "feature_layers": ["parse", "ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/Transforms/SparseGPUCodegen.cpp", "functions": ["genToCoordinates"]}]}
{"pr_number": 75542, "url": "https://github.com/llvm/llvm-project/pull/75542", "title": "[Instrumentation][X86] Limit setting large section flag to medium/large code models", "body": "In #74514 and #74778 we marked various instrumentation-added sections as\r\nlarge. This causes an extra PT_LOAD segment if using the small code\r\nmodel. Since people using the small code model presumably aren't hitting\r\nrelocation limits, disable this when using the small code model to avoid\r\nthe extra segment.\r\n\r\nThis uses Module::getCodeModel() which isn't necessarily reliable since it reads module metadata (which right now only the clang frontend sets), but it would be nice to get to a point where we reliably put this sort of information (e.g. PIC/code model/etc) in the IR. This requires duplicating the existing tests since opt/llc currently don't set these metadata. If we get to a point where they do set the code model metadata based on command line arguments then we can deduplicate these tests.", "feature_layers": ["ir", "frontend"], "feature_directives": ["for", "sections", "requires"], "files_changed": [{"filename": "llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp", "functions": ["TM", "CompileKernel", "Options"]}, {"filename": "llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp", "functions": ["M", "Lowerer"]}]}
{"pr_number": 73596, "url": "https://github.com/llvm/llvm-project/pull/73596", "title": "Add option to pass thread ID to thread select command", "body": "We'd like a way to select the current thread by its thread ID (rather than its internal LLDB thread index).\r\n\r\nThis PR adds a `-t` option (`--thread_id` long option) that tells the `thread select` command to interpret the `<thread-index>` argument as a thread ID.\r\n\r\nHere's an example of it working:\r\n```\r\nmichristensen@devbig356 llvm/llvm-project (thread-select-tid) \u00bb ../Debug/bin/lldb ~/scratch/cpp/threading/a.out\r\n(lldb) target create \"/home/michristensen/scratch/cpp/threading/a.out\"\r\nCurrent executable set to '/home/michristensen/scratch/cpp/threading/a.out' (x86_64).\r\n(lldb) b 18\r\nBreakpoint 1: where = a.out`main + 80 at main.cpp:18:12, address = 0x0000000000000850\r\n(lldb) run\r\nProcess 215715 launched: '/home/michristensen/scratch/cpp/threading/a.out' (x86_64)\r\nThis is a thread, i=1\r\nThis is a thread, i=2\r\nThis is a thread, i=3\r\nThis is a thread, i=4\r\nThis is a thread, i=5\r\nProcess 215715 stopped\r\n* thread #1, name = 'a.out', stop reason = breakpoint 1.1\r\n    frame #0: 0x0000555555400850 a.out`main at main.cpp:18:12\r\n   15     for (int i = 0; i < 5; i++) {\r\n   16       pthread_create(&thread_ids[i], NULL, foo, NULL);\r\n   17     }\r\n-> 18     for (int i = 0; i < 5; i++) {\r\n   19       pthread_join(thread_ids[i], NULL);\r\n   20     }\r\n   21     return 0;\r\n(lldb) thread select 2\r\n* thread #2, name = 'a.out'\r\n    frame #0: 0x00007ffff68f9918 libc.so.6`__nanosleep + 72\r\nlibc.so.6`__nanosleep:\r\n->  0x7ffff68f9918 <+72>: cmpq   $-0x1000, %rax ; imm = 0xF000\r\n    0x7ffff68f991e <+78>: ja     0x7ffff68f9952 ; <+130>\r\n    0x7ffff68f9920 <+80>: movl   %edx, %edi\r\n    0x7ffff68f9922 <+82>: movl   %eax, 0xc(%rsp)\r\n(lldb) thread info\r\nthread #2: tid = 216047, 0x00007ffff68f9918 libc.so.6`__nanosleep + 72, name = 'a.out'\r\n\r\n(lldb) thread list\r\nProcess 215715 stopped\r\n  thread #1: tid = 215715, 0x0000555555400850 a.out`main at main.cpp:18:12, name = 'a.out', stop reason = breakpoint 1.1\r\n* thread #2: tid = 216047, 0x00007ffff68f9918 libc.so.6`__nanosleep + 72, name = 'a.out'\r\n  thread #3: tid = 216048, 0x00007ffff68f9918 libc.so.6`__nanosleep + 72, name = 'a.out'\r\n  thread #4: tid = 216049, 0x00007ffff68f9918 libc.so.6`__nanosleep + 72, name = 'a.out'\r\n  thread #5: tid = 216050, 0x00007ffff68f9918 libc.so.6`__nanosleep + 72, name = 'a.out'\r\n  thread #6: tid = 216051, 0x00007ffff68f9918 libc.so.6`__nanosleep + 72, name = 'a.out'\r\n(lldb) thread select 215715\r\nerror: invalid thread #215715.\r\n(lldb) thread select -t 215715\r\n* thread #1, name = 'a.out', stop reason = breakpoint 1.1\r\n    frame #0: 0x0000555555400850 a.out`main at main.cpp:18:12\r\n   15     for (int i = 0; i < 5; i++) {\r\n   16       pthread_create(&thread_ids[i], NULL, foo, NULL);\r\n   17     }\r\n-> 18     for (int i = 0; i < 5; i++) {\r\n   19       pthread_join(thread_ids[i], NULL);\r\n   20     }\r\n   21     return 0;\r\n(lldb) thread select -t 216051\r\n* thread #6, name = 'a.out'\r\n    frame #0: 0x00007ffff68f9918 libc.so.6`__nanosleep + 72\r\nlibc.so.6`__nanosleep:\r\n->  0x7ffff68f9918 <+72>: cmpq   $-0x1000, %rax ; imm = 0xF000\r\n    0x7ffff68f991e <+78>: ja     0x7ffff68f9952 ; <+130>\r\n    0x7ffff68f9920 <+80>: movl   %edx, %edi\r\n    0x7ffff68f9922 <+82>: movl   %eax, 0xc(%rsp)\r\n(lldb) thread select 3\r\n* thread #3, name = 'a.out'\r\n    frame #0: 0x00007ffff68f9918 libc.so.6`__nanosleep + 72\r\nlibc.so.6`__nanosleep:\r\n->  0x7ffff68f9918 <+72>: cmpq   $-0x1000, %rax ; imm = 0xF000\r\n    0x7ffff68f991e <+78>: ja     0x7ffff68f9952 ; <+130>\r\n    0x7ffff68f9920 <+80>: movl   %edx, %edi\r\n    0x7ffff68f9922 <+82>: movl   %eax, 0xc(%rsp)\r\n(lldb) thread select -t 216048\r\n* thread #3, name = 'a.out'\r\n    frame #0: 0x00007ffff68f9918 libc.so.6`__nanosleep + 72\r\nlibc.so.6`__nanosleep:\r\n->  0x7ffff68f9918 <+72>: cmpq   $-0x1000, %rax ; imm = 0xF000\r\n    0x7ffff68f991e <+78>: ja     0x7ffff68f9952 ; <+130>\r\n    0x7ffff68f9920 <+80>: movl   %edx, %edi\r\n    0x7ffff68f9922 <+82>: movl   %eax, 0xc(%rsp)\r\n(lldb) thread select --thread_id 216048\r\n* thread #3, name = 'a.out'\r\n    frame #0: 0x00007ffff68f9918 libc.so.6`__nanosleep + 72\r\nlibc.so.6`__nanosleep:\r\n->  0x7ffff68f9918 <+72>: cmpq   $-0x1000, %rax ; imm = 0xF000\r\n    0x7ffff68f991e <+78>: ja     0x7ffff68f9952 ; <+130>\r\n    0x7ffff68f9920 <+80>: movl   %edx, %edi\r\n    0x7ffff68f9922 <+82>: movl   %eax, 0xc(%rsp)\r\n(lldb) help thread select\r\nChange the currently selected thread.\r\n\r\nSyntax: thread select <cmd-options> <thread-index>\r\n\r\nCommand Options Usage:\r\n  thread select [-t] <thread-index>\r\n\r\n       -t ( --thread_id )\r\n            Provide a thread ID instead of a thread index.\r\n\r\n     This command takes options and free-form arguments.  If your arguments\r\n     resemble option specifiers (i.e., they start with a - or --), you must use\r\n     ' -- ' between the end of the command options and the beginning of the\r\n     arguments.\r\n(lldb) c\r\nProcess 215715 resuming\r\nProcess 215715 exited with status = 0 (0x00000000)\r\n```", "feature_layers": [], "feature_directives": ["for", "target"], "files_changed": [{"filename": "lldb/source/Commands/CommandObjectThread.cpp", "functions": ["Status"]}]}
{"pr_number": 75175, "url": "https://github.com/llvm/llvm-project/pull/75175", "title": "[LLD] [COFF] Rewrite handling of the /debug: option. NFC.", "body": "Don't treat the options as unique enum items, but more as flags that can be composed, like the /opt: options.\r\n\r\nThis still only processes the last option on the command line though, so the behaviour should still remain exactly as it was, in all corner cases.\r\n", "feature_layers": ["ast"], "feature_directives": [], "files_changed": [{"filename": "lld/COFF/Driver.cpp", "functions": ["parseDebugKind"]}]}
{"pr_number": 74820, "url": "https://github.com/llvm/llvm-project/pull/74820", "title": "[RFC] [LLD] [COFF] Restructure /debug: option handling, allow controlling features separately", "body": "This is an RFC for a restructuring of the handling of the `/debug:` options in LLD/COFF. This consists of a series of small bitesize refactoring commits, to clearly show the procession. For actual review, if there's agreement on the general direction, I probably would split them up into individual PRs for all the steps.\r\n\r\nThe motive of the refactoring, is to allow controlling individual debug info features. Currently, if producing a PDB, one passes `/debug` to lld-link. However, if any of the input files also contain DWARF debug info, the output executable will also contain those bits of DWARF - `/debug` includes any DWARF debug info, which is omitted if `/debug` is left out. It would be good to be able to control things more granularly, like create a PDB, but skip any DWARF, but still retain a symbol table.\r\n\r\nWe do have a bunch of `/debug:<foo>` options, like `/debug:dwarf` and `/debug:symtab`, plus a bunch of variants like `/debug:ghash` and `/debug:noghash`.\r\n\r\n(For reference, MS link.exe has none of these options, it only has `/debug`, and it passes DWARF sections into the output regardless of whther the `/debug` option was set.)\r\n\r\nThe main inflexibility with our current `/debug:` option handling, is that it is treated as an enum - we inspect the last option provided, and it selects one behaviour out of a number profiles. But if one want to be able to control all of these aspects individually, we're in a combinatorial nightmare, we'd need almost 4x4 potential combinations - PDB on/off, GHash on/off, DWARF on/off, symtab on/off, etc.\r\n\r\nThis branch tries to refactor the handling of the `/debug:` options so that instead of just inspecting the last, we iterate over all of them, progressively applying the settings from each of them. This mostly tries to keep the effect of the last flag dictating the chosen behaviour, like before, but e.g. `/debug:dwarf` or `/debug:symtab` doesn't disable PDB writing, even if there was an earlier `/debug:full` parsed before. On top of these, I add new flags `/debug:nodwarf` and `/debug:nosymtab`. This allows doing things like `/debug:full,nodwarf,symtab` to achieve the particular combination I mentioned before.\r\n\r\nThis allows handling the `-s` and `-S` options properly in the MinGW linker frontend, to omit the DWARF debug info (but possibly keep a symbol table) while creating a PDB.", "feature_layers": ["parse", "ir", "ast", "frontend"], "feature_directives": ["for", "sections"], "files_changed": [{"filename": "lld/COFF/Driver.cpp", "functions": ["parseDebugKind"]}]}
{"pr_number": 73685, "url": "https://github.com/llvm/llvm-project/pull/73685", "title": "[builtins][arm64] Build __init_cpu_features_resolver on Apple platforms", "body": "", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/IR/Verifier.cpp", "functions": ["T"]}, {"filename": "llvm/lib/Target/AArch64/AArch64AsmPrinter.cpp", "functions": ["emitManualSymbolResolver", "emitLinkerSymbolResolver", "if"]}, {"filename": "llvm/lib/Target/X86/X86AsmPrinter.cpp", "functions": ["if"]}, {"filename": "clang/test/CodeGen/attr-ifunc.c", "functions": ["f1", "f1a", "__attribute__"]}, {"filename": "llvm/lib/CodeGen/GlobalISel/CallLowering.cpp", "functions": ["if"]}]}
{"pr_number": 75517, "url": "https://github.com/llvm/llvm-project/pull/75517", "title": "[mlir][math] Added `math.sinh` with expansions to `math.exp`", "body": "Includes end-to-end tests for the cpu running, folders using `libm` and lowerings to the corresponding `libm` operations.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Math/IR/MathOps.cpp", "functions": ["APFloat"]}, {"filename": "mlir/lib/Dialect/Math/Transforms/ExpandPatterns.cpp", "functions": ["convertCoshOp", "convertSinhOp", "success", "b"]}]}
{"pr_number": 75534, "url": "https://github.com/llvm/llvm-project/pull/75534", "title": "[flang][nfc] Refactor linker invocation logic", "body": "Refactor how the Fortran runtime libs are added to the linker\ninvocation. This is a non-functional change.\n", "feature_layers": ["runtime"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Driver/ToolChains/CommonArgs.cpp", "functions": ["isWholeArchivePresent"]}]}
{"pr_number": 75645, "url": "https://github.com/llvm/llvm-project/pull/75645", "title": "[mlir][sparse] set up the skeleton for SparseTensorLevel abstraction.", "body": "Note that at the current moment, the newly-introduced `SparseTensorLevel` classes are far from complete, we plan to migrate code generation related to accessing sparse tensor levels to these classes in the near future to simplify `LoopEmitter`.", "feature_layers": ["parse", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/Transforms/Utils/SparseTensorLevels.cpp", "functions": ["genIndexLoad"]}]}
{"pr_number": 75226, "url": "https://github.com/llvm/llvm-project/pull/75226", "title": "[PowerPC] Emit libcall to frexpl for calls to frexp(ppcDoublDouble)", "body": "On Linux PPC call lib func ``frexpl`` for calls to ``frexp()`` for input of type PPCDoubleDouble.\r\n\r\nFixes bug: https://github.com/llvm/llvm-project/issues/64426", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/CodeGen/CGBuiltin.cpp", "functions": ["if"]}]}
{"pr_number": 75670, "url": "https://github.com/llvm/llvm-project/pull/75670", "title": "[mlir][sparse] support loop range query using SparseTensorLevel.", "body": "", "feature_layers": ["parse", "ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/Transforms/Utils/SparseTensorLevel.cpp", "functions": ["constantRange", "peekCrdAt", "peekRangeAt", "genIndexLoad"]}]}
{"pr_number": 75664, "url": "https://github.com/llvm/llvm-project/pull/75664", "title": "[llvm-readobj] Print the associated CUDA SM flags", "body": "Summary:\nThe architecture that the CUDA application was compiled for is stored in\nthe ELF flags. This patch just adds some simple enum values to indicate\nthis to the user in a readable way.\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/tools/llvm-readobj/ELFDumper.cpp", "functions": ["if"]}]}
{"pr_number": 75657, "url": "https://github.com/llvm/llvm-project/pull/75657", "title": "[NFC][CLANG] Rename duplicate loop attributes diagnostic functions", "body": "This patch renames CheckForDuplicateCodeAlignAttrs() to CheckForDuplicateLoopAttrs() and corresponding other functions that call it to be used for other statement attributes in future.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Sema/SemaStmtAttr.cpp", "functions": ["CheckForDuplicateLoopAttrs"]}]}
{"pr_number": 75648, "url": "https://github.com/llvm/llvm-project/pull/75648", "title": "[flang][nfc] Refactor linker invocation logic", "body": "Refactor how the Fortran runtime libs are added to the linker\ninvocation. This is a non-functional change.\n\nThis is an updated version of #75534. This iteration makes sure that\nFortranMain.a comes before FortranRuntme.a (the former depends on the\nlatter).\n", "feature_layers": ["runtime"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Driver/ToolChains/CommonArgs.cpp", "functions": ["isWholeArchivePresent"]}]}
{"pr_number": 75712, "url": "https://github.com/llvm/llvm-project/pull/75712", "title": "[TSAN] add instrumentation for pthread_mutex_clocklock", "body": "The function `pthread_mutex_clocklock` is not supported by TSAN yet, which is mentioned by[ llvm/llvm-project/issues/62623](https://github.com/llvm/llvm-project/issues/62623#issue-1701600538). This patch is to handle this function.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "compiler-rt/test/tsan/pthread_mutex_clocklock.cpp", "functions": ["main"]}]}
{"pr_number": 75729, "url": "https://github.com/llvm/llvm-project/pull/75729", "title": "[mlir][SparseTensor][NFC] Remove `isNestedIn` helper function", "body": "Use `Region::findAncestorBlockInRegion` instead of a custom IR traversal.", "feature_layers": ["parse", "ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/Transforms/SparseGPUCodegen.cpp", "functions": ["isNestedIn"]}]}
{"pr_number": 75689, "url": "https://github.com/llvm/llvm-project/pull/75689", "title": "[GISel][TableGen] Enhance default ops support", "body": "- Instead of checking the default ops directly, this change queries DAG default operands collected during patterns reading. It does not only simplify the code but also handle few cases where integer values are converted from convertible types, such as 'bits'.\r\n- A test case is added GlobalISelEmitter.td as the regression test of default 'bits' values.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "llvm/utils/TableGen/GlobalISelEmitter.cpp", "functions": ["failedImport"]}]}
{"pr_number": 75675, "url": "https://github.com/llvm/llvm-project/pull/75675", "title": "[CodeGen] Emit a more accurate alignment for non-temporal loads/stores", "body": "Call EmitPointerWithAlignment to compute the alignment based on the underlying lvalue's alignment when it's available.", "feature_layers": ["codegen"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CodeGen/Nontemporal.cpp", "functions": ["__attribute__", "test_alignment"]}]}
{"pr_number": 75427, "url": "https://github.com/llvm/llvm-project/pull/75427", "title": "[RISCV] Simplify PrintExtension. NFC", "body": "Instead of using a format string that needs to be parsed, we can use left_justify to print each string with padding.", "feature_layers": ["parse"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Support/RISCVISAInfo.cpp", "functions": ["format"]}]}
{"pr_number": 75519, "url": "https://github.com/llvm/llvm-project/pull/75519", "title": "[mlir][vector] Fix invalid `LoadOp` indices being created", "body": "Fixes https://github.com/llvm/llvm-project/issues/71326.\r\n\r\nThe cause of the issue was that a new `LoadOp` was created which looked something like:\r\n```mlir\r\n%arg4 = \r\nfunc.func main(%arg1 : index, %arg2 : index) {\r\n  %alloca_0 = memref.alloca() : memref<vector<1x32xi1>>\r\n  %1 = vector.type_cast %alloca_0 : memref<vector<1x32xi1>> to memref<1xvector<32xi1>>\r\n  %2 = memref.load %1[%arg1, %arg2] : memref<1xvector<32xi1>>\r\n  return\r\n}\r\n```\r\nwhich crashed inside the `LoadOp::verify`. Note here that `%alloca_0` is 0 dimensional, `%1` has one dimension, but `memref.load` tries to index `%1` with two indices.\r\n\r\nThis is now fixed by using the fact that `unpackOneDim` always unpacks one dim \r\n\r\nhttps://github.com/llvm/llvm-project/blob/1bce61e6b01b38e04260be4f422bbae59c34c766/mlir/lib/Conversion/VectorToSCF/VectorToSCF.cpp#L897-L903\r\n\r\nand so the `loadOp` should just index only one dimension.", "feature_layers": ["ir", "ast"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/MemRef/IR/MemRefOps.cpp", "functions": ["emitOpError", "getMemRefType"]}]}
{"pr_number": 75483, "url": "https://github.com/llvm/llvm-project/pull/75483", "title": "[clang][dataflow] Fix an issue with `Environment::getResultObjectLocation()`.", "body": "So far, if there was a chain of record type prvalues,\n`getResultObjectLocation()` would assign a different result object location to\neach one. This makes no sense, of course, as all of these prvalues end up\ninitializing the same result object.\n\nThis patch fixes this by propagating storage locations up through the entire\nchain of prvalues.\n\nThe new implementation also has the desirable effect of making it possible to\nmake `getResultObjectLocation()` const, which seems appropriate given that,\nlogically, it is just an accessor.\n", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp", "functions": ["getStorageLocationInternal", "isOriginalRecordConstructor", "getResultObjectLocation", "FallbackForAssertFailure", "children"]}, {"filename": "clang/unittests/Analysis/FlowSensitive/TransferTest.cpp", "functions": ["target"]}]}
{"pr_number": 75159, "url": "https://github.com/llvm/llvm-project/pull/75159", "title": "[MLIR][OpenMP][Offload] Lower target update op to DeviceRT", "body": "Adds support for lowring `UpdateDataOp` to the DeviceRT. This reuses the\r\nexisting utils used by other device directive.\r\n", "feature_layers": ["ir"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "mlir/lib/Target/LLVMIR/Dialect/OpenMP/OpenMPToLLVMIRTranslation.cpp", "functions": ["failure", "success", "convertOmpTargetData"]}]}
{"pr_number": 75391, "url": "https://github.com/llvm/llvm-project/pull/75391", "title": "[llvm-windres] Change the interpretation of --preprocessor to match Binutils 2.36", "body": "Binutils 2.36 had a somewhat controversial change in how the --preprocessor option was handled in GNU windres; previously, the option was interpreted as a part of the command string, potentially containing multiple arguments (which even was hinted at in the documentation).\r\n\r\nIn Binutils 2.36, this was changed to interpret the --preprocessor argument as one argument (possibly containing spaces) pointing at the preprocessor executable.\r\n\r\nThe existing behaviour where implicit arguments like -E -xc -DRC_INVOKED are dropped if --preprocessor is specified, was kept.\r\n\r\nThis was a breaking change for some users of GNU windres, see https://sourceware.org/git/?p=binutils-gdb.git;a=commitdiff;h=21c33bcbe36377abf01614fb1b9be439a3b6de20, https://sourceware.org/bugzilla/show_bug.cgi?id=27594, and https://sourceware.org/git/?p=binutils-gdb.git;a=commitdiff;h=5edb8e3f5ad8d74a83fc0df7f6e4514eed0aa77f.\r\n\r\nAs multiple years have passed since, the behaviour change seems to be here to stay, and any users of the previous form of the option have been forced to avoid this construct. Thus update llvm-windres to match the new way Binutils of handling this option.\r\n\r\nOne construct for specifying the path to the preprocessor, which works both before and after binutils 2.36 (and this change in llvm-windres) is to specify options like this:\r\n\r\n    --preprocessor path/to/executable --preprocessor-arg -E --preprocessor-arg -xc -DRC_INVOKED", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/tools/llvm-rc/llvm-rc.cpp", "functions": ["unescapeSplit"]}]}
{"pr_number": 71966, "url": "https://github.com/llvm/llvm-project/pull/71966", "title": "[llvm][Support] Add indirection to call correct validate(...) function", "body": "    Previously \"yamlize\" overload for validatedMappingTraits was\r\n    unconditionally calling \"MappingTraits<T>::validate\" even if\r\n    \"MappingContextTraits<T, Context>\" was passed to it. Therefore\r\n    compilation failed when specifying\r\n    \"MappingContextTraits<T,Context>::validate()\"", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/unittests/Support/YAMLIOTest.cpp", "functions": ["validate"]}]}
{"pr_number": 70829, "url": "https://github.com/llvm/llvm-project/pull/70829", "title": "[clang] Fix false positive -Wmissing-field-initializer for anonymous unions", "body": "Normally warning is not reported when a field has default initializer. Do so for anonymous unions with default initializers as well. No release note since it is a regression in clang 18.\r\n\r\nFixes https://github.com/llvm/llvm-project/issues/70384", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/SemaCXX/cxx2a-initializer-aggregates.cpp", "functions": ["foo"]}, {"filename": "clang/lib/Sema/SemaInit.cpp", "functions": ["if"]}]}
{"pr_number": 72410, "url": "https://github.com/llvm/llvm-project/pull/72410", "title": "[Clang][OpenMP] Fix ordering of processing of map clauses when mapping a struct.", "body": "Mapping a struct, if done in the wrong order, can overwrite the pointer attachment details. This fixes this problem.\r\n\r\nOriginal failing example:\r\n\r\n```\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\nstruct Descriptor {\r\n  int *datum;\r\n  long int x;\r\n  int xi;\r\n  long int arr[1][30];\r\n};\r\n\r\nint main() {\r\n  Descriptor dat = Descriptor();\r\n  dat.datum = (int *)malloc(sizeof(int)*10);\r\n  dat.xi = 3;\r\n  dat.arr[0][0] = 1;\r\n\r\n  #pragma omp target enter data map(to: dat.datum[:10]) map(to: dat)\r\n\r\n  #pragma omp target\r\n  {\r\n    dat.xi = 4;\r\n    dat.datum[dat.arr[0][0]] = dat.xi;\r\n  }\r\n\r\n  #pragma omp target exit data map(from: dat)\r\n\r\n return 0;\r\n}\r\n```\r\n\r\nPrevious attempt at fixing this: https://github.com/llvm/llvm-project/pull/70821", "feature_layers": [], "feature_directives": ["target"], "files_changed": [{"filename": "clang/test/OpenMP/map_struct_ordering.cpp", "functions": ["map_struct"]}, {"filename": "openmp/libomptarget/test/offloading/struct_mapping_with_pointers.cpp", "functions": ["main"]}]}
{"pr_number": 74624, "url": "https://github.com/llvm/llvm-project/pull/74624", "title": "[libc++] Remove assumptions that std::array::iterator is a raw pointer", "body": "This patch removes assumptions that std::array's iterators are raw pointers in the source code and in our test suite. While this is true right now, this doesn't have to be true and ion the future we might want to enable bounded iterators in std::array, which would require this change.\r\n\r\nThis is a pre-requisite for landing #74482", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "libcxx/test/std/algorithms/robust_against_proxy_iterators_lifetime_bugs.pass.cpp", "functions": ["begin", "Input", "end"]}]}
{"pr_number": 75672, "url": "https://github.com/llvm/llvm-project/pull/75672", "title": "[Libomptarget] Remove bitcode image map used for JIT processing", "body": "Summary:\nLibomptarget supports JIT by treating an LLVM-IR file as a regular input\nimage. The handling here used a global map to keep track of triples once\nit was parsed. This was done to same time, however this created a global\nconstructor as well as an extra mutex to handle it. This patch removes\nthe use of this map.\n\nInstead, we simply use the file magic to perform a quick check if the\ninput image is valid bitcode. If not, we then create a lazy module. This\nshould roughly equivalent to the old handling that create an IR symbol\ntable. Here we can prevent the module from materializing everything but\nthe single triple metadata we read in later.\n", "feature_layers": ["parse", "ir"], "feature_directives": ["for", "single", "target"], "files_changed": [{"filename": "openmp/libomptarget/plugins-nextgen/common/src/JIT.cpp", "functions": ["Binary", "SharedLock", "identify_magic", "compile", "Triple", "isImageBitcode", "Lock"]}]}
{"pr_number": 68373, "url": "https://github.com/llvm/llvm-project/pull/68373", "title": "[OpenMP][Clang] Force use of `num_teams` and `thread_limit` for bare kernel", "body": "This patch makes `num_teams` and `thread_limit` mandatory for bare kernels,\nsimilar to a reguar kernel language that when launching a kernel, the grid size\nhas to be set explicitly.\n", "feature_layers": [], "feature_directives": ["for", "teams"], "files_changed": [{"filename": "clang/lib/Sema/SemaOpenMP.cpp", "functions": ["StmtError"]}]}
{"pr_number": 67799, "url": "https://github.com/llvm/llvm-project/pull/67799", "title": "[libc++] Floating Point Atomic", "body": "- implement P0020R6 Floating Point Atomic\n\nDifferential Revision: https://reviews.llvm.org/D153981\n", "feature_layers": [], "feature_directives": ["atomic"], "files_changed": [{"filename": "libcxx/test/std/atomics/atomics.types.generic/atomics.types.float/copy.compile.pass.cpp", "functions": ["test"]}, {"filename": "libcxx/test/std/atomics/atomics.types.generic/atomics.types.float/ctor.pass.cpp", "functions": ["test", "testOne"]}, {"filename": "libcxx/test/std/atomics/atomics.types.generic/atomics.types.float/fetch_add.pass.cpp", "functions": ["testImpl", "test_impl"]}, {"filename": "libcxx/test/std/atomics/atomics.types.generic/atomics.types.float/fetch_sub.pass.cpp", "functions": ["testImpl", "test_impl"]}, {"filename": "libcxx/test/std/atomics/atomics.types.generic/atomics.types.float/lockfree.pass.cpp", "functions": ["decltype"]}, {"filename": "libcxx/test/std/atomics/atomics.types.generic/atomics.types.float/typedef.compile.pass.cpp", "functions": ["test"]}, {"filename": "libcxx/test/std/atomics/atomics.types.generic/atomics.types.float/operator.minus_equals.pass.cpp", "functions": ["testImpl", "test_impl"]}, {"filename": "libcxx/test/std/atomics/atomics.types.generic/atomics.types.float/operator.plus_equals.pass.cpp", "functions": ["testImpl", "test_impl"]}, {"filename": "libcxx/test/libcxx/atomics/atomics.types.generic/atomics.types.float/locakfree.pass.cpp", "functions": ["test", "main"]}, {"filename": "libcxx/test/std/atomics/atomics.types.generic/atomics.types.float/assign.pass.cpp", "functions": ["testImpl", "test_impl"]}, {"filename": "libcxx/test/std/atomics/atomics.types.generic/atomics.types.float/compare_exchange_strong.pass.cpp", "functions": ["testImpl", "test_impl"]}, {"filename": "libcxx/test/std/atomics/atomics.types.generic/atomics.types.float/compare_exchange_weak.pass.cpp", "functions": ["workaroundClangBug", "constexpr"]}, {"filename": "libcxx/test/std/atomics/atomics.types.generic/atomics.types.float/exchange.pass.cpp", "functions": ["testImpl", "test_impl"]}, {"filename": "libcxx/test/std/atomics/atomics.types.generic/atomics.types.float/load.pass.cpp", "functions": ["testImpl", "test_impl"]}, {"filename": "libcxx/test/std/atomics/atomics.types.generic/atomics.types.float/operator.float.pass.cpp", "functions": ["testImpl", "test_impl"]}, {"filename": "libcxx/test/std/atomics/atomics.types.generic/atomics.types.float/store.pass.cpp", "functions": ["testImpl", "test_impl"]}, {"filename": "libcxx/test/std/atomics/atomics.types.generic/atomics.types.float/wait.pass.cpp", "functions": ["testImpl", "test_impl"]}, {"filename": "libcxx/test/std/atomics/atomics.types.generic/atomics.types.float/notify_all.pass.cpp", "functions": ["testImpl", "test_impl"]}, {"filename": "libcxx/test/std/atomics/atomics.types.generic/atomics.types.float/notify_one.pass.cpp", "functions": ["testImpl", "test_impl"]}, {"filename": "libcxx/test/std/atomics/atomics.types.generic/atomics.types.float/fetch_add1.pass.cpp", "functions": ["constexpr", "a", "main", "test_impl", "test", "decltype"]}, {"filename": "libcxx/test/std/atomics/atomics.types.generic/atomics.types.float/fetch_add2.pass.cpp", "functions": ["constexpr", "main", "test_impl", "test", "res"]}, {"filename": "libcxx/test/std/atomics/atomics.types.generic/atomics.types.float/fetch_add3.pass.cpp", "functions": ["test_impl", "test", "main", "constexpr"]}, {"filename": "libcxx/test/std/atomics/atomics.types.generic/atomics.types.float/fetch_add4.pass.cpp", "functions": ["test_impl", "test", "main", "constexpr"]}, {"filename": "libcxx/test/std/atomics/atomics.types.generic/atomics.types.float/fetch_add1_double.pass.cpp", "functions": ["constexpr", "a", "main", "test_impl", "test", "decltype"]}, {"filename": "libcxx/test/std/atomics/atomics.types.generic/atomics.types.float/fetch_add1_float.pass.cpp", "functions": ["constexpr", "a", "main", "test_impl", "test", "decltype"]}, {"filename": "libcxx/test/std/atomics/atomics.types.generic/atomics.types.float/fetch_add1_long_double.pass.cpp", "functions": ["constexpr", "a", "main", "test_impl", "test", "decltype"]}, {"filename": "libcxx/test/std/atomics/atomics.types.generic/atomics.types.float/fetch_add2_double.pass.cpp", "functions": ["constexpr", "main", "test_impl", "test", "res"]}, {"filename": "libcxx/test/std/atomics/atomics.types.generic/atomics.types.float/fetch_add2_float.pass.cpp", "functions": ["constexpr", "main", "test_impl", "test", "res"]}, {"filename": "libcxx/test/std/atomics/atomics.types.generic/atomics.types.float/fetch_add2_long_double.pass.cpp", "functions": ["constexpr", "main", "test_impl", "test", "res"]}]}
{"pr_number": 71927, "url": "https://github.com/llvm/llvm-project/pull/71927", "title": "[AArch64][SME2] Enable bfm builtins for sme2", "body": "This patch enables the following builtins for SME2\r\n    svbfmlslb_f32\r\n    svbfmlslb_lane_f32\r\n    svbfmlslt_f32\r\n    svbfmlslt_lane_f32\r\n\r\nPatch by: Kerry McLaughlin <kerry.mclaughlin@arm.com>", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_bfmlsl.c", "functions": ["test_bfmlslt", "test_bfmlslb_lane", "test_bfmlslt_lane", "test_bfmlslb"]}, {"filename": "clang/test/Sema/aarch64-sme2-intrinsics/acle_sme2_imm.cpp", "functions": ["test_bfmlslb_bad_lane"]}]}
{"pr_number": 75814, "url": "https://github.com/llvm/llvm-project/pull/75814", "title": "[Libomptarget] Remove remaining global constructors in plugins", "body": "Summary:\nThis patch fixes the remaining global constructor in the plguins after\naddressing the ones in the JIT interface. This struct was mistakenly\nusing global constructors as not all the members were being initialized\nproperly. This was almost certainly being optimized out because it's\ntrivial, but would still be present in debug builds and prevented us\nfrom compiling with `-Werror=global-constructors`. We will want to do\nthat once offloading is moved to a runtimes only build.\n", "feature_layers": ["runtime"], "feature_directives": ["target"], "files_changed": [{"filename": "openmp/libomptarget/plugins-nextgen/common/src/PluginInterface.cpp", "functions": ["Status", "RecordReplayTy"]}]}
{"pr_number": 75757, "url": "https://github.com/llvm/llvm-project/pull/75757", "title": "[LinkerWrapper] Forward more arguments to the CPU offloading linker", "body": "Summary:\nThe CPU target currently inherits all the libraries from the normal link\njob to ensure that it has access to the same envrionment that the host\ndoes. However, this previously was not respecting argument libraries\nthat are passed by name rather than `-l` as well as the whole archive\nflags. This patch fixes this to allow the CPU linker to correctly pick\nup the libraries associated with things like address sanitizers.\n\nFixes: https://github.com/llvm/llvm-project/issues/75651\n", "feature_layers": [], "feature_directives": ["for", "target"], "files_changed": [{"filename": "clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp", "functions": ["if", "createStringError"]}]}
{"pr_number": 70612, "url": "https://github.com/llvm/llvm-project/pull/70612", "title": "[OpenMP] Directly use user's grid and block size in kernel language mode", "body": "In kernel language mode, use user's grid and blocks size directly. No validity\r\ncheck, which means if user's values are too large, the launch will fail, similar\r\nto what CUDA and HIP are doing right now.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "openmp/libomptarget/test/offloading/ompx_bare.c", "functions": ["main"]}]}
{"pr_number": 75835, "url": "https://github.com/llvm/llvm-project/pull/75835", "title": "Revert \"[PGO][GlobalValue][LTO]In GlobalValues::getGlobalIdentifier, use semicolon as delimiter for local-linkage varibles.\"", "body": "Reverts llvm/llvm-project#74008\r\n\r\nThe compiler-rt test failed due to `llvm-dis` not found (https://lab.llvm.org/buildbot/#/builders/127/builds/59884)\r\nWill revert and investigate how to require the proper dependency.\r\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "compiler-rt/test/profile/instrprof-thinlto-indirect-call-promotion.cpp", "functions": ["callee0", "callee1", "void", "main", "global_func"]}]}
{"pr_number": 75831, "url": "https://github.com/llvm/llvm-project/pull/75831", "title": "[mlir][memref] Make `LoadOp::verify` error more clear", "body": "While debugging https://github.com/llvm/llvm-project/issues/71326, the `LoadOp::verify` code and error were very confusing. This PR improves that.\r\n\r\nThis code was a part from the reverted PR https://github.com/llvm/llvm-project/pull/75519. Fixing the `-convert-vector-to-scf` issue is going to take a bit longer and this code was out of scope anyway.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/MemRef/IR/MemRefOps.cpp", "functions": ["emitOpError", "getMemRefType"]}]}
{"pr_number": 75674, "url": "https://github.com/llvm/llvm-project/pull/75674", "title": "[HLSL][DirectX] Move handling of resource element types into the frontend", "body": "Rather than shepherding a type name all the way to the backend as a\nstring and attempting to parse it, get the element type out of the AST\nand store that in the resource annotation metadata directly.\n", "feature_layers": ["parse", "ir", "ast", "frontend"], "feature_directives": [], "files_changed": [{"filename": "clang/lib/CodeGen/CGHLSLRuntime.cpp", "functions": ["if", "QT"]}, {"filename": "llvm/lib/Target/DirectX/DXILResource.cpp", "functions": ["right_justify", "ResourceBase"]}]}
{"pr_number": 75713, "url": "https://github.com/llvm/llvm-project/pull/75713", "title": "[TSAN] add instrumentation for pthread_mutex_clocklock", "body": "The function `pthread_mutex_clocklock` is not supported by TSAN yet, which is mentioned by[ llvm/llvm-project/issues/62623](https://github.com/llvm/llvm-project/issues/62623#issue-1701600538). This patch is to handle this function.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "compiler-rt/test/tsan/pthread_mutex_clocklock.cpp", "functions": ["main"]}]}
{"pr_number": 75747, "url": "https://github.com/llvm/llvm-project/pull/75747", "title": "[X86AsmParser] Check displacement overflow", "body": "A displacement is an 8-, 16-, or 32-bit value.\r\nLLVM integrated assembler silently encodes an out-of-range displacement.\r\n\r\nGNU assembler checks the displacement and may report a warning or error\r\n(error is for 64-bit addressing, done as part of\r\nhttps://sourceware.org/PR10636).\r\n```\r\nmovq 0x80000000(%rip), %rax\r\nError: 0x80000000 out of range of signed 32bit displacement\r\n\r\nmovq -0x080000001(%rax), %rax\r\nError: 0xffffffff7fffffff out of range of signed 32bit displacement\r\n\r\nmovl 0x100000001(%eax), %eax\r\nWarning: 0x100000001 shortened to 0x1\r\n```\r\n\r\nFor 32-bit addressing, GNU assembler gives no diagnostic when the\r\ndisplacement is within `[-2**32,2**32)`. 16-bit addressing is similar.\r\n```\r\nmovl 0xffffffff(%eax), %eax  # no diagnostic\r\nmovl -0xffffffff(%eax), %eax # no diagnostic\r\n```\r\n\r\nSupporting a larger range is probably because wraparound using a large\r\nconstant is more reasonable. E.g. Linux kernel arch/x86/kernel/head_32.S\r\nhas `leal -__PAGE_OFFSET(%ecx),%esp` where `__PAGE_OFFSET` is\r\n0xc0000000.\r\n\r\nThis patch implements a similar behavior.\r\n", "feature_layers": ["parse", "parser"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp", "functions": ["Error"]}]}
{"pr_number": 75846, "url": "https://github.com/llvm/llvm-project/pull/75846", "title": "[mlir][vector] Improve `makeArithReduction` expansion", "body": "Propagate fast math flags.\r\nDistinguish `minf`/`maxf` and `minimumf`/`maximumf`.\r\n\r\nRequired for future patterns in https://github.com/llvm/llvm-project/pull/75727.", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Vector/Transforms/LowerVectorContract.cpp", "functions": ["makeArithReduction"]}]}
{"pr_number": 75727, "url": "https://github.com/llvm/llvm-project/pull/75727", "title": "[mlir][vector] Add pattern to break down reductions into arith ops", "body": "The number of vector elements considered 'small' enough to extract is               \r\nparameterized.                                                   \r\n                                                                 \r\nThis is to avoid going into specialized reduction lowering when a\r\nsingle/couple of arith ops can do. Targets without dedicated reduction  \r\nintrinsics can use that as an emulation path too.                  \r\n                                                                   \r\nDepends on https://github.com/llvm/llvm-project/pull/75846. ", "feature_layers": ["ir"], "feature_directives": ["single", "target"], "files_changed": [{"filename": "mlir/lib/Dialect/Vector/Transforms/VectorTransforms.cpp", "functions": ["failure", "success", "OpRewritePattern", "extracted"]}, {"filename": "mlir/test/lib/Dialect/Vector/TestVectorTransforms.cpp", "functions": ["getDescription", "getArgument", "runOnOperation", "patterns"]}]}
{"pr_number": 75857, "url": "https://github.com/llvm/llvm-project/pull/75857", "title": "Revert counted_by attribute feature", "body": "There are many issues that popped up with the counted_by feature. The\r\npatch #73730 has grown too large and approval is blocking Linux testing.\r\n\r\nIncludes reverts of:\r\ncommit 769bc11f684d (\"[Clang] Implement the 'counted_by' attribute (#68750)\")\r\ncommit bc09ec696209 (\"[CodeGen] Revamp counted_by calculations (#70606)\")\r\ncommit 1a09cfb2f35d (\"[Clang] counted_by attr can apply only to C99 flexible array members (#72347)\")\r\ncommit a76adfb992c6 (\"[NFC][Clang] Refactor code to calculate flexible array member size (#72790)\")\r\ncommit d8447c78ab16 (\"[Clang] Correct handling of negative and out-of-bounds indices (#71877)\")\r\nPartial commit b31cd07de5b7 (\"[Clang] Regenerate test checks (NFC)\")\r\n\r\nCloses #73168\r\nCloses #75173\r\n", "feature_layers": ["codegen"], "feature_directives": [], "files_changed": [{"filename": "clang/lib/AST/Expr.cpp", "functions": ["if"]}, {"filename": "clang/lib/CodeGen/CGBuiltin.cpp", "functions": ["getDefaultBuiltinObjectSizeResult"]}, {"filename": "clang/lib/CodeGen/CGExpr.cpp", "functions": ["if", "DName", "SanScope"]}, {"filename": "clang/lib/Sema/SemaDeclAttr.cpp", "functions": ["MemResult", "OrdResult", "handleCountedByAttr", "Filter"]}, {"filename": "clang/test/CodeGen/attr-counted-by.c", "functions": ["test5", "test7", "test4", "test3", "__counted_by", "test11", "test1", "test6", "test9", "test2", "test8", "test10"]}, {"filename": "clang/test/Sema/attr-counted-by.c", "functions": ["__counted_by"]}]}
{"pr_number": 73465, "url": "https://github.com/llvm/llvm-project/pull/73465", "title": "[Clang] Use correct base expression for counted_by field (#73168)", "body": "I'll add some testcases later today.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CodeGen/attr-counted-by.c", "functions": ["__attribute__", "test12", "test13"]}]}
{"pr_number": 74780, "url": "https://github.com/llvm/llvm-project/pull/74780", "title": "[MLIR][RISCV] Add VCIX dialect", "body": "The changeset adds new dialect called VCIX to support VCIX intrinsics of XSfvcp extension to allow MLIR users to interact with co-processors that are compatible with that extension.\r\n\r\nSource: https://www.sifive.com/document-file/sifive-vector-coprocessor-interface-vcix-software", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/VCIX/IR/VCIXOps.cpp", "functions": ["emitOpError", "success", "verifyVectorType", "failure", "if", "isWidenType", "verifyVCIXOpCommon"]}]}
{"pr_number": 74664, "url": "https://github.com/llvm/llvm-project/pull/74664", "title": "[MLIR][RISCV] Add VCIX dialect to LLVMIR target conversion", "body": "The changeset adds new dialect to support VCIX intrinsics of `XSfvcp` extension to allow MLIR users to interact with co-processors that are compatible with that extension.\r\n\r\nSource: https://www.sifive.com/document-file/sifive-vector-coprocessor-interface-vcix-software", "feature_layers": ["ir"], "feature_directives": ["target"], "files_changed": [{"filename": "mlir/lib/Dialect/VCIX/IR/VCIXOps.cpp", "functions": ["emitOpError", "success", "verifyVectorType", "failure", "if", "isWidenType", "verifyVCIXOpCommon"]}, {"filename": "mlir/lib/Dialect/VCIX/Transforms/LegalizeForLLVMExport.cpp", "functions": ["success", "OneToOneWithPromotion", "getXLen", "getTargetFeatures", "res", "failure", "OneToOneUnaryROWithPromotion", "OneToOneWithPromotionBase", "OneToOneBinaryROWithPromotion", "OneToOneUnaryWithPromotion", "getInteger"]}, {"filename": "mlir/lib/Target/LLVMIR/Dialect/VCIX/VCIXToLLVMIRTranslation.cpp", "functions": ["getXlenFromOpcode", "getTernaryIntrinsicId", "getWideTernaryROIntrinsicId", "getBinaryROIntrinsicId", "getTernaryROIntrinsicId", "failure", "getBinaryIntrinsicId", "getWideTernaryIntrinsicId"]}]}
{"pr_number": 74781, "url": "https://github.com/llvm/llvm-project/pull/74781", "title": "[MLIR][RISCV] Add VCIX legalization to `VectorToLLVM` pass", "body": "The changeset continues the work on the VCIX dialect by introducing legalization part to `VectorToLLVM` pass.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/VCIX/IR/VCIXOps.cpp", "functions": ["emitOpError", "success", "verifyVectorType", "failure", "if", "isWidenType", "verifyVCIXOpCommon"]}, {"filename": "mlir/lib/Dialect/VCIX/Transforms/LegalizeForLLVMExport.cpp", "functions": ["success", "OneToOneWithPromotion", "getXLen", "getTargetFeatures", "res", "failure", "OneToOneUnaryROWithPromotion", "OneToOneWithPromotionBase", "OneToOneBinaryROWithPromotion", "OneToOneUnaryWithPromotion", "getInteger"]}]}
{"pr_number": 75862, "url": "https://github.com/llvm/llvm-project/pull/75862", "title": "Reland '[TextAPI] Add DylibReader'", "body": "Add support for reading binary Mach-o dynamic libraries. It uses libObject APIs for extracting information relavant to TAPI and tbd files. This includes but is not limited to load commands encode data like install names, current/compat versions and symbols.\r\n\r\nThis originally broke because DylibReader uses Object and Object depends on TextAPI. Breaking this up in a nested library prevents this cycle.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/TextAPI/BinaryReader/DylibReader.cpp", "functions": ["readMachOHeader", "Triples", "OSVersion", "VStream", "getOSVersionStr"]}]}
{"pr_number": 75052, "url": "https://github.com/llvm/llvm-project/pull/75052", "title": "[OpenACC] Add 'clause' parsing infrastructure plus a few clauses", "body": "As we've now finished parsing the constructs, we're moving onto implementing 'clause' parsing.  While some are complicated and require their own patch, the handful added here are simple to parse (that is,\r\n    they are a single identifier).\r\n\r\nThis patch adds the infrastructure to parse these and a clause-list in its entirety. This adds some complication to how we are diagnosing parsing errors elsewhere, so a few changes were made to better recover from errors.", "feature_layers": ["parse", "ir", "ast"], "feature_directives": ["single"], "files_changed": [{"filename": "clang/lib/Parse/ParseOpenACC.cpp", "functions": ["SkipUntilEndOfDirective", "getOpenACCClauseKind", "ParseOpenACCClause"]}, {"filename": "clang/test/ParserOpenACC/parse-clauses.c", "functions": ["func", "bar"]}]}
{"pr_number": 75860, "url": "https://github.com/llvm/llvm-project/pull/75860", "title": "Reland \"[PGO][GlobalValue][LTO]In GlobalValues::getGlobalIdentifier, use semicolon as delimiter for local-linkage varibles. \"", "body": "Fixed build-bot failures caught by post-submit tests (currently this pull request contains a [re-apply](https://github.com/llvm/llvm-project/pull/75860/commits/13133ac931e7d4d8e5ba7083d9c3b52e37d8fefb) commit and a [fix](https://github.com/llvm/llvm-project/pull/75860/commits/2ea522b24160cb8b9d8aab1ea7bf5be12362773e) commit, to make the reland diff clearer)\r\n1) Add the list of command line tools needed by new compiler-rt test into dependency.\r\n    * Fixed `<command-line-tool> not found` error in https://lab.llvm.org/buildbot/#/builders/127/builds/59884\r\n    * I was able to reproduce the error and verified the fix with similar testing commands as used in the bot\r\n       ```\r\n       # Run cmake \r\n       cmake -G Ninja -DCMAKE_BUILD_TYPE=Debug -DLLVM_ENABLE_PROJECTS='clang;compiler-rt;lld' -DLLVM_USE_SPLIT_DWARF=On -DLLVM_USE_LINKER=lld -DLLVM_ENABLE_SPHINX=ON -DLLVM_OPTIMIZED_TABLEGEN=TRUE -DLLVM_TARGETS_TO_BUILD=X86 ../llvm\r\n      # Build compiler-rt\r\n      ninja -j <parallelism> compiler-rt\r\n      # Build clang and lld\r\n      ninja -j <parallelism> clang lld\r\n      # Upon failure, add missing dependencies one by one fixed all errors\r\n      ninja -j <parallelism> check-profile\r\n       ```\r\n       In the last step `ninja check-profile`, add missing dependencies one by one allows me to see errors due to missed dependencies and fixed all of them. \r\n2) Use `starts_with` to replace deprecated `startswith`.\r\n    * Should fix the error ` error: 'startswith' is deprecated: Use starts_with instead [-Werror,-Wdeprecated-declarations]` in https://lab.llvm.org/buildbot/#/builders/36/builds/40893\r\n\r\n**Original commit message**\r\nCommit fe05193 (phab D156569), IRPGO names uses format `[<filepath>;]<linkage-name>` while prior format is `[<filepath>:<mangled-name>`. The format change would break the use case demonstrated in (updated)\r\n`llvm/test/Transforms/PGOProfile/thinlto_indirect_call_promotion.ll` and `compiler-rt/test/profile/instrprof-thinlto-indirect-call-promotion.cpp`\r\n\r\nThis patch changes `GlobalValues::getGlobalIdentifer` to use the semicolon.\r\n\r\nTo elaborate on the scenario how things break without this PR\r\n1. IRPGO raw profiles stores (compressed) IRPGO names of functions in one section, and per-function profile data in another section. The [NameRef](https://github.com/llvm/llvm-project/blob/fc715e4cd942612a091097339841733757b53824/compiler-rt/include/profile/InstrProfData.inc#L72) field in per-function profile data is the MD5 hash of IRPGO names.\r\n2. When raw profiles are converted to indexed format profiles, the profiled address is [mapped](https://github.com/llvm/llvm-project/blob/fc715e4cd942612a091097339841733757b53824/llvm/lib/ProfileData/InstrProf.cpp#L876-L885) to the MD5 hash of the callee.\r\n3. In `pgo-instr-use` thin-lto prelink pipeline, MD5 hash of IRPGO names will be [annotated](https://github.com/llvm/llvm-project/blob/fc715e4cd942612a091097339841733757b53824/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp#L1707) as value profiles, and used to import indirect-call-prom candidates. If the annotated MD5 hash is computed from the new format while import uses the prior format, the callee cannot be imported.\r\n\r\n* `compiler-rt/test/profile/instrprof-thinlto-indirect-call-promotion.cpp` is added to have an end-to-end test.\r\n* `llvm/test/Transforms/PGOProfile/thinlto_indirect_call_promotion.ll` is updated to have better test coverage from another aspect (as runtime tests are more sensitive to the environment and may be skipped by some contributors)", "feature_layers": ["runtime", "ir", "ast"], "feature_directives": ["parallel", "for", "target"], "files_changed": [{"filename": "compiler-rt/test/profile/instrprof-thinlto-indirect-call-promotion.cpp", "functions": ["callee0", "callee1", "void", "main", "global_func"]}]}
{"pr_number": 75888, "url": "https://github.com/llvm/llvm-project/pull/75888", "title": "Revert \"Reland \"[PGO][GlobalValue][LTO]In GlobalValues::getGlobalIdentifier, use semicolon as delimiter for local-linkage varibles. \"\"", "body": "Reverts llvm/llvm-project#75860\r\n- Mangled name mismatch on Windows (https://lab.llvm.org/buildbot/#/builders/127/builds/59907/steps/8/logs/stdio)", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "compiler-rt/test/profile/instrprof-thinlto-indirect-call-promotion.cpp", "functions": ["callee0", "callee1", "void", "main", "global_func"]}]}
{"pr_number": 75726, "url": "https://github.com/llvm/llvm-project/pull/75726", "title": "[LTO] Improve diagnostics handling when parsing module-level inline assembly", "body": "Non-LTO compiles set the buffer name to \"<inline asm>\"\n(`AsmPrinter::addInlineAsmDiagBuffer`) and pass diagnostics to\n`ClangDiagnosticHandler` (through the `MCContext` handler in\n`MachineModuleInfoWrapperPass::doInitialization`) to ensure that\nthe exit code is 1 in the presence of errors. In contrast, LTO compiles\nspuriously succeed even if error messages are printed.\n\n```\n% cat a.c\nvoid _start() {}\nasm(\"unknown instruction\");\n% clang -c a.c\n<inline asm>:1:1: error: invalid instruction mnemonic 'unknown'\n    1 | unknown instruction\n      | ^\n1 error generated.\n% clang -c -flto a.c; echo $?  # -flto=thin is the same\nerror: invalid instruction mnemonic 'unknown'\nunknown instruction\n^~~~~~~\nerror: invalid instruction mnemonic 'unknown'\nunknown instruction\n^~~~~~~\n0\n```\n\n`CollectAsmSymbols` parses inline assembly and is transitively called by\nboth `ModuleSummaryIndexAnalysis::run` and `WriteBitcodeToFile`, leading\nto duplicate diagnostics.\n\nThis patch updates `CollectAsmSymbols` to be similar to non-LTO\ncompiles.\n```\n% clang -c -flto=thin a.c; echo $?\n<inline asm>:1:1: error: invalid instruction mnemonic 'unknown'\n    1 | unknown instruction\n      | ^\n1 errors generated.\n1\n```\n\nThe `HasErrors` check does not prevent duplicate warnings but assembler\nwarnings are very uncommon.\n", "feature_layers": ["parse", "ast"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/Object/ModuleSymbolTable.cpp", "functions": ["Buffer"]}]}
{"pr_number": 67266, "url": "https://github.com/llvm/llvm-project/pull/67266", "title": "[AVR] Support return address intrinsics", "body": "This PR allows the use of @llvm.returnaddress and @llvm.addressofreturnaddress. Zig's runtime checks currently use these for some sort of unwinding mechanism. All code used in this implementation has been copied from PPC/MSP430/M68k/X86 and relies on functions exposed by generic LLVM code.", "feature_layers": ["runtime"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AVR/AVRISelLowering.cpp", "functions": ["LowerRETURNADDR", "LowerADDROFRETURNADDR", "DL", "getReturnAddressFrameIndex"]}]}
{"pr_number": 75802, "url": "https://github.com/llvm/llvm-project/pull/75802", "title": "[flang] Pass one element struct by register on X86-64", "body": "Implement the C struct passing ABI on X86-64 for the trivial case where the structs have one element. This is required to cover some cases of BIND(C) derived type pass with the VALUE attribute.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Optimizer/CodeGen/Target.cpp", "functions": ["passAsFieldIfOneFieldStruct"]}]}
{"pr_number": 75813, "url": "https://github.com/llvm/llvm-project/pull/75813", "title": "[lldb][PDB] Update max matches test for type queries", "body": "NestedClass will be found via Class::NestedClass and ClassTypedef::NestedClass. So the first part of the test gets 2 results as the default is to find all matching types.\r\n\r\nIn the next part, we ask for only the first match and expect to get only 1 of those two possible results.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "lldb/unittests/SymbolFile/PDB/SymbolFilePDBTests.cpp", "functions": ["query"]}]}
{"pr_number": 74334, "url": "https://github.com/llvm/llvm-project/pull/74334", "title": "[libc++] Format the code base", "body": "This patch runs clang-format on all of libcxx/include and libcxx/src, in accordance with the RFC discussed at [1]. Follow-up patches will format the benchmarks, the test suite and remaining parts of the code. I'm splitting this one into its own patch so the diff is a bit easier to review.\r\n\r\nThis patch was generated with:\r\n\r\n```\r\nfind libcxx/include libcxx/src -type f \\\r\n   | grep -v 'module.modulemap.in' \\\r\n   | grep -v 'CMakeLists.txt' \\\r\n   | grep -v 'README.txt' \\\r\n   | grep -v 'libcxx.imp' \\\r\n   | grep -v '__config_site.in' \\\r\n   | xargs clang-format -i\r\n```\r\n\r\n  A Git merge driver is available in libcxx/utils/clang-format-merge-driver.sh\r\n    to help resolve merge and rebase issues across these formatting changes.\r\n\r\n[1]: https://discourse.llvm.org/t/rfc-clang-formatting-all-of-libc-once-and-for-all\r\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "libcxx/src/any.cpp", "functions": ["what"]}, {"filename": "libcxx/src/atomic.cpp", "functions": ["__libcpp_atomic_notify", "__libcpp_contention_monitor_for_wait", "__cxx_atomic_notify_one", "alignas", "__cxx_atomic_notify_all", "__libcpp_atomic_monitor", "__libcpp_atomic_wait", "__libcpp_contention_state", "__libcpp_contention_table_entry", "__cxx_atomic_load", "__libcpp_platform_wake_by_address"]}, {"filename": "libcxx/src/barrier.cpp", "functions": ["__expected", "alignas", "if", "__destroy_barrier_algorithm_base", "__construct_barrier_algorithm_base", "__barrier_algorithm_base", "__arrive"]}, {"filename": "libcxx/src/call_once.cpp", "functions": ["__call_once"]}, {"filename": "libcxx/src/charconv.cpp", "functions": ["__u32toa", "__u64toa", "__base_10_u64", "__base_10_u32"]}, {"filename": "libcxx/src/chrono.cpp", "functions": ["void", "__QueryPerformanceFrequency", "__libcpp_steady_clock_now", "__libcpp_system_clock_now", "time_t"]}, {"filename": "libcxx/src/condition_variable.cpp", "functions": ["decltype", "notify_all_at_thread_exit"]}, {"filename": "libcxx/src/condition_variable_destructor.cpp", "functions": ["condition_variable"]}, {"filename": "libcxx/src/filesystem/directory_iterator.cpp", "functions": ["__stream_"]}, {"filename": "libcxx/src/filesystem/filesystem_clock.cpp", "functions": ["time_point"]}, {"filename": "libcxx/src/filesystem/int128_builtins.cpp", "functions": ["__muloti4"]}, {"filename": "libcxx/src/filesystem/operations.cpp", "functions": ["scope_exit", "bout", "__copy_file", "operator", "__create_directory_symlink", "__copy", "copy_file_impl", "bin", "__copy_symlink", "__permissions", "__status", "__symlink_status", "cleanup_"]}, {"filename": "libcxx/src/filesystem/path.cpp", "functions": ["CompareRootDir", "CompareEndState", "__wide_to_char", "ConsumeRootName", "CompareRootName", "CompareRelative", "__char_to_wide"]}, {"filename": "libcxx/src/future.cpp", "functions": ["logic_error", "name", "future_errc", "AvoidDestroyingFutureCategory", "future_category", "string", "message", "__lk", "__state_"]}, {"filename": "libcxx/src/hash.cpp", "functions": ["__next_prime"]}, {"filename": "libcxx/src/ios.cpp", "functions": ["AvoidDestroyingIostreamCategory", "name", "__ios_new_cap", "iostream_category", "string", "system_error", "message"]}, {"filename": "libcxx/src/iostream.cpp", "functions": ["g"]}, {"filename": "libcxx/src/locale.cpp", "functions": ["utf16be_to_ucs2_length", "__locale_", "init_wam_pm", "release", "install_from", "countof", "use_facet", "facets_", "init_am_pm", "facet", "acquire", "__check_grouping", "s", "build_name", "__loc_", "__libcpp_btowc_l", "utf16le_to_ucs2_length", "if", "in", "ct", "utf8_to_ucs2_length", "utf8_to_ucs4_length", "utf16be_to_ucs4_length", "init_months", "name", "init_wmonths", "make", "out", "lhs", "has_facet", "__pctype_func", "towupper_l", "size_t", "__time_get_temp", "checked_string_to_wchar_convert", "install", "rhs", "towlower_l", "checked_string_to_char_convert", "init_weeks", "__time_get", "utf8_to_utf16_length", "loc", "isascii", "utf16le_to_ucs4_length", "__imp", "init_wweeks"]}, {"filename": "libcxx/src/memory.cpp", "functions": ["if", "__lx_", "align", "__get_sp_mut"]}, {"filename": "libcxx/src/mutex.cpp", "functions": ["_", "__libcpp_recursive_mutex_trylock", "__count_", "__locked_", "__libcpp_mutex_trylock", "lk"]}, {"filename": "libcxx/src/mutex_destructor.cpp", "functions": ["mutex"]}, {"filename": "libcxx/src/random.cpp", "functions": ["if", "arc4random", "__f_"]}, {"filename": "libcxx/src/random_shuffle.cpp", "functions": ["__rs_get", "__rs_default", "__rs_g"]}, {"filename": "libcxx/src/regex.cpp", "functions": ["__get_classname", "__get_collation_name", "operator", "runtime_error", "if", "make_error_type_string"]}, {"filename": "libcxx/src/string.cpp", "functions": ["S", "s", "stoi", "__throw_out_of_range", "stoll", "stol", "operator", "__throw_length_error", "int", "as_integer", "stod", "to_wstring", "stold", "to_string", "stof"]}, {"filename": "libcxx/src/support/ibm/xlocale_zos.cpp", "functions": ["freelocale"]}, {"filename": "libcxx/src/support/win32/locale_win32.cpp", "functions": ["mbrlen_l", "newlocale", "mbsrtowcs", "wcsnrtombs", "btowc", "wctob", "strftime_l", "mbrtowc_l", "mbrtowc", "localeconv_l", "vasprintf_l", "__libcpp_vasprintf", "mbrlen", "mbsnrtowcs", "__current", "wctob_l", "snprintf_l", "wcrtomb_l", "asprintf_l", "btowc_l", "wcrtomb"]}, {"filename": "libcxx/src/support/win32/support.cpp", "functions": ["__libcpp_vasprintf"]}, {"filename": "libcxx/src/support/win32/thread_win32.cpp", "functions": ["__libcpp_condvar_timedwait", "__libcpp_thread_get_id", "__libcpp_recursive_mutex_trylock", "__libcpp_beginthreadex_thunk", "__libcpp_thread_sleep_for", "GetThreadId", "__libcpp_mutex_lock", "__libcpp_mutex_trylock", "__libcpp_thread_detach", "__libcpp_condvar_broadcast", "__libcpp_thread_yield", "__libcpp_mutex_destroy", "__libcpp_thread_create", "__libcpp_condvar_signal", "__libcpp_thread_join", "__libcpp_recursive_mutex_init", "__libcpp_recursive_mutex_destroy", "__libcpp_thread_id_equal", "__libcpp_recursive_mutex_lock", "__libcpp_thread_isnull", "__libcpp_execute_once", "__libcpp_recursive_mutex_unlock", "__libcpp_tls_create", "__libcpp_condvar_wait", "__libcpp_tls_get", "__libcpp_condvar_destroy", "GetCurrentThreadId", "__libcpp_thread_id_less", "__libcpp_mutex_unlock", "FlsGetValue", "TryAcquireSRWLockExclusive", "__libcpp_thread_get_current_id", "__libcpp_tls_set"]}, {"filename": "libcxx/src/system_error.cpp", "functions": ["AvoidDestroyingSystemCategory", "AvoidDestroyingGenericCategory", "default_error_condition", "do_strerror_r", "name", "system_category", "__throw_system_error", "string", "message", "runtime_error", "error_condition", "generic_category"]}, {"filename": "libcxx/src/thread.cpp", "functions": ["__make_ready_at_thread_exit", "__p_", "notify_all_at_thread_exit", "max_size", "__thread_local_data", "sleep_for", "deallocate", "allocate"]}, {"filename": "libcxx/src/valarray.cpp", "functions": ["__indices"]}, {"filename": "libcxx/src/verbose_abort.cpp", "functions": ["__libcpp_verbose_abort"]}]}
{"pr_number": 73291, "url": "https://github.com/llvm/llvm-project/pull/73291", "title": "[SelectionDAG] Add space-optimized forms of OPC_EmitRegister", "body": "The followed byte of `OPC_EmitRegister` is a MVT type, which is\nusually i32 or i64.\n\nWe add `OPC_EmitRegisterI32` and `OPC_EmitRegisterI64` so that we\ncan reduce one byte.\n\nOverall this reduces the llc binary size with all in-tree targets by\nabout 10K.\n", "feature_layers": [], "feature_directives": ["for", "target"], "files_changed": [{"filename": "llvm/utils/TableGen/DAGISelMatcherEmitter.cpp", "functions": ["getQualifiedName"]}]}
{"pr_number": 75780, "url": "https://github.com/llvm/llvm-project/pull/75780", "title": "[llvm-cov] format cells in code coverage report with 0/0 branches/functions/lines differently", "body": "Currently such cells in the report are formatted as red. Which screams \"problem\" but with more and more rangefied code, there can be whole files without any branch inside them. \r\n\r\nBefore:\r\n<img width=\"916\" alt=\"Screenshot 2023-12-18 at 11 09 07\" src=\"https://github.com/llvm/llvm-project/assets/6557263/d0e79c75-7f34-471f-a1f6-a2fd2bd111f2\">\r\n\r\nAfter:\r\n<img width=\"920\" alt=\"Screenshot 2023-12-18 at 11 08 29\" src=\"https://github.com/llvm/llvm-project/assets/6557263/7db3278f-ad6d-4421-967a-cf72b67c5760\">\r\n\r\nThings to notice:\r\n-  highlighted line which is result of cursor hover (now whole line is highlighted)\r\n-  before there were some borders doubled (fixed)\r\n-  cells with `- 0/0` coverage are no longer red\r\n\r\n\r\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/tools/llvm-cov/SourceCoverageViewHTML.cpp", "functions": ["if"]}]}
{"pr_number": 65399, "url": "https://github.com/llvm/llvm-project/pull/65399", "title": "[LVI] Handle freeze instruction in BlockValue", "body": "Skip freeze instruction and take its source Value\r\nfor further processing.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Analysis/LazyValueInfo.cpp", "functions": ["solveBlockValueImpl"]}]}
{"pr_number": 75058, "url": "https://github.com/llvm/llvm-project/pull/75058", "title": "[VFABI] Create FunctionType for vector functions", "body": "`createFunctionType` optionally returns a FunctionType and the mask's position when there's one. It requires VFInfo and an Instruction.\r\n\r\nAdd `checkFunctionType` in 'VectorFunctionABITest.cpp' tests to check that both the number and the type of vectorized parameters matches the created `FunctionType`.", "feature_layers": ["ir"], "feature_directives": ["for", "requires"], "files_changed": [{"filename": "llvm/lib/Analysis/VectorUtils.cpp", "functions": ["isVectorized"]}, {"filename": "llvm/unittests/Analysis/VectorFunctionABITest.cpp", "functions": ["checkFunctionType", "CI"]}]}
{"pr_number": 75793, "url": "https://github.com/llvm/llvm-project/pull/75793", "title": "[lldb] Fix a quirk in SBValue::GetDescription", "body": "The function was using the default version of ValueObject::Dump, which has a default of using the synthetic-ness of the top-level value for determining whether to print _all_ values as synthetic. This resulted in some unusual behavior, where e.g. a std::vector is stringified as synthetic if its dumped as the top level object, but in its raw form if it is a member of a struct without a pretty printer.\r\n\r\nThe SBValue class already has properties which determine whether one should be looking at the synthetic view of the object (and also whether to use dynamic types), so it seems more natural to use that.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "lldb/test/API/python_api/sbvalue_synthetic/main.cpp", "functions": ["main"]}]}
{"pr_number": 75309, "url": "https://github.com/llvm/llvm-project/pull/75309", "title": "[mlir] support dialect attribute translation to LLVM IR", "body": "Extend the `amendOperation` mechanism for translating dialect attributes attached to operations from another dialect when translating MLIR to LLVM IR. Previously, this mechanism would have no knowledge of the LLVM IR instructions created for the given operation, making it impossible for it to perform local modifications such as attaching operation-level metadata. Collect instructions inserted by the LLVM IR builder and pass them to `amendOperation`.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Target/LLVMIR/ModuleTranslation.cpp", "functions": ["setEnabled", "getCapturedInstructions", "convertDialectAttributes", "builder", "clearCapturedInstructions"]}, {"filename": "mlir/test/lib/Dialect/Test/TestToLLVMIRTranslation.cpp", "functions": ["success"]}]}
{"pr_number": 75779, "url": "https://github.com/llvm/llvm-project/pull/75779", "title": "[clang] Fix CTAD not work for C++ explicit type conversion (functional annotation).", "body": "This fixes https://github.com/llvm/llvm-project/issues/64347.\r\n\r\nThe CTAD for an aggregate class is missing to handle the explicit type conversion case, e.g. `TemplateFooClass(1, 2);`. Per C++  expr.type.conv p1, the deduced type is the return type of the deduction guide selected by the CTAD for the reminder.\r\n\r\nIn the deduction implementation `DeduceTemplateSpecializationFromInitializer`, the parenthesized express-list case relies on the `ParenListExpr` parameter (default is nullptr), the AST `ParenListExpr` node is not built for all variant initializer cases (`BuildCXXTypeConstructorExpr`, `BuildCXXNew` etc), thus the deduction doesn't perform for these cases. This patch fixes it by removing the `ParenListExpr` and using the `Inits` instead (which also simplifies the interface and implementation).", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Sema/SemaInit.cpp", "functions": ["TempListInit"]}, {"filename": "clang/test/SemaCXX/ctad.cpp", "functions": ["f", "test", "k", "A"]}]}
{"pr_number": 74086, "url": "https://github.com/llvm/llvm-project/pull/74086", "title": "[asan][Windows] Synchronizing ASAN init on Windows", "body": "This is an attempt to synchronize ASAN initialization using `__sanitizer::atomic`s on Windows. One case in particular is a C# application that loads an ASan instrumented library.\n\nThis addresses:\n\n1. [This check failure](https://github.com/llvm/llvm-project/blob/1df5ea29b43690b6622db2cad7b745607ca4de6a/compiler-rt/lib/asan/asan_interceptors.h#L29C36-L29C36) if a function is intercepted on T1 and called on T2 before T1 is done with ASAN initialization.\n2. [This check failure](https://github.com/llvm/llvm-project/blob/1df5ea29b43690b6622db2cad7b745607ca4de6a/compiler-rt/lib/asan/asan_rtl.cpp#L387) can happen in parallel when two threads call `ENSURE_ASAN_INITED`.\n3. [This check failure](https://github.com/llvm/llvm-project/blob/1df5ea29b43690b6622db2cad7b745607ca4de6a/compiler-rt/lib/asan/asan_rtl.cpp#L481) when thread is created before the main thread gets a chance to get created due to when `CreateThread` is intercepted.\n\nCurrently, everything is blocked by `#if SANITIZER_WINDOWS` because I'm not 100% sure about how ASan is loaded on other platforms and the implications.\n\n\nSPR PRs [one](https://github.com/llvm/llvm-project/pull/74084) and [two](https://github.com/llvm/llvm-project/pull/74085)\n", "feature_layers": [], "feature_directives": ["parallel", "for", "atomic"], "files_changed": [{"filename": "compiler-rt/lib/asan/asan_rtl.cpp", "functions": ["SetAsanInitIsRunning", "AsanInitIsRunning", "SetAsanInited", "AsanInited", "CheckAsanInitRunning", "atomic_load"]}]}
{"pr_number": 75565, "url": "https://github.com/llvm/llvm-project/pull/75565", "title": "[MLIR][Presburger] Add LLL basis reduction", "body": "Add a method for LLL basis reduction to the FracMatrix class.\r\nThis needs an abs() method for Fractions, which is added to Fraction.h.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/unittests/Analysis/Presburger/MatrixTest.cpp", "functions": ["checkReducedBasis"]}]}
{"pr_number": 74734, "url": "https://github.com/llvm/llvm-project/pull/74734", "title": "[mlir][bufferization] Add `buffer_deallocation` transform op", "body": "", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Bufferization/TransformOps/BufferizationTransformOps.cpp", "functions": ["emitSilenceableError"]}]}
{"pr_number": 75649, "url": "https://github.com/llvm/llvm-project/pull/75649", "title": "[mlir][Transform] Fix crash with invalid ir for transform libraries", "body": "This patch fixes a crash caused when the transform library interpreter is given an IR that fails to parse.", "feature_layers": ["parse", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Transform/Transforms/TransformInterpreterUtils.cpp", "functions": ["failure"]}]}
{"pr_number": 74638, "url": "https://github.com/llvm/llvm-project/pull/74638", "title": "[SystemZ][z/OS] Add exception handling for XPLINK", "body": "Adds emitting the exception table and the EH registers for XPLINK.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp", "functions": ["getContext"]}]}
{"pr_number": 75962, "url": "https://github.com/llvm/llvm-project/pull/75962", "title": "[libc] __stack_chk_fail post submit test failures", "body": "Use a size smaller than the smallest supported page size so that we don't\nclobber over any guard pages, which may result in a segfault before\n__stack_chk_fail can be called.\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "libc/src/compiler/generic/__stack_chk_fail.cpp", "functions": ["__stack_chk_fail"]}]}
{"pr_number": 75834, "url": "https://github.com/llvm/llvm-project/pull/75834", "title": "[Libomptarget] Use scoped atomics in the device runtime", "body": "Summary:\nA recent patch allowed us to easily replace GNU atomics with scoped\nvariants that make use of the backend's handling for more permissive\nscopes. The default is full \"system\" scope, that means the atomic\noperation must be consistent with operations that may happen on the\nhost's memory. This is generally only required for processes that are\ncommunicating with something via global fine-grained memory. This patch\nuses these atomics to make everything device scoped, as nothing in the\nOpenMP runtime should depend on the host.\n\nThis is only provided as a very new clang extension but the DeviceRTL is\nonly compiled with clang so it is always available.\n", "feature_layers": ["runtime", "ir"], "feature_directives": ["for", "atomic", "target"], "files_changed": [{"filename": "openmp/libomptarget/DeviceRTL/src/Synchronization.cpp", "functions": ["__atomic_fetch_min", "__atomic_fetch_add", "__atomic_fetch_max", "__atomic_fetch_and", "__atomic_fetch_or", "__atomic_fetch_xor"]}]}
{"pr_number": 75967, "url": "https://github.com/llvm/llvm-project/pull/75967", "title": "[libc] try fixing LlvmLibcStackChkFail.Smash again", "body": "Looks like adding attributes to lambdas wasn't added to ISO C++ until C++23.\nForget lambdas and just use a static function.\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "libc/test/src/compiler/stack_chk_guard_test.cpp", "functions": ["smash_stack"]}]}
{"pr_number": 75973, "url": "https://github.com/llvm/llvm-project/pull/75973", "title": "[CommandLine][NFC] Replace 'std::function' with 'function_ref'", "body": "This implements a post-commit suggestion for #75679.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Support/CommandLine.cpp", "functions": ["forEachSubCommand"]}]}
{"pr_number": 75977, "url": "https://github.com/llvm/llvm-project/pull/75977", "title": "Skip the thinlto icp test on powerpc. ", "body": "One ppc build-bot reports missed imports of indirect callees (https://lab.llvm.org/buildbot/#/builders/231/builds/18902)\r\n\r\nCannot reproduce this on an x86 machine with `-DLLVM_TARGETS_TO_BUILD=\"X86;PowerPC\"`. Will need to repro and fix.", "feature_layers": ["ir"], "feature_directives": ["target"], "files_changed": [{"filename": "compiler-rt/test/profile/instrprof-thinlto-indirect-call-promotion.cpp", "functions": ["callee0", "callee1", "void", "main", "global_func"]}]}
{"pr_number": 75959, "url": "https://github.com/llvm/llvm-project/pull/75959", "title": "[TextAPI] use unique sorted vector for holding target triples for", "body": "reading dylibs\r\n\r\n* This is a better fix than what I originally did to appease CI.", "feature_layers": [], "feature_directives": ["for", "target"], "files_changed": [{"filename": "llvm/lib/TextAPI/BinaryReader/DylibReader.cpp", "functions": ["emplace"]}]}
{"pr_number": 74757, "url": "https://github.com/llvm/llvm-project/pull/74757", "title": "Debuginfod failed-server cache", "body": "When using the Debuginfod library to pull symbols, a non-responding server is a major performance hit. I've added a \"failed server\" cache so that if a server has failed to respond, the library won't continue to query it. The performance hit is moderately catastrophic in my experience: 'target create /bin/ls' takes 45 seconds to fail on a system that's trying to talk to a server that is unreachable.\r\n\r\nI'll be exposing more configuration settings for use of Debuginfod in the very near term, but for right now, this eliminates a pretty major negative user experience for folks on a Linux system sitting behind a proxy server, or in similar network-constrained situations.", "feature_layers": ["ast"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "llvm/lib/Debuginfod/Debuginfod.cpp", "functions": ["ShouldSkipServer", "RegisterFailedServer"]}]}
{"pr_number": 75469, "url": "https://github.com/llvm/llvm-project/pull/75469", "title": "Triple: Fix handling of macos with unexpected target arches", "body": "Some tools with a specified target arch, but no full triple default to the host triple. On macos hosts, this would then force using macho on targets that didn't expect it, resulting in assertions.\r\n\r\nWe should also probably emit explicit errors if the object format is specified on targets which don't handle it.", "feature_layers": [], "feature_directives": ["for", "target"], "files_changed": [{"filename": "llvm/lib/TargetParser/Triple.cpp", "functions": ["if"]}]}
{"pr_number": 75952, "url": "https://github.com/llvm/llvm-project/pull/75952", "title": "[mlir][vector][gpu] Use `makeArithReduction` in lowering patterns. NFC.", "body": "Use the `vector::makeArithReduction` helper as the source-of-truth of reduction to arith ops lowering.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/GPU/Transforms/AllReduceLowering.cpp", "functions": ["getFactory", "AccumulatorFactory"]}]}
{"pr_number": 75988, "url": "https://github.com/llvm/llvm-project/pull/75988", "title": "[libc] try fixing LlvmLibcStackChkFail.Smash a third time", "body": "Build bots are failing in post submit. Unclear why but can't reproduce locally.\nDisable this test for asan for now.\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "libc/test/src/compiler/stack_chk_guard_test.cpp", "functions": ["smash_stack"]}]}
{"pr_number": 73887, "url": "https://github.com/llvm/llvm-project/pull/73887", "title": "[IR] Disallow ZeroInit for spirv.Image", "body": "According to spirv spec, OpConstantNull's result type can't be image\r\ntype. So we can't generate zeroinitializer for spirv.Image.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/IR/Type.cpp", "functions": ["TargetTypeInfo"]}]}
{"pr_number": 75416, "url": "https://github.com/llvm/llvm-project/pull/75416", "title": "[AMDGPU][IGLP]: Add SchedGroupMask::TRANS", "body": "Makes constructing SchedGroups of this type easier, and provides ability to create them with __builtin_amdgcn_sched_group_barrier", "feature_layers": [], "feature_directives": ["barrier"], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp", "functions": ["if"]}]}
{"pr_number": 75964, "url": "https://github.com/llvm/llvm-project/pull/75964", "title": "[ELF] Add CPU name detection for CUDA architectures", "body": "Summary:\nRecently we added support for detecting the CUDA processor with the ELF\nflags. This allows us to get a string representation of it in other\ncode. This will be used by the offloading runtime.\n", "feature_layers": ["runtime"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Object/ELFObjectFile.cpp", "functions": ["getPlatformFlags", "getNVPTXCPUName"]}]}
{"pr_number": 75720, "url": "https://github.com/llvm/llvm-project/pull/75720", "title": "[Libomptarget] Remove __tgt_image_info and use the ELF directly", "body": "Summary:\nThis patch reorganizes a lot of the code used to check for compatibility\nwith the current environment. The main bulk of this patch involves\nmoving from using a separate `__tgt_image_info` struct (which just\ncontains a string for the architecture) to instead simply checking this\ninformation from the ELF directly. Checking information in the ELF is\nvery inexpensive as creating an ELF file is simply writing a base\npointer.\n\nThe main desire to do this was to reorganize everything into the ELF\nimage. We can then do the majority of these checks without first\ninitializing the plugin. A future patch will move the first ELF checks\nto happen without initializing the plugin so we no longer need to\ninitialize and plugins that don't have needed images.\n\nThis patch also adds a lot more sanity checks for whether or not the ELF\nis actually compatible. Such as if the images have a valid ABI, 64-bit\nwidth, executable, etc.\n", "feature_layers": ["ir"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "openmp/libomptarget/plugins-nextgen/amdgpu/src/rtl.cpp", "functions": ["isImageCompatible", "isELFCompatible"]}, {"filename": "openmp/libomptarget/plugins-nextgen/common/src/PluginInterface.cpp", "functions": ["Buffer", "isELFCompatible"]}, {"filename": "openmp/libomptarget/plugins-nextgen/common/src/Utils/ELF.cpp", "functions": ["StrBuf", "createError", "Callback", "withBytesAsElf"]}, {"filename": "openmp/libomptarget/plugins-nextgen/cuda/src/rtl.cpp", "functions": ["ArchStr", "isImageCompatible", "isELFCompatible", "PrefixStr"]}, {"filename": "openmp/libomptarget/plugins-nextgen/generic-elf-64bit/src/rtl.cpp", "functions": ["isImageCompatible", "isELFCompatible"]}]}
{"pr_number": 75314, "url": "https://github.com/llvm/llvm-project/pull/75314", "title": "[mlir][SCF] `scf.parallel`: Make reductions part of the terminator", "body": "This commit makes reductions part of the terminator. Instead of `scf.yield`, `scf.reduce` now terminates the body of `scf.parallel` ops. `scf.reduce` may contain an arbitrary number of reductions, with one region per reduction.\r\n\r\nExample:\r\n```mlir\r\n%init = arith.constant 0.0 : f32\r\n%r:2 = scf.parallel (%iv) = (%lb) to (%ub) step (%step) init (%init, %init)\r\n    -> f32, f32 {\r\n  %elem_to_reduce1 = load %buffer1[%iv] : memref<100xf32>\r\n  %elem_to_reduce2 = load %buffer2[%iv] : memref<100xf32>\r\n  scf.reduce(%elem_to_reduce1, %elem_to_reduce2 : f32, f32) {\r\n    ^bb0(%lhs : f32, %rhs: f32):\r\n      %res = arith.addf %lhs, %rhs : f32\r\n      scf.reduce.return %res : f32\r\n  }, {\r\n    ^bb0(%lhs : f32, %rhs: f32):\r\n      %res = arith.mulf %lhs, %rhs : f32\r\n      scf.reduce.return %res : f32\r\n  }\r\n}\r\n```\r\n\r\n`scf.reduce` operations can no longer be interleaved with other ops in the body of `scf.parallel`. This simplifies the op and makes it possible to assign the `RecursiveMemoryEffects` trait to `scf.reduce`. (This was not possible before because the op was not a terminator, causing the op to be DCE'd.)", "feature_layers": ["ir"], "feature_directives": ["parallel", "for"], "files_changed": [{"filename": "mlir/lib/Conversion/AffineToStandard/AffineToStandard.cpp", "functions": ["failure", "success"]}, {"filename": "mlir/lib/Conversion/SCFToOpenMP/SCFToOpenMP.cpp", "functions": ["addAtomicRMW"]}, {"filename": "mlir/lib/Dialect/SCF/IR/SCF.cpp", "functions": ["emitOpError", "success", "MutableOperandRange", "guard", "failure"]}]}
{"pr_number": 71622, "url": "https://github.com/llvm/llvm-project/pull/71622", "title": "[C++20] [Modules] Introduce thin BMI", "body": "Close https://github.com/llvm/llvm-project/issues/71034\r\n\r\nThis patch introduces thin BMI, which doesn't contain the definitions of functions and variables if its definitions won't contribute to the ABI.\r\n\r\nTesting is a big part of the patch. We want to make sure the thin BMI contains the same behavior with the existing and relatively stable fatBMI. This is pretty helpful for further reduction.\r\n\r\nFor user interfeaces, this patch introduces `-fthinBMI-output=` arguments to specify the position of thin BMI. This should be used when compiling a single module unit.\r\n\r\nThe design is helpful to use thin BMI in two phase compilations too. With thin BMI, In two phase compilations, we'll generate 2 BMIs, one thin BMI for being used by consumers, one fat BMI for compiling itself to object files. Maybe it sounds confusing to have 2 BMIs for one module unit. But only the thin BMI will be the BMI we're talking about generally and the fat BMI is only visible by the module unit itself.\r\n\r\nWith one phase compilation, we may find the behavior of `-fthinBMI-output=` is pretty similar with `-fmodule-output=`, except one generating thin BMI and the other generating fat BMI. The design here is based on 2 things:\r\n(1) The serialization of C++ is pretty complex. We can't be sure we're handling every detail correctly in the every beginning.\r\n(2) The fat BMI is relatively widely used and relatively stable. So it looks not good to replace the fat BMI immediately with thin BMI.\r\n\r\nBut, of course, in the end of the day, we want the consumers to use the thin BMI only. When that day comes, the `-fmodule-output=` will be an alias to `-fthinBMI-output=`.\r\n\r\nAnother design choice is to reuse `-fmodule-output=` and introduce a flag `-femit-thin-BMI`. Then `-femit-thin-BMI -fmodule-output=` will have the same effect with `-fthinBMI-output=` now.\r\nThe flag `-femit-thin-BMI` should be opt-in now and opt-off later and finally deprecated.\r\n\r\nThe roadmap for thin BMI in my mind is:\r\n\r\n(1) In clang18, release thin BMI and mark it as experimental. Also encourage users and build systems to try this new mode. (2) In clang19 or clang20 (based on the issue feedbacks), remove the experimental mark for thin BMI and mark fat BMI as deprecated to be used by consumers.\r\n(3) In clang21 or clang22, error out if we found the users are trying to import a fat BMI.\r\n\r\nCC: @mathstuf ", "feature_layers": [], "feature_directives": ["for", "single"], "files_changed": [{"filename": "clang/lib/Frontend/FrontendActions.cpp", "functions": ["CreateThinBMIGenerator"]}, {"filename": "clang/lib/Serialization/ASTWriterDecl.cpp", "functions": ["W"]}, {"filename": "clang/lib/Serialization/GeneratePCH.cpp", "functions": ["getOutputFile", "getBufferPtr"]}]}
{"pr_number": 75900, "url": "https://github.com/llvm/llvm-project/pull/75900", "title": "[Clang][Wswitch-default] Warning for enum even completely covered the cases", "body": "", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/Sema/switch-default.c", "functions": ["check_enum"]}]}
{"pr_number": 75073, "url": "https://github.com/llvm/llvm-project/pull/75073", "title": "[MLIR][transform][python] add sugared python abstractions for transform dialect", "body": "This adds Python abstractions for the different handle types of the transform dialect \r\n\r\nThe abstractions allow for straightforward chaining of transforms by calling their member functions.\r\nAs an initial PR for this infrastructure, only a single transform is included: `transform.structured.match`. \r\nWith a future `tile` transform abstraction an example of the usage is: \r\n```Python\r\ndef script(module: OpHandle):\r\n    module.match_ops(MatchInterfaceEnum.TilingInterface).tile(tile_sizes=[32,32])\r\n```\r\nto generate the following IR:\r\n```mlir\r\n%0 = transform.structured.match interface{TilingInterface} in %arg0\r\n%tiled_op, %loops = transform.structured.tile_using_for %0 [32, 32]\r\n```\r\n\r\nThese abstractions are intended to enhance the usability and flexibility of the transform dialect by providing an accessible interface that allows for easy assembly of complex transformation chains.", "feature_layers": ["ir", "ast"], "feature_directives": ["for", "single"], "files_changed": [{"filename": "mlir/lib/CAPI/Dialect/Transform.cpp", "functions": ["mlirTransformAnyParamTypeGetTypeID", "mlirTransformAnyValueTypeGetTypeID", "mlirTransformParamTypeGetTypeID", "wrap", "mlirTransformAnyOpTypeGetTypeID"]}]}
{"pr_number": 75954, "url": "https://github.com/llvm/llvm-project/pull/75954", "title": "Reland the reland \"[PGO][GlobalValue][LTO]In GlobalValues::getGlobalIdentifier, use semicolon as delimiter for local-linkage varibles. \"  ", "body": "Simplify the compiler-rt test to make it more general for different platforms, and use `*DAG` matchers for lines that may be emitted out-of-order.\r\n- The compiler-rt  test passed on a Windows machine. Previously name matchers don't work for MSVC mangling (https://lab.llvm.org/buildbot/#/builders/127/builds/59907)\r\n- `*DAG` matchers fixed the error in https://lab.llvm.org/buildbot/#/builders/94/builds/17924\r\n\r\nThis is the second reland and fixed errors caught in first reland (https://github.com/llvm/llvm-project/pull/75860)\r\n\r\n**Original commit message**\r\nCommit fe05193 (phab D156569), IRPGO names uses format `[<filepath>;]<linkage-name>` while prior format is `[<filepath>:<mangled-name>`. The format change would break the use case demonstrated in (updated)\r\n`llvm/test/Transforms/PGOProfile/thinlto_indirect_call_promotion.ll` and `compiler-rt/test/profile/instrprof-thinlto-indirect-call-promotion.cpp`\r\n\r\nThis patch changes `GlobalValues::getGlobalIdentifer` to use the semicolon.\r\n\r\nTo elaborate on the scenario how things break without this PR\r\n1. IRPGO raw profiles stores (compressed) IRPGO names of functions in one section, and per-function profile data in another section. The [NameRef](https://github.com/llvm/llvm-project/blob/fc715e4cd942612a091097339841733757b53824/compiler-rt/include/profile/InstrProfData.inc#L72) field in per-function profile data is the MD5 hash of IRPGO names.\r\n2. When raw profiles are converted to indexed format profiles, the profiled address is [mapped](https://github.com/llvm/llvm-project/blob/fc715e4cd942612a091097339841733757b53824/llvm/lib/ProfileData/InstrProf.cpp#L876-L885) to the MD5 hash of the callee.\r\n3. In `pgo-instr-use` thin-lto prelink pipeline, MD5 hash of IRPGO names will be [annotated](https://github.com/llvm/llvm-project/blob/fc715e4cd942612a091097339841733757b53824/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp#L1707) as value profiles, and used to import indirect-call-prom candidates. If the annotated MD5 hash is computed from the new format while import uses the prior format, the callee cannot be imported.\r\n\r\n* `compiler-rt/test/profile/instrprof-thinlto-indirect-call-promotion.cpp` is added to have an end-to-end test.\r\n* `llvm/test/Transforms/PGOProfile/thinlto_indirect_call_promotion.ll` is updated to have better test coverage from another aspect (as runtime tests are more sensitive to the environment and may be skipped by some contributors)", "feature_layers": ["runtime", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "compiler-rt/test/profile/instrprof-thinlto-indirect-call-promotion.cpp", "functions": ["callee0", "callee1", "void", "main", "global_func"]}]}
{"pr_number": 75887, "url": "https://github.com/llvm/llvm-project/pull/75887", "title": "[mlir] Require folders to produce Values of same type", "body": "This commit adds extra assertions to `OperationFolder` and `OpBuilder` to ensure that the types of the folded SSA values match with the result types of the op. There used to be checks that discard the folded results if the types do not match. This commit makes these checks stricter and turns them into assertions.\r\n\r\nDiscarding folded results with the wrong type (without failing explicitly) can hide bugs in op folders. Two such bugs became apparent in MLIR (and some more in downstream projects) and are fixed with this change.\r\n\r\nNote: The existing type checks were introduced in https://reviews.llvm.org/D95991.\r\n\r\nMigration guide: If you see failing assertions (`folder produced value of incorrect type`; make sure to run with assertions enabled!), run with `-debug` or dump the operation right before the failing assertion. This will point you to the op that has the broken folder. A common mistake is a mismatch between static/dynamic dimensions (e.g., input has a static dimension but folded result has a dynamic dimension).\r\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/IR/Builders.cpp", "functions": ["cleanupFailure"]}, {"filename": "mlir/lib/Transforms/Utils/FoldUtils.cpp", "functions": ["failure"]}, {"filename": "mlir/test/lib/Dialect/Test/TestDialect.cpp", "functions": ["getOperand"]}]}
{"pr_number": 75020, "url": "https://github.com/llvm/llvm-project/pull/75020", "title": "[mlir][IR] Change block/region walkers to enumerate `this` block/region", "body": "This change makes block/region walkers consistent with operation walkers. An operation walk enumerates the current operation. Similarly, block/region walks should enumerate the current block/region.\r\n\r\nExample:\r\n```\r\n// Current behavior:\r\nop1->walk([](Operation *op2) { /* op1 is enumerated */ });\r\nblock1->walk([](Block *block2) { /* block1 is NOT enumerated */ });\r\nregion1->walk([](Block *block) { /* blocks of region1 are NOT enumerated */ });\r\nregion1->walk([](Region *region2) { /* region1 is NOT enumerated });\r\n\r\n// New behavior:\r\nop1->walk([](Operation *op2) { /* op1 is enumerated */ });\r\nblock1->walk([](Block *block2) { /* block1 IS enumerated */ });\r\nregion1->walk([](Block *block) { /* blocks of region1 ARE enumerated */ });\r\nregion1->walk([](Region *region2) { /* region1 IS enumerated });\r\n```\r\n", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/test/lib/IR/TestVisitors.cpp", "functions": ["testBlockAndRegionWalkers"]}]}
{"pr_number": 75126, "url": "https://github.com/llvm/llvm-project/pull/75126", "title": "[mlir][bufferization] Buffer deallocation: skip ops that do not operate on buffers", "body": "Skip ops that do not operate on buffers during ownership-based buffer deallocation. Such ops can be ignored during buffer deallocation. (Except for terminators.)", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Bufferization/Transforms/OwnershipBasedBufferDeallocation.cpp", "functions": ["regionOperatesOnMemrefValues", "hasNoAllocateOrFreeSideEffect", "hasBufferSemantics"]}]}
{"pr_number": 75556, "url": "https://github.com/llvm/llvm-project/pull/75556", "title": "[ClangRepl] Reland Semanic Code Completion", "body": "This patch contains changes from 002d471a4a3cd8b429e4ca7c84fd54a642e50e4c, in\r\naddition to a bug fix that added a virtual destructor to\r\n`CompletionContextHandler`\r\n\r\nThe original changes in the orginal commit piggybacks on clang's\r\nsemantic modules to enable semantic completion.  In particular, we use\r\n`CodeCompletionContext` to differentiate two types of code completion. We also\r\nextract the relevant type information from it.\r\n", "feature_layers": ["sema", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Interpreter/CodeCompletion.cpp", "functions": ["CompletionContextHandler", "handleMacro", "handlePattern", "CCC", "handleDeclaration", "handleKeyword"]}]}
{"pr_number": 75965, "url": "https://github.com/llvm/llvm-project/pull/75965", "title": "[clangd] Perform self-containedness check at EOF", "body": "Header gurads are not detected until we hit EOF. Make sure we postpone\nany such detection until then.\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang-tools-extra/clangd/unittests/IndexActionTests.cpp", "functions": ["other"]}]}
{"pr_number": 74192, "url": "https://github.com/llvm/llvm-project/pull/74192", "title": "[mlir][spirv] Add folding for SPIR-V Shifting ops", "body": "Add missing constant propogation folder for LeftShiftLogical, RightShift[Logical|Arithmetic].\r\n\r\nImplement additional folding when Shift value is 0.\r\n\r\nThis helps for readability of lowered code into SPIR-V.\r\n\r\nPart of work for #70704", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/SPIRV/IR/SPIRVCanonicalization.cpp", "functions": ["getOperand1"]}]}
{"pr_number": 75596, "url": "https://github.com/llvm/llvm-project/pull/75596", "title": "[AArch64] Update target feature requirements of SVE bfloat instructions", "body": "According to the latest update of the ISA\r\nhttps://developer.arm.com/documentation/ddi0602/2023-09/?lang=en all of the affected instruction encodings now require\r\n\r\n    (FEAT_SVE2 or FEAT_SME2) and FEAT_SVE_B16B16", "feature_layers": ["ir"], "feature_directives": ["target"], "files_changed": [{"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_bfadd.c", "functions": ["test_svadd_bf16_m", "test_svadd_bf16_x", "test_svadd_bf16_n_m", "test_svadd_bf16_z", "test_svadd_bf16_n_x", "test_svadd_bf16_n_z"]}, {"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_bfmax.c", "functions": ["test_svmax_bf16_n_m", "test_svmax_bf16_x", "test_svmax_bf16_m", "test_svmax_bf16_z", "test_svmax_bf16_n_z", "test_svmax_bf16_n_x"]}, {"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_bfmaxnm.c", "functions": ["test_svmaxnm_bf16_n_z", "test_svmaxnm_bf16_m", "test_svmaxnm_bf16_z", "test_svmaxnm_bf16_n_x", "test_svmaxnm_bf16_n_m", "test_svmaxnm_bf16_x"]}, {"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_bfmin.c", "functions": ["test_svmin_bf16_m", "test_svmin_bf16_n_x", "test_svmin_bf16_x", "test_svmin_bf16_n_m", "test_svmin_bf16_n_z", "test_svmin_bf16_z"]}, {"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_bfminnm.c", "functions": ["test_svminnm_bf16_n_x", "test_svminnm_bf16_z", "test_svminnm_bf16_n_z", "test_svminnm_bf16_m", "test_svminnm_bf16_n_m", "test_svminnm_bf16_x"]}, {"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_bfmla.c", "functions": ["test_svmla_n_bf16_m", "test_svmla_bf16_x", "test_svmla_bf16_z", "test_svmla_n_bf16_x", "test_svmla_bf16_m", "test_svmla_n_bf16_z"]}, {"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_bfmls.c", "functions": ["test_svmls_bf16_m", "test_svmls_bf16_x", "test_svmls_n_bf16_m", "test_svmls_n_bf16_x", "test_svmls_bf16_z", "test_svmls_n_bf16_z"]}, {"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_bfmul.c", "functions": ["test_svmul_bf16_n_z", "test_svmul_bf16_x", "test_svmul_bf16_m", "test_svmul_bf16_z", "test_svmul_bf16_n_m", "test_svmul_bf16_n_x"]}, {"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_bfsub.c", "functions": ["test_svsub_bf16_m", "test_svsub_bf16_n_z", "test_svsub_bf16_x", "test_svsub_bf16_n_x", "test_svsub_bf16_z", "test_svsub_bf16_n_m"]}]}
{"pr_number": 71631, "url": "https://github.com/llvm/llvm-project/pull/71631", "title": "[mlir][emitc] Add op modelling C expressions", "body": "Add an emitc.expression operation that models C expressions, and provide\ntransforms to form and fold expressions. The translator emits the body of\nemitc.expression ops as a single C expression.\nThis expression is emitted by default as the RHS of an EmitC SSA value, but if\npossible, expressions with a single use that is not another expression are\ninstead inlined. Specific expression's inlining can be fine tuned by lowering\npasses and transforms.\n", "feature_layers": ["ir"], "feature_directives": ["for", "single"], "files_changed": [{"filename": "mlir/lib/Dialect/EmitC/IR/EmitC.cpp", "functions": ["emitOpError", "success"]}, {"filename": "mlir/lib/Dialect/EmitC/Transforms/FormExpressions.cpp", "functions": ["runOnOperation", "signalPassFailure", "patterns", "builder", "getDependentDialects"]}, {"filename": "mlir/lib/Dialect/EmitC/Transforms/Transforms.cpp", "functions": ["createExpression"]}, {"filename": "mlir/lib/Target/Cpp/TranslateToCpp.cpp", "functions": ["getEmittedExpression", "lowestPrecedence", "success", "isPartOfCurrentExpression", "interleaveCommaWithError", "getExpressionPrecedence", "getOrCreateName", "failure", "getOperatorPrecedence", "pushExpressionPrecedence", "popExpressionPrecedence", "emitOperand", "emitExpression", "shouldBeInlined"]}]}
{"pr_number": 74203, "url": "https://github.com/llvm/llvm-project/pull/74203", "title": "[InstrRef][nfc] Remove usage of unique_ptrs of arrays", "body": "These are usually difficult to reason about, and they were being used to pass raw pointers around with array semantic (i.e., we were using operator [] on raw pointers). To put it in InstrRef terminology: we were passing a pointer to a ValueTable but using it as if it were a FuncValueTable.\r\n\r\nThese could have easily been SmallVectors, which now allow us to have reference semantics in some places, as well as simpler initialization.\r\n\r\nIn the future, we can use even more pass-by-reference with some extra changes in the code.", "feature_layers": ["sema"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp", "functions": ["MInLocs", "MOutLocs"]}]}
{"pr_number": 68680, "url": "https://github.com/llvm/llvm-project/pull/68680", "title": "[ValueTracking] isNonZero sub of ptr2int's with recursive GEP", "body": "When the sub arguments are ptr2int it is not possible to determine computeKnownBits() of its arguments.\r\nFor scalar case generally sub of 2 ptr2int are converted to sub of indexes.\r\nHowever a loop with recursive GEP/PHI where the arguments to sub is of type ptr2int, if it is possible to determine that a sub of this GEP and another pointer with the same base is KnownNonZero we can return this. This helps subsequent passes to optimize the loop further.\r\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Analysis/ValueTracking.cpp", "functions": ["isKnownNonEqual"]}]}
{"pr_number": 75970, "url": "https://github.com/llvm/llvm-project/pull/75970", "title": "[acc] Initial implementation of MemoryEffects on `acc` operations", "body": "The `acc` dialect operations now implement MemoryEffects interfaces in the following ways:\r\n- Data entry operations which may read host memory via `varPtr` are now marked as so. The majority of them do NOT actually read the host memory. For example, `acc.present` works on the basis of presence of pointer and not necessarily what the data points to - so they are not marked as reading the host memory. They still use `varPtr` though but this dependency is reflected through ssa.\r\n- Data clause operations which may mutate the data pointed to by `accPtr` are marked as doing so.\r\n- Data clause operations which update required structured or dynamic runtime counters are marked as reading and writing the newly defined `RuntimeCounters` resource. Some operations, like `acc.getdeviceptr` do not actually use the runtime counters - but are marked as reading them since the address obtained depends on the mapping operations which do update the runtime counters. Namely, `acc.getdeviceptr` cannot be moved across other mapping operations.\r\n- Constructs are marked as writing to the `ConstructResource`. This may be too strict but is needed for the following reasons: 1) Structured constructs may not use `accPtr` and instead use `varPtr` - when this is the case, data actions may be removed even when used. 2) Unstructured constructs are currently used to aggregate multiple data actions. We do not want such constructs removed or moved for now.\r\n- Terminators are marked as `Pure` as in other dialects.\r\n\r\nThe current approach has the following limitations which may require further improvements:\r\n- Subsequent `acc.copyin` operations on same data do not actually read host memory pointed to by `varPtr` but are still marked as so.\r\n- Two `acc.delete` operations on same data may not mutate `accPtr` until the runtime counters are zero (but are still marked as mutating).\r\n- The `varPtrPtr` argument, when present, points to the address of location of `varPtr`. When mapping to target device, an `accPtrPtr` needs computed and this memory is mutated. This effect is not captured since the current operations do not produce `accPtrPtr`.\r\n- Runtime counter effects are imprecise since two operations with differing `varPtr` increment/decrement different counters. Additionally, operations with `varPtrPtr` mutate attachment counters.\r\n- The `ConstructResource` is too strict and likely can be relaxed with better modeling.", "feature_layers": ["runtime", "ir"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "mlir/lib/Dialect/OpenACC/IR/OpenACC.cpp", "functions": ["emitError"]}]}
{"pr_number": 73077, "url": "https://github.com/llvm/llvm-project/pull/73077", "title": "[clang][Sema] Add -Wswitch-default warning option", "body": "Adds a warning, issued by the clang semantic analysis. The patch warns on switch which don't have the default branch.\r\n\r\nThis is a counterpart of gcc's Wswitch-default.", "feature_layers": ["sema"], "feature_directives": [], "files_changed": [{"filename": "clang/test/Sema/switch-default.c", "functions": ["f1", "f2"]}]}
{"pr_number": 75527, "url": "https://github.com/llvm/llvm-project/pull/75527", "title": "[ARM] Check all terms in emitPopInst when clearing Restored for LR.", "body": "emitPopInst checks a single function exit MBB. If other paths also exit the function and any of there terminators uses LR implicitly, it is not save to clear the Restored bit.\r\n\r\nCheck all terminators for the function before clearing Restored.\r\n\r\nThis fixes a mis-compile in outlined-fn-may-clobber-lr-in-caller.ll\r\nwhere the machine-outliner previously introduced BLs that clobbered LR\r\nwhich in turn is used by the tail call return.\r\n\r\nAlternative to #73553", "feature_layers": [], "feature_directives": ["for", "single"], "files_changed": [{"filename": "llvm/lib/Target/ARM/ARMFrameLowering.cpp", "functions": ["all_of"]}]}
{"pr_number": 73124, "url": "https://github.com/llvm/llvm-project/pull/73124", "title": "[flang][Driver] Let the linker fail on multiple definitions of main()", "body": "The flang driver was silently ignoring the `main()` function in `Fortran_main.a` for entry into the Fortran program unit if an external `main()` as supplied (e.g., via cross-language linkage with Fortran and C/C++).  This PR fixes this by making sure that the linker always pulls in the `main()` definition from `Fortran_main.a` and consequently fails due to multiple definitions of the same symbol if another object file also has a definition of `main()`.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "flang/test/Driver/Inputs/main_dupes.c", "functions": ["main"]}]}
{"pr_number": 75007, "url": "https://github.com/llvm/llvm-project/pull/75007", "title": "[TextAPI] Add support to convert RecordSlices -> InterfaceFile", "body": "Introduce RecordVisitor. This is used for different clients that want to extract information out of RecordSlice types.\r\nThe first and immediate use case is for serializing symbol information into TBD files.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/TextAPI/BinaryReader/DylibReader.cpp", "functions": ["convertToInterfaceFile"]}, {"filename": "llvm/lib/TextAPI/RecordVisitor.cpp", "functions": ["shouldSkipRecord"]}, {"filename": "llvm/lib/TextAPI/RecordsSlice.cpp", "functions": ["Converter"]}]}
{"pr_number": 75989, "url": "https://github.com/llvm/llvm-project/pull/75989", "title": "[mlir][arith] Add support for expanding arith.maxnumf/minnumf ops.", "body": "The maxnum/minnum semantics can be found at https://llvm.org/docs/LangRef.html#llvm-minnum-intrinsic.\r\n\r\nThe revision also updates function names in lit tests to match op name.\r\n\r\nTake arith.maxnumf as example:\r\n\r\n```\r\nfunc.func @maxnumf(%lhs: f32, %rhs: f32) -> f32 {\r\n  %result = arith.maxnumf %lhs, %rhs : f32\r\n  return %result : f32\r\n}\r\n```\r\n\r\nwill be expanded to\r\n\r\n```\r\nfunc.func @maxnumf(%lhs: f32, %rhs: f32) -> f32 {\r\n  %0 = arith.cmpf ugt, %lhs, %rhs : f32\r\n  %1 = arith.select %0, %lhs, %rhs : f32\r\n  %2 = arith.cmpf uno, %lhs, %lhs : f32\r\n  %3 = arith.select %2, %rhs, %1 : f32\r\n  return %3 : f32\r\n}\r\n```\r\n\r\nCase 1: Both LHS and RHS are not NaN; LHS > RHS\r\n\r\nIn this case, `%1` is LHS. `%3` and `%1` have the same value, so `%3` is LHS.\r\n\r\nCase 2: LHS is NaN and RHS is not NaN\r\n\r\nIn this case, `%2` is true, so `%3` is always RHS.\r\n\r\nCase 3: LHS is not NaN and RHS is NaN\r\n\r\nIn this case, `%0` is true and `%1` is LHS. `%2` is false, so `%3` and `%1` have the same value, which is LHS.\r\n\r\nCase 4: Both LHS and RHS are NaN:\r\n\r\n`%1` and RHS are all NaN, so the result is still NaN.", "feature_layers": ["sema", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Arith/Transforms/ExpandOps.cpp", "functions": ["success"]}]}
{"pr_number": 72150, "url": "https://github.com/llvm/llvm-project/pull/72150", "title": "[lldb] Remove 2nd \"error: \" substring in output to developer", "body": "This patch serves 2 goals:\r\n- Remove a second \"error: \" substring in error messages from debugging Swift.\r\n- Print caret (^) line with optional leading/trailing tildes (~) below the line the developer last entered.\r\n\r\nHere' an example from a Swift app:\r\n```\r\n(lldb) p abc\r\nerror: <EXPR>:3:1: error: cannot find 'abc' in scope\r\nabc\r\n^~~\r\n```\r\n\r\nAnd here's what that same error message is after the patch\r\n```\r\n(lldb) p abc\r\n         ^~~\r\nerror: <EXPR>:3:1: cannot find 'abc' in scope\r\nabc\r\n^~~\r\n```\r\n\r\nTo make this work, the patch passes the diagnostics up the call stack to `CommandInterpreter::IOHandlerInputComplete(...)` because the deepest call frame that knows what the developer entered at the prompt. This is important for commands like DWIM print (and its aliases 'p' and 'po') where the length of the actual command they typed in gets us the correct spacing to pad before the line with the caret.\r\n\r\nTo get the diagnostics up to that level, I added a vector of `Diagnostic` instances into `Status` and `CommandReturnObject`. I originally prototyped this by hoisting a `DiagnosticManager` manager instance but it's a bit heavy handed for what we need to accomplish the goal.", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "lldb/source/Expression/UserExpression.cpp", "functions": ["detail"]}]}
{"pr_number": 74912, "url": "https://github.com/llvm/llvm-project/pull/74912", "title": "[lldb] In-progress \u2014 All ValueObjectSP instances are now valid (non-null) but have an error state", "body": "### Purpose\r\nFor now, we'd like to get people's thought's on the goal, design, and scope of this PR by reviewing these preliminary changes.\r\n\r\nI recommend focussing (or starting) on these files:\r\n* `ValueObject.h`\r\n* `ValueObject.cpp`\r\n\r\n\r\n### Goal\r\nEvery `ValueObjectSP` will have an actual value and will never be equal to `nullptr`.\r\n\r\n\r\n### Design\r\nTo force each `ValueObjectSP` to contain _something_, we're considering changing the type from a typedef\u2026\r\n```cpp\r\ntypedef std::shared_ptr<lldb_private::ValueObject> ValueObjectSP;\r\n\r\n```\r\n\r\nto this subclass:\r\n```cpp\r\nclass ValueObjectSP : public std::shared_ptr<lldb_private::ValueObject> {\r\n  ValueObjectSP() = delete;\r\n  operator bool() = delete;\r\n\r\npublic:\r\n  ValueObjectSP(std::shared_ptr<lldb_private::ValueObject> &&pointer)\r\n      : std::shared_ptr<lldb_private::ValueObject>(std::move(pointer)) {\r\n    assert(pointer);\r\n  }\r\n};\r\n```\r\n\r\nThis class removes the default constructor to force each `ValueObjectSP` to point to a real `ValueObject` instance. It also removes `operator bool()` because no instance will ever equal `nullptr`. \r\n\r\n\r\n### Change Patterns\r\nThe bulk of the changes into one of these two camps:\r\n1. For methods that have a `Status &error` parameter **and** return an `ValueObjectSP`, the return value *becomes* the container for the error state, which eliminate the need for a parameter.\r\n* This means that callers of these methods need to check the return value's error state.\r\n  * `return_value->GetError.Success()`\r\n  * `return_value->GetError.Fail()`\r\n\r\n2. For all other methods that return a `ValueObjectSP` but don't have a `Status &` parameter, they now return `std::optional<ValueObjectSP>`.\r\n* This changes a fair amount of code in these ways:\r\n  * Code which had been using the `std::shared_ptr` Boolean operator now uses the `std::optional` Boolean operator.\r\n  * Nearby code has to call the optional's `value()` method to get the shared pointer inside.\r\n  * Methods with lines that return `ValueObjectSP()` now return `{}`, which creates an optional with nothing in it.\r\n\r\nAgain, I recommend focussing (or starting) on these files:\r\n* `ValueObject.h`\r\n* `ValueObject.cpp`\r\n\r\n\r\n### Remaining work\r\nThis is very much a work-in-progress for a proof of concept, which means:\r\n* It doesn't compile (yet)\r\n* So far I've modified 53 files\r\n* I estimate another 100-250 more files need to change based on the ninja build progress indicator.\r\n\r\nThe remaining changes will just be more of the same but now's a good time to take a look at this sample to get a sense of the magnitude and trajectory of the remaining changes.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "lldb/source/Commands/CommandObjectExpression.cpp", "functions": ["error"]}, {"filename": "lldb/source/Commands/CommandObjectFrame.cpp", "functions": ["printer"]}, {"filename": "lldb/source/Commands/CommandObjectWatchpoint.cpp", "functions": ["compiler_type"]}, {"filename": "lldb/source/Core/IOHandlerCursesGUI.cpp", "functions": ["value"]}, {"filename": "lldb/source/Core/ValueObject.cpp", "functions": ["root", "exe_ctx", "ValueObjectSP", "GetSP"]}, {"filename": "lldb/source/Core/ValueObjectConstResult.cpp", "functions": ["ValueObjectSP"]}, {"filename": "lldb/source/Core/ValueObjectRegister.cpp", "functions": ["ValueObjectSP"]}, {"filename": "lldb/source/Core/ValueObjectSyntheticFilter.cpp", "functions": ["synth_val", "GetChildAtIndex"]}, {"filename": "lldb/source/DataFormatters/FormatManager.cpp", "functions": ["synth_sp", "child_sp", "child_compiler_type"]}, {"filename": "lldb/source/DataFormatters/ValueObjectPrinter.cpp", "functions": ["child_sp"]}, {"filename": "lldb/source/DataFormatters/VectorType.cpp", "functions": ["GetChildAtIndex"]}, {"filename": "lldb/source/Target/StackFrame.cpp", "functions": ["GetValueForOffset", "ValueObjectSP", "deref_valobj_sp", "GetValueObjectForFrameVariable", "if", "address_of_valobj_sp", "temp"]}, {"filename": "lldb/source/Target/Thread.cpp", "functions": ["ValueObjectSP"]}]}
{"pr_number": 75935, "url": "https://github.com/llvm/llvm-project/pull/75935", "title": "[clang] Add getClangVendor() and use it in CodeGenModule.cpp", "body": "In 9a38a72f1d482 `ProductId` was assigned from the stringified value of `CLANG_VENDOR`, if that macro was defined. However, `CLANG_VENDOR` is supposed to be a string, as it is defined (optionally) as such in the top-level clang `CMakeLists.txt`.\r\n\r\nMove the addition of `-DCLANG_VENDOR` to the compiler flags from `clang/lib/Basic/CMakeLists.txt` to the top-level `CMakeLists.txt`, so it is consistent across the whole clang codebase. Then remove the stringification from `CodeGenModule.cpp`, to make it work correctly.\r\n\r\nFixes:\t\t9a38a72f1d482", "feature_layers": ["codegen"], "feature_directives": [], "files_changed": [{"filename": "clang/lib/Basic/Version.cpp", "functions": ["getClangVendor"]}]}
{"pr_number": 75996, "url": "https://github.com/llvm/llvm-project/pull/75996", "title": "[flang][runtime] Enable more APIs in the offload build.", "body": "This patch enables more numeric (mod, sum, matmul, etc.) APIs,\r\nand some others.\r\n\r\nI added new macros to disable warnings about using C++ STD methods\r\nlike operators of std::complex, which do not have __device__ attribute.\r\nThis may probably result in unresolved references, if the header files\r\nimplementation relies on libstdc++. I will need to follow up on this.\r\n", "feature_layers": ["runtime"], "feature_directives": [], "files_changed": [{"filename": "flang/runtime/allocatable.cpp", "functions": ["RTDEF", "RTNAME"]}, {"filename": "flang/runtime/derived-api.cpp", "functions": ["RTDEF", "CompareDerivedTypeNames", "RTNAME"]}, {"filename": "flang/runtime/matmul-transpose.cpp", "functions": ["RTDEF", "operator", "RTNAME"]}, {"filename": "flang/runtime/matmul.cpp", "functions": ["GetResult", "RTDEF", "Accumulator", "Accumulate", "operator", "RTNAME"]}, {"filename": "flang/runtime/numeric.cpp", "functions": ["Nint", "Fraction", "RealMod", "SetExponent", "RTDEF", "Ceiling", "Scale", "Exponent", "RTNAME", "Floor", "FPowI", "IntMod", "Nearest"]}, {"filename": "flang/runtime/reduction.cpp", "functions": ["GetResult", "AccumulateAt", "RTDEF", "Reinitialize", "RTNAME", "IntegerAndAccumulator", "IntegerXorAccumulator", "IntegerOrAccumulator"]}, {"filename": "flang/runtime/sum.cpp", "functions": ["ComplexSumAccumulator", "AccumulateAt", "GetResult", "RTDEF", "Result", "Reinitialize", "IntegerSumAccumulator", "Accumulate", "RTNAME", "RealSumAccumulator"]}, {"filename": "flang/runtime/support.cpp", "functions": ["RTDEF", "RTNAME"]}]}
{"pr_number": 74008, "url": "https://github.com/llvm/llvm-project/pull/74008", "title": "[PGO][GlobalValue][LTO]In GlobalValues::getGlobalIdentifier, use semicolon as delimiter for local-linkage varibles.", "body": "Commit fe05193 (phab D156569), IRPGO names uses format `[<filepath>;]<linkage-name>` while prior format is `[<filepath>:<mangled-name>`. The format change would break the use case demonstrated in (updated)\r\n`llvm/test/Transforms/PGOProfile/thinlto_indirect_call_promotion.ll` and `compiler-rt/test/profile/instrprof-thinlto-indirect-call-promotion.cpp`\r\n\r\nThis patch changes `GlobalValues::getGlobalIdentifer` to use the semicolon.\r\n\r\nTo elaborate on the scenario how things break without this PR\r\n1. IRPGO raw profiles stores (compressed) IRPGO names of functions in one section, and per-function profile data in another section. The [NameRef](https://github.com/llvm/llvm-project/blob/fc715e4cd942612a091097339841733757b53824/compiler-rt/include/profile/InstrProfData.inc#L72) field in per-function profile data is the MD5 hash of IRPGO names.\r\n2. When raw profiles are converted to indexed format profiles, the profiled address is [mapped](https://github.com/llvm/llvm-project/blob/fc715e4cd942612a091097339841733757b53824/llvm/lib/ProfileData/InstrProf.cpp#L876-L885) to the MD5 hash of the callee.\r\n3. In `pgo-instr-use` thin-lto prelink pipeline, MD5 hash of IRPGO names will be [annotated](https://github.com/llvm/llvm-project/blob/fc715e4cd942612a091097339841733757b53824/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp#L1707) as value profiles, and used to import indirect-call-prom candidates. If the annotated MD5 hash is computed from the new format while import uses the prior format, the callee cannot be imported.\r\n\r\n* `compiler-rt/test/profile/instrprof-thinlto-indirect-call-promotion.cpp` is added to have an end-to-end test.\r\n* `llvm/test/Transforms/PGOProfile/thinlto_indirect_call_promotion.ll` is updated to have better test coverage from another aspect (as runtime tests are more sensitive to the environment and may be skipped by some contributors)", "feature_layers": ["runtime", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/ProfileData/InstrProf.cpp", "functions": ["getPGOFuncName", "getLegacyPGOFuncName"]}, {"filename": "llvm/test/Transforms/PGOProfile/Inputs/lib.cc", "functions": ["global_func", "callee0", "callee1", "void"]}, {"filename": "llvm/test/Transforms/PGOProfile/Inputs/main.cc", "functions": ["main"]}, {"filename": "compiler-rt/test/profile/instrprof-thinlto-indirect-call-promotion.cpp", "functions": ["callee0", "callee1", "void", "main", "global_func"]}]}
{"pr_number": 76099, "url": "https://github.com/llvm/llvm-project/pull/76099", "title": "[mlir][sparse] initialize slice-driven loop-related fields in one place", "body": "", "feature_layers": ["parse", "ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/Transforms/Utils/CodegenEnv.cpp", "functions": ["merger"]}, {"filename": "mlir/lib/Dialect/SparseTensor/Transforms/Utils/LoopEmitter.cpp", "functions": ["guard"]}]}
{"pr_number": 76075, "url": "https://github.com/llvm/llvm-project/pull/76075", "title": "[readtapi] Setup simple stubify support", "body": "Stubify broadly takes either tbd files or binary dylibs and turns them into tbd files. In future patches, stubify will also allow additional information to be embedded into the final tbd output too.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/TextAPI/Utils.cpp", "functions": ["P"]}, {"filename": "llvm/tools/llvm-readtapi/llvm-readtapi.cpp", "functions": ["handleStubifyAction", "setStubOptions"]}]}
{"pr_number": 75864, "url": "https://github.com/llvm/llvm-project/pull/75864", "title": "[mlir][openacc] Add device_type support for compute operations", "body": "This patch adds representation for `device_type` clause information on compute construct (parallel, kernels, serial).\r\n\r\nThe `device_type` clause on compute construct impacts clauses that appear after it. The values impacted by `device_type` are now tied with an attribute array that represent the device_type associated with them. `DeviceType::None` is used to represent the value produced by a clause before any `device_type`. The operands and the attribute information are parser/printed together. \r\n\r\nThis is an example with `vector_length` clause. The first value (64) is not impacted by `device_type` so it will be represented with DeviceType::None. None is not printed. The second value (128) is tied with the `device_type(multicore)` clause. \r\n```\r\n!$acc parallel vector_length(64) device_type(multicore) vector_length(256)\r\n```\r\n```\r\nacc.parallel vector_length(%c64 : i32, %c128 : i32 [#acc.device_type<multicore>]) {\r\n}\r\n```\r\n\r\nWhen multiple values can be produced for a single clause like `num_gangs` and `wait`, an extra attribute describe the number of values belonging to each `device_type`. Values and attributes are parsed/printed together. \r\n\r\n```\r\nacc.parallel num_gangs({%c2 : i32, %c4 : i32}, {%c4 : i32} [#acc.device_type<nvidia>])\r\n```\r\n\r\nWhile preparing this patch I noticed that the wait devnum is not part of the operations and is not lowered. It will be added in a follow up patch. \r\n", "feature_layers": ["parse", "ir", "parser"], "feature_directives": ["parallel", "for", "single"], "files_changed": [{"filename": "flang/lib/Lower/OpenACC.cpp", "functions": ["constexpr"]}, {"filename": "mlir/lib/Dialect/OpenACC/IR/OpenACC.cpp", "functions": ["hasWaitOnly", "emitOpError", "success", "getValuesFromSegments", "getNumWorkersValue", "getVectorLengthValue", "getNumGangsValues", "failure", "arrayAttr", "getWaitValues", "hasAsyncOnly", "getValueInDeviceTypeSegment", "getAsyncValue"]}]}
{"pr_number": 73895, "url": "https://github.com/llvm/llvm-project/pull/73895", "title": "[BOLT] CDSplit main logic part 1/2", "body": "This diff defines and initializes auxiliary variables used by CDSplit and implements two important helper functions. The first helper function approximates the block level size increase if a function is hot-warm split at a given split index (X86 specific). The second helper function finds all calls in the form of X->Y or Y->X for each BF given function order [... X ... BF ... Y ...]. These calls are referred to as \"cover calls\". Their distance will decrease if BF's hot fragment size is further reduced by hot-warm splitting. NFC.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "bolt/lib/Passes/SplitFunctions.cpp", "functions": ["SplitCacheDirected", "extractCoverCalls", "buildCallGraph", "shouldConsiderForCallGraph", "initializeAuxiliaryVariables"]}]}
{"pr_number": 73078, "url": "https://github.com/llvm/llvm-project/pull/73078", "title": "[BOLT] Refactor SplitFunctions for function reuse. NFC.", "body": "This commit updates SplitFunctions.h and SplitFunctions.cpp to enable\r\nthe reuse of createEHTrampolines, mergeEHTrampolines, allBlocksCold \r\nby a distinct function splitting pass (CDSplit). While the SplitFunctions \r\npass happens before the function reordering pass because function \r\nreordering depends on the function splitting decisions, CDSplit will be \r\nimplemented as a separate function splitting pass and called after the \r\nfunction reordering pass to make use of the fixed function ordering to \r\nachieve better function splitting decisions. ", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "bolt/lib/Passes/SplitFunctions.cpp", "functions": ["hasFullProfile"]}]}
{"pr_number": 73084, "url": "https://github.com/llvm/llvm-project/pull/73084", "title": "[BOLT] CDSplit Main Logic Part 3/3", "body": "The third diff in a series of 3 that implements the main logic of\r\nCDSplit. CDSplit processes functions in a binary in parallel. For each\r\nfunction BF, it assumes that all other functions are hot-cold split. For\r\neach possible hot-warm split point of BF, it computes its corresponding\r\nSplitScore, and chooses the split point with the best SplitScore. The\r\nSplitScore of each split point is computed in the following way: each\r\ncall edge or jump edge has an edge score that is proportional to its\r\nexecution count, and inversely proportional to its distance. The\r\nSplitScore of a split point is a sum of edge scores over a fixed set of\r\nedges whose distance can change due to hot-warm splitting BF. This set\r\ncontains all cover calls in the form of X->Y or Y->X given function\r\norder [... X ... BF ... Y ...]; we refer to the sum of edge scores over\r\nthe set of cover calls as CoverCallScore. This set also contains all\r\njump edges (branches) within BF as well as all call edges originated\r\nfrom BF; we refer to the sum of edge scores over this set of edges as\r\nLocalScore. CDSplit finds the split index maximizing CoverCallScore +\r\nLocalScore.\r\n", "feature_layers": ["ir"], "feature_directives": ["parallel", "for"], "files_changed": [{"filename": "bolt/lib/Passes/SplitFunctions.cpp", "functions": ["keepEmpty"]}, {"filename": "bolt/lib/Passes/CDSplit.cpp", "functions": ["computeCallScore", "JumpPower", "CallPower", "computeJumpScore"]}, {"filename": "bolt/lib/Core/BinaryFunction.cpp", "functions": ["formatv"]}]}
{"pr_number": 73083, "url": "https://github.com/llvm/llvm-project/pull/73083", "title": "[BOLT] CDSplit Main Logic Part 2/3", "body": "The second diff in a series of 3 that implements the main logic of\r\nCDSplit. When the function order is [... X ... BF ... Y ...], a main\r\nbenefit of splitting the hot fragment of BF further into a hot and a\r\nwarm fragment is that function calls in the form of X->Y or Y->X will\r\nbecome shorter (i.e., SrcBB and DstBB will become closer to each other)\r\nas long as the new hot fragment of BF is smaller in size compared to\r\nthe original hot fragment. This diff implements a function that finds\r\nall such \"shortenable\" calls in the form of X->Y or Y->X for the given\r\nfunction BF.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "bolt/lib/Passes/SplitFunctions.cpp", "functions": ["keepEmpty"]}, {"filename": "bolt/lib/Passes/CDSplit.cpp", "functions": ["analyzeBranches"]}, {"filename": "bolt/lib/Core/BinaryFunction.cpp", "functions": ["formatv"]}]}
{"pr_number": 73082, "url": "https://github.com/llvm/llvm-project/pull/73082", "title": "[BOLT] CDSplit Main Logic Part 1/3", "body": "The first diff in a series of 3 that implements the main logic of\r\nCDSplit. Under X86, function splitting can lead to block size increase.\r\nThis is because conditional and unconditional branch instructions whose\r\noffset is under 8 bits can be encoded with 2 bytes. If the offset is\r\ngreater than 8 bits, then they need 6 and 5 bytes respectively.\r\nSplitting a short conditional / unconditional branch will thus increase\r\nthe size of the src basic block by 4 and 3 bytes respectively. CDSplit\r\ntakes into account the potential block size increase when it makes\r\nsplitting decisions. This diff implements a function\r\nestimatePostSplitBBAddress in CDSplit that approximates the block level\r\nsize increase at the given split index of the given function.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "bolt/lib/Passes/SplitFunctions.cpp", "functions": ["keepEmpty"]}, {"filename": "bolt/lib/Passes/CDSplit.cpp", "functions": ["analyzeBranches"]}, {"filename": "bolt/lib/Core/BinaryFunction.cpp", "functions": ["formatv"]}]}
{"pr_number": 73080, "url": "https://github.com/llvm/llvm-project/pull/73080", "title": "[BOLT] Introduce .text.warm for -use-cdsplit=1", "body": "This commit explicitly adds a warm code section, .text.warm, when the\r\n-use-cdsplit=1 flag is set. This replaces the previous approach of using\r\n.text.cold.0 as warm and .text.cold.1 as cold in 3-way splitting.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "bolt/lib/Passes/SplitFunctions.cpp", "functions": ["keepEmpty"]}, {"filename": "bolt/lib/Passes/CDSplit.cpp", "functions": ["Main", "shouldConsider", "NewLayout", "format", "Cold", "Warm"]}, {"filename": "bolt/lib/Core/BinaryFunction.cpp", "functions": ["formatv"]}]}
{"pr_number": 74991, "url": "https://github.com/llvm/llvm-project/pull/74991", "title": "[clang][ASTImporter] add processing of SubstNonTypeTemplateParmExpr in isAncestorDeclContextOf", "body": "Lack of processing of `SubstNonTypeTemplateParmExpr` in `isAncestorDeclContextOf` would make `hasAutoReturnTypeDeclaredInside` returns false and lead to infinite recursion. This patch adds the processor and try to fix [this issue](https://github.com/llvm/llvm-project/issues/74839)", "feature_layers": ["ast"], "feature_directives": ["declare"], "files_changed": [{"filename": "clang/unittests/AST/ASTImporterTest.cpp", "functions": ["bar", "foo"]}]}
{"pr_number": 75855, "url": "https://github.com/llvm/llvm-project/pull/75855", "title": "[mlir][vector] Refactor parts of `VectorToSCF.cpp` (NFC)", "body": "I'm trying to work on https://github.com/llvm/llvm-project/issues/71326. However, the code in `VectorToSCF.cpp` is quite complex. This PR suggests the following refactorings to make it slightly simpler to read:\r\n\r\n- Specify the type explicitly instead of using `auto`, except when the type is obvious (https://llvm.org/docs/CodingStandards.html#use-auto-type-deduction-to-make-code-more-readable).\r\n- Replace a few Systems Hungarian namings by less verbose ones (related to the previous point). For example, `auto signlessSourceVectorType` to `VectorType signlessSource`.\r\n-  Use `cast` instead of `dyn_cast` when the result is not tested.\r\n- Extracted one method. The code is still complex, but (in my opinion) it is now slightly more clear which variables are used where.", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Conversion/VectorToSCF/VectorToSCF.cpp", "functions": ["guard"]}]}
{"pr_number": 75662, "url": "https://github.com/llvm/llvm-project/pull/75662", "title": "[AArch64][GlobalISel] Lower scalarizing G_UNMERGE_VALUES to G_EXTRACT_VECTOR_ELT", "body": "This adds post-legalizing lowering of G_UNMERGE_VALUES which take a vector and produce scalar values for each lane. They are converted to a G_EXTRACT_VECTOR_ELT for each lane, allowing all the existing tablegen patterns to apply to them.\r\n\r\nA couple of tablegen patterns need to be altered to make sure the type of the constant operand is known, so that the patterns are recognized under global isel.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AArch64/GISel/AArch64PostLegalizerLowering.cpp", "functions": ["matchScalarizeVectorUnmerge"]}]}
{"pr_number": 74296, "url": "https://github.com/llvm/llvm-project/pull/74296", "title": "[clang][analyzer] Support `fflush` in the StreamChecker", "body": "", "feature_layers": [], "feature_directives": ["flush"], "files_changed": [{"filename": "clang/test/Analysis/stream-error.c", "functions": ["error_fflush_on_non_null_stream_clear_error_states", "error_fflush_0", "error_fflush_on_null_stream_clear_error_states", "error_fflush_after_fclose", "error_fflush_on_unknown_stream", "error_fflush_on_open_failed_stream", "error_fflush_1"]}]}
{"pr_number": 75919, "url": "https://github.com/llvm/llvm-project/pull/75919", "title": "[TLI] Add getLibFunc that accepts an Opcode and scalar Type.", "body": "It sets a LibFunc similarly with the other two getLibFunc methods. Currently, it supports only the FRem Instruction.\r\n\r\nAdd tests for FRem.\r\n\r\n# Motivation:\r\nAlmost all libm functions are represented in LLVM as intrinsics with the exception of `fmod` that is transformed into the `FREM` Instruction. This difference means existing code to map scalar calls to vector functions (as used by `LoopVectorize` and `ReplaceWithVecLib`) does not work and so first we want to map the instruction back to it\u2019s representative scalar function. \r\n\r\nGiven variants of getLibFunc exist to map an intrinsic to such functions it seems reasonable to have a variant for instructions as well.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Analysis/TargetLibraryInfo.cpp", "functions": ["if"]}, {"filename": "llvm/unittests/Analysis/TargetLibraryInfoTest.cpp", "functions": ["getFremScalarName", "getScalarName"]}]}
{"pr_number": 73642, "url": "https://github.com/llvm/llvm-project/pull/73642", "title": "[TLI] Pass replace-with-veclib works with Scalable Vectors.", "body": "[TLI] Pass replace-with-veclib works with Scalable Vectors.\r\n\r\nThe pass uses the Masked variant of TLI method when the Intrinsic\r\n operates on Scalable Vectors and it fails to find a non-Masked variant.\r\n", "feature_layers": [], "feature_directives": ["masked"], "files_changed": [{"filename": "llvm/lib/CodeGen/ReplaceWithVeclib.cpp", "functions": ["IRBuilder", "Args"]}]}
{"pr_number": 75290, "url": "https://github.com/llvm/llvm-project/pull/75290", "title": "[asan] Install `pthread_atfork`", "body": "This prevents deadlocks in forked process\nif parent had more then one running threads.\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "compiler-rt/lib/hwasan/hwasan.cpp", "functions": ["__hwasan_get_tag_from_pointer"]}, {"filename": "compiler-rt/lib/lsan/lsan_common.cpp", "functions": ["UnlockGlobal", "LockGlobal"]}, {"filename": "compiler-rt/lib/lsan/lsan_fuchsia.cpp", "functions": ["InstallAtForkHandler"]}, {"filename": "compiler-rt/lib/lsan/lsan_posix.cpp", "functions": ["InstallAtForkHandler"]}, {"filename": "compiler-rt/test/hwasan/TestCases/tag-ptr.cpp", "functions": ["main"]}]}
{"pr_number": 74637, "url": "https://github.com/llvm/llvm-project/pull/74637", "title": "[flang] add no-cpp-dep test for AIX 64 bit", "body": "Add a new test for no-cpp-dep on AIX as it requires 64 bit OBJECT_MODE since only 64-bit AIX is supported. AIX does not allow `-o /dev/null` and requires `-lpthread` flag to be added. ", "feature_layers": ["ir"], "feature_directives": ["for", "requires"], "files_changed": [{"filename": "flang/test/Runtime/no-cpp-dep-aix.c", "functions": ["main", "RTNAME"]}]}
{"pr_number": 74731, "url": "https://github.com/llvm/llvm-project/pull/74731", "title": "[lldb] add support for thread names on Windows", "body": "This PR adds support for thread names in lldb on Windows.\r\n\r\n```\r\n(lldb) thr list\r\nProcess 2960 stopped\r\n  thread #53: tid = 0x03a0, 0x00007ff84582db34 ntdll.dll`NtWaitForMultipleObjects + 20\r\n  thread #29: tid = 0x04ec, 0x00007ff845830a14 ntdll.dll`NtWaitForAlertByThreadId + 20, name = 'SPUW.6'\r\n  thread #89: tid = 0x057c, 0x00007ff845830a14 ntdll.dll`NtWaitForAlertByThreadId + 20, name = 'PPU[0x1000019] physics[main]'\r\n  thread #3: tid = 0x0648, 0x00007ff843c2cafe combase.dll`InternalDoATClassCreate + 39518\r\n  thread #93: tid = 0x0688, 0x00007ff845830a14 ntdll.dll`NtWaitForAlertByThreadId + 20, name = 'PPU[0x100501d] uMovie::StreamingThread'\r\n  thread #1: tid = 0x087c, 0x00007ff842e7a104 win32u.dll`NtUserMsgWaitForMultipleObjectsEx + 20\r\n  thread #96: tid = 0x0890, 0x00007ff845830a14 ntdll.dll`NtWaitForAlertByThreadId + 20, name = 'PPU[0x1002020] HLE Video Decoder'\r\n  thread #40: tid = 0x08e0, 0x00007ff845830a14 ntdll.dll`NtWaitForAlertByThreadId + 20, name = 'Camera Thread'\r\n  thread #78: tid = 0x0a04, 0x00007ff845830a14 ntdll.dll`NtWaitForAlertByThreadId + 20, name = 'PPU[0x100000e] _gcm_intr_thread'\r\n  thread #44: tid = 0x0a48, 0x00007ff845830a14 ntdll.dll`NtWaitForAlertByThreadId + 20, name = 'RSX.W1'\r\n  thread #90: tid = 0x0b24, 0x00007ff845830a14 ntdll.dll`NtWaitForAlertByThreadId + 20, name = 'PPU[0x100001a] physics[job]-000'\r\n  thread #80: tid = 0x0c70, 0x00007ff845830a14 ntdll.dll`NtWaitForAlertByThreadId + 20, name = 'PPU[0x1000010] Resource Loader'\r\n  thread #26: tid = 0x0c78, 0x00007ff845830a14 ntdll.dll`NtWaitForAlertByThreadId + 20, name = 'SPUW.3'\r\n  thread #47: tid = 0x0ec4, 0x00007ff845830a14 ntdll.dll`NtWaitForAlertByThreadId + 20, name = 'RSX.W4'\r\n  thread #18: tid = 0x0fe8, 0x00007ff845830a14 ntdll.dll`NtWaitForAlertByThreadId + 20, name = 'NetStart Hack'\r\n  thread #36: tid = 0x106c, 0x00007ff845830a14 ntdll.dll`NtWaitForAlertByThreadId + 20, name = 'cellAudio Thread'\r\n  thread #69: tid = 0x1090, 0x00007ff845830a14 ntdll.dll`NtWaitForAlertByThreadId + 20, name = 'SPU[0x3000400] xf_appli_CellSpursKernel3'\r\n  thread #5: tid = 0x1094, 0x00007ff845830a74 ntdll.dll`NtWaitForWorkViaWorkerFactory + 20\r\n  thread #65: tid = 0x1234, 0x00007ff845830a14 ntdll.dll`NtWaitForAlertByThreadId + 20, name = 'PPU[0x1000008] xf_sound_SpursHdlr0'\r\n  thread #9: tid = 0x12f8, 0x00007ff842e71224 win32u.dll`NtUserPostMessage + 20\r\n  thread #60: tid = 0x13c4, 0x00007ff845830a14 ntdll.dll`NtWaitForAlertByThreadId + 20, name = 'SPU[0x0000200] xf_at3p_CellSpursKernel0'\r\n  thread #46: tid = 0x1428, 0x00007ff845830a14 ntdll.dll`NtWaitForAlertByThreadId + 20, name = 'RSX.W3'\r\n  thread #42: tid = 0x1470, 0x00007ff845830a14 ntdll.dll`NtWaitForAlertByThreadId + 20, name = 'Overlay Input Thread'\r\n  thread #91: tid = 0x1678, 0x00007ff845830a14 ntdll.dll`NtWaitForAlertByThreadId + 20, name = 'PPU[0x100001b] nativeFiber Thread'\r\n  thread #85: tid = 0x1718, 0x00007ff845830a14 ntdll.dll`NtWaitForAlertByThreadId + 20, name = 'PPU[0x1000015] snddrv_stream_preparing_thre'\r\n  thread #13: tid = 0x19ac, 0x00007ff845830a14 ntdll.dll`NtWaitForAlertByThreadId + 20, name = 'Tcp Over Udp Timeout Manager Thread'\r\n  thread #31: tid = 0x1a00, 0x00007ff845830a14 ntdll.dll`NtWaitForAlertByThreadId + 20, name = 'CPU Profiler'\r\n  thread #8: tid = 0x1a14, 0x00007ff84582d664 ntdll.dll`NtDelayExecution + 20\r\n  thread #15: tid = 0x1b44, 0x00007ff84582d664 ntdll.dll`NtDelayExecution + 20, name = 'Network Thread'\r\n  thread #39: tid = 0x1b68, 0x00007ff845830a14 ntdll.dll`NtWaitForAlertByThreadId + 20, name = 'Gem Thread'\r\n  thread #4: tid = 0x1b6c, 0x00007ff845830a74 ntdll.dll`NtWaitForWorkViaWorkerFactory + 20\r\n  thread #79: tid = 0x2160, 0x00007ff845830a14 ntdll.dll`NtWaitForAlertByThreadId + 20, name = 'PPU[0x100000f] closeAsync'\r\n  thread #14: tid = 0x2200, 0x00007ff845830a14 ntdll.dll`NtWaitForAlertByThreadId + 20, name = 'MediaList Thread'\r\n  thread #70: tid = 0x228c, 0x00007ff845830a14 ntdll.dll`NtWaitForAlertByThreadId + 20, name = 'SPU[0x4000400] xf_appli_CellSpursKernel4'\r\n  thread #97: tid = 0x229c, 0x00007ff845830a14 ntdll.dll`NtWaitForAlertByThreadId + 20, name = 'PPU[0x1002021] _atxdec_adapter_decode_thr_f'\r\n  thread #17: tid = 0x22b8, 0x00007ff845830a14 ntdll.dll`NtWaitForAlertByThreadId + 20, name = 'Signaling Manager Thread'\r\n  thread #11: tid = 0x232c, 0x00007ff845830a14 ntdll.dll`NtWaitForAlertByThreadId + 20, name = 'Progress Dialog Server'\r\n  thread #50: tid = 0x2360, 0x00007ff84582d8a4 ntdll.dll`NtYieldExecution + 20, name = 'rsx::thread'\r\n  thread #59: tid = 0x254c, 0x00007ff845830a14 ntdll.dll`NtWaitForAlertByThreadId + 20, name = 'PPU[0x1000004] xf_ms_SpursHdlr0'\r\n  thread #49: tid = 0x2614, 0x00007ff845830a14 ntdll.dll`NtWaitForAlertByThreadId + 20, name = 'RSX.W6'\r\n  thread #30: tid = 0x2618, 0x00007ff845830a14 ntdll.dll`NtWaitForAlertByThreadId + 20, name = 'PPU Syscall Usage Thread'\r\n  thread #20: tid = 0x2640, 0x00007ff845830a14 ntdll.dll`NtWaitForAlertByThreadId + 20, name = 'LV2 Watchdog Thread'\r\n```", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "lldb/unittests/Thread/ThreadTest.cpp", "functions": ["host_thread", "arch", "t", "listener_sp"]}]}
{"pr_number": 76160, "url": "https://github.com/llvm/llvm-project/pull/76160", "title": "[ValueTracking] Make isGuaranteedNotToBeUndef() more precise", "body": "Currently isGuaranteedNotToBeUndef() is the same as isGuaranteedNotToBeUndefOrPoison(). This function is used in places where we only care about undef (due to multi-use issues), not poison.\r\n\r\nMake it more precise by only considering instructions that can create undef (like loads or call), and ignore those that can only create poison. In particular, we can ignore poison-generating flags.\r\n\r\nThis means that inferring more flags has less chance to pessimize other transforms.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Analysis/ValueTracking.cpp", "functions": ["is_contained", "if", "programUndefinedIfUndefOrPoison", "includesUndef", "isGuaranteedNotToBeUndefOrPoison", "includesPoison"]}]}
{"pr_number": 74688, "url": "https://github.com/llvm/llvm-project/pull/74688", "title": "[RISCV] Add codegen support for experimental.vp.splice", "body": "IR intrinsics were already defined, but no codegen support had been added.\r\n\r\nI extracted this code from our downstream. Some of it may have come from https://repo.hca.bsc.es/gitlab/rferrer/llvm-epi/ originally.", "feature_layers": ["codegen", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp", "functions": ["SDValue"]}, {"filename": "llvm/lib/Target/RISCV/RISCVISelLowering.cpp", "functions": ["lowerVPSpliceExperimental", "convertFromScalableVector", "DL"]}]}
{"pr_number": 76015, "url": "https://github.com/llvm/llvm-project/pull/76015", "title": "[mlir][gpu] Allow subgroup reductions over 1-d vector types", "body": "Each vector element is reduced independently, which is a form of multi-reduction.\r\n\r\nThe plan is to allow for gradual lowering of multi-reduction that results in fewer `gpu.shuffle` ops at the end:\r\n1d `vector.multi_reduction` --> 1d `gpu.subgroup_reduce` --> smaller 1d `gpu.subgroup_reduce` --> packed `gpu.shuffle` over i32\r\n\r\nFor example we can perform 2 independent f16 reductions with a series of `gpu.shuffles` over i32, reducing the final number of `gpu.shuffles` by 2x.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Conversion/GPUToSPIRV/GPUToSPIRV.cpp", "functions": ["failure"]}, {"filename": "mlir/lib/Dialect/GPU/IR/GPUDialect.cpp", "functions": ["emitOpError"]}]}
{"pr_number": 76042, "url": "https://github.com/llvm/llvm-project/pull/76042", "title": "[clang][dataflow] Disallow setting properties on `RecordValue`s.", "body": "Instead, synthetic fields should now be used for the same purpose. These have a\nnumber of advantages, as described in\nhttps://github.com/llvm/llvm-project/pull/73860, and longer-term, we want to\neliminate `RecordValue` entirely.\n\nAs `RecordValue`s cannot have properties any more, I have replaced the\n`OptionalIntAnalysis` with an equivalent analysis that tracks nullness of\npointers (instead of whether an optional has a value). This serves the same\npurpose, namely to check whether the framework applies a custom `merge()`\noperation to widen properties.\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/unittests/Analysis/FlowSensitive/TypeErasedDataflowAnalysisTest.cpp", "functions": ["if", "OptionalIntAnalysis", "NullPointerAnalysis"]}]}
{"pr_number": 69399, "url": "https://github.com/llvm/llvm-project/pull/69399", "title": "[LLVM[NFC] Refactor to allow debug_names entries to conatain DIE offset", "body": "This is pre-cursor patch to enabling type units with DWARF5 acceleration tables.\nWith this change it allows for entries to contain offsets directly, this way type\nunits do not need to be preserved until .debug_names is written out.\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp", "functions": ["OffsetVal"]}]}
{"pr_number": 75737, "url": "https://github.com/llvm/llvm-project/pull/75737", "title": "[AArch64][SME2] Add builtins for FDOT, BFDOT, SUDOT, USDOT, SDOT, UDOT.", "body": "Add SME2 DOT builtins.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CodeGen/aarch64-sme2-intrinsics/acle_sme2_fp_dots.c", "functions": ["test_svdot_multi_za32_vg1x4_f16", "test_svdot_lane_za32_vg1x4_f16", "test_svdot_single_za32_vg1x4_bf16", "test_svdot_multi_za32_vg1x4_bf16", "test_svdot_lane_za32_vg1x4_bf16", "test_svdot_multi_za32_vg1x2_bf16", "test_svdot_lane_za32_vg1x2_f16", "test_svdot_single_za32_vg1x2_f16", "test_svdot_single_za32_vg1x2_bf16", "test_svdot_multi_za32_vg1x2_f16", "test_svdot_lane_za32_vg1x2_bf16", "test_svdot_single_za32_vg1x4_f16"]}, {"filename": "clang/test/CodeGen/aarch64-sme2-intrinsics/acle_sme2_int_dots.c", "functions": ["test_svdot_single_za64_vg1x2_u16", "test_svdot_single_za32_vg1x2_u8", "test_svdot_lane_za32_vg1x2_u16", "test_svdot_lane_za32_vg1x4_s8", "test_svdot_multi_za64_vg1x4_u16", "test_svsudot_single_za32_vg1x2_s8", "test_svdot_lane_za64_vg1x2_u16", "test_svdot_lane_za32_vg1x4_u16", "test_svusdot_lane_za32_vg1x4_u8", "test_svdot_single_za32_vg1x2_s8", "test_svdot_single_za32_vg1x4_u16", "test_svdot_single_za32_vg1x4_s8", "test_svsudot_multi_za32_vg1x2_s8", "test_svusdot_single_za32_vg1x4_u8", "test_svdot_multi_za32_vg1x4_s16", "test_svsudot_multi_za32_vg1x4_s8", "test_svdot_multi_za32_vg1x2_u8", "test_svdot_multi_za32_vg1x2_s16", "test_svdot_multi_za64_vg1x4_s16", "test_svdot_multi_za64_vg1x2_u16", "test_svdot_lane_za64_vg1x4_s16", "test_svsudot_single_za32_vg1x4_s8", "test_svusdot_lane_za32_vg1x2_u8", "test_svsudot_lane_za32_vg1x4_s8", "test_svdot_multi_za32_vg1x4_u8", "test_svdot_single_za64_vg1x4_s16", "test_svusdot_multi_za32_vg1x4_u8", "test_svdot_lane_za32_vg1x2_s8", "test_svusdot_single_za32_vg1x2_u8", "test_svdot_multi_za32_vg1x2_s8", "test_svdot_single_za32_vg1x2_u16", "test_svdot_multi_za32_vg1x4_u16", "test_svdot_lane_za32_vg1x4_u8", "test_svdot_multi_za32_vg1x2_u16", "test_svdot_lane_za32_vg1x2_s16", "test_svdot_single_za32_vg1x4_u8", "test_svdot_lane_za64_vg1x2_s16", "test_svusdot_multi_za32_vg1x2_u8", "test_svdot_multi_za32_vg1x4_s8", "test_svdot_lane_za32_vg1x4_s16", "test_svdot_lane_za32_vg1x2_u8", "test_svdot_multi_za64_vg1x2_s16", "test_svdot_single_za64_vg1x4_u16", "test_svdot_single_za32_vg1x2_s16", "test_svdot_lane_za64_vg1x4_u16", "test_svdot_single_za64_vg1x2_s16", "test_svdot_single_za32_vg1x4_s16", "test_svsudot_lane_za32_vg1x2_s8"]}, {"filename": "clang/test/CodeGen/aarch64-sme2-intrinsics/acle_sme2_vdot.c", "functions": ["test_svvdot_lane_za64_s16_vg1x4", "test_svusvdot_lane_za32_u8_vg1x4", "test_svvdot_lane_za32_u16_vg1x2", "test_svvdot_lane_za32_u8_vg1x4", "test_svvdot_lane_za32_s8_vg1x4", "test_svvdot_lane_za64_u16_vg1x4", "test_svvdot_lane_za32_bf16_vg1x2", "test_svvdot_lane_za32_f16_vg1x2", "test_svvdot_lane_za32_s16_vg1x2", "test_svsuvdot_lane_za32_s8_vg1x4"]}]}
{"pr_number": 74398, "url": "https://github.com/llvm/llvm-project/pull/74398", "title": "[OpenMP] Add unit tests for nextgen plugins", "body": "This patch add three GTest unit tests that test plugin read and write operations. Tests can be compiled with `ninja -C runtimes/runtimes-bins LibomptUnitTests`.", "feature_layers": ["runtime"], "feature_directives": ["for"], "files_changed": [{"filename": "openmp/libomptarget/unittests/Plugins/NextgenPluginsTest.cpp", "functions": ["init_test_device"]}]}
{"pr_number": 76114, "url": "https://github.com/llvm/llvm-project/pull/76114", "title": "[mlir][spirv] Convert `bf16` to `spirv` as a `i16`", "body": "`bf16` is not support currently in `spirv`. Current conversions treat it as an `i16` with bit-shifting, extending, and other manipulations. Change to `i16` appropriately.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/SPIRV/Transforms/SPIRVConversion.cpp", "functions": ["convertType"]}]}
{"pr_number": 76007, "url": "https://github.com/llvm/llvm-project/pull/76007", "title": "[Clang][Sema] Fix Wswitch-default bad warning in template", "body": "https://github.com/llvm/llvm-project/pull/73077 added -Wswitch-default diagnostic but it produced false positives in templates. This PR will address that. https://github.com/llvm/llvm-project/issues/75943", "feature_layers": ["sema"], "feature_directives": [], "files_changed": [{"filename": "clang/test/Sema/switch-default.c", "functions": ["f1", "f2", "check_enum"]}, {"filename": "clang/test/Sema/switch-default.cpp", "functions": ["t1", "check_enum", "main", "t2", "f1", "f2"]}]}
{"pr_number": 75642, "url": "https://github.com/llvm/llvm-project/pull/75642", "title": "[Clang][OpenMP] Fix mapping of structs to device", "body": "Fix mapping of structs to device.\r\n\r\nThe following example fails:\r\n\r\n```\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\nstruct Descriptor {\r\n  int *datum;\r\n  long int x;\r\n  int xi;\r\n  long int arr[1][30];\r\n};\r\n\r\nint main() {\r\n  Descriptor dat = Descriptor();\r\n  dat.datum = (int *)malloc(sizeof(int)*10);\r\n  dat.xi = 3;\r\n  dat.arr[0][0] = 1;\r\n\r\n  #pragma omp target enter data map(to: dat.datum[:10]) map(to: dat)\r\n\r\n  #pragma omp target\r\n  {\r\n    dat.xi = 4;\r\n    dat.datum[dat.arr[0][0]] = dat.xi;\r\n  }\r\n\r\n  #pragma omp target exit data map(from: dat)\r\n\r\n return 0;\r\n}\r\n```\r\n\r\nThis is a rework of the previous attempt: https://github.com/llvm/llvm-project/pull/72410", "feature_layers": [], "feature_directives": ["target"], "files_changed": [{"filename": "clang/test/OpenMP/map_struct_ordering.cpp", "functions": ["map_struct"]}, {"filename": "openmp/libomptarget/test/offloading/struct_mapping_with_pointers.cpp", "functions": ["main"]}]}
{"pr_number": 75817, "url": "https://github.com/llvm/llvm-project/pull/75817", "title": "[mlir][MemRef] Add runtime bounds checking", "body": "This change adds (runtime) bounds checks for `memref` ops using the existing `RuntimeVerifiableOpInterface`. For `memref.load` and `memref.store`, we check that the indices are in-bounds of the memref's index space. For `memref.reinterpret_cast` and `memref.subview` we check that the resulting address space is in-bounds of the input memref's address space.", "feature_layers": ["runtime", "ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/MemRef/Transforms/RuntimeOpVerification.cpp", "functions": ["computeLinearBounds", "getValueOrCreateConstantIndexOp"]}]}
{"pr_number": 76032, "url": "https://github.com/llvm/llvm-project/pull/76032", "title": "[RISCV] Split TuneShiftedZExtFusion", "body": "We split `TuneShiftedZExtFusion` into three fusions to make them\r\nreusable and match the GCC implementation[1].\r\n\r\nThe zexth/zextw fusions can be reused by XiangShan[2] and other\r\ncommercial processors, but shifted zero extension is not so common.\r\n\r\n`macro-fusions-veyron-v1.mir` is renamed so it's not relevant to\r\nspecific processor.\r\n\r\nReferences:\r\n[1] https://gcc.gnu.org/pipermail/gcc-patches/2023-November/637303.html\r\n[2] https://xiangshan-doc.readthedocs.io/zh_CN/latest/frontend/decode\r\n", "feature_layers": ["ir", "frontend"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVMacroFusion.cpp", "functions": ["checkRegisters", "isZExtW", "isZExtH"]}]}
{"pr_number": 75308, "url": "https://github.com/llvm/llvm-project/pull/75308", "title": "[clang][ASTImporter] Import AlignValueAttr correctly.", "body": "Expression of attribute `align_value` was not imported. Import of the attribute is corrected, a test for it is added, other related tests with FIXME are updated.\r\nFixes #75054.", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/unittests/AST/ASTImporterTest.cpp", "functions": ["alignas", "foo", "test", "__attribute__"]}]}
{"pr_number": 74813, "url": "https://github.com/llvm/llvm-project/pull/74813", "title": "[clang][ASTImporter] Support Importer of BuiltinBitCastExpr", "body": "Since import `ExplicitCastExpr` lacks of processing `BuiltinBitCastExprClass` type, it would reach to the 'unreachable' code and produce the crash. This patch aims to fix the [crash](https://github.com/llvm/llvm-project/issues/74774) and try to handle `BuiltinBitCastExpr`.", "feature_layers": ["ast"], "feature_directives": [], "files_changed": [{"filename": "clang/lib/AST/ASTImporter.cpp", "functions": ["new"]}]}
{"pr_number": 76010, "url": "https://github.com/llvm/llvm-project/pull/76010", "title": "[mlir][python] Make the Context/Operation capsule creation methods work as documented.", "body": "This fixes a longstanding bug in the `Context._CAPICreate` method whereby it was not taking ownership of the PyMlirContext wrapper when casting to a Python object. The result was minimally that all such contexts transferred in that way would leak. In addition, counter to the documentation for the `_CAPICreate` helper (see `mlir-c/Bindings/Python/Interop.h`) and the `forContext` / `forOperation` methods, we were silently upgrading any unknown context/operation pointer to steal-ownership semantics. This is dangerous and was causing some subtle bugs downstream where this facility is getting the most use.\r\n\r\nThis patch corrects the semantics and will only do an ownership transfer for `_CAPICreate`, and it will further require that it is an ownership transfer (if already transferred, it was just silently succeeding). Removing the mis-aligned behavior made it clear where the downstream was doing the wrong thing.\r\n\r\nIt also adds some `_testing_` functions to create unowned context and operation capsules so that this can be fully tested upstream, reworking the tests to verify the behavior.\r\n\r\nIn some torture testing downstream, I was not able to trigger any memory corruption with the newly enforced semantics. When getting it wrong, a regular exception is raised.", "feature_layers": ["sema", "ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Bindings/Python/IRCore.cpp", "functions": ["createInstance", "PyMlirContextRef", "forContext", "stealExternalOperation", "forOperation", "stealExternalContext"]}]}
{"pr_number": 75821, "url": "https://github.com/llvm/llvm-project/pull/75821", "title": "[Clang][SME2] Enable multi-vector loads & stores for SME2", "body": "This patch enables the following builtins for SME2:\r\n - svld1, svld1_vnum\r\n - svldnt1, svldnt1_vnum\r\n - svst1, svst1_vnum\r\n - svstnt1, svstnt1_vnum", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_ld1.c", "functions": ["test_svld1_vnum_s64_x2", "test_svld1_vnum_s64_x4", "test_svld1_vnum_s32_x4", "test_svld1_vnum_s32_x2", "test_svld1_vnum_u16_x2", "test_svld1_vnum_f16_x4", "test_svld1_vnum_f32_x2", "test_svld1_vnum_u32_x2", "test_svld1_vnum_u8_x4", "test_svld1_vnum_u16_x4", "test_svld1_vnum_f64_x2", "test_svld1_vnum_s16_x4", "test_svld1_vnum_u32_x4", "test_svld1_vnum_u64_x4", "test_svld1_vnum_s16_x2", "test_svld1_vnum_u64_x2", "test_svld1_vnum_f32_x4", "test_svld1_vnum_u8_x2", "test_svld1_vnum_f64_x4", "test_svld1_vnum_f16_x2", "test_svld1_vnum_s8_x4", "test_svld1_vnum_s8_x2"]}, {"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_ldnt1.c", "functions": ["test_svldnt1_vnum_s32_x4", "test_svldnt1_vnum_u32_x2", "test_svldnt1_vnum_s32_x2", "test_svldnt1_vnum_u8_x4", "test_svldnt1_vnum_f64_x2", "test_svldnt1_vnum_s16_x2", "test_svldnt1_vnum_s8_x2", "test_svldnt1_vnum_u8_x2", "test_svldnt1_vnum_u16_x2", "test_svldnt1_vnum_f16_x2", "test_svldnt1_vnum_f32_x2", "test_svldnt1_vnum_u64_x4", "test_svldnt1_vnum_u64_x2", "test_svldnt1_vnum_s16_x4", "test_svldnt1_vnum_f16_x4", "test_svldnt1_vnum_u32_x4", "test_svldnt1_vnum_f32_x4", "test_svldnt1_vnum_s8_x4", "test_svldnt1_vnum_u16_x4", "test_svldnt1_vnum_s64_x4", "test_svldnt1_vnum_s64_x2", "test_svldnt1_vnum_f64_x4"]}, {"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_st1.c", "functions": ["test_svst1_f64_x2", "test_svst1_vnum_u8_x2", "test_svst1_vnum_u32_x2", "test_svst1_vnum_u8_x4", "test_svst1_s16_x2", "test_svst1_f16_x4", "test_svst1_vnum_s32_x2", "test_svst1_f16_x2", "test_svst1_s32_x4", "test_svst1_f32_x2", "test_svst1_u16_x2", "test_svst1_vnum_u32_x4", "test_svst1_s8_x2", "test_svst1_vnum_f32_x2", "test_svst1_u32_x4", "test_svst1_u8_x4", "test_svst1_vnum_s32_x4", "test_svst1_vnum_u64_x2", "test_svst1_s8_x4", "test_svst1_u32_x2", "test_svst1_s32_x2", "test_svst1_s16_x4", "test_svst1_vnum_s64_x2", "test_svst1_vnum_f16_x4", "test_svst1_vnum_u16_x4", "test_svst1_vnum_f64_x2", "test_svst1_vnum_f32_x4", "test_svst1_u16_x4", "test_svst1_vnum_s64_x4", "test_svst1_u64_x2", "test_svst1_u8_x2", "test_svst1_vnum_s8_x4", "test_svst1_s64_x4", "test_svst1_u64_x4", "test_svst1_f32_x4", "test_svst1_vnum_s16_x2", "test_svst1_vnum_s16_x4", "test_svst1_s64_x2", "test_svst1_vnum_f64_x4", "test_svst1_vnum_u64_x4", "test_svst1_vnum_s8_x2", "test_svst1_vnum_f16_x2", "test_svst1_vnum_u16_x2", "test_svst1_f64_x4"]}, {"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_stnt1.c", "functions": ["test_svstnt1_f32_x4", "test_svstnt1_s16_x4", "test_svstnt1_vnum_u32_x4", "test_svstnt1_u16_x4", "test_svstnt1_s8_x2", "test_svstnt1_u32_x4", "test_svstnt1_s32_x2", "test_svstnt1_vnum_s32_x4", "test_svstnt1_u64_x4", "test_svstnt1_u8_x2", "test_svstnt1_vnum_f32_x2", "test_svstnt1_s32_x4", "test_svstnt1_u8_x4", "test_svstnt1_f16_x4", "test_svstnt1_f64_x2", "test_svstnt1_s8_x4", "test_svstnt1_vnum_f16_x4", "test_svstnt1_vnum_u64_x4", "test_svstnt1_u64_x2", "test_svstnt1_s16_x2", "test_svstnt1_vnum_f64_x4", "test_svstnt1_s64_x2", "test_svstnt1_vnum_u64_x2", "test_svstnt1_f64_x4", "test_svstnt1_vnum_s16_x4", "test_svstnt1_vnum_f32_x4", "test_svstnt1_u16_x2", "test_svstnt1_f16_x2", "test_svstnt1_f32_x2", "test_svstnt1_vnum_u16_x2", "test_svstnt1_u32_x2", "test_svstnt1_vnum_u32_x2", "test_svstnt1_vnum_u8_x4", "test_svstnt1_vnum_s16_x2", "test_svstnt1_vnum_u8_x2", "test_svstnt1_vnum_s64_x2", "test_svstnt1_vnum_s8_x4", "test_svstnt1_vnum_s64_x4", "test_svstnt1_vnum_f16_x2", "test_svstnt1_vnum_s32_x2", "test_svstnt1_vnum_u16_x4", "test_svstnt1_vnum_f64_x2", "test_svstnt1_vnum_s8_x2", "test_svstnt1_s64_x4"]}]}
{"pr_number": 75941, "url": "https://github.com/llvm/llvm-project/pull/75941", "title": "[Clang][SME2] Add builtins for multi-vector fp round to integral value", "body": "Adds the following SME2 builtins:\r\n - svrinta, svrintm, svrintn, svrintp (x2 & x4)", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CodeGen/aarch64-sme2-intrinsics/acle_sme2_frint.c", "functions": ["test_svfrintn_f32_x4", "test_svfrintp_f32_x2", "test_svfrinta_f32_x4", "test_svfrintp_f32_x4", "test_svfrintam_f32_x2", "test_svfrintn_f32_x2", "test_svfrinta_f32_x2", "test_svfrintm_f32_x4", "SVE_ACLE_FUNC"]}]}
{"pr_number": 75345, "url": "https://github.com/llvm/llvm-project/pull/75345", "title": "[flang][MLIR][OpenMP] Emit `UpdateDataOp` from `!$omp target update`", "body": "Emits MLIR op corresponding to `!$omp target update` directive. So far,\r\nonly motion types: `to` and `from` are supported. Motion modifiers:\r\n`present`, `mapper`, and `iterator` are not supported yet.\r\n\r\nThis is a follow up to #75047 & #75159, only the last commit is relevant\r\nto this PR.", "feature_layers": ["ir", "ast"], "feature_directives": ["target"], "files_changed": [{"filename": "flang/lib/Lower/OpenMP.cpp", "functions": ["constexpr"]}]}
{"pr_number": 68016, "url": "https://github.com/llvm/llvm-project/pull/68016", "title": "[OpenMP] Improve omp offload profiler", "body": "Summary:\r\nAdding information to the LIBOMPTARGET profiler runtime kernel and API calls.\r\n\r\nKey changes:\r\n* Adding information to runtime calls for better understanding of how the application\r\n  is executing. For example teams requested by the user, size of memory transfers.\r\n* Profile timer was changed from 'us' to 'ns', since 'us' was too coarse-grain\r\n  to register some important details like key kernel duration\r\n* Removed non API or Runtime calls, to reduce complexity of profile for application\r\n  developers.\r\n", "feature_layers": ["runtime"], "feature_directives": ["for", "target", "teams"], "files_changed": [{"filename": "llvm/lib/Support/TimeProfiler.cpp", "functions": ["getFlameGraphDurNs", "getFlameGraphDurUs", "getFlameGraphStartNs", "getFlameGraphStartUs"]}]}
{"pr_number": 76242, "url": "https://github.com/llvm/llvm-project/pull/76242", "title": "[InstCombine] Fold minmax intrinsic using KnownBits information", "body": "This patch tries to fold minmax intrinsic by using `computeConstantRangeIncludingKnownBits`.\r\nFixes regression in [_karatsuba_rec:cpython/Modules/_decimal/libmpdec/mpdecimal.c](https://github.com/python/cpython/blob/c31943af16f885c8cf5d5a690c25c366afdb2862/Modules/_decimal/libmpdec/mpdecimal.c#L5460-L5462), which was introduced by #71396.\r\nSee also https://github.com/dtcxzyw/llvm-opt-benchmark/issues/16#issuecomment-1865875756.\r\n\r\nAlive2 for splat vectors with undef: https://alive2.llvm.org/ce/z/J8hKWd\r\nIt is an alternative to #76221.\r\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp", "functions": ["replaceInstUsesWith"]}]}
{"pr_number": 76272, "url": "https://github.com/llvm/llvm-project/pull/76272", "title": "Revert \"[Sema] Fix crash on invalid code with parenthesized aggregate initialization\"", "body": "Reverts llvm/llvm-project#76232 and 7ab16fb5207fe187ab999f882069bd632d2e68e5 to recover build bots.\r\n\r\nBreaks libc++ tests, details in #76232\r\n\r\n#76228", "feature_layers": ["sema"], "feature_directives": [], "files_changed": [{"filename": "clang/test/SemaCXX/crash-GH76228.cpp", "functions": ["a1", "a2", "a4", "a5"]}, {"filename": "clang/test/SemaCXX/paren-list-agg-init.cpp", "functions": ["c"]}]}
{"pr_number": 72250, "url": "https://github.com/llvm/llvm-project/pull/72250", "title": "[RegAllocFast] Refactor dominates algorithm for large basic block", "body": "The original brute force dominates algorithm is O(n) complexity so it is\r\nvery slow for very large machine basic block which is very common with\r\nO0. This patch added InstrPosIndexes to assign index for each\r\ninstruction and use it to determine dominance. The complexity is now\r\nO(1).", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/CodeGen/RegAllocFast.cpp", "functions": ["init", "getIndex"]}]}
{"pr_number": 76279, "url": "https://github.com/llvm/llvm-project/pull/76279", "title": "[NFC][sanitizer] Rename Lock{Before,After}Fork suffixes locking StackDepotBase", "body": "This is preporation for performance optimization.\n\nWe need to highlight that this is very specific lock, and should not be\nused for other purposes.\nAdd `fork_child` parameter to distinguish processes after fork.\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "compiler-rt/lib/asan/asan_posix.cpp", "functions": ["AfterFork", "BeforeFork"]}, {"filename": "compiler-rt/lib/dfsan/dfsan_chained_origin_depot.cpp", "functions": ["ChainedOriginDepotUnlockAfterFork", "ChainedOriginDepotLockBeforeFork"]}, {"filename": "compiler-rt/lib/dfsan/dfsan_custom.cpp", "functions": ["AfterFork"]}, {"filename": "compiler-rt/lib/hwasan/hwasan_linux.cpp", "functions": ["AfterFork", "BeforeFork"]}, {"filename": "compiler-rt/lib/lsan/lsan_posix.cpp", "functions": ["AfterFork", "BeforeFork"]}, {"filename": "compiler-rt/lib/msan/msan_chained_origin_depot.cpp", "functions": ["ChainedOriginDepotAfterFork", "ChainedOriginDepotUnlockAll", "ChainedOriginDepotLockAll", "ChainedOriginDepotBeforeFork"]}, {"filename": "compiler-rt/lib/msan/msan_linux.cpp", "functions": ["AfterFork", "BeforeFork"]}, {"filename": "compiler-rt/lib/sanitizer_common/sanitizer_stackdepot.cpp", "functions": ["StackDepotUnlockAll", "StackDepotLockBeforeFork", "StackDepotLockAll", "StackDepotUnlockAfterFork"]}]}
{"pr_number": 73262, "url": "https://github.com/llvm/llvm-project/pull/73262", "title": "[libc++][print] Adds ostream overloads.", "body": "Finishes implementation of\r\n- P2093R14 Formatted output\r\n- P2539R4  Should the output of std::print to a terminal be synchronized with the underlying stream?\r\n\r\nDifferential Revision: https://reviews.llvm.org/D156609", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "libcxx/src/ostream.cpp", "functions": ["__get_ostream_file"]}, {"filename": "libcxx/test/libcxx/input.output/iostream.format/output.streams/ostream.formatted/ostream.formatted.print/vprint_unicode.pass.cpp", "functions": ["test_is_terminal_not_a_file_stream", "is_terminal", "stream", "test_is_terminal_std_cout_cerr_clog", "main", "test_is_terminal_file_stream", "sync", "test_is_terminal_rdbuf_derived_from_filebuf", "test_is_terminal_is_flushed"]}, {"filename": "libcxx/test/std/input.output/iostream.format/output.streams/ostream.formatted/ostream.formatted.print/locale-specific_form.pass.cpp", "functions": ["do_decimal_point", "do_thousands_sep", "main", "do_grouping", "test_floating_point_default", "test_floating_point_general_upper_case", "test_floating_point_hex_lower_case_precision", "test_floating_point_hex_lower_case", "test_floating_point_default_precision", "test_bool", "test_floating_point", "test_floating_point_fixed_lower_case", "test_integer", "constexpr", "test_floating_point_fixed_upper_case", "test_floating_point_general_lower_case", "test", "test_floating_point_scientific_upper_case", "test_floating_point_hex_upper_case", "do_falsename", "do_truename", "test_floating_point_hex_upper_case_precision", "test_floating_point_scientific_lower_case"]}, {"filename": "libcxx/test/std/input.output/iostream.format/output.streams/ostream.formatted/ostream.formatted.print/print.pass.cpp", "functions": ["test_sentry_failure", "test_write_failure", "test_stream_formatting", "os", "test_format_exception", "main", "sync", "os_tied", "overflow"]}, {"filename": "libcxx/test/std/input.output/iostream.format/output.streams/ostream.formatted/ostream.formatted.print/println.pass.cpp", "functions": ["main"]}, {"filename": "libcxx/test/std/input.output/iostream.format/output.streams/ostream.formatted/ostream.formatted.print/vprint_nonunicode.pass.cpp", "functions": ["test_sentry_failure", "test_write_failure", "test_stream_formatting", "os", "test_format_exception", "main", "sync", "os_tied", "overflow"]}, {"filename": "libcxx/test/std/input.output/iostream.format/output.streams/ostream.formatted/ostream.formatted.print/vprint_unicode.pass.cpp", "functions": ["test_sentry_failure", "test_write_failure", "test_stream_formatting", "os", "test_format_exception", "main", "sync", "os_tied", "overflow"]}]}
{"pr_number": 76262, "url": "https://github.com/llvm/llvm-project/pull/76262", "title": "[ConstraintElim] Add (UGE, var, 0) to unsigned system for new vars.", "body": "The constraint system used for ConstraintElimination assumes all varibles to be signed. This can cause missed optimization in the unsigned system, due to missing the information that all variables are unsigned (non-negative).\r\n\r\nVariables can be marked as non-negative by adding Var >= 0 for all variables. This is done for arguments on ConstraintInfo construction and after adding new variables. This handles cases like the ones outlined in https://discourse.llvm.org/t/why-does-llvm-not-perform-range-analysis-on-integer-values/74341\r\n\r\nThe original example shared above is now handled without this change, but adding another variable means that instcombine won't be able to simplify examples like https://godbolt.org/z/hTnra7zdY\r\n\r\nAdding the extra variables comes with a slight compile-time increase https://llvm-compile-time-tracker.com/compare.php?from=7568b36a2bc1a1e496ec29246966ffdfc3a8b87f&to=641a47f0acce7755e340447386013a2e086f03d9&stat=instructions:u\r\n\r\nstage1-O3    stage1-ReleaseThinLTO    stage1-ReleaseLTO-g  stage1-O0-g\r\n +0.04%           +0.07%                   +0.05%           +0.02%\r\nstage2-O3    stage2-O0-g    stage2-clang\r\n  +0.05%         +0.05%        +0.05%", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Scalar/ConstraintElimination.cpp", "functions": ["VarPos", "UnsignedCS"]}]}
{"pr_number": 76051, "url": "https://github.com/llvm/llvm-project/pull/76051", "title": "[LiveDebugValues][nfc] Reduce memory usage of InstrRef", "body": "Commit 1b531d54f623 (#74203) removed the usage of unique_ptrs of arrays in favour of using vectors, but inadvertently increased peak memory usage by removing the ability to deallocate vector memory that was no longer needed mid-LDV.\r\n\r\nIn that same review, it was pointed out that `FuncValueTable` typedef could be removed, since it was \"just a vector\".\r\n\r\nThis commit addresses both issues by making `FuncValueTable` a real data structure, capable of mapping BBs to ValueTables and able to free ValueTables as needed.\r\n\r\nThis reduces peak memory usage in the compiler by 10% in the benchmarks flagged by the original review.\r\n\r\nAs a consequence, we had to remove a handful of instances of the \"declare-then-initialize\" antipattern in unittests, as the FuncValueTable class is no longer default-constructible.", "feature_layers": [], "feature_directives": ["declare", "allocate"], "files_changed": [{"filename": "llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp", "functions": ["MInLocs", "MOutLocs"]}]}
{"pr_number": 76302, "url": "https://github.com/llvm/llvm-project/pull/76302", "title": "core: Add `irdl.base` operation", "body": "", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/IRDL/IR/IRDL.cpp", "functions": ["emitOpError", "success"]}, {"filename": "mlir/lib/Dialect/IRDL/IRDLVerifiers.cpp", "functions": ["failure", "success", "emitError"]}]}
{"pr_number": 76303, "url": "https://github.com/llvm/llvm-project/pull/76303", "title": "[NFC][sanitizer] Rename to Lock{Before,After}Fork StackDepotBase locking", "body": "Followup to #76279\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "compiler-rt/lib/dfsan/dfsan_chained_origin_depot.cpp", "functions": ["ChainedOriginDepotLockBeforeFork"]}, {"filename": "compiler-rt/lib/msan/msan_chained_origin_depot.cpp", "functions": ["ChainedOriginDepotBeforeFork"]}]}
{"pr_number": 76256, "url": "https://github.com/llvm/llvm-project/pull/76256", "title": "[Clang][RISCV] Add missing support for `__builtin_riscv_cpop_32/64`", "body": "This patch adds support for `__builtin_riscv_cpop_32/64`, which are used by `riscv_bitmanip.h`.\r\nSee also https://github.com/llvm/llvm-project/blob/04c473bea3e0f135432698fcaafab52e1fe1b5ec/clang/lib/Headers/riscv_bitmanip.h#L35-L60.\r\nThank @Liaoshihua for reporting this!\r\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CodeGen/RISCV/rvb-intrinsics/zbb.c", "functions": ["cpop_32", "__builtin_riscv_cpop_32", "cpop_64", "__builtin_riscv_cpop_64"]}]}
{"pr_number": 76286, "url": "https://github.com/llvm/llvm-project/pull/76286", "title": "[Clang][RISCV] Use `__builtin_popcount` in `__riscv_cpop_32/64`", "body": "This patch replaces `__builtin_riscv_cpop_32/64` with `__builtin_popcount(ll)` because `__builtin_riscv_cpop_32/64` is not implemented in clang.\r\nThank @Liaoshihua for reporting this!\r\n\r\nIt is an alternative to #76256.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CodeGen/RISCV/rvb-intrinsics/zbb.c", "functions": ["cpop_32", "cpop_64", "__riscv_cpop_64", "__riscv_cpop_32"]}]}
{"pr_number": 76289, "url": "https://github.com/llvm/llvm-project/pull/76289", "title": "[Clang][RISCV] Add missing support for `__riscv_clmulr_32/64` in `riscv_bitmanip.h`", "body": "This patch adds support for `__riscv_clmulr_32/64` in `riscv_bitmanip.h`.\r\nIt also fixes the extension requirements of `clmul/clmulh`.\r\n\r\nThank @Liaoshihua for reporting this!\r\n ", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CodeGen/RISCV/rvb-intrinsics/zbc.c", "functions": ["__builtin_riscv_clmulr_64", "__builtin_riscv_clmulh_64", "__riscv_clmul_32", "__builtin_riscv_clmulh_32", "__riscv_clmulh_32", "__builtin_riscv_clmul_64", "__riscv_clmulr_32", "__builtin_riscv_clmul_32", "__builtin_riscv_clmulr_32", "__riscv_clmulh_64", "__riscv_clmulr_64", "__riscv_clmul_64"]}]}
{"pr_number": 76021, "url": "https://github.com/llvm/llvm-project/pull/76021", "title": "[clang-format] Add an fnmatch-like function for .clang-format-ignore", "body": "This is needed because Windows doesn't have anything equivalent to the POSIX fnmatch() function.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Format/MatchFilePath.cpp", "functions": ["matchFilePath"]}, {"filename": "clang/unittests/Format/MatchFilePathTest.cpp", "functions": ["matchFilePath", "match"]}]}
{"pr_number": 70020, "url": "https://github.com/llvm/llvm-project/pull/70020", "title": "[libc++] <experimental/simd> Add assignment operator of simd reference", "body": "", "feature_layers": [], "feature_directives": ["simd"], "files_changed": [{"filename": "libcxx/test/std/experimental/simd/simd.reference/reference_assignment.pass.cpp", "functions": ["main", "constexpr", "operator"]}]}
{"pr_number": 76276, "url": "https://github.com/llvm/llvm-project/pull/76276", "title": "[builtins] Fix CPU feature detection for Zircon", "body": "This is a follow up to #75635 which broke the build on Fuchsia. We don't support ifunc on Fuchsia so we shouldn't define __init_cpu_features. For __init_cpu_features_resolver we have to use _zx_system_get_features as a Zircon native solution.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "compiler-rt/lib/builtins/cpu_model/aarch64/fmv/fuchsia.inc", "functions": ["__init_cpu_features_resolver", "__init_cpu_features"]}]}
{"pr_number": 76275, "url": "https://github.com/llvm/llvm-project/pull/76275", "title": "[RegAllocFast] Lazily initialize InstrPosIndexes for each MBB", "body": "Most basic block do not need to query dominates. Defer initialization of\r\nInstrPosIndexes to first query for each MBB.", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/CodeGen/RegAllocFast.cpp", "functions": ["unsetInitialized"]}]}
{"pr_number": 74919, "url": "https://github.com/llvm/llvm-project/pull/74919", "title": "[clang][ASTImporter] skip TemplateTypeParmDecl in VisitTypeAliasTemplateDecl", "body": "Skip checking `TemplateTypeParmDecl ` in `VisitTypeAliasTemplateDecl`. [Fix this crash](https://github.com/llvm/llvm-project/issues/74765)", "feature_layers": ["ast"], "feature_directives": [], "files_changed": [{"filename": "clang/lib/AST/ASTStructuralEquivalence.cpp", "functions": ["IsStructurallyEquivalent"]}]}
{"pr_number": 75146, "url": "https://github.com/llvm/llvm-project/pull/75146", "title": "[CodeGen] Port `CFGuard` to new pass manager", "body": "Port `CFGuard` to new pass manager, add a pass parameter to choose guard mechanism.", "feature_layers": ["codegen"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/Passes/PassBuilder.cpp", "functions": ["parseCFGuardPassOptions"]}, {"filename": "llvm/lib/Transforms/CFGuard/CFGuard.cpp", "functions": ["doInitialization", "Impl", "CFGuard", "runOnFunction"]}]}
{"pr_number": 74920, "url": "https://github.com/llvm/llvm-project/pull/74920", "title": "[CodeGen] Port `SelectOptimize` to new pass manager", "body": "- Use `BlockFrequencyInfoWrapperPass` in legacy pass so member `std::unique_ptr<BranchProbabilityInfo> BPI` could be removed.\r\n- Member `DominatorTree *DT = nullptr` is unused, remove it.", "feature_layers": ["codegen"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/CodeGen/SelectOptimize.cpp", "functions": ["getAnalysisUsage", "run", "Impl", "runOnFunction"]}]}
{"pr_number": 76297, "url": "https://github.com/llvm/llvm-project/pull/76297", "title": "[mlir][doc] Escape effects, interfaces, and traits", "body": "Fixes https://github.com/llvm/llvm-project/issues/76270.\r\n\r\nThanks to @scottamain for the clear description.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/tools/mlir-tblgen/OpDocGen.cpp", "functions": ["backticks"]}]}
{"pr_number": 76280, "url": "https://github.com/llvm/llvm-project/pull/76280", "title": "[sanitizers] Optimize locking StackDepotBase for fork", "body": "Locking StackDepotBase fully is very expensive, as 2^20 buckets needs to\nbe locked. Not locking, but only unlocking buckets, needed to be\nunlocked to avoid deadlocks, increases a chance of data race, when the\nvalue with same hash can be inserted into table twice, but one is lost.\nHowever this is just a small additional memory usage by forked process.\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "compiler-rt/lib/asan/asan_posix.cpp", "functions": ["AfterFork", "BeforeFork"]}, {"filename": "compiler-rt/lib/dfsan/dfsan_chained_origin_depot.cpp", "functions": ["ChainedOriginDepotUnlockAfterFork", "ChainedOriginDepotLockBeforeFork"]}, {"filename": "compiler-rt/lib/dfsan/dfsan_custom.cpp", "functions": ["AfterFork"]}, {"filename": "compiler-rt/lib/hwasan/hwasan_linux.cpp", "functions": ["AfterFork", "BeforeFork"]}, {"filename": "compiler-rt/lib/lsan/lsan_posix.cpp", "functions": ["AfterFork", "BeforeFork"]}, {"filename": "compiler-rt/lib/msan/msan_chained_origin_depot.cpp", "functions": ["ChainedOriginDepotAfterFork", "ChainedOriginDepotUnlockAll", "ChainedOriginDepotLockAll", "ChainedOriginDepotBeforeFork"]}, {"filename": "compiler-rt/lib/msan/msan_linux.cpp", "functions": ["AfterFork", "BeforeFork"]}, {"filename": "compiler-rt/lib/sanitizer_common/sanitizer_stackdepot.cpp", "functions": ["StackDepotUnlockAll", "StackDepotLockBeforeFork", "StackDepotLockAll", "StackDepotUnlockAfterFork"]}]}
{"pr_number": 75702, "url": "https://github.com/llvm/llvm-project/pull/75702", "title": "[MLIR][Presburger] Generating functions and quasi-polynomials for Barvinok's algorithm", "body": "Define basic types and classes for Barvinok's algorithm, including polyhedra, generating functions and quasi-polynomials.\r\nThe class definitions include methods for arithmetic manipulation, printing, logical relations, etc.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Analysis/Presburger/QuasiPolynomial.cpp", "functions": ["qp", "numParam", "QuasiPolynomial"]}]}
{"pr_number": 75251, "url": "https://github.com/llvm/llvm-project/pull/75251", "title": "[flang][runtime] Fix empty FINDLOC() results", "body": "When FINDLOC() can't find its target value among the unmasked array elements, it must return a zero result.  Its implementation doesn't sufficiently distinguish a zero result from a hit in an array with lower bound(s) less than one.  Fix by adding a flag to distinguish the case with no hits from cases with hits.\r\n\r\nFixes llvm-test-suite/Fortran/gfortran/regression/findloc_6.f90.", "feature_layers": ["runtime"], "feature_directives": ["for", "target", "masked"], "files_changed": [{"filename": "flang/runtime/findloc.cpp", "functions": ["Reinitialize"]}]}
{"pr_number": 75400, "url": "https://github.com/llvm/llvm-project/pull/75400", "title": "[flang][runtime] Handle unconsumed repeated list-directed input items", "body": "If list-directed input contains a repeated item (\"20*123.0\") that is not fully consumed by the READ statement's data item list, the end of that READ statement was repositioning the input to the repeated value (\"123.0\"), leading to later confusion.  Cancel the input item repetition during EndIoStatement() processing to prevent this misbehavior.\r\n\r\nFixes llvm-test-suite/Fortran/gfortran/regression/list_read_4.f90.", "feature_layers": ["runtime", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/runtime/io-stmt.cpp", "functions": ["constexpr"]}]}
{"pr_number": 75525, "url": "https://github.com/llvm/llvm-project/pull/75525", "title": "[flang][runtime] Return +/-HUGE() for some real input roundings", "body": "The Fortran standard says that overflow input cases in some rounding modes (RZ, RD, RU) should round to a \"representable\" number.  Some Fortran compilers interpret this to mean +/-HUGE(), some as +/-Inf. Follow the precedent of gfortran and the Intel compilers.", "feature_layers": ["runtime"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Decimal/decimal-to-binary.cpp", "functions": ["constexpr"]}]}
{"pr_number": 75701, "url": "https://github.com/llvm/llvm-project/pull/75701", "title": "[clang-tidy] Treat fields in anonymous records as names in enclosing scope when checking name styles", "body": "Currently, fields in anonymous records are treated as normal record members during naming style check. This can be undesirable in certain situations since these fields are used just like names in their enclosing scopes:\r\n\r\n```c++\r\nclass Foo {\r\n  union {\r\n    int iv_;    // warning: invalid case style for public member 'iv_'\r\n    float fv_;  // warning: invalid case style for public member 'fv_'\r\n  };\r\n};\r\n```\r\n\r\n`iv_` and `fv_` are used in the code like private members of `Foo` but their naming style comes from rules for public members.\r\n\r\nThis PR changes this behavior. It adds a new option `CheckAnonFieldInParent` to `readability-identifier-naming`. When set to `true`, fields in anonymous records will be treated as names in their enclosing scopes when checking name styles. Specifically:\r\n\r\n- If the anonymous record is defined within the file scope or in a namespace scope, treat its fields as global variables when checking name styles;\r\n- If the anonymous record is defined within a function, treat its fields as local variables when checking name styles;\r\n- If the anonymous record is defined within a non-anonymous record, treat its fields as non-static record members when checking name styles.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang-tools-extra/clang-tidy/readability/IdentifierNamingCheck.cpp", "functions": ["getFailureInfo", "findStyleKindForAnonField"]}, {"filename": "clang-tools-extra/test/clang-tidy/checkers/readability/identifier-naming-anon-record-fields.cpp", "functions": ["test"]}]}
{"pr_number": 70886, "url": "https://github.com/llvm/llvm-project/pull/70886", "title": "[clang]get non-injected-class before finding instantiated decl", "body": "Fixes #21483 ", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/SemaCXX/friend.cpp", "functions": ["foo"]}]}
{"pr_number": 72187, "url": "https://github.com/llvm/llvm-project/pull/72187", "title": "[AArch64] merge index address with large offset into base address", "body": "A case for this transformation, https://gcc.godbolt.org/z/nhYcWq1WE\r\n```\r\nFold\r\n  mov     w8, #56952\r\n  movk    w8, #15, lsl #16\r\n  ldrb    w0, [x0, x8]\r\ninto\r\n  add     x0, x0, 1036288\r\n  ldrb    w0, [x0, 3704]\r\n```\r\nOnly support single use base, multi-use scenes are supported by PR74046.\r\nFix https://github.com/llvm/llvm-project/issues/71917", "feature_layers": [], "feature_directives": ["for", "single"], "files_changed": [{"filename": "llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp", "functions": ["isLegalSingleMOVImmediate"]}]}
{"pr_number": 75061, "url": "https://github.com/llvm/llvm-project/pull/75061", "title": "[clang-tidy][misleading-indentation]ignore false-positives for line started with empty macro", "body": "Fixes: #71767", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang-tools-extra/test/clang-tidy/checkers/readability/misleading-indentation.cpp", "functions": ["foo3"]}]}
{"pr_number": 69426, "url": "https://github.com/llvm/llvm-project/pull/69426", "title": "[DAGCombine] Add DAG optimisation for BF16_TO_FP", "body": "Before\r\n```\r\nslli a0, a0, 48\r\nsrli a0, a0, 48\r\nslli a0, a0, 16\r\n```\r\nAfter\r\n```\r\nslli a0, a0, 16\r\n```", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp", "functions": ["visitFP16_TO_FP"]}]}
{"pr_number": 76379, "url": "https://github.com/llvm/llvm-project/pull/76379", "title": "[Clang] support vector subscript expressions in constant evaluator (WIP)", "body": "Feel free to add additional reviewers as relevant,\r\n\r\nI'm yet to update float test cases as I'm not sure whether it would be safe to directly compare float results in static assert. Would it okay to integer cast the results and compare them ?", "feature_layers": ["ir", "ast"], "feature_directives": [], "files_changed": [{"filename": "clang/lib/AST/ExprConstant.cpp", "functions": ["EvaluateInteger", "addVectorUnchecked", "EvaluateVector", "addVector"]}]}
{"pr_number": 74949, "url": "https://github.com/llvm/llvm-project/pull/74949", "title": "[RISCV] Refactor checkRVVTypeSupport to use BuiltinVectorTypeInfo.", "body": "We can decompose the type into ElementType and MinSize and use those to perform the checks. This is more efficient than using isRVVType.\r\n\r\nThis also fixes a bug that we didn't disallow vbool64_t on Zve32x.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/Sema/riscv-vector-zve32x-check.c", "functions": ["vbool64"]}, {"filename": "clang/test/Sema/riscv-vector-zve64x-check.c", "functions": ["vbool64"]}]}
{"pr_number": 74950, "url": "https://github.com/llvm/llvm-project/pull/74950", "title": "[RISCV] Prevent checkRVVTypeSupport from issuing more than 1 diagnostic.", "body": "If vector isn't enabled at all, we might hit one of the earlier\r\ndiagnostics and the requires Zve32x diagnostic. The Zve32x diagnostic\r\nwould be redundant.\r\n\r\nThis is stacked on #74949", "feature_layers": ["ir"], "feature_directives": ["requires"], "files_changed": [{"filename": "clang/lib/Sema/SemaChecking.cpp", "functions": ["if"]}]}
{"pr_number": 76461, "url": "https://github.com/llvm/llvm-project/pull/76461", "title": "[SLP][TTI][X86]Add addsub pattern cost estimation.", "body": "SLP/TTI do not know about the cost estimation for addsub pattern, supported by X86. Previously the support for pattern detection was added (seeTTI::isLegalAltInstr), but the cost still did not estimated properly.\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp", "functions": ["OpcodeMask"]}]}
{"pr_number": 76440, "url": "https://github.com/llvm/llvm-project/pull/76440", "title": "[AMDGPU][True16] Don't use the VGPR_LO/HI16 register classes.", "body": "Removing the classes requires updating tests and so is planned to be done with a separate change.", "feature_layers": ["ir"], "feature_directives": ["requires"], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/Disassembler/AMDGPUDisassembler.cpp", "functions": ["createRegOperand"]}]}
{"pr_number": 76480, "url": "https://github.com/llvm/llvm-project/pull/76480", "title": "[clang] Add basic support for #embed", "body": "This patch takes the first steps toward C23 #embed support. We can include binary files, but embed-parameter-sequences are not implemented. Adding the embedded file to the -M dependency array is also not implemented.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Lex/DependencyDirectivesScanner.cpp", "functions": ["lexIncludeFilename"]}, {"filename": "clang/lib/Lex/PPDirectives.cpp", "functions": ["if", "HandleEmbedDirective"]}]}
{"pr_number": 76319, "url": "https://github.com/llvm/llvm-project/pull/76319", "title": "[X86][MC] Support encoding/decoding for APX variant ADD/SUB/ADC/SBB/OR/XOR/NEG/NOT instructions", "body": "Four variants: promoted legacy, ND (new data destination), NF (no flags update) and NF_ND (NF + ND).\r\n\r\nThe syntax of NF instructions is aligned with GNU binutils.\r\nhttps://sourceware.org/pipermail/binutils/2023-September/129545.html\r\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp", "functions": ["if"]}, {"filename": "llvm/lib/Target/X86/Disassembler/X86Disassembler.cpp", "functions": ["if"]}, {"filename": "llvm/lib/Target/X86/MCTargetDesc/X86MCCodeEmitter.cpp", "functions": ["setNF"]}, {"filename": "llvm/utils/TableGen/X86DisassemblerTables.cpp", "functions": ["if"]}, {"filename": "llvm/utils/TableGen/X86RecognizableInstr.cpp", "functions": ["if"]}]}
{"pr_number": 73888, "url": "https://github.com/llvm/llvm-project/pull/73888", "title": "[llvm-special-case-list-fuzzer] fix off-by-one read", "body": "The current fuzzer relies on MemoryBuffer to hold the fuzz data. However, the fuzzer runs into an OOB instantly because the MemoryBuffer interface guarantees that \"In addition to basic access to the characters in the file, this interface guarantees you can read one character past the end of the file, and that this character will read as '\\0'.\" [ref](https://llvm.org/doxygen/classllvm_1_1MemoryBuffer.html#details), which the fuzzer fails to satisfy. As such, it runs into an OOB on [this line](https://github.com/llvm/llvm-project/blob/c57ef2c69846a3f69c9d1db61055ea3b7b5100c3/llvm/lib/Support/LineIterator.cpp#L48).\r\n\r\nConsequently, the OSS-Fuzz set up is not running since the build is declared failing as the fuzzer fails on the first run. See here for links to build logs https://introspector.oss-fuzz.com/project-profile?project=llvm and specifically at the bottom of [this build log](https://oss-fuzz-build-logs.storage.googleapis.com/log-aecaad16-9581-48fe-af4a-a7be4dd947db.txt).\r\n\r\nThis change fixes the fuzzer and should solve the OSS-Fuzz build as well.\r\n\r\nCC @mmdriley", "feature_layers": ["ir", "ast"], "feature_directives": ["for", "declare"], "files_changed": [{"filename": "llvm/tools/llvm-special-case-list-fuzzer/special-case-list-fuzzer.cpp", "functions": ["Payload"]}]}
{"pr_number": 65963, "url": "https://github.com/llvm/llvm-project/pull/65963", "title": "Fix: Distinguish CFI Metadata Checks in MergeFunctions Pass", "body": "This diff fixes an issue in the MergeFunctions pass where two different Control Flow Integrity (CFI) metadata checks were incorrectly considered identical. These merges would lead to runtime violations down the line as two separate objects contained a single destructor which itself contained checks for only one of the objects.\r\n\r\nHere I update the comparison logic to take into account the metadata at llvm.type.test checks. Now, only truly identical checks will be considered for merging, thus preserving the integrity of each check.\r\n\r\nPrevious discussion: https://reviews.llvm.org/D154119", "feature_layers": ["runtime"], "feature_directives": ["for", "single"], "files_changed": [{"filename": "llvm/lib/Transforms/IPO/MergeFunctions.cpp", "functions": ["hasDistinctMetadataIntrinsic"]}]}
{"pr_number": 76271, "url": "https://github.com/llvm/llvm-project/pull/76271", "title": "[mlir][gpu] Add patterns to break down subgroup reduce", "body": "The new patterns break down subgroup reduce ops with vector values into a sequence of subgroup reductions that fit the native shuffle size. The maximum/native shuffle size is parametrized.\r\n\r\nThe overall goal is to be able to perform multi-element reductions with a sequence of `gpu.shuffle` ops.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/GPU/Transforms/SubgroupReduceLowering.cpp", "functions": ["success", "OpRewritePattern"]}, {"filename": "mlir/test/lib/Dialect/GPU/TestGpuRewrite.cpp", "functions": ["registerTestAllReduceLoweringPass", "runOnOperation", "getArgument", "registerTestGpuLoweringPasses", "patterns", "getDependentDialects", "getDescription"]}, {"filename": "mlir/tools/mlir-opt/mlir-opt.cpp", "functions": ["registerTestGpuLoweringPasses", "registerTestAllReduceLoweringPass"]}]}
{"pr_number": 76408, "url": "https://github.com/llvm/llvm-project/pull/76408", "title": "[llvm-dwarfdump-fuzzer] fix out of bounds potential", "body": "The fuzzer relies on MemoryBuffer to hold fuzz data, and MemoryBuffer guarantees that \"In addition to basic access to the characters in the file, this interface guarantees you can read one character past the end of the file, and that this character will read as '\\0'.\" [Ref](https://llvm.org/doxygen/classllvm_1_1MemoryBuffer.html#details). The current fuzzing set up does not support this, which causes potential false positives. This PR fixes it.\r\n\r\nFixes: https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=65114", "feature_layers": ["ast"], "feature_directives": [], "files_changed": [{"filename": "llvm/tools/llvm-dwarfdump/fuzzer/llvm-dwarfdump-fuzzer.cpp", "functions": ["Payload"]}]}
{"pr_number": 76536, "url": "https://github.com/llvm/llvm-project/pull/76536", "title": "Revert \"[RISCV][CostModel] Add getRISCVInstructionCost() to TTI for Cost\u2026 (#73651)\"", "body": "Fails on bots https://lab.llvm.org/buildbot/#/builders/5/builds/39629\n\nIssue #76535\n\nThis reverts commit 3e75dece919511e4a2edada82d783304cc14a9cd.\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVISelLowering.cpp", "functions": ["getLMULCost"]}, {"filename": "llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp", "functions": ["if"]}]}
{"pr_number": 76486, "url": "https://github.com/llvm/llvm-project/pull/76486", "title": "[flang][runtime] Enable more APIs in the offload build.", "body": "", "feature_layers": ["runtime"], "feature_directives": [], "files_changed": [{"filename": "flang/runtime/array-constructor.cpp", "functions": ["RTDEF", "RTNAME"]}, {"filename": "flang/runtime/character.cpp", "functions": ["LenTrim", "RTDEF", "Adjust", "CompareToBlankPadding", "RTNAME"]}, {"filename": "flang/runtime/dot-product.cpp", "functions": ["GetResult", "RTDEF", "Accumulator", "operator", "RTNAME", "AccumulateIndexed"]}, {"filename": "flang/runtime/extrema.cpp", "functions": ["NumericExtremumAccumulator", "CharacterExtremumAccumulator", "GetResult", "AccumulateAt", "RTDEF", "Reinitialize", "ExtremumLocAccumulator", "operator", "Accumulate", "argRank", "Norm2Accumulator", "RTNAME", "Value", "CharacterCompare"]}, {"filename": "flang/runtime/findloc.cpp", "functions": ["AccumulateAt", "GetResult", "RTDEF", "Reinitialize", "operator", "RTNAME"]}, {"filename": "flang/runtime/inquiry.cpp", "functions": ["RTDEF", "RTNAME"]}, {"filename": "flang/runtime/memory.cpp", "functions": ["FreeMemory"]}, {"filename": "flang/runtime/misc-intrinsic.cpp", "functions": ["RTDEF", "RTNAME"]}, {"filename": "flang/runtime/pointer.cpp", "functions": ["RTDEF", "RTNAME"]}, {"filename": "flang/runtime/product.cpp", "functions": ["AccumulateAt", "GetResult", "RTDEF", "Reinitialize", "NonComplexProductAccumulator", "ComplexProductAccumulator", "RTNAME"]}, {"filename": "flang/runtime/ragged.cpp", "functions": ["RTDEF", "isIndirection", "rank", "RTNAME", "RaggedArrayDeallocate"]}]}
{"pr_number": 75420, "url": "https://github.com/llvm/llvm-project/pull/75420", "title": "[RISCV] Move SiFive cdiscard.d.l1 and cflush.d.l1 to their own extensions.", "body": "These were previously in XSfcie which is not an official SiFive Extension name and \"SiFive Custom Instruction Extension\" refers to a different feature that is not supported by LLVM today.\r\n\r\nThese extensions are prefixed with XSiFive instead of XSf because that is what has been in SiFive's downstream toolchain for a while making this SiFive's preferred name for these extensions.\r\n\r\nI plan to remove XSfcie once I get everything moved out of it.\r\n\r\nCC @quic-garvgupt", "feature_layers": ["ir"], "feature_directives": ["for", "flush"], "files_changed": [{"filename": "llvm/lib/Support/RISCVISAInfo.cpp", "functions": ["format"]}]}
{"pr_number": 75259, "url": "https://github.com/llvm/llvm-project/pull/75259", "title": "[libcxx] adds ranges::fold_left_with_iter and ranges::fold_left", "body": "Notable things in this commit does:\r\n\r\n* refactors `__indirect_binary_left_foldable`, making it slightly different (but equivalent) to _`indirect-binary-left-foldable`_, which improves readability (a [patch to the Working Paper][patch] was made)\r\n* omits `__cpo` namespace, since it is not required for implementing niebloids (a cleanup should happen in 2024)\r\n* puts tests ensuring invocable robustness and dangling correctness inside the correctness testing to ensure that the algorithms' results are still correct\r\n\r\n[patch]: https://github.com/cplusplus/draft/pull/6734", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "libcxx/test/std/algorithms/alg.nonmodifying/alg.fold/fold_left/requirements.compile.pass.cpp", "functions": ["requires_movable_init", "requires_init_is_convertible_to_decayed", "requires_sentinel", "requires_decaying_invoke_result", "requires_input_iterator", "requires_assignable_from_invoke_result", "requires_invocable_with_decayed", "test", "requires_raw_invocable", "requires_copy_constructible_F", "requires_movable_decayed"]}, {"filename": "libcxx/test/std/algorithms/alg.nonmodifying/alg.fold/fold_left/return_types.compile.pass.cpp", "functions": ["plus"]}, {"filename": "libcxx/test/std/algorithms/alg.nonmodifying/alg.fold/fold_left/valid.pass.cpp", "functions": ["test", "main"]}, {"filename": "libcxx/test/std/algorithms/alg.nonmodifying/alg.fold/fold_left_with_iter/requirements.compile.pass.cpp", "functions": ["requires_movable_init", "requires_init_is_convertible_to_decayed", "requires_sentinel", "requires_decaying_invoke_result", "requires_input_iterator", "requires_assignable_from_invoke_result", "requires_invocable_with_decayed", "test", "requires_raw_invocable", "requires_copy_constructible_F", "requires_movable_decayed"]}, {"filename": "libcxx/test/std/algorithms/alg.nonmodifying/alg.fold/fold_left_with_iter/return_types.compile.pass.cpp", "functions": ["plus"]}, {"filename": "libcxx/test/std/algorithms/alg.nonmodifying/alg.fold/fold_left_with_iter/valid.pass.cpp", "functions": ["test", "main"]}, {"filename": "libcxx/test/std/algorithms/alg.nonmodifying/alg.fold/fold_left_with_iter/requirements.verify.cpp", "functions": ["test_iterator", "begin", "test_fold_range", "end"]}, {"filename": "libcxx/test/std/algorithms/alg.nonmodifying/alg.fold/fold_left/requirements.verify.cpp", "functions": ["test_iterator", "begin", "test_fold_range", "end"]}, {"filename": "libcxx/test/std/algorithms/alg.nonmodifying/alg.fold/requirements.compile.pass.cpp", "functions": ["requires_movable_init", "begin", "apply", "requires_sentinel", "end", "requires_init_is_convertible_to_decayed", "requires_decaying_invoke_result", "requires_input_iterator", "requires_assignable_from_invoke_result", "operator", "requires_invocable_with_decayed", "test", "requires_raw_invocable", "requires_copy_constructible_F", "requires_movable_decayed"]}, {"filename": "libcxx/test/std/algorithms/alg.nonmodifying/alg.fold/left_folds.pass.cpp", "functions": ["Long", "plus"]}, {"filename": "libcxx/test/std/algorithms/algorithms.results/in_value_result.pass.cpp", "functions": ["test", "ConvertibleFrom", "main", "A"]}]}
{"pr_number": 73651, "url": "https://github.com/llvm/llvm-project/pull/73651", "title": "[RISCV][CostModel] Add getRISCVInstructionCost() to TTI for Cost\u2026", "body": "\u2026Kind\r\n\r\nInstruction cost for CodeSize and Latency/RecipThroughput can be very differnet. Considering the diversity of CostKind and vendor-specific cost, and how they are spread across various TTI functions, it's becoming quite a challenge to handle. This patch adds an interface getRISCVInstructionCost to address it.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp", "functions": ["if"]}, {"filename": "llvm/lib/Target/RISCV/RISCVISelLowering.cpp", "functions": ["getLMULCost"]}]}
{"pr_number": 76492, "url": "https://github.com/llvm/llvm-project/pull/76492", "title": "[clangd] Avoid crash when summarizing pointer-to-member expr for block-end hint", "body": "Fixes https://github.com/clangd/clangd/issues/1873", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang-tools-extra/clangd/unittests/InlayHintTests.cpp", "functions": ["foo"]}]}
{"pr_number": 66745, "url": "https://github.com/llvm/llvm-project/pull/66745", "title": "[IPSCCP] Variable not visible at Og.", "body": "https://bugs.llvm.org/show_bug.cgi?id=51559\r\nhttps://github.com/llvm/llvm-project/issues/50901\r\n\r\nIPSCCP pass removes the global variable and does not create a constant expression for the initializer value.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/IPO/SCCP.cpp", "functions": ["if", "DIB", "createDebugConstantExpression"]}, {"filename": "llvm/lib/Transforms/Utils/Local.cpp", "functions": ["createIntegerExpression"]}, {"filename": "llvm/unittests/Transforms/Utils/LocalTest.cpp", "functions": ["M", "DIB"]}]}
{"pr_number": 75468, "url": "https://github.com/llvm/llvm-project/pull/75468", "title": "[OpenMP] Introduce -fopenmp-force-usm flag", "body": "The new flag implements logic to include `#pragma omp requires unified_shared_memory` in every translation unit.\r\nThis enables a straightforward way to enable USM for an application without the need to modify sources.\r\n\r\nThis is the flag mentioned in https://github.com/llvm/llvm-project/pull/75467\r\nOnce the test landed, I'll rebase and enable the test with this patch.", "feature_layers": ["ir"], "feature_directives": ["for", "requires"], "files_changed": [{"filename": "clang/lib/Driver/ToolChains/AMDGPUOpenMP.cpp", "functions": ["P"]}]}
{"pr_number": 76120, "url": "https://github.com/llvm/llvm-project/pull/76120", "title": "[Libomptarget] Rework image checking further", "body": "Summary:\nIn the future, we may have more checks for different kinds of inputs,\ne.g. SPIR-V. This patch simply reworks the handling to be more generic\nand do the magic detection up-front. The checks inside the routines are\nnow asserts so we don't spend time checking this stuff over and over\nagain.\n\nThis patch also tweaked the bitcode check. I used a different function\nto get the Lazy-IR module now, as it returns the raw expected value\nrather than the SM diganostic.\n\nNo functionality change intended.\n", "feature_layers": ["ir"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "openmp/libomptarget/plugins-nextgen/common/src/JIT.cpp", "functions": ["Data", "Triple"]}, {"filename": "openmp/libomptarget/plugins-nextgen/common/src/PluginInterface.cpp", "functions": ["Buffer", "HandleError", "isELFCompatible", "__tgt_rtl_is_valid_binary"]}, {"filename": "openmp/libomptarget/plugins-nextgen/common/src/Utils/ELF.cpp", "functions": ["createError"]}]}
{"pr_number": 75274, "url": "https://github.com/llvm/llvm-project/pull/75274", "title": "[mlir] Handle simple commutative cases in CSE.", "body": "Tried to keep this simple while handling obvious CSE instances. For more complicated cases the expectation is still that the sorting pass would run before. While simple, this case did turn up in a real deployed instance where it had a large e2e impact. This can of course be refined.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/IR/OperationSupport.cpp", "functions": ["failure", "success"]}]}
{"pr_number": 76368, "url": "https://github.com/llvm/llvm-project/pull/76368", "title": "[llvm-exegesis] Add support for loading X86 segment registers", "body": "This patch adds support for setting the X86 segment registers. These registers are used in quite a few basic blocks in BHive and similar datasets, so being able to set them is necessary to ensure consistent runs as the live-in values of fs and gs can change across runs.\r\n\r\nFixes #76340.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/tools/llvm-exegesis/lib/X86/Target.cpp", "functions": ["if"]}]}
{"pr_number": 76557, "url": "https://github.com/llvm/llvm-project/pull/76557", "title": "[clang][analyzer] Support 'fflush' in the StdLibraryFunctionsChecker", "body": "", "feature_layers": [], "feature_directives": ["flush"], "files_changed": [{"filename": "clang/test/Analysis/stream-errno.c", "functions": ["check_fflush_1", "check_fflush_0", "check_fflush_all", "check_fflush_opened_file"]}]}
{"pr_number": 76603, "url": "https://github.com/llvm/llvm-project/pull/76603", "title": "[mlir][tensor] Centralize pack/unpack related patterns.", "body": "The revision moves pack/unpack related patterns to PackAndUnpackPatterns.cpp. This follows the convention like other tensor ops.\r\n\r\nIt also renames `populateSimplifyTensorPack` to `populateSimplifyPackAndUnpackPatterns` and adds a TODO item for tensor.unpack op.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Tensor/IR/TensorOps.cpp", "functions": ["failure", "success"]}, {"filename": "mlir/lib/Dialect/Tensor/Transforms/PackAndUnpackPatterns.cpp", "functions": ["failure", "success", "populateSimplifyPackAndUnpackPatterns"]}, {"filename": "mlir/test/lib/Dialect/Tensor/TestTensorTransforms.cpp", "functions": ["applySimplifyPackUnpackPatterns", "applySimplifyPackPatterns"]}]}
{"pr_number": 69445, "url": "https://github.com/llvm/llvm-project/pull/69445", "title": "[Instsimplify] lshr&icmp adds support for the or instruction", "body": "Closes #69333.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Analysis/InstructionSimplify.cpp", "functions": ["existOrChain"]}]}
{"pr_number": 76553, "url": "https://github.com/llvm/llvm-project/pull/76553", "title": "[FuncAttrs] Deduce `noundef` attributes for return values", "body": "This patch deduces `noundef` attributes for return values.\r\nIIUC, a function returns `noundef` values iff all of its return values are guaranteed not to be `undef` or `poison`.\r\nDefinition of `noundef` from LangRef:\r\n```\r\nnoundef\r\nThis attribute applies to parameters and return values. If the value representation contains any \r\nundefined or poison bits, the behavior is undefined. Note that this does not refer to padding \r\nintroduced by the type\u2019s storage representation.\r\n```\r\nAlive2: https://alive2.llvm.org/ce/z/g8Eis6\r\n\r\nCompile-time impact: http://llvm-compile-time-tracker.com/compare.php?from=30dcc33c4ea3ab50397a7adbe85fe977d4a400bd&to=c5e8738d4bfbf1e97e3f455fded90b791f223d74&stat=instructions:u\r\n|stage1-O3|stage1-ReleaseThinLTO|stage1-ReleaseLTO-g|stage1-O0-g|stage2-O3|stage2-O0-g|stage2-clang|\r\n|--|--|--|--|--|--|--|\r\n|+0.01%|+0.01%|-0.01%|+0.01%|+0.03%|-0.04%|+0.01%|\r\n\r\nThe motivation of this patch is to reduce the number of `freeze` insts and enable more optimizations.\r\nExample:\r\n```\r\ndiff --git a/bench/flac/optimized/replaygain.c.ll b/bench/flac/optimized/replaygain.c.ll\r\nindex fa826475..413bd717 100644\r\n--- a/bench/flac/optimized/replaygain.c.ll\r\n+++ b/bench/flac/optimized/replaygain.c.ll\r\n@@ -63,7 +63,7 @@ entry:\r\n declare i32 @InitGainAnalysis(i64 noundef) local_unnamed_addr #1\r\n \r\n ; Function Attrs: nounwind sspstrong uwtable\r\n-define dso_local i32 @grabbag__replaygain_analyze(ptr nocapture noundef readonly %input, i32 noundef %is_stereo, i32 noundef %bps, i32 noundef %samples) local_unnamed_addr #0 {\r\n+define dso_local noundef i32 @grabbag__replaygain_analyze(ptr nocapture noundef readonly %input, i32 noundef %is_stereo, i32 noundef %bps, i32 noundef %samples) local_unnamed_addr #0 {\r\n entry:\r\n   %cmp = icmp eq i32 %bps, 16\r\n   br i1 %cmp, label %if.then, label %if.else71\r\n@@ -337,7 +337,7 @@ entry:\r\n declare float @GetTitleGain() local_unnamed_addr #1\r\n \r\n ; Function Attrs: nounwind sspstrong uwtable\r\n-define dso_local ptr @grabbag__replaygain_analyze_file(ptr noundef %filename, ptr nocapture noundef writeonly %title_gain, ptr nocapture noundef writeonly %title_peak) local_unnamed_addr #0 {\r\n+define dso_local noundef ptr @grabbag__replaygain_analyze_file(ptr noundef %filename, ptr nocapture noundef writeonly %title_gain, ptr nocapture noundef writeonly %title_peak) local_unnamed_addr #0 {\r\n entry:\r\n   %instance = alloca %struct.DecoderInstance, align 4\r\n   %call = tail call ptr @FLAC__stream_decoder_new() #15\r\n@@ -392,7 +392,7 @@ declare i32 @FLAC__stream_decoder_set_metadata_respond(ptr noundef, i32 noundef)\r\n declare i32 @FLAC__stream_decoder_init_file(ptr noundef, ptr noundef, ptr noundef, ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #1\r\n \r\n ; Function Attrs: nounwind sspstrong uwtable\r\n-define internal i32 @write_callback_(ptr nocapture readnone %decoder, ptr nocapture noundef readonly %frame, ptr nocapture noundef readonly %buffer, ptr nocapture noundef %client_data) #0 {\r\n+define internal noundef i32 @write_callback_(ptr nocapture readnone %decoder, ptr nocapture noundef readonly %frame, ptr nocapture noundef readonly %buffer, ptr nocapture noundef %client_data) #0 {\r\n entry:\r\n   %bits_per_sample1 = getelementptr inbounds %struct.FLAC__FrameHeader, ptr %frame, i64 0, i32 4\r\n   %0 = load i32, ptr %bits_per_sample1, align 8\r\n@@ -429,23 +429,16 @@ land.lhs.true14:                                  ; preds = %land.lhs.true11\r\n   %cmp16 = icmp eq i32 %2, %8\r\n   br i1 %cmp16, label %if.end, label %if.end.thread\r\n \r\n-if.end.thread:                                    ; preds = %land.lhs.true, %land.lhs.true14, %land.lhs.true11, %land.lhs.true8, %entry\r\n-  store i32 1, ptr %error, align 4\r\n-  br label %9\r\n-\r\n if.end:                                           ; preds = %land.lhs.true14\r\n   %conv = zext i1 %cmp to i32\r\n   %call = tail call i32 @grabbag__replaygain_analyze(ptr noundef %buffer, i32 noundef %conv, i32 noundef %0, i32 noundef %3), !range !14\r\n-  %call.fr = freeze i32 %call\r\n-  %lnot.ext = xor i32 %call.fr, 1\r\n-  store i32 %lnot.ext, ptr %error, align 4\r\n-  %tobool22.not = icmp ne i32 %lnot.ext, 0\r\n-  %spec.select = zext i1 %tobool22.not to i32\r\n-  br label %9\r\n-\r\n-9:                                                ; preds = %if.end, %if.end.thread\r\n-  %10 = phi i32 [ 1, %if.end.thread ], [ %spec.select, %if.end ]\r\n-  ret i32 %10\r\n+  %lnot.ext = xor i32 %call, 1\r\n+  br label %if.end.thread\r\n+\r\n+if.end.thread:                                    ; preds = %entry, %land.lhs.true8, %land.lhs.true11, %land.lhs.true14, %land.lhs.true, %if.end\r\n+  %storemerge = phi i32 [ %lnot.ext, %if.end ], [ 1, %land.lhs.true ], [ 1, %land.lhs.true14 ], [ 1, %land.lhs.true11 ], [ 1, %land.lhs.true8 ], [ 1, %entry ]\r\n+  store i32 %storemerge, ptr %error, align 4\r\n+  ret i32 %storemerge\r\n }\r\n \r\n ; Function Attrs: nounwind sspstrong uwtable\r\n\r\n```", "feature_layers": [], "feature_directives": ["for", "declare"], "files_changed": [{"filename": "llvm/lib/Transforms/IPO/FunctionAttrs.cpp", "functions": ["isGuaranteedNotToBeUndefOrPoison"]}]}
{"pr_number": 73920, "url": "https://github.com/llvm/llvm-project/pull/73920", "title": "[clang][AMDGPU] precommit test for ballot on Windows", "body": "The Clang declaration of the wave-64 builtin uses \"UL\" as the return type, which is interpreted as a 32-bit unsigned integer on Windows. This emits an incorrect LLVM declaration with i32 return type instead of i64. The clang declaration needs to be fixed to use \"WU\" instead.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CodeGenHIP/ballot.cpp", "functions": ["__builtin_amdgcn_ballot_w64", "foo"]}]}
{"pr_number": 73906, "url": "https://github.com/llvm/llvm-project/pull/73906", "title": "[clang][AMDGPU] fix the return type for ballot", "body": "In the builtins declaration, \"ULi\" is a 32-bit integer on Windows. Use \"WUi\" instead to ensure a 64-bit integer on all platforms.\r\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CodeGenHIP/ballot.cpp", "functions": ["__builtin_amdgcn_ballot_w64", "foo"]}]}
{"pr_number": 74053, "url": "https://github.com/llvm/llvm-project/pull/74053", "title": "[RISCV] Support printing immediate of RISCV MCInst in hexadecimal format", "body": "Enable the llvm-objdump to disassemble the immediate of RISCV instruction in hexadecimal format with --print-imm-hex flag.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/MCTargetDesc/RISCVInstPrinter.cpp", "functions": ["formatImm"]}]}
{"pr_number": 76655, "url": "https://github.com/llvm/llvm-project/pull/76655", "title": "[analyzer][NFC] Cleanup BugType lazy-init patterns", "body": "Cleanup most of the lazy-init `BugType` legacy.\r\nSome will be preserved, as those are slightly more complicated to refactor.\r\n\r\nNotice, that the default category for `BugType` is `LogicError`. I omitted setting this explicitly where I could.\r\n\r\nPlease, actually have a look at the diff. I did this manually, and we rarely check the bug type descriptions and stuff in tests, so the testing might be shallow on this one.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/StaticAnalyzer/Checkers/BasicObjCFoundationChecks.cpp", "functions": ["BugType"]}, {"filename": "clang/lib/StaticAnalyzer/Checkers/DivZeroChecker.cpp", "functions": ["BugType"]}, {"filename": "clang/lib/StaticAnalyzer/Checkers/DynamicTypeChecker.cpp", "functions": ["BugType", "initBugType"]}, {"filename": "clang/lib/StaticAnalyzer/Checkers/EnumCastOutOfRangeChecker.cpp", "functions": ["BugType"]}, {"filename": "clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp", "functions": ["initBugType"]}, {"filename": "clang/lib/StaticAnalyzer/Checkers/ObjCAtSyncChecker.cpp", "functions": ["BugType"]}, {"filename": "clang/lib/StaticAnalyzer/Checkers/ObjCContainersChecker.cpp", "functions": ["initBugType"]}, {"filename": "clang/lib/StaticAnalyzer/Checkers/UndefBranchChecker.cpp", "functions": ["BugType", "FindIt"]}, {"filename": "clang/lib/StaticAnalyzer/Checkers/UndefCapturedBlockVarChecker.cpp", "functions": ["BugType"]}, {"filename": "clang/lib/StaticAnalyzer/Checkers/UndefResultChecker.cpp", "functions": ["BugType"]}, {"filename": "clang/lib/StaticAnalyzer/Checkers/VLASizeChecker.cpp", "functions": ["BugType"]}, {"filename": "clang/lib/StaticAnalyzer/Checkers/BlockInCriticalSectionChecker.cpp", "functions": ["IILockGuard"]}, {"filename": "clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp", "functions": ["BugType", "NSObjectII"]}, {"filename": "clang/lib/StaticAnalyzer/Checkers/CloneChecker.cpp", "functions": ["BugType"]}, {"filename": "clang/lib/StaticAnalyzer/Checkers/InvalidatedIteratorChecker.cpp", "functions": ["BugType"]}, {"filename": "clang/lib/StaticAnalyzer/Checkers/IteratorRangeChecker.cpp", "functions": ["BugType"]}, {"filename": "clang/lib/StaticAnalyzer/Checkers/MismatchedIteratorChecker.cpp", "functions": ["BugType"]}, {"filename": "clang/lib/StaticAnalyzer/Checkers/ObjCSuperDeallocChecker.cpp", "functions": ["IIdealloc"]}, {"filename": "clang/lib/StaticAnalyzer/Checkers/SimpleStreamChecker.cpp", "functions": ["BugType", "OpenFn"]}, {"filename": "clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp", "functions": ["BT_uninitField"]}, {"filename": "clang/unittests/StaticAnalyzer/CallEventTest.cpp", "functions": ["BT_uninitField"]}]}
{"pr_number": 75311, "url": "https://github.com/llvm/llvm-project/pull/75311", "title": "[LVI] Support using block values when handling conditions", "body": "Currently, LVI will only use conditions like \"X < C\" to constrain the value of X on the relevant edge. This patch extends it to handle conditions like \"X < Y\" by querying the known range of Y.\r\n\r\nThis means that getValueFromCondition() and various related APIs can now return nullopt to indicate that they have pushed to the worklist, and need to be called again later. This behavior is currently controlled by a UseBlockValue option, and only enabled for actual edge value handling. All other places deriving constraints from conditions keep using the previous logic for now.\r\n\r\nThis change was originally motivated as a fix for the regression reported in https://github.com/llvm/llvm-project/pull/73662#issuecomment-1849281758. Unfortunately, it doesn't actually fix it, because we run into another issue there (LVI currently is really bad at handling values used in loops).\r\n\r\nThis change has some compile-time impact (http://llvm-compile-time-tracker.com/compare.php?from=41aa0d4690a25366a5acbd4f3cbc94ca89176dfe&to=a0d36310343898db0aea04f02682f6ff72d0b60f&stat=instructions:u), but it's fairly small, in the 0.05% range.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Analysis/LazyValueInfo.cpp", "functions": ["getValueFromICmpCondition", "getValueFromSimpleICmpCondition", "getValueFromCondition", "if", "intersect"]}]}
{"pr_number": 76363, "url": "https://github.com/llvm/llvm-project/pull/76363", "title": "[InstCombine] fold Select with a predicate consists of Icmp connected by And ", "body": "\r\nThis patch closes #76043. \r\n\r\n---\r\nWe extended the pre-exist `foldSelectWithBinaryOp`, to make it support the below case: \r\n```\r\n%A = icmp eq %TV, %FV\r\n%C = and %A, %B\r\n%D = select %C, %TV, %FV\r\n->\r\n%FV\r\n```\r\nor \r\n```\r\n%A = icmp ne %TV, %FV\r\n%C = or %A, %B\r\n%D = select %C, %FV, %TV\r\n->\r\n%TV\r\n```\r\nThe Alive2 proof: https://alive2.llvm.org/ce/z/XLyhE-\r\n\r\n--- \r\nFor updated test cases in `select-and-cmp.ll` and `select-or-cmp.ll`, we also provided Alive2 proof: https://alive2.llvm.org/ce/z/krhtZy", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Analysis/InstructionSimplify.cpp", "functions": ["getSimplifiedValue"]}]}
{"pr_number": 75911, "url": "https://github.com/llvm/llvm-project/pull/75911", "title": "[AMDGPU] Update compute program resource registers for GFX12", "body": "", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp", "functions": ["Error"]}]}
{"pr_number": 76041, "url": "https://github.com/llvm/llvm-project/pull/76041", "title": "[RISCV][test] Add tests for RISCVInstrInfo::describeLoadedValue", "body": "Tests are in preparation for adding handling of the load of a constant value as Mips does (noted in\r\n<https://github.com/llvm/llvm-project/pull/72356#discussion_r1395203532>).\r\n\r\nI've opted to implement these tests as a C++ unit test as on balance I _think_ it's easier to follow and maintain than .mir tests trying to indirectly test this function. That said, you see the limitations with the test of describeLoadedValue on a memory operation where we'd rather pass `MachinePointerInfo::getFixedStack` but can't because we'd need to then ensure the necessary stack metadata for the function is present.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/unittests/Target/RISCV/RISCVInstrInfoTest.cpp", "functions": ["OS", "expectDIEPrintResult"]}]}
{"pr_number": 76708, "url": "https://github.com/llvm/llvm-project/pull/76708", "title": "[llvm][NFC] Use SDValue::getConstantOperandVal(i) where possible", "body": "This helper function shortens examples like\r\n`cast<ConstantSDNode>(Node->getOperand(1))->getZExtValue();` to `Node->getConstantOperandVal(1);`.\r\n\r\nImplemented with:\r\n`git grep -l\r\n\"cast<ConstantSDNode>\\(.*->getOperand\\(.*\\)\\)->getZExtValue\\(\\)\" | xargs sed -E -i\r\n's/cast<ConstantSDNode>\\((.*)->getOperand\\((.*)\\)\\)->getZExtValue\\(\\)/\\1->getConstantOperandVal(\\2)/` and `git grep -l\r\n\"cast<ConstantSDNode>\\(.*\\.getOperand\\(.*\\)\\)->getZExtValue\\(\\)\" | xargs sed -E -i\r\n's/cast<ConstantSDNode>\\((.*)\\.getOperand\\((.*)\\)\\)->getZExtValue\\(\\)/\\1.getConstantOperandVal(\\2)/'`. With a couple of simple manual fixes needed. Result then processed by `git clang-format`.", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AArch64/AArch64ISelLowering.cpp", "functions": ["getPTrue"]}, {"filename": "llvm/lib/Target/Hexagon/HexagonISelLowering.cpp", "functions": ["Flags"]}, {"filename": "llvm/lib/Target/PowerPC/PPCISelLowering.cpp", "functions": ["SDValue", "Flags"]}]}
{"pr_number": 66073, "url": "https://github.com/llvm/llvm-project/pull/66073", "title": "[RISCV] Fix bugs about getting register list of Zcmp push/pop.", "body": "The pr does two things, one is to fix internal compiler error when we need to spill callee saves but none of them is GPR, another is to fix wrong register number for pushed registers are {ra, s0-s11}.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVFrameLowering.cpp", "functions": ["getPushPopEncoding"]}]}
{"pr_number": 76232, "url": "https://github.com/llvm/llvm-project/pull/76232", "title": "[Sema] Fix crash on invalid code with parenthesized aggregate initialization", "body": "Fixes #76228.\r\nUse the same logic as braced init lists, also adds a test that puts incomplete types in various positions to check for regressions in the future.", "feature_layers": ["sema"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/SemaCXX/crash-GH76228.cpp", "functions": ["a5"]}]}
{"pr_number": 76089, "url": "https://github.com/llvm/llvm-project/pull/76089", "title": "[GlobalIsel]  Combine selects with constants", "body": "A first small step at combining selects.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp", "functions": ["if", "isConstantSplatVector"]}]}
{"pr_number": 76475, "url": "https://github.com/llvm/llvm-project/pull/76475", "title": "[flang] Defer processing of non-pointer variable initializers", "body": "Initializers in entity-decls don't need to have their expressions analyzed immediately in name resolution unless of course they are defining the values of named constants.  By deferring the expression analysis, the compiler can better handle references to module and internal procedures that might appear in structure constructors; at present, these are typically rejected as being forward references (which they can be) to subprogram names that can't yet be checked for compatibility with the characteristics of the corresponding procedure component.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Semantics/resolve-names.cpp", "functions": ["FinishExecutionParts", "Pre"]}]}
{"pr_number": 76104, "url": "https://github.com/llvm/llvm-project/pull/76104", "title": "[GlobalIsel][AArch64] MVP for vectorized selects.", "body": "Try to select Selects where the condition is a vector.\r\n\r\nInspired by arm64-vselect.ll and extensions to it.\r\n\r\nNote that there are not tests for all legal types.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp", "functions": ["selectVectorSelect"]}]}
{"pr_number": 76538, "url": "https://github.com/llvm/llvm-project/pull/76538", "title": "[flang] Accept BIND(C) derived type for Cray pointees", "body": "The compiler requires that a Cray pointee have a SEQUENCE type, but a recent bug report points out that a BIND(C) type should also be accepted.\r\n\r\nFixes https://github.com/llvm/llvm-project/issues/76529.", "feature_layers": ["ir"], "feature_directives": ["for", "requires"], "files_changed": [{"filename": "flang/lib/Evaluate/tools.cpp", "functions": ["IsSequenceOrBindCType"]}]}
{"pr_number": 75709, "url": "https://github.com/llvm/llvm-project/pull/75709", "title": "[OpenMP] atomic compare fail : Codegen support", "body": "This is a continuation of https://reviews.llvm.org/D123235 ([OpenMP] atomic compare fail : Parser & AST support). In this branch Support for codegen support for atomic compare fail is being added.", "feature_layers": ["parse", "codegen", "ast", "parser"], "feature_directives": ["for", "atomic"], "files_changed": [{"filename": "clang/lib/CodeGen/CGStmtOpenMP.cpp", "functions": ["if"]}, {"filename": "clang/test/OpenMP/atomic_compare_codegen.cpp", "functions": ["fail_dxevd"]}]}
{"pr_number": 76606, "url": "https://github.com/llvm/llvm-project/pull/76606", "title": "[mlir][tensor] Improve tensor.pack simplication pattern. ", "body": "A tensor.pack op can be rewritten to a tensor.expand_shape op if the packing only happens on inner most dimension.\r\n\r\nThis also formats the lit checks better.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Tensor/Transforms/PackAndUnpackPatterns.cpp", "functions": ["failure"]}]}
{"pr_number": 76642, "url": "https://github.com/llvm/llvm-project/pull/76642", "title": "[flang][runtime] Don't use -1 in I/O API for \"default unit\"", "body": "The I/O runtime's API allows -1 to be passed for a unit number in a READ, WRITE, or PRINT statement, where it gets replaced by 5 or 6 as appropriate.  This turns out to have been a bad idea, as it prevents the I/O runtime from detecting and reporting a program's invalid attempt to use -1 as an I/O unit number. So just pass 5 or 6 as appropriate.", "feature_layers": ["runtime"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Lower/IO.cpp", "functions": ["genIOUnit"]}]}
{"pr_number": 76578, "url": "https://github.com/llvm/llvm-project/pull/76578", "title": "[RISCV] Don't emit vxrm writes for vnclip(u).wi with shift of 0.", "body": "If there's no shift being performed, the rounding mode doesn't matter.\r\n\r\nWe could do the same for vssra and vssrl, but they are no-ops with a shift of 0 so would be better off being removed earlier.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp", "functions": ["ignoresVXRM"]}]}
{"pr_number": 75244, "url": "https://github.com/llvm/llvm-project/pull/75244", "title": "[lldb-dap] Emit more structured info along with variables", "body": "In order to allow smarter vscode extensions, it's useful to send additional structured information of SBValues to the client. Specifically, I'm now sending error, summary, autoSummary and inMemoryValue in addition to the existing properties being sent. This is cheap because these properties have to be calculated anyway to generate the display value of the variable, but they are now available for extensions to better analyze variables. For example, if the error field is not present, the extension might be able to provide cool features, and the current way to do that is to look for the `\"<error: \"` prefix, which is error-prone.\r\n\r\nThis also incorporates a tiny feedback from https://github.com/llvm/llvm-project/pull/74865#issuecomment-1850695477", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "lldb/tools/lldb-dap/JSONUtils.cpp", "functions": ["v", "TryCreateAutoSummary", "ValueToString", "CreateUniqueVariableNameForDisplay", "strm", "desc", "os_display_value"]}, {"filename": "lldb/tools/lldb-dap/lldb-dap.cpp", "functions": ["desc"]}]}
{"pr_number": 75402, "url": "https://github.com/llvm/llvm-project/pull/75402", "title": "[coroutines] Use DILocation from new storage for hoisted dbg.declare", "body": "Make the hoisted dbg.declare inherent the DILocation scope from the new storage.\r\n\r\nAfter hoisting, the dbg.declare is moved into the block that defines the new storage. This could create an inconsistency in the debug location scope hierarchy where the scope of hoisted dbg.declare (i.e. DILexicalBlock) is enclosed with the scope of the block (i.e. DISubprogram). This confuses LiveDebugValues pass to think that the hoisted dbg.declare is killed in that block and does not generate DBG_VALUE in other blocks. Debugger won't be able to track its value anymore.\r\n\r\nWe do this for unoptimized binary only.", "feature_layers": [], "feature_directives": ["for", "declare"], "files_changed": [{"filename": "llvm/lib/Transforms/Coroutines/CoroFrame.cpp", "functions": ["if"]}]}
{"pr_number": 76594, "url": "https://github.com/llvm/llvm-project/pull/76594", "title": "[flang] Add notify-type and notify-wait-stmt", "body": "Add `notify-type` to `iso_fortran_env` module. Add `notify-wait-stmt` to the parser and add checks for constraints on the statement, `C1177` and `C1178`, from the Fortran 2023 standard. Add three semantics tests for `notify-wait-stmt`.", "feature_layers": ["parse", "sema", "parser"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Evaluate/tools.cpp", "functions": ["IsNotifyType", "IsBuiltinDerivedType"]}, {"filename": "flang/lib/Lower/Bridge.cpp", "functions": ["genFIR"]}, {"filename": "flang/lib/Parser/unparse.cpp", "functions": ["Before", "Unparse"]}]}
{"pr_number": 75738, "url": "https://github.com/llvm/llvm-project/pull/75738", "title": "[mlir][tosa] Move lowering of `tosa.transpose` to `tosa-to-linalg-named`", "body": "Currently, there exists a pattern lowering `tosa.transpose` to `linalg.generic` in `tosa-to-linalg`. This patch adds a pattern lowering `tosa.transpose` to `linalg.transpose` in `tosa-to-linalg-named`. Lowering to the named linalg Op has the advantage that following optimization passes can easily identify transposition without having to perform pattern matching on linalg.generic Ops. The `linalg.transpose` can simply be generalized to a `linalg.generic` in a second step.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Conversion/TosaToLinalg/TosaToLinalgNamed.cpp", "functions": ["failure", "success"]}, {"filename": "mlir/lib/Conversion/TosaToLinalg/TosaToLinalg.cpp", "functions": ["success"]}]}
{"pr_number": 76731, "url": "https://github.com/llvm/llvm-project/pull/76731", "title": "[DebugNames] Implement per-entry abbreviation support", "body": "(ignore the first commit, this depends on https://github.com/llvm/llvm-project/pull/76296)\r\n\r\n    Prior to this commit, the choice of forms to use in debug_names abbreviations\r\n    was made independently of entries themselves. For example, if we wanted entries\r\n    to have a \"IDX_compile_unit\", all entries needed to use the same form (e.g\r\n    data2) for such IDX, even if a specific entry could fit its IDX in a single byte\r\n    (e.g. data1).\r\n\r\n    This commit changes that by creating an `AbbreviationContents` data structure to\r\n    handle the encoding of abbreviations on a per-entry basis. We don't need the\r\n    full generality of abbreviations from the debug_info section -- abbreviations in\r\n    debug_names are more limited --, but this commit is desirable for two reasons:\r\n\r\n    1. Upcoming patches may want to use different forms for different entries (there\r\n    is ongoing work for IDX_parent that will benefit from this)\r\n    2. This allows for space savings by using smaller forms.\r\n\r\n    A few tests had to be updated, as this commit changes the abbreviation number\r\n    (and therefore the order in which abbreviations are printed). Notably, this\r\n    _decreases_ the abbreviation number used, which may lead to smaller ULEB\r\n    encodings. A future patch should just renumber these to start with 1.\r\n\r\n", "feature_layers": ["ir"], "feature_directives": ["for", "single"], "files_changed": [{"filename": "llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp", "functions": ["getUniqueCode", "getHashValue", "getEmptyKey", "isEqual", "getFormForIndex", "AbbreviationContents", "toDwarfDataForm", "getTagFromAbbreviationTag", "Tag", "getTombstoneKey"]}]}
{"pr_number": 76530, "url": "https://github.com/llvm/llvm-project/pull/76530", "title": "[mlir][gpu] Add subgroup_reduce to shuffle lowering", "body": "This supports both the scalar and the vector multi-reduction cases.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/GPU/Transforms/SubgroupReduceLowering.cpp", "functions": ["success", "OpRewritePattern"]}, {"filename": "mlir/lib/Dialect/GPU/Transforms/Utils.cpp", "functions": ["convertReductionKind"]}, {"filename": "mlir/test/lib/Dialect/GPU/TestGpuRewrite.cpp", "functions": ["PassWrapper"]}]}
{"pr_number": 76081, "url": "https://github.com/llvm/llvm-project/pull/76081", "title": "[mlir] Add inferContractionDims util for indexing map inputs", "body": "This PR adds a util function to infer contraction dimensions given only the indexing maps of a linalg operation.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Linalg/IR/LinalgInterfaces.cpp", "functions": ["failure", "iterators", "inferContractionDimsImpl"]}]}
{"pr_number": 76758, "url": "https://github.com/llvm/llvm-project/pull/76758", "title": "[mlir][sparse] recognize NVidia 2:4 type for matmul", "body": "This removes the temporary DENSE24 attribute and replaces it with proper recognition of dense to 24 conversion. The compressionh will be performed on the device prior to performing the matrix mult. Note that we no longer need to start with the linalg version, we can lift this to the proper named linalg op. Also renames some files into more consistent names.", "feature_layers": ["parse", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/Transforms/SparseGPUCodegen.cpp", "functions": ["isAdmissible24", "isConversionInto24", "isDenseTensor"]}]}
{"pr_number": 72440, "url": "https://github.com/llvm/llvm-project/pull/72440", "title": " [Libomptarget] Fix RPC-based malloc on NVPTX ", "body": "Summary:\r\nThe device allocator on NVPTX architectures is enqueued to a stream that\r\nthe kernel is potentially executing on. This can lead to deadlocks as\r\nthe kernel will not proceed until the allocation is complete and the\r\nallocation will not proceed until the kernel is complete. CUDA 11.2\r\nintroduced async allocations that we can manually place on separate\r\nstreams to combat this. This patch makes a new allocation type that's\r\nguaranteed to be non-blocking so it will actually make progress, only\r\nNvidia needs to care about this as the others are not blocking in this\r\nway by default.\r\n\r\nI had originally tried to make the `alloc` and `free` methods take a\r\n`__tgt_async_info`. However, I observed that with the large volume of\r\nstreams being created by a parallel test it quickly locked up the system\r\nas presumably too many streams were being created. This implementation\r\nnot just creates a new stream and immediately destroys it. This\r\nobviously isn't very fast, but it at least gets the cases to stop\r\ndeadlocking for now.", "feature_layers": ["ast"], "feature_directives": ["parallel", "for", "target"], "files_changed": [{"filename": "openmp/libomptarget/plugins-nextgen/cuda/src/rtl.cpp", "functions": ["cuMemAllocAsync", "cuMemFreeAsync"]}]}
{"pr_number": 76179, "url": "https://github.com/llvm/llvm-project/pull/76179", "title": "[mlir][mesh] Add resharding spmdization on a 1D device mesh", "body": "The current implementation supports only sharding of tensor axes that have size divisible by the mesh axis size.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/Mesh/IR/MeshOps.cpp", "functions": ["failure", "success", "isUnique", "emitError"]}, {"filename": "mlir/lib/Dialect/Mesh/Transforms/Spmdization.cpp", "functions": ["resShapeArr", "shardDimension", "ceilDiv", "sourceShardingPartialAxesSet", "dynamicOffsets", "shardCount", "staticOffsets", "implicitLocOpBuilder", "reshardingRegisterDependentDialects", "unshardDimension", "targetShardingPartialAxesSet"]}, {"filename": "mlir/test/lib/Dialect/Mesh/TestReshardingSpmdization.cpp", "functions": ["runOnOperation", "success", "getArgument", "registerTestMeshReshardingSpmdizationPass", "signalPassFailure", "patterns", "failure", "builder", "getDependentDialects", "getDescription"]}, {"filename": "mlir/tools/mlir-opt/mlir-opt.cpp", "functions": ["registerTestMeshReshardingSpmdizationPass"]}]}
{"pr_number": 74786, "url": "https://github.com/llvm/llvm-project/pull/74786", "title": "Make only one function that needs to be implemented when searching for types", "body": "This patch revives the effort to get this Phabricator patch into upstream:\r\n\r\nhttps://reviews.llvm.org/D137900\r\n\r\nThis patch was accepted before in Phabricator but I found some -gsimple-template-names issues that are fixed in this patch.\r\n\r\nA fixed up version of the description from the original patch starts now.\r\n\r\nThis patch started off trying to fix Module::FindFirstType() as it sometimes didn't work. The issue was the SymbolFile plug-ins didn't do any filtering of the matching types they produced, and they only looked up types using the type basename. This means if you have two types with the same basename, your type lookup can fail when only looking up a single type. We would ask the Module::FindFirstType to lookup \"Foo::Bar\" and it would ask the symbol file to find only 1 type matching the basename \"Bar\", and then we would filter out any matches that didn't match \"Foo::Bar\". So if the SymbolFile found \"Foo::Bar\" first, then it would work, but if it found \"Baz::Bar\" first, it would return only that type and it would be filtered out.\r\n\r\nDiscovering this issue lead me to think of the patch Alex Langford did a few months ago that was done for finding functions, where he allowed SymbolFile objects to make sure something fully matched before parsing the debug information into an AST type and other LLDB types. So this patch aimed to allow type lookups to also be much more efficient.\r\n\r\nAs LLDB has been developed over the years, we added more ways to to type lookups. These functions have lots of arguments. This patch aims to make one API that needs to be implemented that serves all previous lookups:\r\n\r\n- Find a single type\r\n- Find all types\r\n- Find types in a namespace\r\n\r\nThis patch introduces a `TypeQuery` class that contains all of the state needed to perform the lookup which is powerful enough to perform all of the type searches that used to be in our API. It contain a vector of CompilerContext objects that can fully or partially specify the lookup that needs to take place.\r\n\r\nIf you just want to lookup all types with a matching basename, regardless of the containing context, you can specify just a single CompilerContext entry that has a name and a CompilerContextKind mask of CompilerContextKind::AnyType.\r\n\r\nOr you can fully specify the exact context to use when doing lookups like: CompilerContextKind::Namespace \"std\"\r\nCompilerContextKind::Class \"foo\"\r\nCompilerContextKind::Typedef \"size_type\"\r\n\r\nThis change expands on the clang modules code that already used a vector<CompilerContext> items, but it modifies it to work with expression type lookups which have contexts, or user lookups where users query for types. The clang modules type lookup is still an option that can be enabled on the `TypeQuery` objects.\r\n\r\nThis mirrors the most recent addition of type lookups that took a vector<CompilerContext> that allowed lookups to happen for the expression parser in certain places.\r\n\r\nPrior to this we had the following APIs in Module:\r\n\r\n```\r\nvoid\r\nModule::FindTypes(ConstString type_name, bool exact_match, size_t max_matches,\r\n                  llvm::DenseSet<lldb_private::SymbolFile *> &searched_symbol_files,\r\n                  TypeList &types);\r\n\r\nvoid\r\nModule::FindTypes(llvm::ArrayRef<CompilerContext> pattern, LanguageSet languages,\r\n                  llvm::DenseSet<lldb_private::SymbolFile *> &searched_symbol_files,\r\n                  TypeMap &types);\r\n\r\nvoid Module::FindTypesInNamespace(ConstString type_name,\r\n                                  const CompilerDeclContext &parent_decl_ctx,\r\n                                  size_t max_matches, TypeList &type_list);\r\n```\r\n\r\nThe new Module API is much simpler. It gets rid of all three above functions and replaces them with:\r\n\r\n```\r\nvoid FindTypes(const TypeQuery &query, TypeResults &results);\r\n```\r\nThe `TypeQuery` class contains all of the needed settings:\r\n\r\n- The vector<CompilerContext> that allow efficient lookups in the symbol file classes since they can look at basename matches only realize fully matching types. Before this any basename that matched was fully realized only to be removed later by code outside of the SymbolFile layer which could cause many types to be realized when they didn't need to.\r\n- If the lookup is exact or not. If not exact, then the compiler context must match the bottom most items that match the compiler context, otherwise it must match exactly\r\n- If the compiler context match is for clang modules or not. Clang modules matches include a Module compiler context kind that allows types to be matched only from certain modules and these matches are not needed when d oing user type lookups.\r\n- An optional list of languages to use to limit the search to only certain languages\r\n\r\nThe `TypeResults` object contains all state required to do the lookup and store the results:\r\n- The max number of matches\r\n- The set of SymbolFile objects that have already been searched\r\n- The matching type list for any matches that are found\r\n\r\nThe benefits of this approach are:\r\n- Simpler API, and only one API to implement in SymbolFile classes\r\n- Replaces the FindTypesInNamespace that used a CompilerDeclContext as a way to limit the search, but this only worked if the TypeSystem matched the current symbol file's type system, so you couldn't use it to lookup a type in another module\r\n- Fixes a serious bug in our FindFirstType functions where if we were searching for \"foo::bar\", and we found a \"baz::bar\" first, the basename would match and we would only fetch 1 type using the basename, only to drop it from the matching list and returning no results", "feature_layers": ["parse", "ir", "ast", "parser"], "feature_directives": ["for", "single"], "files_changed": [{"filename": "lldb/source/API/SBModule.cpp", "functions": ["SBType", "query", "name", "type_sp"]}, {"filename": "lldb/source/API/SBTarget.cpp", "functions": ["SBType", "query", "type_sp", "module_sp"]}, {"filename": "lldb/source/Commands/CommandObjectMemory.cpp", "functions": ["query", "type_sp"]}, {"filename": "lldb/source/Commands/CommandObjectTarget.cpp", "functions": ["query", "name"]}, {"filename": "lldb/source/Core/Module.cpp", "functions": ["type_basename_const_str", "TypeSP"]}, {"filename": "lldb/source/DataFormatters/TypeFormat.cpp", "functions": ["query"]}, {"filename": "lldb/source/Plugins/ExpressionParser/Clang/ClangASTSource.cpp", "functions": ["query", "name", "clang_type", "copied_clang_type"]}, {"filename": "lldb/source/Plugins/LanguageRuntime/CPlusPlus/ItaniumABI/ItaniumABILanguageRuntime.cpp", "functions": ["const_lookup_name", "query"]}, {"filename": "lldb/source/Plugins/LanguageRuntime/ObjC/ObjCLanguageRuntime.cpp", "functions": ["query", "type_sp"]}, {"filename": "lldb/source/Plugins/SymbolFile/DWARF/DWARFASTParserClang.cpp", "functions": ["TypeSP"]}, {"filename": "lldb/source/Plugins/SymbolFile/DWARF/SymbolFileDWARF.cpp", "functions": ["UpdateCompilerContextForSimpleTemplateNames", "guard", "die_query", "query_simple"]}, {"filename": "lldb/source/Plugins/SymbolFile/NativePDB/SymbolFileNativePDB.cpp", "functions": ["guard", "type_match"]}, {"filename": "lldb/source/Plugins/SymbolFile/PDB/SymbolFilePDB.cpp", "functions": ["guard", "type_match"]}, {"filename": "lldb/source/Plugins/TypeSystem/Clang/TypeSystemClang.cpp", "functions": ["if"]}, {"filename": "lldb/source/Symbol/Type.cpp", "functions": ["ConvertTypeClass", "ConstString", "query", "m_options", "CompilerType", "m_context"]}, {"filename": "lldb/source/Symbol/TypeMap.cpp", "functions": ["TypeSP"]}, {"filename": "lldb/source/Target/Language.cpp", "functions": ["cs_key", "query"]}, {"filename": "lldb/test/API/functionalities/type_find_first/main.cpp", "functions": ["main"]}, {"filename": "lldb/tools/lldb-test/lldb-test.cpp", "functions": ["query", "parseCompilerContext"]}]}
{"pr_number": 72340, "url": "https://github.com/llvm/llvm-project/pull/72340", "title": "[RISCV][ISel] Combine scalable vector add/sub/mul with zero/sign extension", "body": "This PR mainly aims at resolving the below missed-optimization case,  while it could also be considered as an extension of the previous patch https://reviews.llvm.org/D133739?id=\r\n\r\n## Missed-Optimization Case\r\nCompiler Explorer: https://godbolt.org/z/GzWzP7Pfh\r\n### Source Code: \r\n```\r\ndefine <vscale x 2 x i16> @multiple_users(ptr  %x, ptr  %y, ptr %z) {\r\n  %a = load <vscale x 2 x i8>, ptr %x\r\n  %b = load <vscale x 2 x i8>, ptr %y\r\n  %b2 = load <vscale x 2 x i8>, ptr %z\r\n  %c = sext <vscale x 2 x i8> %a to <vscale x 2 x i16>\r\n  %d = sext <vscale x 2 x i8> %b to <vscale x 2 x i16>\r\n  %d2 = sext <vscale x 2 x i8> %b2 to <vscale x 2 x i16>\r\n  %e = mul <vscale x 2 x i16> %c, %d\r\n  %f = add <vscale x 2 x i16> %c, %d2\r\n  %g = sub <vscale x 2 x i16> %c, %d2\r\n  %h = or <vscale x 2 x i16> %e, %f\r\n  %i = or <vscale x 2 x i16> %h, %g\r\n  ret <vscale x 2 x i16> %i\r\n}\r\n```\r\n### Before This Patch\r\n```\r\n# %bb.0:\r\n        vsetvli a3, zero, e16, mf2, ta, ma\r\n        vle8.v  v8, (a0)\r\n        vle8.v  v9, (a1)\r\n        vle8.v  v10, (a2)\r\n        svf2       v11, v8\r\n        vsext.vf2       v8, v9\r\n        vsext.vf2       v9, v10\r\n        vmul.vv v8, v11, v8\r\n        vadd.vv v10, v11, v9\r\n        vsub.vv v9, v11, v9\r\n        vor.vv  v8, v8, v10\r\n        vor.vv  v8, v8, v9\r\n        ret\r\n```\r\n###  After This Patch \r\n```\r\n# %bb.0:\r\n\tvsetvli\ta3, zero, e8, mf4, ta, ma\r\n\tvle8.v\tv8, (a0)\r\n\tvle8.v\tv9, (a1)\r\n\tvle8.v\tv10, (a2)\r\n\tvwmul.vv\tv11, v8, v9\r\n\tvwadd.vv\tv9, v8, v10\r\n\tvwsub.vv\tv12, v8, v10\r\n\tvsetvli\tzero, zero, e16, mf2, ta, ma\r\n\tvor.vv\tv8, v11, v9\r\n\tvor.vv\tv8, v8, v12\r\n\tret\r\n```\r\nWe can see Add/Sub/Mul are combined with the Sign Extension.\r\n\r\n## Relation to the Patch D133739\r\nThe patch D133739 introduced an optimization for folding `ADD_VL`/ `SUB_VL` / `MUL_V` with `VSEXT_VL` / `VZEXT_VL`. However, the patch did not consider the case of non-fixed length vector case, thus this PR could also be considered as an extension for the  D133739. \r\n\r\nFurthermore,  in the current `SelectionDAG`,  we represent scalable vector add (or any binary operator) as a normal `ADD` operation. It might be better to use an Opcode like `ADD_VL`, which needs further conversation and decision.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVISelLowering.cpp", "functions": ["combineBinOp_VLToVWBinOp_VL"]}]}
{"pr_number": 74929, "url": "https://github.com/llvm/llvm-project/pull/74929", "title": "[GlobalISel][AArch64] Tail call libcalls.", "body": "This tries to allow libcalls to be tail called, using a similar method to DAG where the type is checked to make sure they match, and if so the backend, through lowerCall checks that the tailcall is valid for all arguments.       ", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp", "functions": ["createLibcall"]}, {"filename": "llvm/unittests/CodeGen/GlobalISel/LegalizerHelperTest.cpp", "functions": ["DummyLocObserver"]}]}
{"pr_number": 75310, "url": "https://github.com/llvm/llvm-project/pull/75310", "title": "[mlir][EmitC] Disallow string attributes as initial values", "body": "", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/EmitC/IR/EmitC.cpp", "functions": ["failure", "emitOpError", "success", "verifyInitializationAttribute"]}]}
{"pr_number": 76729, "url": "https://github.com/llvm/llvm-project/pull/76729", "title": "[coroutines] Do not check coroutine wrappers for skipped function bodies", "body": "Without function bodies, we cannot tell whether a function is a coroutine or not.\r\nThe analysis of coroutine wrappers is not useful when this information is not available.\r\n\r\nWe therefore now skip this analysis for skipped function bodies.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang-tools-extra/clangd/unittests/DiagnosticsTests.cpp", "functions": ["final_suspend", "unhandled_exception", "return_value", "from_promise", "foo_coro", "await_suspend", "address", "initial_suspend", "from_address", "await_ready", "get_return_object", "await_resume"]}]}
{"pr_number": 75197, "url": "https://github.com/llvm/llvm-project/pull/75197", "title": "[AMDGPU] Add VDSDIR instructions for GFX12", "body": "", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp", "functions": ["isImmTy", "isWaitVAVDst", "isWaitVMVSrc"]}]}
{"pr_number": 76816, "url": "https://github.com/llvm/llvm-project/pull/76816", "title": "[mlir] fix Operation::getDiscardableAttrs in absence of properties", "body": "When properties are not enabled in an operation, inherent attributes are stored in the common dictionary with discardable attributes. However, `getDiscardableAttrs` and `getDiscardableAttrDictionary` were returning the entire dictionary, making the caller mistakenly believe that all inherent attributes are discardable. Fix this by filtering out attributes whose names are registered with the operation, i.e., inherent attributes. This requires an API change so `getDiscardableAttrs` returns a filter range.", "feature_layers": ["ir"], "feature_directives": ["requires"], "files_changed": [{"filename": "mlir/unittests/IR/OpPropertiesTest.cpp", "functions": ["getOperationName", "getAttributeNames", "config", "ArrayRef"]}]}
{"pr_number": 76765, "url": "https://github.com/llvm/llvm-project/pull/76765", "title": "[coroutines][DPValue] Update DILocation in DPValue for hoisted dbg.declare", "body": "Follow up #75402 to cover DPValue", "feature_layers": [], "feature_directives": ["for", "declare"], "files_changed": [{"filename": "llvm/lib/Transforms/Coroutines/CoroFrame.cpp", "functions": ["if"]}]}
{"pr_number": 76513, "url": "https://github.com/llvm/llvm-project/pull/76513", "title": "[libc] Lock the output stream for the 'puts' call", "body": "Summary:\nThe `puts` function consists of an initial write and then another write\nto append the newline. When executing code in parallel, it is possible\nfor these writes to becomes disjointed. This code adds an explicit lock\ncall to ensure that the string is always appended by the newline as the\nusers expects.\n\nWasn't sure if this required a test as it would be difficult since\nreproducing it would be flaky.\n", "feature_layers": ["ir"], "feature_directives": ["parallel", "for"], "files_changed": [{"filename": "libc/src/stdio/generic/puts.cpp", "functions": ["lock"]}]}
{"pr_number": 76607, "url": "https://github.com/llvm/llvm-project/pull/76607", "title": "[mlir][tensor] Add a pattern to simplify tensor.unpack to collpase shape", "body": "", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/Tensor/Transforms/PackAndUnpackPatterns.cpp", "functions": ["failure", "success"]}]}
{"pr_number": 75421, "url": "https://github.com/llvm/llvm-project/pull/75421", "title": "[mlir][Pass] Enable the option for reproducer generation without crashing", "body": "This PR adds API `makeReproducer` and cl::opt flag `--mlir-generate-reproducer=<filename>` in order to allow for mlir reproducer dumps even when the pipeline doesn't crash.\r\n\r\nThis PR also decouples the code that handles generation of an MLIR reproducer from the crash recovery portion. The purpose is to allow for generating reproducers outside of the context of a compiler crash.\r\n\r\nThis will be useful for frameworks and runtimes that use MLIR where it is needed to reproduce the pipeline behavior for reasons outside of diagnosing crashes. An example is for diagnosing performance issues using offline tools, where being able to dump the reproducer from a runtime compiler would be helpful.", "feature_layers": ["runtime", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Pass/Pass.cpp", "functions": ["getOpAnchorName"]}, {"filename": "mlir/lib/Pass/PassCrashRecovery.cpp", "functions": ["passOS"]}]}
{"pr_number": 69927, "url": "https://github.com/llvm/llvm-project/pull/69927", "title": "[mlir] Add config for PDL", "body": "Make it so that PDL in pattern rewrites can be optionally disabled.\r\n\r\nPDL is still enabled by default and not optional bazel. So this should be a NOP for most folks, while enabling other to disable.\r\n\r\nThis is piped through mlir-tblgen invocation and that could be changed/avoided by splitting up the passes file instead.\r\n\r\nThis only works with tests disabled. With tests enabled this still compiles but tests fail as there is no lit config to disable tests that depend on PDL rewrites yet.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/include/mlir/IR/PDLPatternMatch.h.inc", "functions": ["success", "getKindOf", "bool", "getModule", "failure", "processAsArg", "getTypeID", "clear", "dyn_cast", "classof", "processResults", "addConfig", "registerRewriteFunction", "cast", "takeConstraintFunctions", "getConfigID", "print", "storage", "mergeIn", "errorFn", "notifyRewriteEnd", "PDLPatternModule", "getKind", "attachConfigToPatterns", "pdlModule", "takeRewriteFunctions", "push_back", "isa", "takeConfigs", "value", "notifyRewriteBegin"]}, {"filename": "mlir/tools/mlir-opt/mlir-opt.cpp", "functions": ["registerTestTransformDialectExtension"]}]}
{"pr_number": 76198, "url": "https://github.com/llvm/llvm-project/pull/76198", "title": "[WebAssembly][Object]Use file offset as function symbol address for linked files", "body": "WebAssembly doesn't have a single virtual memory space the way other object formats or architectures do, so \"addresses\" mean different things depending on the context.\r\nFunction symbol addresses in object files are offsets from the start of the code section. This is good for linking and relocation. However when dealing with linked binaries, offsets from the start of the file/module are more often used (e.g. for stack traces in browsers), and are more useful for use cases like binary size attribution. This PR changes Object to use the file offset instead of the section offset for function symbols, but only for linked (non-DSO) files.\r\n\r\nThis implements item number 4 from #76107 ", "feature_layers": ["ir"], "feature_directives": ["for", "single"], "files_changed": [{"filename": "llvm/lib/Object/WasmObjectFile.cpp", "functions": ["getDefinedFunction", "getSymbolValue"]}]}
{"pr_number": 76847, "url": "https://github.com/llvm/llvm-project/pull/76847", "title": "[SelectionDAG][X86] Use disjoint flag in SelectionDAG::isADDLike.", "body": "Keep the haveNoCommonBitsSet check because we haven't started infering the flag yet.\r\n\r\nI've added tests for two transforms, but these are not the only transforms that use isADDLike.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp", "functions": ["haveNoCommonBitsSet"]}]}
{"pr_number": 76854, "url": "https://github.com/llvm/llvm-project/pull/76854", "title": "Warn inf nan fast fp", "body": "", "feature_layers": ["ast"], "feature_directives": [], "files_changed": [{"filename": "clang/test/CodeGenCXX/fixed-point-mangle.cpp", "functions": ["func", "func2"]}]}
{"pr_number": 70244, "url": "https://github.com/llvm/llvm-project/pull/70244", "title": "[clang] Add support for -fcx-limited-range, #pragma CX_LIMITED_RANGE and -fcx-fortran-rules. ", "body": "This patch adds the #pragma CX_LIMITED_RANGE defined in the C specification.\r\nIt also adds the options -f[no]cx-limited-range and -f[no]cx-fortran-rules.\r\n-fcx-limited-range enables algebraic formulas for complex multiplication and division. This option is enabled with -ffast-math. \r\n-fcx-fortran-rules enables algebraic formulas for complex multiplication and enables Smith\u2019s algorithm for complex division (SMITH, R. L. Algorithm 116: Complex division. Commun. ACM 5, 8 (1962)).  \r\n", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CodeGenCXX/fixed-point-mangle.cpp", "functions": ["func", "func2"]}, {"filename": "clang/lib/CodeGen/CGExprComplex.cpp", "functions": ["ComplexPairTy"]}, {"filename": "clang/lib/Parse/ParseStmt.cpp", "functions": ["StmtError"]}, {"filename": "clang/test/CodeGen/cx-full-range.c", "functions": ["mul", "pragma_off_mul"]}, {"filename": "clang/test/CodeGen/pragma-cx-limited-range.c", "functions": ["no_pragma_mul", "no_pragma_div"]}, {"filename": "clang/test/CodeGenCXX/cx-limited-range.c", "functions": ["f1", "f2"]}, {"filename": "clang/test/CodeGen/cx-complex-range.c", "functions": ["div", "mul"]}, {"filename": "clang/test/CodeGen/cx-limited-range.c", "functions": ["f1", "f2"]}, {"filename": "llvm/lib/Target/RISCV/GISel/RISCVCallLowering.cpp", "functions": ["MemTy"]}, {"filename": "llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp", "functions": ["OffsetVal"]}, {"filename": "lldb/source/Plugins/InstrumentationRuntime/ASan/InstrumentationRuntimeASan.cpp", "functions": ["__asan_report_present", "__asan_get_report_access_type", "symbol_name", "__asan_get_report_access_size"]}, {"filename": "lldb/source/Plugins/InstrumentationRuntime/ASanLibsanitizers/InstrumentationRuntimeASanLibsanitizers.cpp", "functions": ["InstrumentationRuntimeASanLibsanitizers"]}, {"filename": "lldb/source/Plugins/InstrumentationRuntime/Utility/ReportRetriever.cpp", "functions": ["__asan_report_present", "__asan_get_report_access_type", "__asan_get_report_access_size"]}, {"filename": "mlir/lib/Dialect/SparseTensor/IR/SparseTensorDialect.cpp", "functions": ["failure", "verifySparsifierGetterSetter", "success"]}, {"filename": "mlir/lib/Dialect/SparseTensor/Transforms/Sparsification.cpp", "functions": ["failure"]}, {"filename": "lldb/source/Plugins/SymbolFile/DWARF/SymbolFileDWARFDwo.cpp", "functions": ["GetBaseSymbolFile"]}, {"filename": "llvm/lib/Target/RISCV/RISCVPostRAExpandPseudoInsts.cpp", "functions": ["expandMovImm", "getPassName", "expandMBB", "runOnMachineFunction", "RISCVPostRAExpandPseudo"]}, {"filename": "llvm/utils/TableGen/CompressInstEmitter.cpp", "functions": ["run", "SourceInst", "emitCompressInstEmitter"]}, {"filename": "clang/lib/CodeGen/CGBuiltin.cpp", "functions": ["EmitAMDGCNBallotForExec"]}, {"filename": "clang-tools-extra/clang-tidy/bugprone/DanglingHandleCheck.cpp", "functions": ["handleFrom"]}, {"filename": "clang-tools-extra/clang-tidy/cppcoreguidelines/ProTypeConstCastCheck.cpp", "functions": ["hasConstQualifier", "ClangTidyCheck", "hasVolatileQualifier"]}, {"filename": "clang-tools-extra/test/clang-tidy/checkers/cppcoreguidelines/pro-type-const-cast.cpp", "functions": ["f"]}, {"filename": "clang-tools-extra/test/clang-tidy/checkers/cppcoreguidelines/narrowing-conversions-ignoreconversionfromtypes-option.cpp", "functions": ["test_ignore_builtin_type_pr58809"]}, {"filename": "clang-tools-extra/clang-tidy/cppcoreguidelines/PreferMemberInitializerCheck.cpp", "functions": ["Insertion", "getLangOpts"]}, {"filename": "llvm/lib/Support/Caching.cpp", "functions": ["errorCodeToError", "createStringError"]}, {"filename": "clang/unittests/Tooling/RecursiveASTVisitorTests/BitfieldInitializer.cpp", "functions": ["VisitIntegerLiteral"]}, {"filename": "llvm/lib/Target/AMDGPU/SIShrinkInstructions.cpp", "functions": ["if"]}, {"filename": "lldb/source/Target/RegisterFlags.cpp", "functions": ["escape_strm", "m_name"]}, {"filename": "llvm/lib/Target/AArch64/AArch64ISelLowering.cpp", "functions": ["SDValue", "isHalvingTruncateOfLegalScalableType"]}, {"filename": "mlir/lib/Dialect/Affine/IR/AffineOps.cpp", "functions": ["flattener"]}, {"filename": "mlir/lib/IR/AffineExpr.cpp", "functions": ["flattener"]}, {"filename": "llvm/lib/IR/DataLayout.cpp", "functions": ["reportError"]}, {"filename": "llvm/lib/Target/AMDGPU/SIInstrInfo.cpp", "functions": ["if", "canRemat"]}, {"filename": "clang/lib/Sema/SemaOpenMP.cpp", "functions": ["getOpenMPDirectiveName"]}, {"filename": "clang/test/OpenMP/loop_bind_messages.cpp", "functions": ["parallel_targetfor_with_loop_bind", "teams_targetfor_with_loop_bind", "loop_bind_AND_loop_bind", "parallel_for_with_loop_teams_bind", "parallel_nowait", "orphan_loop_parallel_bind", "orphan_loop_teams_bind", "parallel_with_sections_loop", "parallel_for_with_nothing", "parallel_for_AND_loop_bind", "orphan_loop_no_bind", "teams_with_loop_thread_bind", "orphan_loop_with_bind", "teams_loop_distribute", "parallel_targetparallel_with_loop", "teams_targetteams_with_loop"]}, {"filename": "mlir/lib/Dialect/ArmSVE/Transforms/LegalizeVectorStorage.cpp", "functions": ["target", "runOnOperation", "getSVELegalizedMemref", "success", "isSVEMaskType", "widenScalableMaskTypeToSvbool", "patterns", "failure", "kSVELegalizerTag"]}, {"filename": "clang/test/CodeGen/LoongArch/abi-lp64d-empty-structs.c", "functions": ["test_s10", "test_s15", "test_s13", "test_s14", "test_s11", "test_s16", "test_s12"]}, {"filename": "llvm/lib/Target/M68k/MCTargetDesc/M68kMCCodeEmitter.cpp", "functions": ["Scratch"]}, {"filename": "llvm/utils/TableGen/VarLenCodeEmitterGen.cpp", "functions": ["RS"]}, {"filename": "llvm/lib/CodeGen/ExpandVectorPredication.cpp", "functions": ["isSafeToSpeculativelyExecuteWithOpcode"]}, {"filename": "flang/lib/Optimizer/Builder/IntrinsicCall.cpp", "functions": ["if", "isCoarrayIntrinsic"]}, {"filename": "clang/test/AST/Interp/arrays.cpp", "functions": ["foo2", "assert", "foo", "F"]}, {"filename": "llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp", "functions": ["any_of", "if", "VecMask", "add"]}, {"filename": "libcxx/test/libcxx/odr_signature.exceptions.sh.cpp", "functions": ["tu2", "main", "tu1", "f"]}, {"filename": "libcxx/test/libcxx/odr_signature.hardening.sh.cpp", "functions": ["tu4", "main", "tu1", "f", "tu2", "tu3"]}, {"filename": "clang/test/Analysis/loop-widening-notes.cpp", "functions": ["test_for_range_loop"]}, {"filename": "clang/lib/AST/Interp/Descriptor.cpp", "functions": ["Source"]}, {"filename": "clang/lib/AST/Interp/Interp.cpp", "functions": ["CheckDummy"]}, {"filename": "clang/lib/Driver/ToolChains/Clang.cpp", "functions": ["EnumComplexRangeToStr"]}]}
{"pr_number": 68820, "url": "https://github.com/llvm/llvm-project/pull/68820", "title": "[clang] Add support for -fcx-limited-range and #pragma CX_LIMITED_RANGE.", "body": "This patch adds the #pragma CX_LIMITED_RANGE defined in the C specification. \r\n\r\nIt also adds the options -f[no]cx-limited-range and -f[no]cx-fortran-rules. \r\nTheir behavior is like the gcc\u2019s command line options.\r\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/CodeGen/CGExprComplex.cpp", "functions": ["ComplexPairTy"]}, {"filename": "clang/lib/Parse/ParseStmt.cpp", "functions": ["StmtError"]}, {"filename": "clang/test/CodeGen/cx-full-range.c", "functions": ["mul", "pragma_off_mul"]}, {"filename": "clang/test/CodeGen/pragma-cx-limited-range.c", "functions": ["no_pragma_mul", "no_pragma_div"]}, {"filename": "clang/test/CodeGenCXX/cx-limited-range.c", "functions": ["f1", "f2"]}, {"filename": "clang/test/CodeGen/cx-complex-range.c", "functions": ["div", "mul"]}, {"filename": "clang/test/CodeGen/cx-limited-range.c", "functions": ["f1", "f2"]}]}
{"pr_number": 76755, "url": "https://github.com/llvm/llvm-project/pull/76755", "title": "[mlir][GPU] Expand LLVM function attribute copies", "body": "Expand the copying of attributes on GPU kernel arguments during LLVM lowering.\r\n\r\nSupport copying attributes from values that are already LLVM pointers.\r\n\r\nSupport copying attributes, like `noundef`, that aren't specific to (the pointer parts of) arguments.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Conversion/GPUCommon/GPUOpsLowering.cpp", "functions": ["NamedAttrList"]}]}
{"pr_number": 76523, "url": "https://github.com/llvm/llvm-project/pull/76523", "title": "[Clang] Fix ICE where C++ Template Instantiation failed to handle attributed lambdas", "body": "This PR is proposing a fix for https://github.com/llvm/llvm-project/issues/76521.\r\n\r\nClang used to assume that during template instantiation, Lambda expressions can only have `FunctionProtoTypeLoc`s. However, this is not true for certain attributes like `__attribute__((pcs(\"aapcs-vfp\")))`, whose interpretation happens after template instantiation. This PR changes the transformation logic for lambdas. ", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/SemaCXX/template-instantiation.cpp", "functions": ["bar", "foo"]}]}
{"pr_number": 76522, "url": "https://github.com/llvm/llvm-project/pull/76522", "title": "AMDGPU: Fix packed 16-bit inline constants", "body": "Consistently treat packed 16-bit operands as 32-bit values, because that's really what they are. The attempt to treat them differently was ultimately incorrect and lead to miscompiles, e.g. when using non-splat constants such as (1, 0) as operands.\r\n\r\nRecognize 32-bit float constants for i/u16 instructions. This is a bit odd conceptually, but it matches HW behavior and SP3.\r\n\r\nRemove isFoldableLiteralV216; there was too much magic in the dependency between it and its use in SIFoldOperands. Instead, we now simply rely on checking whether a constant is an inline constant, and trying a bunch of permutations of the low and high halves. This is more obviously correct and leads to some new cases where inline constants are used as shown by tests.\r\n\r\nMove the logic for switching packed add vs. sub into SIFoldOperands. This has two benefits: all logic that optimizes for inline constants in packed math is now in one place; and it applies to both SelectionDAG and GISel paths.\r\n\r\nDisable the use of opsel with v_dot* instructions on gfx11. They are documented to ignore opsel on src0 and src1. It may be interesting to re-enable to use of opsel on src2 as a future optimization.\r\n\r\nA similar \"proper\" fix of what inline constants mean could potentially be applied to unpacked 16-bit ops. However, it's less clear what the benefit would be, and there are surely places where we'd have to carefully audit whether values are properly sign- or zero-extended. It is best to keep such a change separate.\r\n\r\nFixes: Corruption in FSR 2.0 (latent bug exposed by an LLPC change)", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/MCTargetDesc/AMDGPUInstPrinter.cpp", "functions": ["if", "formatHex"]}, {"filename": "llvm/lib/Target/AMDGPU/MCTargetDesc/AMDGPUMCCodeEmitter.cpp", "functions": ["getLit16IntEncoding", "getLit32Encoding", "getLit16Encoding"]}, {"filename": "llvm/lib/Target/AMDGPU/SIFoldOperands.cpp", "functions": ["if", "tryFoldImmWithOpSel"]}, {"filename": "llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.cpp", "functions": ["getInlineEncodingV2F16", "isFoldableLiteralV216", "isInlinableLiteralV216", "getInlineEncodingV2I16", "getInlineEncodingV216", "isInlinableLiteralV2I16", "isInlinableIntLiteral", "isInlinableLiteralV2F16", "isInlinableIntLiteralV216"]}]}
{"pr_number": 76876, "url": "https://github.com/llvm/llvm-project/pull/76876", "title": "Revert \"[Clang][Sema] Diagnose unexpanded packs in the template argument lists of function template specializations\"", "body": "Reverts llvm/llvm-project#76677\r\n\r\nSee discussion here: https://github.com/llvm/llvm-project/pull/76677", "feature_layers": ["sema"], "feature_directives": [], "files_changed": [{"filename": "clang/lib/Sema/SemaDecl.cpp", "functions": ["SourceRange", "TemplateArgsPtr"]}, {"filename": "clang/test/CXX/temp/temp.decls/temp.variadic/p5.cpp", "functions": ["InnerFunction", "PrimaryFunction"]}]}
{"pr_number": 76830, "url": "https://github.com/llvm/llvm-project/pull/76830", "title": "[mlir][mesh] Use one type for mesh axis", "body": "Make all ops and attributes use the types MeshAxis and MeshAxesAttr instead of int16_t, int32_t, DenseI16ArrayAttr and DenseI32ArrayAttr.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Mesh/Interfaces/ShardingInterface.cpp", "functions": ["splitAxes"]}]}
{"pr_number": 75202, "url": "https://github.com/llvm/llvm-project/pull/75202", "title": "[SHT_LLVM_BB_ADDR_MAP][AsmPrinter] Implements PGOAnalysisMap emitting in AsmPrinter with tests.", "body": "Uses machine analyses to emit PGOAnalysisMap into the bb-addr-map ELF section. Implements filecheck tests to verify emitting new fields.\r\n\r\n## PR Series\r\n\r\nThe current code for PGOBBAddrMap to be upstreamed is split into five PRs:\r\n1. Object and ObjectYAML - https://github.com/llvm/llvm-project/pull/71750\r\n2. AsmPrinter - (this one) https://github.com/red1bluelost/llvm-project/tree/pgo-bb-addr-map--asm-printer\r\n3. llvm-readobj - https://github.com/red1bluelost/llvm-project/pull/2 or https://github.com/red1bluelost/llvm-project/tree/pgo-bb-addr-map--llvm-readobj\r\n4. llvm obj2yaml - https://github.com/red1bluelost/llvm-project/tree/pgo-bb-addr-map--llvm-obj2yaml\r\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp", "functions": ["if"]}]}
{"pr_number": 68648, "url": "https://github.com/llvm/llvm-project/pull/68648", "title": "[mlir][bufferization] Ownership-based deallocation: Allow manual (de)allocs", "body": "Add a new attribute `bufferization.manual_deallocation` that can be attached to allocation and deallocation ops. Buffers that are allocated with this attribute are assigned an ownership of \"false\". Such buffers can be deallocated manually (e.g., with `memref.dealloc`) if the deallocation op also has the attribute set. Previously, the ownership-based buffer deallocation pass used to reject IR with existing deallocation ops. This is no longer the case if such ops have this new attribute.\r\n\r\nThis change is useful for the sparse compiler, which currently deallocates the sparse tensor buffers by itself.", "feature_layers": ["parse", "ir"], "feature_directives": ["for", "allocate"], "files_changed": [{"filename": "mlir/lib/Dialect/Bufferization/IR/BufferizationDialect.cpp", "functions": ["success"]}, {"filename": "mlir/lib/Dialect/Bufferization/Transforms/OwnershipBasedBufferDeallocation.cpp", "functions": ["g"]}]}
{"pr_number": 76539, "url": "https://github.com/llvm/llvm-project/pull/76539", "title": "[mlir] Add `res()` method to `linalg::ContractionOpInterface`", "body": "In addition to `lhs()` and `rhs()` to return left and right operands, add `res()` to return the result value.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/unittests/Dialect/Linalg/LinalgInterfacesTest.cpp", "functions": ["b"]}]}
{"pr_number": 76692, "url": "https://github.com/llvm/llvm-project/pull/76692", "title": "[InstCombine] Refactor folding of commutative binops over select/phi/minmax", "body": "This patch cleans up the duplicate code for folding commutative binops over `select/phi/minmax`.\r\n\r\nRelated commits:\r\n+ select support: https://github.com/llvm/llvm-project/commit/88cc35b27e6c7966ab2463fa06d3dd970e88df64\r\n+ phi support: https://github.com/llvm/llvm-project/commit/8674a023bcacb677ce48b8831e2ae35b5aa2d8ef\r\n+ minmax support: https://github.com/llvm/llvm-project/commit/624973806c5644ccfa84805319b5852edb68d48d\r\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/InstCombine/InstructionCombining.cpp", "functions": ["matchSymmetricPhiNodesPair", "replaceInstUsesWith"]}]}
{"pr_number": 76865, "url": "https://github.com/llvm/llvm-project/pull/76865", "title": "[mlir][dataflow]Fix dense backward dataflow intraprocedural hook", "body": "The dataflow analysis framework within MLIR allows to customize the transfer function when a `call-like` operation is encuntered.  \r\n\r\nThe check to see if the analysis was executed in intraprocedural mode was executed after the check to see if the callee had the CallableOpInterface, and thus intraprocedural analyses would behave as interpocedural ones when performing indirect calls. \r\n\r\nThis commit fixes the issue by performing the check for intraprocedurality first.\r\n\r\nDense forward analyses were already behaving correctly. https://github.com/llvm/llvm-project/blob/main/mlir/lib/Analysis/DataFlow/DenseAnalysis.cpp#L63", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Analysis/DataFlow/DenseAnalysis.cpp", "functions": ["setToExitState"]}]}
{"pr_number": 76327, "url": "https://github.com/llvm/llvm-project/pull/76327", "title": "[clang-format] Add .clang-format-ignore for ignoring files", "body": "Closes #52975.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/tools/clang-format/ClangFormat.cpp", "functions": ["isIgnored"]}]}
{"pr_number": 74333, "url": "https://github.com/llvm/llvm-project/pull/74333", "title": "[VPlan] Initial modeling of runtime VF * UF as VPValue.", "body": "This patch starts initial modeling of runtime VF * UF in VPlan. Initially, introduce a dedicated RuntimeVFxUF VPValue, which is then populated during VPlan::prepareToExecute. Initially, the runtime VF * UF applies only to the main vector loop region. Once we extend the scope of VPlan in the future, we may want to associate different VFxUFs with different vector loop regions (e.g. the epilogue vector loop)\r\n\r\nThis allows explicitly parameterizing recipes that rely on the runtime VF * UF, like the canonical induction increment. At the moment, this mainly helps to avoid generating some duplicated calls to vscale with scalable vectors. It should also allow using EVL as induction increments explicitly in D99750. Referring to VF * UF is also needed in other places that we plan to migrate to VPlan, like the minimum trip count check during skeleton creation.\r\n\r\nThe first version creates the value for VF * UF directly in prepareToExecute to limit the scope of the patch. A follow-on patch will model VF * UF computation explicitly in VPlan using recipes.\r\n\r\nMoved from Phabricator (https://reviews.llvm.org/D157322)", "feature_layers": ["runtime", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Vectorize/VPlan.cpp", "functions": ["Builder"]}]}
{"pr_number": 74490, "url": "https://github.com/llvm/llvm-project/pull/74490", "title": "[Sema] When checking for constraint equivalence, do not calculate satisfaction", "body": "... and only look at equivalence of substituted expressions, not results of constraint satisfaction.\r\n\r\nFixes #74314.\r\n\r\nThere is already some existing machinery for that in `TemplateInstantiator` and `Sema` exposed separate functions for substituting expressions with intention to do that:\r\n- `Sema::SubstExpr` should not evaluate constraints.\r\n- `Sema::SubstConstraintExpr` should.\r\n\r\nHowever, both functions used to be equivalent. This commit changes the former to actually avoid calculating constraint satisfaction and uses it in the code path that matches definition and declaration.", "feature_layers": ["sema"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Sema/SemaTemplateInstantiate.cpp", "functions": ["new", "SubstExpr", "RebuildNestedRequirement"]}, {"filename": "clang/test/SemaTemplate/concepts-out-of-line-def.cpp", "functions": ["foo"]}]}
{"pr_number": 71191, "url": "https://github.com/llvm/llvm-project/pull/71191", "title": "[Clang][SME2] Add builtins for moving multi-vectors to/from ZA", "body": "Adds the following SME2 builtins:\r\n - svread_hor/ver,\r\n - svwrite_hor/ver,\r\n - svread_za64,\r\n - svwrite_za64\r\n\r\nSee https://github.com/ARM-software/acle/pull/217", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CodeGen/aarch64-sme2-intrinsics/acle_sme2_read.c", "functions": ["test_svread_za32_u32_vg1x2", "test_svread_za8_u8_vg1x2", "svread_za8_s8_vg1x4", "svread_za8_u8_vg1x2", "svread_za16_s16_vg1x4", "test_svread_za16_u16_vg1x4", "svread_za16_s16_vg1x2", "svread_za16_bf16_vg1x4", "test_svread_za32_u32_vg1x4", "test_svread_za8_s8_vg1x4", "test_svread_za32_s32_vg1x4", "svread_za16_f16_vg1x2", "svread_za16_bf16_vg1x2", "test_svread_za32_s32_vg1x2", "svread_za32_s32_vg1x2", "svread_za8_u8_vg1x4", "test_svread_za16_f16_vg1x4", "test_svread_za16_f16_vg1x2", "test_svread_za32_f32_vg1x2", "test_svread_za16_bf16_vg1x2", "test_svread_za16_s16_vg1x4", "svread_za16_u16_vg1x2", "svread_za32_u32_vg1x2", "svread_za32_u32_vg1x4", "test_svread_za8_s8_vg1x2", "test_svread_za16_bf16_vg1x4", "test_svread_za16_u16_vg1x2", "test_svread_za8_u8_vg1x4", "svread_za16_u16_vg1x4", "test_svread_za16_s16_vg1x2", "svread_za16_f16_vg1x4", "svread_za32_s32_vg1x4", "test_svread_za32_f32_vg1x4", "svread_za32_f32_vg1x4", "svread_za32_f32_vg1x2", "svread_za8_s8_vg1x2"]}, {"filename": "clang/test/CodeGen/aarch64-sme2-intrinsics/acle_sme2_write.c", "functions": ["test_svwrite_za8_s8_vg1x4", "test_svwrite_za16_bf16_vg1x4", "test_svwrite_za16_f16_vg1x4", "test_svwrite_za8_s8_vg1x2", "test_svwrite_za32_f32_vg1x2", "test_svwrite_za16_s16_vg1x2", "test_svwrite_za8_u8_vg1x2", "test_svwrite_za32_u32_vg1x2", "test_svwrite_za16_bf16_vg1x2", "test_svwrite_za16_s16_vg1x4", "test_svwrite_za16_u16_vg1x4", "test_svwrite_za32_u32_vg1x4", "test_svwrite_za32_s32_vg1x2", "test_svwrite_za32_f32_vg1x4", "test_svwrite_za16_u16_vg1x2", "test_svwrite_za8_u8_vg1x4", "test_svwrite_za16_f16_vg1x2", "test_svwrite_za32_s32_vg1x4"]}, {"filename": "clang/test/Sema/aarch64-sme2-intrinsics/acle_sme2_imm.cpp", "functions": ["test_multivector_read"]}]}
{"pr_number": 76925, "url": "https://github.com/llvm/llvm-project/pull/76925", "title": "[ConstraintElim] Use SCEV to check for multiples", "body": "When adding constraints for induction variables, if the step is not one, we need to make sure that (end-start) is a multiple of step, otherwise we might step over the end value.\r\n\r\nCurrently this only supports one specific pattern for pointers, where the end is a gep of the start with an appropriate offset.\r\n\r\nGeneralize this by using SCEV to check for multiples, which also makes this work for integer IVs.\r\n\r\nThere is no impact on compile-time.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Scalar/ConstraintElimination.cpp", "functions": ["UpperConstantOffset"]}]}
{"pr_number": 76793, "url": "https://github.com/llvm/llvm-project/pull/76793", "title": "[RISCV][CostModel] Add getRISCVInstructionCost() to TTI for CostKind", "body": "Instruction cost for CodeSize and Latency/RecipThroughput can be very\r\ndifferent. Considering the diversity of CostKind and vendor-specific\r\ncost, and how they are spread across various TTI functions, it's\r\nbecoming quite a challenge to handle. This patch adds an interface\r\ngetRISCVInstructionCost to address it.\r\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVISelLowering.cpp", "functions": ["getLMULCost"]}, {"filename": "llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp", "functions": ["if"]}]}
{"pr_number": 76066, "url": "https://github.com/llvm/llvm-project/pull/76066", "title": "[mlir][EmitC] Use declarative assembly format for opaque types and attributes", "body": "The parser and printer of string attributes were changed to handle escape sequences. Therefore, we no longer require a custom parser and printer. Verification is moved from the parser to the verifier accordingly.", "feature_layers": ["parse", "ir", "parser"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/EmitC/IR/EmitC.cpp", "functions": ["success", "get", "Attribute", "emitError", "Type"]}]}
{"pr_number": 76215, "url": "https://github.com/llvm/llvm-project/pull/76215", "title": "AMDGPU: Make bf16/v2bf16 legal types", "body": "There are some intrinsics are using i16 vectors in place of bfloat vectors.\r\nMove towards making bf16 vectors legal so these can migrate. Leave the\r\nlarger vectors for a later change.\r\n\r\nDepends #76213 #76214 ", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp", "functions": ["SL", "DL"]}, {"filename": "llvm/lib/Target/AMDGPU/SIISelLowering.cpp", "functions": ["SL", "lowerFP_EXTEND"]}]}
{"pr_number": 76825, "url": "https://github.com/llvm/llvm-project/pull/76825", "title": "[clang] Optimize castToDeclContext for 2% improvement in build times", "body": "[copied from issue]\r\n\r\nThe function castToDeclContext takes around 2% of the execution time in my test run.\r\n\r\nI was profiling clang to see if by any chance I could spot any small mistakes that were taking a significant amount of time on debug builds, and while pretty much everything is either complicated enough where optimizing would be impossible for me or is already very performant, I noticed that valgrind was reporting an interesting function as the top of the 'auto' category:\r\n![interesting_entry](https://github.com/llvm/llvm-project/assets/25348040/8b7e5d79-d7c7-4c3e-a0de-2ea63058c5aa)\r\n\r\nIt is being executed 1.8 billion times, and the implementation looks pretty trivial to me:\r\n![code_snippet](https://github.com/llvm/llvm-project/assets/25348040/a9f87c3f-55da-43b8-b028-db79ad61cf20)\r\n\r\nLooking at the assembly, I expected pretty much a lookup table and an add operation, but it is pretty clear that the resulting code is not ideal:\r\n\r\n```asm\r\nclang::Decl::castFromDeclContext(clang::DeclContext const*): # @clang::Decl::castFromDeclContext(clang::DeclContext const*)\r\n.L_ZN5clang4Decl19castFromDeclContextEPKNS_11DeclContextE$local:\r\n  movzwl 8(%rdi), %edx\r\n  movq %rdi, %rax\r\n  andl $127, %edx\r\n  leal -1(%rdx), %esi\r\n  cmpl $84, %esi\r\n  ja .LBB65_7\r\n  leaq .LJTI65_0(%rip), %rdi\r\n  movq $-40, %rcx\r\n  movslq (%rdi,%rsi,4), %rsi\r\n  addq %rdi, %rsi\r\n  jmpq *%rsi\r\n.LBB65_2:\r\n  addq %rcx, %rax\r\n  retq\r\n.LBB65_4:\r\n  movq $-48, %rcx\r\n  addq %rcx, %rax\r\n  retq\r\n.LBB65_5:\r\n  movq $-64, %rcx\r\n  addq %rcx, %rax\r\n  retq\r\n.LBB65_6:\r\n  movq $-56, %rcx\r\n  addq %rcx, %rax\r\n  retq\r\n.LBB65_7:\r\n  leal -53(%rdx), %esi\r\n  movq $-72, %rcx\r\n  cmpl $6, %esi\r\n  jb .LBB65_2\r\n  addl $-34, %edx\r\n  xorl %ecx, %ecx\r\n  cmpl $5, %edx\r\n  setae %cl\r\n  shll $4, %ecx\r\n  orq $-64, %rcx\r\n  addq %rcx, %rax\r\n  retq\r\n.LJTI65_0:\r\n<JUMP TABLE>\r\n```\r\n\r\nThe PR I'll submit in a few minutes fixes this problem by eliminating the need for the macro DECL_CONTEXT_BASE (it's only used here and in two other analogous functions), and reordering the AST decl order to prioritize classes that inherit from DeclContext. I also experimented with hand rolled offset tables, but this is far from maintainable even if it manages to compress 3 lookup tables into one. The resulting assembly is just:\r\n\r\n```asm\r\nclang::Decl::castFromDeclContext(clang::DeclContext const*): # @clang::Decl::castFromDeclContext(clang::DeclContext const*)\r\n.L_ZN5clang4Decl19castFromDeclContextEPKNS_11DeclContextE$local:\r\n  movzwl 8(%rdi), %ecx\r\n  leaq .Lswitch.table._ZN5clang4Decl19castFromDeclContextEPKNS_11DeclContextE(%rip), %rdx\r\n  movq %rdi, %rax\r\n  andl $127, %ecx\r\n  addq (%rdx,%rcx,8), %rax\r\n  retq\r\n```\r\n  \r\nAnd the build difference of clang+clang-tools-extra with a debug build:\r\nNonOpt: ninja  19007,02s user 760,01s system 2284% cpu 14:25,23 total\r\nOpt: ninja  18806,18s user 763,33s system 2308% cpu 14:07,74 total\r\n\r\nSo around ~1.02 speedup, ~0.98 of the previous execution, nothing earth shattering, but what would be expected from valgrind, and I already did all the legwork, so I might as well send it :)", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/utils/TableGen/ClangASTNodesEmitter.cpp", "functions": ["macroHierarchyName", "DeclContexts", "Records"]}]}
{"pr_number": 76967, "url": "https://github.com/llvm/llvm-project/pull/76967", "title": "[Clang] Fix the instantiation of return type requirements in lambda bodies", "body": "Currently, due to the incomplete implementation of p0588r1, the instantiation of lambda expressions leads to the instantiation of the body. And `EvaluateConstraints` is false during the instantiation of the body, which causes crashes during the instantiation of the return type requirement:\r\n\r\n```cpp\r\ntemplate<typename T> concept doesnt_matter = true;\r\n\r\ntemplate<class T>\r\nconcept test = \r\n    []{\r\n        return requires(T t) {\r\n            { t } -> doesnt_matter; // crash\r\n        };\r\n    }();\r\n\r\nstatic_assert(test<int>);\r\n```\r\n\r\n Although a complete implementation of p0588r1 can solve these crashes, it will take some time. Therefore, this pull request aims to fix these crashes first.\r\n\r\nFixes https://github.com/llvm/llvm-project/issues/63808\r\nFixes https://github.com/llvm/llvm-project/issues/64607\r\nFixes https://github.com/llvm/llvm-project/issues/64086\r\n", "feature_layers": ["ir"], "feature_directives": ["for", "requires"], "files_changed": [{"filename": "clang/lib/Sema/SemaTemplateInstantiate.cpp", "functions": ["TransformLambdaBody"]}, {"filename": "clang/test/SemaTemplate/concepts-lambda.cpp", "functions": ["f1", "requires", "foo"]}]}
{"pr_number": 75514, "url": "https://github.com/llvm/llvm-project/pull/75514", "title": "[SPIR-V] Do not reassign kernel arg SPIRVType based on later calls/uses", "body": "", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/Target/SPIRV/SPIRVEmitIntrinsics.cpp", "functions": ["insertPtrCastInstr"]}]}
{"pr_number": 76869, "url": "https://github.com/llvm/llvm-project/pull/76869", "title": "[RISCV][llvm-mca] Use correct LMUL and SEW for strided loads and stores", "body": "The pseudos for strided loads and stores use the SEW coming from the name. For example, vlse8 has SEW=8 and vlse16 has SEW=16.\r\n\r\nWhen llvm-mca tries to lookup (VLSE8_V, SEW=S, LMUL=L) in the inverse pseudo table, a result will only be found when S=8, where S was set from the previous vsetvli instruction. Instead, for a match to be found, we must lookup (VLSE8_V, SEW=8, LMUL=L') where L' is the EMUL which was calculated by scaling the LMUL and SEW from the previous vsetvli and the SEW=8.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/MCA/RISCVCustomBehaviour.cpp", "functions": ["opcodeHasEEWAndEMULInfo"]}]}
{"pr_number": 76989, "url": "https://github.com/llvm/llvm-project/pull/76989", "title": "[ORC] Refactor executor symbol lookup to use ExecutorSymbolDef (NFC)", "body": "This migrates the dylib manager lookup and related APIs to replace\r\nExecutorAddress with ExecutorSymbolDef so that in the future we can\r\nmodel JITSymbolFlags for these symbols. The current change should be NFC\r\nas we are only setting the Exported symbol flag.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/ExecutionEngine/Orc/EPCGenericDylibManager.cpp", "functions": ["Result"]}, {"filename": "compiler-rt/lib/orc/tests/unit/simple_packed_serialization_test.cpp", "functions": ["OB", "blobSerializationRoundTrip", "IB"]}]}
{"pr_number": 70962, "url": "https://github.com/llvm/llvm-project/pull/70962", "title": "[clang][AST] Fix crash in MatchChildASTVisitor::TraverseLambdaExpr", "body": "When a lambda expression captures a VLA array by reference, the 'capture_init' array contains one element, which is 'nullptr'. While traversing the AST with the 'IgnoreUnlessSpelledInSource' flag, there is a dereference of this 'nullptr'.\r\n\r\nThis change introduces a verification step to check if 'capture_init' is 'nullptr' before attempting to dereference it. Additionally, it includes tests for matchers and for the clang-tidy check that originally revealed the issue.", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang-tools-extra/test/clang-tidy/checkers/cppcoreguidelines/owning-memory.cpp", "functions": ["h", "f"]}, {"filename": "clang/unittests/ASTMatchers/ASTMatchersTraversalTest.cpp", "functions": ["f"]}]}
{"pr_number": 70253, "url": "https://github.com/llvm/llvm-project/pull/70253", "title": "[VPlan] Introduce ComputeReductionResult VPInstruction opcode.", "body": "This patch introduces a new ComputeReductionResult opcode to compute the final reduction result in the middle block. The code from fixReduction has been moved to ComputeReductionResult, after some earlier cleanup changes to model parts of fixReduction explicitly elsewhere as needed.\r\n\r\nThe recipe may be broken down further in the future.\r\n\r\nNote that the ComputeReductionResult at the moment also creates the phi node to merge the reduction result from the trip count check and the middle block, to be used as resume value for the scalar remainder loop. Once we have a VPValue for the reduction result, this can also be modeled explicitly and moved out of the recipe.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Vectorize/LoopVectorize.cpp", "functions": ["if", "fixCrossIterationPHIs", "RdxParts", "FMFG"]}, {"filename": "llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp", "functions": ["if", "RdxParts", "FMFG"]}]}
{"pr_number": 75080, "url": "https://github.com/llvm/llvm-project/pull/75080", "title": "[llvm-profdata] Use semicolon as the delimiter for supplementary profiles.", "body": "When merging instrFDO profiles with afdo profile as supplementary, instrFDO counters for static functions are stored with function's PGO name (with `filename.cpp;` prefix).\r\n- This pull request fixes the delimiter used when a PGO function name is 'normalized' for AFDO look-up.\r\n- This is a follow-up patch of https://github.com/llvm/llvm-project/pull/74008", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/ProfileData/InstrProf.cpp", "functions": ["getPGOFuncName", "getLegacyPGOFuncName"]}, {"filename": "llvm/test/Transforms/PGOProfile/Inputs/lib.cc", "functions": ["global_func", "callee0", "callee1", "void"]}, {"filename": "llvm/test/Transforms/PGOProfile/Inputs/main.cc", "functions": ["main"]}, {"filename": "compiler-rt/test/profile/instrprof-thinlto-indirect-call-promotion.cpp", "functions": ["callee0", "callee1", "void", "main", "global_func"]}]}
{"pr_number": 76994, "url": "https://github.com/llvm/llvm-project/pull/76994", "title": "[InstrProf] No linkage prefixes in IRPGO names", "body": "Change the format of IRPGO counter names to `[<filepath>;]<mangled-name>` which is computed by `GlobalValue::getGlobalIdentifier()` to fix #74565.\r\n\r\nIn fe051934cbb0aaf25d960d7d45305135635d650b (https://reviews.llvm.org/D156569) the format of IRPGO counter names was changed to be `[<filepath>;]<linkage-name>` where `<linkage-name>` is basically `F.getName()` with some prefix, e.g., `_` or `l_` on Mach-O (yes, it is confusing that `<linkage-name>` is computed with `Mangler().getNameWithPrefix()` while `<mangled-name>` is just `F.getName()`). We discovered in #74565 that this causes some missed import issues on some targets and #74008 is a partial fix.\r\n\r\nSince `<mangled-name>` may not match the `<linkage-name>` on some targets like Mach-O, we will need to post-process the output of `llvm-profdata order` before passing to the linker via `-order_file`.\r\n\r\nProfiles generated after fe051934cbb0aaf25d960d7d45305135635d650b will become stale after this diff, but I think this is acceptable since that patch landed after the LLVM 18 cut which hasn't been released yet.", "feature_layers": ["ir"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "llvm/lib/ProfileData/InstrProf.cpp", "functions": ["getIRPGONameForGlobalObject", "lookupPGONameFromMetadata"]}]}
{"pr_number": 74792, "url": "https://github.com/llvm/llvm-project/pull/74792", "title": "[MLIR] Support interrupting AffineExpr walks", "body": "Support WalkResult for AffineExpr walk and support interrupting walks\r\nalong the lines of Operation::walk. This allows interrupted walks when a\r\ncondition is met. Also, switch from std::function to llvm::function_ref\r\nfor the walk function.\r\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/IR/AffineExpr.cpp", "functions": ["visitAffineBinaryOpExpr", "visitSymbolExpr", "AffineExprWalker", "visitDimExpr", "callback", "visitConstantExpr"]}, {"filename": "mlir/test/lib/IR/TestAffineWalk.cpp", "functions": ["registerTestAffineWalk", "runOnOperation", "getArgument", "getDescription", "checkMod"]}, {"filename": "mlir/tools/mlir-opt/mlir-opt.cpp", "functions": ["registerTestAffineWalk", "registerTestGpuLoweringPasses", "registerTestAffineLoopUnswitchingPass"]}]}
{"pr_number": 69621, "url": "https://github.com/llvm/llvm-project/pull/69621", "title": "[SPIR-V] Emit SPIR-V bitcasts between source/expected pointer type", "body": "This patch introduces a new spv_ptrcast intrinsic for tracking expected pointer types. The change fixes multiple OpenCL CTS regressions due the switch to opaque pointers (e.g. basic/hiloeo).", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/SPIRV/SPIRVEmitIntrinsics.cpp", "functions": ["insertPtrCastInstr"]}]}
{"pr_number": 74332, "url": "https://github.com/llvm/llvm-project/pull/74332", "title": "DAG: Implement promotion for strict_fp_round", "body": "Needs an AMDGPU hack to get the selection to work. The ordinary\r\nvariant is custom lowered through an almost equivalent target node\r\nthat would need a strict variant for additional known bits optimizations.", "feature_layers": [], "feature_directives": ["for", "target"], "files_changed": [{"filename": "llvm/lib/CodeGen/SelectionDAG/LegalizeFloatTypes.cpp", "functions": ["DL", "GetPromotionOpcodeStrict"]}, {"filename": "llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp", "functions": ["dl"]}]}
{"pr_number": 76901, "url": "https://github.com/llvm/llvm-project/pull/76901", "title": "[X86][BF16] Try to use `f16` for lowering", "body": "This patch fixes BF16 32-bit ABI problem: https://godbolt.org/z/6dMnh8jGG", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/X86/X86ISelLoweringCall.cpp", "functions": ["SDValue"]}]}
{"pr_number": 76238, "url": "https://github.com/llvm/llvm-project/pull/76238", "title": "[AArch64][GlobalISel] Add legalization for G_VECREDUCE_SEQ_FADD.", "body": "And G_VECREDUCE_SEQ_FMUL at the same time. They require the elements of the vector operand to be accumulated in order, so just need to be scalarized.\r\n\r\nSome of the operands are not simplified as much as they can quite yet due to not canonicalizing constant operands post-legalization.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp", "functions": ["fewerElementsVectorSeqReductions"]}]}
{"pr_number": 67393, "url": "https://github.com/llvm/llvm-project/pull/67393", "title": "[RISCV] Support fmaximum/fminimum for fp16 vector when only Zvfhmin enabled", "body": "This patch promotes fmaximum/fminimum for fp16 vector to float operation.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVISelLowering.cpp", "functions": ["SplitVectorOp"]}]}
{"pr_number": 73907, "url": "https://github.com/llvm/llvm-project/pull/73907", "title": "[VFABI] Improve VFABI unit tests", "body": "Do checks for scalar parameter counts for all mappings with `matchScalarParametersNum`. It is not part of `invokeParser` so it can be selectively applied only to tests that supply valid mangled names.\r\n\r\nAlso, minor reformatting and typo fixes.", "feature_layers": ["parse", "parser"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/unittests/Analysis/VectorFunctionABITest.cpp", "functions": ["matchParametersNum", "matchScalarParamNum"]}]}
{"pr_number": 76818, "url": "https://github.com/llvm/llvm-project/pull/76818", "title": "[coroutines] Introduce [[clang::coro_disable_lifetimebound]]", "body": "Lifetime-bound analysis of reference parameters of coroutines and coroutine wrappers is helpful in surfacing memory bugs associated with using temporaries and stack variables in call expressions in plain return statements.\r\n\r\nThis is the default semantics of `[[clang::coro_lifetimebound]]`. But it should be okay to relax the requirements for a function when the reference arguments are not lifetime bound. For example:\r\n\r\nA coroutine wrapper accepts a reference parameter but does not pass it to the underlying coroutine call.\r\n```cpp\r\n[[clang::coro_wrapper]] Task<int> wrapper(const Request& req) {\r\n  return req.shouldCallA() ? coroA() : coroB();\r\n}\r\n```\r\nOr passes it the coroutine by value\r\n```cpp\r\nTask<int> coro(std::string s) { co_return s.size(); }\r\n[[clang::coro_wrapper]] wrapper(const std::string& s) { return coro(s); }\r\n```\r\n\r\nThis patch allows functions to be annotated with `[[clang::coro_disable_lifetime_bound]]` to disable lifetime bound analysis for all calls to this function.\r\n\r\n---\r\nOne missing piece here is a note suggesting using this annotation in cases of lifetime warnings. This would require some more tweaks in the lifetimebound analysis to recognize violations involving coroutines only and produce this note only in those cases.", "feature_layers": ["sema", "ir"], "feature_directives": ["task", "for"], "files_changed": [{"filename": "clang/test/SemaCXX/coro-lifetimebound.cpp", "functions": ["foo", "foo_wrapper", "caller"]}]}
{"pr_number": 76960, "url": "https://github.com/llvm/llvm-project/pull/76960", "title": "[include-cleaner] Fix a race issue when editing multiple files.", "body": "We have a previous fix https://github.com/llvm/llvm-project/commit/be861b64d94198230d8f9889b17280e3cd215a0a, which snapshots all processing files.\r\n\r\nIt works most of times, the snapshot (InMemoryFileSystem) is based on the file path. The file-path-based lookup can fail in a subtle way for some tricky cases (we encounter it internally), which will result in reading a corrupted file.\r\n\r\nThis is a different fix, we don't modify files on the fly, instead, we write files when the tool finishes for all files.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang-tools-extra/include-cleaner/tool/IncludeCleaner.cpp", "functions": ["HeaderFilter"]}]}
{"pr_number": 75775, "url": "https://github.com/llvm/llvm-project/pull/75775", "title": "[mlir][gpu] Productize `test-lower-to-nvvm` as `gpu-lower-to-nvvm`", "body": "The `test-lower-to-nvvm` pipeline serves as the common and proper pipeline for nvvm+host compilation, and it's used across our CUDA integration tests.\r\n\r\nThis PR updates the `test-lower-to-nvvm` pipeline to `gpu-lower-to-nvvm` and moves it within `InitAllPasses.h`. The aim is to call it from Python, also having a standardize compilation process for nvvm. ", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/GPU/Pipelines/GPUToNVVMPipeline.cpp", "functions": ["registerTestLowerToNVVM", "registerGPUToNVVMPipeline"]}]}
{"pr_number": 73504, "url": "https://github.com/llvm/llvm-project/pull/73504", "title": "[RemoveDIs] Handle DPValues in LowerDbgDeclare", "body": "", "feature_layers": [], "feature_directives": ["declare"], "files_changed": [{"filename": "llvm/lib/Transforms/Utils/Local.cpp", "functions": ["getDebugValueLocDPV", "getDebugValueLoc"]}]}
{"pr_number": 75958, "url": "https://github.com/llvm/llvm-project/pull/75958", "title": "[Clang][SME] Add IsStreamingOrSVE2p1", "body": "This patch adds IsStreamingOrSVE2p1 to the applicable builtins and a warning for when those builtins are not used in a streaming or sve2p1 function.\r\n\r\nSorry for the large change. I tried to separate it into two but it's all dependent on each other (the warning needs the builtins to be made IsStreamingOrSVE2p1 to test the diagnostics, which means the tests have to be updated).", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_sclamp.c", "functions": ["test_svclamp_s64", "test_svclamp_s32", "test_svclamp_s16", "test_svclamp_s8", "SVE_ACLE_FUNC"]}, {"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_uclamp.c", "functions": ["test_svclamp_u16", "test_svclamp_u64", "test_svclamp_u32", "test_svclamp_u8", "SVE_ACLE_FUNC"]}, {"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_while_pn.c", "functions": ["test_svwhilels_c32_vl4", "test_svwhilelt_c8_vl4", "test_svwhilegt_c8_vl2", "test_svwhilegt_c64_vl2", "test_svwhilele_c64_vl4", "test_svwhilehi_c16_vl2", "test_svwhilelt_c16_vl4", "test_svwhilehs_c64_vl2", "test_svwhilehs_c64_vl4", "test_svwhilele_c8_vl2", "test_svwhilelt_c32_vl2", "test_svwhilelt_c64_vl4", "test_svwhilegt_c64_vl4", "test_svwhilege_c32_vl2", "test_svwhilegt_c32_vl2", "test_svwhilegt_c32_vl4", "test_svwhilelo_c8_vl2", "test_svwhilelo_c32_vl4", "test_svwhilehs_c16_vl2", "test_svwhilelo_c16_vl2", "test_svwhilehs_c16_vl4", "test_svwhilehi_c32_vl2", "test_svwhilele_c64_vl2", "test_svwhilelo_c8_vl4", "test_svwhilels_c8_vl2", "test_svwhilege_c8_vl2", "test_svwhilelo_c32_vl2", "test_svwhilehi_c64_vl2", "test_svwhilelt_c32_vl4", "test_svwhilelo_c64_vl4", "test_svwhilehi_c8_vl2", "test_svwhilels_c16_vl4", "test_svwhilels_c32_vl2", "test_svwhilele_c16_vl4", "test_svwhilehs_c8_vl4", "test_svwhilegt_c16_vl2", "test_svwhilels_c8_vl4", "test_svwhilehi_c64_vl4", "test_svwhilels_c16_vl2", "test_svwhilehi_c8_vl4", "test_svwhilels_c64_vl4", "test_svwhilege_c16_vl2", "test_svwhilele_c32_vl2", "test_svwhilelt_c8_vl2", "test_svwhilegt_c8_vl4", "test_svwhilehs_c32_vl4", "test_svwhilehs_c32_vl2", "test_svwhilehi_c32_vl4", "test_svwhilege_c8_vl4", "test_svwhilelo_c64_vl2", "test_svwhilege_c64_vl4", "test_svwhilehs_c8_vl2", "test_svwhilelo_c16_vl4", "test_svwhilelt_c16_vl2", "test_svwhilege_c32_vl4", "test_svwhilege_c64_vl2", "test_svwhilele_c16_vl2", "test_svwhilels_c64_vl2", "test_svwhilelt_c64_vl2", "test_svwhilegt_c16_vl4", "test_svwhilele_c8_vl4", "test_svwhilege_c16_vl4", "test_svwhilehi_c16_vl4", "test_svwhilele_c32_vl4"]}, {"filename": "clang/test/Sema/aarch64-sme2-sve2p1-diagnostics.c", "functions": ["svldnt1_s64_x4", "sme2_or_sve2p1_intrinsic_test_sme2", "svldnt1_u8_x2", "sme2_or_sve2p1_intrinsic_test_both_arm_streaming", "svldnt1_u32_x2", "svldnt1_s16_x4", "sme2_or_sve2p1_intrinsic_test_sve2p1", "sme2_or_sve2p1_intrinsic_test_both_no_arm_streaming", "sme2_or_sve2p1_intrinsic_test_sme2_invalid"]}, {"filename": "clang/utils/TableGen/SveEmitter.cpp", "functions": ["if"]}, {"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_cntp.c", "functions": ["test_svcntp_c16_vlx4", "test_svcntp_c32_vlx4", "test_svcntp_c64_vlx2", "test_svcntp_c64_vlx4", "test_svcntp_c16_vlx2", "test_svcntp_c8_vlx4", "test_svcntp_c32_vlx2", "test_svcntp_c8_vlx2"]}, {"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_fclamp.c", "functions": ["test_svclamp_f64", "test_svclamp_f16", "test_svclamp_f32"]}, {"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_pfalse.c", "functions": ["test_svpfalse_c"]}, {"filename": "clang/test/Sema/aarch64-sme2-intrinsics/acle_sme2_imm.cpp", "functions": ["test_bfmlslb_bad_lane"]}, {"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_psel.c", "functions": ["test_svpsel_lane_b16", "test_svpsel_lane_b8", "test_svpsel_lane_c16", "test_svpsel_lane_c32", "test_svpsel_lane_b64", "test_svpsel_lane_b32", "test_svpsel_lane_c8", "test_svpsel_lane_c64"]}]}
{"pr_number": 76975, "url": "https://github.com/llvm/llvm-project/pull/76975", "title": "[Clang][SME] Add IsStreamingOrSVE2p1", "body": "This patch adds IsStreamingOrSVE2p1 to the applicable builtins and a warning for when those builtins are not used in a streaming or sve2p1 function.\r\n\r\nFix after reverting https://github.com/llvm/llvm-project/pull/75958. I'll merge when the tests pass based on the original PR being approved. Apologies for the noise.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_sclamp.c", "functions": ["test_svclamp_s64", "test_svclamp_s32", "test_svclamp_s16", "test_svclamp_s8", "SVE_ACLE_FUNC"]}, {"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_uclamp.c", "functions": ["test_svclamp_u16", "test_svclamp_u64", "test_svclamp_u32", "test_svclamp_u8", "SVE_ACLE_FUNC"]}, {"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_while_pn.c", "functions": ["test_svwhilels_c32_vl4", "test_svwhilelt_c8_vl4", "test_svwhilegt_c8_vl2", "test_svwhilegt_c64_vl2", "test_svwhilele_c64_vl4", "test_svwhilehi_c16_vl2", "test_svwhilelt_c16_vl4", "test_svwhilehs_c64_vl2", "test_svwhilehs_c64_vl4", "test_svwhilele_c8_vl2", "test_svwhilelt_c32_vl2", "test_svwhilelt_c64_vl4", "test_svwhilegt_c64_vl4", "test_svwhilege_c32_vl2", "test_svwhilegt_c32_vl2", "test_svwhilegt_c32_vl4", "test_svwhilelo_c8_vl2", "test_svwhilelo_c32_vl4", "test_svwhilehs_c16_vl2", "test_svwhilelo_c16_vl2", "test_svwhilehs_c16_vl4", "test_svwhilehi_c32_vl2", "test_svwhilele_c64_vl2", "test_svwhilelo_c8_vl4", "test_svwhilels_c8_vl2", "test_svwhilege_c8_vl2", "test_svwhilelo_c32_vl2", "test_svwhilehi_c64_vl2", "test_svwhilelt_c32_vl4", "test_svwhilelo_c64_vl4", "test_svwhilehi_c8_vl2", "test_svwhilels_c16_vl4", "test_svwhilels_c32_vl2", "test_svwhilele_c16_vl4", "test_svwhilehs_c8_vl4", "test_svwhilegt_c16_vl2", "test_svwhilels_c8_vl4", "test_svwhilehi_c64_vl4", "test_svwhilels_c16_vl2", "test_svwhilehi_c8_vl4", "test_svwhilels_c64_vl4", "test_svwhilege_c16_vl2", "test_svwhilele_c32_vl2", "test_svwhilelt_c8_vl2", "test_svwhilegt_c8_vl4", "test_svwhilehs_c32_vl4", "test_svwhilehs_c32_vl2", "test_svwhilehi_c32_vl4", "test_svwhilege_c8_vl4", "test_svwhilelo_c64_vl2", "test_svwhilege_c64_vl4", "test_svwhilehs_c8_vl2", "test_svwhilelo_c16_vl4", "test_svwhilelt_c16_vl2", "test_svwhilege_c32_vl4", "test_svwhilege_c64_vl2", "test_svwhilele_c16_vl2", "test_svwhilels_c64_vl2", "test_svwhilelt_c64_vl2", "test_svwhilegt_c16_vl4", "test_svwhilele_c8_vl4", "test_svwhilege_c16_vl4", "test_svwhilehi_c16_vl4", "test_svwhilele_c32_vl4"]}, {"filename": "clang/test/Sema/aarch64-sme2-sve2p1-diagnostics.c", "functions": ["svldnt1_s64_x4", "sme2_or_sve2p1_intrinsic_test_sme2", "svldnt1_u8_x2", "sme2_or_sve2p1_intrinsic_test_both_arm_streaming", "svldnt1_u32_x2", "svldnt1_s16_x4", "sme2_or_sve2p1_intrinsic_test_sve2p1", "sme2_or_sve2p1_intrinsic_test_both_no_arm_streaming", "sme2_or_sve2p1_intrinsic_test_sme2_invalid"]}, {"filename": "clang/utils/TableGen/SveEmitter.cpp", "functions": ["if"]}, {"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_cntp.c", "functions": ["test_svcntp_c16_vlx4", "test_svcntp_c32_vlx4", "test_svcntp_c64_vlx2", "test_svcntp_c64_vlx4", "test_svcntp_c16_vlx2", "test_svcntp_c8_vlx4", "test_svcntp_c32_vlx2", "test_svcntp_c8_vlx2"]}, {"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_fclamp.c", "functions": ["test_svclamp_f64", "test_svclamp_f16", "test_svclamp_f32"]}, {"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_pfalse.c", "functions": ["test_svpfalse_c"]}, {"filename": "clang/test/Sema/aarch64-sme2-intrinsics/acle_sme2_imm.cpp", "functions": ["test_bfmlslb_bad_lane"]}, {"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_psel.c", "functions": ["test_svpsel_lane_b16", "test_svpsel_lane_b8", "test_svpsel_lane_c16", "test_svpsel_lane_c32", "test_svpsel_lane_b64", "test_svpsel_lane_b32", "test_svpsel_lane_c8", "test_svpsel_lane_c64"]}]}
{"pr_number": 77062, "url": "https://github.com/llvm/llvm-project/pull/77062", "title": "[mlir][gpu] Improve `gpu-lower-to-nvvm-pipeline` Documentation", "body": "This PR improves the documentation for the `gpu-lower-to-nvvm-pipeline` (as it was remaning item for #75775)\r\n\r\n- Changes pipeline `gpu-lower-to-nvvm` -> `gpu-lower-to-nvvm-pipeline`\r\n- Adds a section in GPU Dialect in website. It clarifies the pipeline's functionality in lowering primary dialects to NVVM targets.", "feature_layers": ["ir"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "mlir/lib/Dialect/GPU/Pipelines/GPUToNVVMPipeline.cpp", "functions": ["registerGPUToNVVMPipeline"]}]}
{"pr_number": 73133, "url": "https://github.com/llvm/llvm-project/pull/73133", "title": "[AMDGPU] Define new targets gfx1200 and gfx1201", "body": "Define target names and ELF numbers for new GFX12 targets gfx1200 and\ngfx1201. For now they behave identically to GFX11.\n", "feature_layers": [], "feature_directives": ["for", "target"], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.cpp", "functions": ["isNotGFX12Plus", "isGFX12Plus", "isGFX12"]}]}
{"pr_number": 75001, "url": "https://github.com/llvm/llvm-project/pull/75001", "title": "[clang] Correctly implement CWG 2672", "body": "This is a follow-up patch for [D156993](https://reviews.llvm.org/D156993), that marks only the lambda body as non-immediate context.\r\n\r\nFixes https://github.com/llvm/llvm-project/issues/71684", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/SemaCXX/cxx1y-init-captures.cpp", "functions": ["h"]}]}
{"pr_number": 76947, "url": "https://github.com/llvm/llvm-project/pull/76947", "title": "[System][z/OS] Fix per-thread timing error on z/OS", "body": "This patch calls ProcessCPUUsage() for z/OS because we do not support CLOCK_THREAD_CPUTIME_ID.  This copies the change made to google benchmark here https://github.com/google/benchmark/commit/e3824e7503187993b287ac8c8144a35bf5ccfd44", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "third-party/benchmark/src/timers.cc", "functions": ["ProcessCPUUsage"]}]}
{"pr_number": 76915, "url": "https://github.com/llvm/llvm-project/pull/76915", "title": "Reapply \"[Clang][Sema] Diagnose unexpanded packs in the template argument lists of function template specializations\" (#76876)", "body": "This reapplies f034044ad94d6f7ccec13d89f08acac257ed28bb after it was reverted by 687396b5f4ba0713d103ebd172b308e92eb930cc due to a test failure in clang-doc.\r\n\r\nThe test in question declares a partial specialization of a function template, as well as an explicit specialization of the same function template. Both declarations are now set as invalid, meaning neither is emitted by clang-doc. \r\n\r\nSince this is the sole test of function template specializations in clang-doc, I presume the intent is for the partial specialization to actually be the primary template. Doing so results in the expected output.", "feature_layers": ["sema"], "feature_directives": ["for", "declare"], "files_changed": [{"filename": "clang-tools-extra/test/clang-doc/templates.cpp", "functions": ["function"]}, {"filename": "clang/lib/Sema/SemaDecl.cpp", "functions": ["SourceRange", "TemplateArgsPtr"]}, {"filename": "clang/test/CXX/temp/temp.decls/temp.variadic/p5.cpp", "functions": ["InnerFunction", "PrimaryFunction"]}]}
{"pr_number": 76677, "url": "https://github.com/llvm/llvm-project/pull/76677", "title": "[Clang][Sema] Diagnose unexpanded packs in the template argument lists of function template specializations", "body": "This diagnoses unexpanded packs in the _unqualified-id_ of a function template specialization's _declarator-id_. For example:\r\n```cpp\r\ntemplate<typename... Ts>\r\nstruct A\r\n{\r\n    template<typename U>\r\n    void f();\r\n\r\n    template<>\r\n    void f<Ts>(); // error: explicit specialization contains unexpanded parameter pack 'Ts'\r\n};\r\n```\r\n\r\nI moved the handling of template-id's so it happens right after we determine whether we are declaring a function template/function template specialization so diagnostics are issued in lexical order. ", "feature_layers": ["sema"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Sema/SemaDecl.cpp", "functions": ["SourceRange", "TemplateArgsPtr"]}, {"filename": "clang/test/CXX/temp/temp.decls/temp.variadic/p5.cpp", "functions": ["InnerFunction", "PrimaryFunction"]}]}
{"pr_number": 75156, "url": "https://github.com/llvm/llvm-project/pull/75156", "title": "[X86] Add ABI handling for __float128 to match with GCC", "body": "Fixes #74601", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CodeGen/X86/fp128-abi.c", "functions": ["h3", "h4", "h1", "h2"]}]}
{"pr_number": 76941, "url": "https://github.com/llvm/llvm-project/pull/76941", "title": "[DebugInfo] Correctly track metadata slots for DPValues", "body": "Currently, the AsmWriter can print DPValues, but does not consider them when creating slots for metadata, which can result in erroneous output where metadata is numbered incorrectly. This patch modifies the ModuleSlotTracker to correctly track slots for metadata that appears in DPValues.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/IR/AsmWriter.cpp", "functions": ["processDPValueMetadata"]}]}
{"pr_number": 72222, "url": "https://github.com/llvm/llvm-project/pull/72222", "title": "[TableGen] Add a backend to generate MacroFusion predicators", "body": "`FusionPredicate` is used to predicate if target instruction matches\r\n the requirement. The targets can be firstMI, secondMI or both.\r\n\r\nThe `Fusion` contains a list of `FusionPredicate`. The generated code\r\nwill be like:\r\n```\r\nbool isNAME(const TargetInstrInfo &TII,\r\n            const TargetSubtargetInfo &STI,\r\n            const MachineInstr *FirstMI,\r\n            const MachineInstr &SecondMI) {\r\n  auto &MRI = SecondMI.getMF()->getRegInfo();\r\n  /* Predicates */\r\n  return true;\r\n}\r\n```\r\n\r\nA boilerplate class called `SimpleFusion` is added. `SimpleFusion` has\r\na predefined structure of predicates and accepts predicate for\r\n`firstMI`, predicate for `secondMI` and epilog/prolog as arguments.\r\nThe generated code for `SimpleFusion` will be like:\r\n```\r\nbool isNAME(const TargetInstrInfo &TII,\r\n            const TargetSubtargetInfo &STI,\r\n            const MachineInstr *FirstMI,\r\n            const MachineInstr &SecondMI) {\r\n  auto &MRI = SecondMI.getMF()->getRegInfo();\r\n  /* Prolog */\r\n  /* Predicate for `SecondMI` */\r\n  /* Wildcard */\r\n  /* Predicate for `FirstMI` */\r\n  /* Check One Use */\r\n  /* Tie registers */\r\n  /* Epilog */\r\n  return true;\r\n}\r\n```", "feature_layers": ["ir"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "llvm/utils/TableGen/MacroFusionPredicatorEmitter.cpp", "functions": ["run", "PE", "if"]}, {"filename": "llvm/utils/TableGen/PredicateExpander.cpp", "functions": ["expandCheckIsVRegOperand"]}]}
{"pr_number": 77073, "url": "https://github.com/llvm/llvm-project/pull/77073", "title": "[clang]Transform uninstantiated ExceptionSpec in `TemplateInstantiator`", "body": "Fixes: #77071\r\n`SubstituteDeducedTypeTransform` will transform type and it will visit uninstantiated `ExceptionSpecInfo`, which will cause odd behavior.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/SemaCXX/dependent-noexcept-uninstantiated.cpp", "functions": ["f1"]}]}
{"pr_number": 77002, "url": "https://github.com/llvm/llvm-project/pull/77002", "title": "[OpenACC] Implement 'default' clause parsing.", "body": "A simple clause that is permitted on a few different constructs,\r\n  'default' takes a required parameter of either 'none' or 'present'.\r\n  This patch implements parsing for it.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Parse/ParseOpenACC.cpp", "functions": ["expectIdentifierOrKeyword"]}, {"filename": "clang/test/ParserOpenACC/parse-clauses.c", "functions": ["DefaultClause"]}]}
{"pr_number": 76988, "url": "https://github.com/llvm/llvm-project/pull/76988", "title": "[InstCombine] Fold `switch(zext/sext(X))` into `switch(X)`", "body": "This patch folds `switch(zext/sext(X))` into `switch(X)`.\r\nThe original motivation of this patch is to optimize a pattern found in cvc5. For example:\r\n```\r\n  %bf.load.i = load i16, ptr %d_kind.i, align 8\r\n  %bf.clear.i = and i16 %bf.load.i, 1023\r\n  %bf.cast.i = zext nneg i16 %bf.clear.i to i32\r\n  switch i32 %bf.cast.i, label %if.else [\r\n    i32 335, label %if.then\r\n    i32 303, label %if.then\r\n  ]\r\n\r\nif.then:                                          ; preds = %entry, %entry\r\n  %d_children.i.i = getelementptr inbounds %\"class.cvc5::internal::expr::NodeValue\", ptr %0, i64 0, i32 3\r\n  %cmp.i.i.i.i.i = icmp eq i16 %bf.clear.i, 1023\r\n  %cond.i.i.i.i.i = select i1 %cmp.i.i.i.i.i, i32 -1, i32 %bf.cast.i\r\n```\r\n`%cmp.i.i.i.i.i` always evaluates to false because `%bf.clear.i` can only be 335 or 303.\r\nFolding `switch i32 %bf.cast.i` to `switch i16 %bf.clear.i` will help `CVP` to handle this case.\r\nSee also https://github.com/llvm/llvm-project/pull/76928#issuecomment-1877055722.\r\n\r\nCompile-time impact: http://llvm-compile-time-tracker.com/compare.php?from=7954c57124b495fbdc73674d71f2e366e4afe522&to=502b13ed34e561d995ae1f724cf06d20008bd86f&stat=instructions:u\r\n|stage1-O3|stage1-ReleaseThinLTO|stage1-ReleaseLTO-g|stage1-O0-g|stage2-O3|stage2-O0-g|stage2-clang|\r\n|--|--|--|--|--|--|--|\r\n|+0.03%|+0.06%|+0.07%|+0.00%|-0.02%|-0.03%|+0.02%|\r\n", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/InstCombine/InstructionCombining.cpp", "functions": ["replaceOperand"]}]}
{"pr_number": 70821, "url": "https://github.com/llvm/llvm-project/pull/70821", "title": "[OpenMP][libomptarget][FIX] Fix mapping of struct to device", "body": "In the current implementation the use case below will fail to map correctly leading to device addresses being used on the host for the pointer field `datum` of the struct:\r\n\r\n```\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\nstruct Descriptor {\r\n  int *datum;\r\n  long int x;\r\n  int xi;\r\n  long int arr[1][30];\r\n};\r\n\r\nint main() {\r\n  Descriptor dat = Descriptor();\r\n  dat.datum = (int *)malloc(sizeof(int)*10);\r\n  dat.xi = 3;\r\n  dat.arr[0][0] = 1;\r\n\r\n  #pragma omp target enter data map(to: dat.datum[:10]) map(to: dat)\r\n\r\n  #pragma omp target\r\n  {\r\n    dat.xi = 4;\r\n    dat.datum[dat.arr[0][0]] = dat.xi;\r\n  }\r\n\r\n  #pragma omp target exit data map(from: dat)\r\n\r\n return 0;\r\n}\r\n```\r\n\r\nThis patch fixes this issue and ensures that multiple maps of the dat struct do not overwrite the device data setup.", "feature_layers": [], "feature_directives": ["for", "target"], "files_changed": [{"filename": "openmp/libomptarget/test/offloading/struct_mapping_with_pointers.cpp", "functions": ["main"]}]}
{"pr_number": 75380, "url": "https://github.com/llvm/llvm-project/pull/75380", "title": "Port CodeGenPrepare to new pass manager (and BasicBlockSectionsProfil\u2026", "body": "Port CodeGenPrepare to new pass manager and dependency BasicBlockSectionsProfileReader\r\nFixes: #64560", "feature_layers": ["codegen"], "feature_directives": ["sections"], "files_changed": [{"filename": "llvm/lib/CodeGen/BasicBlockPathCloning.cpp", "functions": ["ApplyCloning"]}, {"filename": "llvm/lib/CodeGen/BasicBlockSectionsProfileReader.cpp", "functions": ["BasicBlockSectionsProfileReader", "BasicBlockSectionsProfileReaderWrapperPass"]}, {"filename": "llvm/lib/CodeGen/CodeGenPrepare.cpp", "functions": ["CodeGenPrepareLegacyPass", "getPassName", "getAnalysisUsage", "runOnFunction", "run", "releaseMemory", "_run", "CGP"]}]}
{"pr_number": 76249, "url": "https://github.com/llvm/llvm-project/pull/76249", "title": "[clang-tidy] Add check `readability-avoid-return-with-void-value`", "body": "Closes #75788.\r\n\r\nThe idea is to check each return statements for an expression that has type `void` as this is only possible in a function with `void` return type.\r\n\r\nThe implementation seems too simple. I might have missed something.\r\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang-tools-extra/test/clang-tidy/checkers/readability/return-expression-in-void-function.cpp", "functions": ["f7", "f8", "f6", "f9"]}, {"filename": "clang-tools-extra/test/clang-tidy/checkers/readability/avoid-return-with-void-value.cpp", "functions": ["f12", "f13"]}, {"filename": "clang-tools-extra/clang-tidy/readability/AvoidReturnWithVoidValueCheck.cpp", "functions": ["ClangTidyCheck"]}]}
{"pr_number": 77008, "url": "https://github.com/llvm/llvm-project/pull/77008", "title": "[ORC] Add absoluteSymbolsLinkGraph to expose absolute symbols to platform", "body": "Adds a function to create a LinkGraph of absolute symbols, and a callback in dynamic library search generators to enable using it to expose its symbols to the platform/orc runtime. This allows e.g. using __orc_rt_run_program to run a precompiled function that was found via dlsym. Ideally we would use this in llvm-jitlink's own search generator, but it will require more work to align with the Process/Platform JITDylib split, so not handled here.\r\n\r\nAs part of this change we need to handle LinkGraphs that only have absolute symbols.", "feature_layers": ["runtime", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/ExecutionEngine/Orc/EPCDynamicLibrarySearchGenerator.cpp", "functions": ["AddAbsoluteSymbols"]}, {"filename": "llvm/lib/ExecutionEngine/Orc/ExecutionUtils.cpp", "functions": ["AddAbsoluteSymbols"]}, {"filename": "llvm/unittests/ExecutionEngine/Orc/ObjectLinkingLayerTest.cpp", "functions": ["notifyFailed", "loadDylib", "notifyRemovingResources"]}]}
{"pr_number": 72078, "url": "https://github.com/llvm/llvm-project/pull/72078", "title": "[clang] Add per-global code model attribute", "body": "This patch adds a per-global code model attribute, which can override the target's code model to access global variables.\r\n\r\nCurrently, the code model attribute is only supported on LoongArch. This patch also maps GCC's code model names to LLVM's, which allows for better compatibility between the two compilers.\r\n\r\n\r\nSuggested-by: Arthur Eubanks <aeubanks@google.com>\r\nLink: https://discourse.llvm.org/t/how-to-best-implement-code-model-overriding-for-certain-values/71816\r\nLink: https://discourse.llvm.org/t/rfc-add-per-global-code-model-attribute/74944", "feature_layers": [], "feature_directives": ["for", "target"], "files_changed": [{"filename": "clang/lib/Sema/SemaDeclAttr.cpp", "functions": ["handleCodeModelAttr"]}, {"filename": "clang/test/CodeGen/LoongArch/attributes.c", "functions": ["__attribute__"]}, {"filename": "clang/test/Sema/loongarch-attr-model.c", "functions": ["__attribute"]}, {"filename": "clang/test/Sema/attr-model.c", "functions": ["__attribute"]}, {"filename": "clang/test/CodeGen/LoongArch/attributes.cpp", "functions": ["__attribute__"]}, {"filename": "clang/test/Sema/attr-model.cpp", "functions": ["__attribute"]}]}
{"pr_number": 70701, "url": "https://github.com/llvm/llvm-project/pull/70701", "title": "[LLD] Tombstone LocalTU entry in .debug_names", "body": "By default LLD uses 0x0... as a tombstone value. For Type Units this is a valid\r\naddress. Changed so that UINT{32,64}_MAX value is used for tombstone. The\r\nformer is for DWARF32, and latter for DWARF64. The default for LLVM is 32 bit DWARF.\r\nAlthough 64 bit DWARF is supported in LLVM, it's not widely used. The value was chosen\r\nbecause it is not a valid offset.\r\n\r\nThis was introduced as a change to DWARF6 spec:\r\nhttps://dwarfstd.org/issues/231013.1.html\r\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "lld/ELF/InputSection.cpp", "functions": ["if"]}]}
{"pr_number": 76831, "url": "https://github.com/llvm/llvm-project/pull/76831", "title": "[mlir][RegionBranchOpInterface] explicitly check for existance of block terminator", "body": "`RegionBranchTerminatorOpInterface` doesn't assume existence of [block terminators](https://github.com/llvm/llvm-project/blob/759cefb70fd13284c782971aa252b453051945bf/mlir/lib/Interfaces/ControlFlowInterfaces.cpp#L187):\r\n\r\n```cpp\r\n    // If there is no return-like terminator, the op itself should verify\r\n    // type consistency.\r\n    if (regionReturnOps.empty())\r\n      continue;\r\n```\r\n\r\nbut it does implicitly because `block.getTerminator()` here\r\n\r\n```cpp\r\n    SmallVector<RegionBranchTerminatorOpInterface> regionReturnOps;\r\n    for (Block &block : region)\r\n      if (auto terminator = dyn_cast<RegionBranchTerminatorOpInterface>(\r\n              block.getTerminator()))\r\n        regionReturnOps.push_back(terminator);\r\n``` \r\n\r\ndoes `assert(mightHaveTerminator());`. So just make that explicit.\r\n\r\n", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/test/lib/Dialect/Test/TestDialect.cpp", "functions": ["failure", "success"]}]}
{"pr_number": 74782, "url": "https://github.com/llvm/llvm-project/pull/74782", "title": "[clang][lex] Fix non-portability diagnostics with absolute path", "body": "The existing code incorrectly assumes that `Path` can be empty. It can't, it always contains at least `<` or `\"`. On Unix, this patch fixes an incorrect diagnostics that instead of `\"/Users/blah\"` suggested `\"Userss/blah\"`. In assert builds, this would outright crash.\r\n\r\nrdar://91172342", "feature_layers": ["ast"], "feature_directives": [], "files_changed": [{"filename": "clang/lib/Lex/PPDirectives.cpp", "functions": ["if"]}]}
{"pr_number": 72079, "url": "https://github.com/llvm/llvm-project/pull/72079", "title": "[llvm][LoongArch] Support per-global code model attribute for LoongArch", "body": "This patch gets the code model from global variable attribute if it has, otherwise the target's will be used.", "feature_layers": [], "feature_directives": ["for", "target"], "files_changed": [{"filename": "llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp", "functions": ["getAddr"]}]}
{"pr_number": 76924, "url": "https://github.com/llvm/llvm-project/pull/76924", "title": "[mlir][gpu] Add Support for  Cluster of Thread Blocks in `gpu.launch`", "body": "This PR improves `gpu.launch` to handle a new feature called cga cluster. Now, when using `gpu.launch`, one can include a cluster size, although it's optional. If provided, the outliner will transform `gpu.launch` with the cluster size into `gpu.launch_func`.\r\n\r\nPreviously, PR #72871 introduced the required support for clusters in the MLIR compiler and its CUDA runtime. This PR builds upon that work.", "feature_layers": ["runtime", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/GPU/IR/GPUDialect.cpp", "functions": ["emitOpError", "success"]}]}
{"pr_number": 76811, "url": "https://github.com/llvm/llvm-project/pull/76811", "title": "[Clang] Correctly construct template arguments for template template parameters", "body": "This fixes the bug introduced by\r\nhttps://github.com/llvm/llvm-project/commit/6db007a0654ed7a6ed5c3aa3b61a937c19a6bc6b.\r\n\r\nWe construct placeholder template arguments for template-template parameters to avoid mismatching argument substitution since they have different depths with their corresponding template arguments. In this case,\r\n\r\n```cpp\r\ntemplate <template <Concept C> class T> void foo(T<int>);\r\n```\r\n\r\nT lies at the depth 0, and C lies at 1. The corresponding argument, of which there is exactly one, int, is at depth 0. If we consider the argument as the outermost one, then we would end up substituting 'int' into the wrong parameter T.\r\n\r\nWe used to perform such placeholder construction during the context walk-up. In the previous patch, we slipped through that inadvertently because we would walk up to the parent, which is precisely a FileContext for template-template parameters, after adding innermost arguments.\r\n\r\nBesides, this patch moves the sanity check up to the context switch. That way, we avoid dereferencing null pointers if ND is unspecified.\r\n\r\nCloses https://github.com/llvm/llvm-project/issues/57410.\r\nCloses https://github.com/llvm/llvm-project/issues/76604. (The case is slightly different than that in #57410. We should *not* assume the surrounding context to be a file-scope one.)", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CXX/temp/temp.arg/temp.arg.template/p3-2a.cpp", "functions": ["bar", "foo"]}]}
{"pr_number": 76353, "url": "https://github.com/llvm/llvm-project/pull/76353", "title": "[mlir][spirv] Support alias/restrict function argument decorations", "body": "Closes #76106", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/SPIRV/IR/SPIRVDialect.cpp", "functions": ["success", "emitError"]}, {"filename": "mlir/lib/Dialect/SPIRV/IR/SPIRVOps.cpp", "functions": ["emitOpError"]}, {"filename": "mlir/lib/Target/SPIRV/Serialization/SerializeOps.cpp", "functions": ["failure"]}, {"filename": "mlir/lib/Target/SPIRV/Serialization/Serializer.cpp", "functions": ["processDecorationAttr", "emitDecoration", "emitError", "stringifyDecoration"]}, {"filename": "mlir/lib/Target/SPIRV/Deserialization/Deserializer.cpp", "functions": ["attr"]}]}
{"pr_number": 76323, "url": "https://github.com/llvm/llvm-project/pull/76323", "title": "[mlir][spirv] Use assemblyFormat to define atomic op assembly", "body": "see #73359\r\n\r\nDeclarative assemblyFormat ODS is more concise and requires less boilerplate than filling out CPP interfaces.\r\n\r\nChanges:\r\n* updates the Ops defined in `SPIRVAtomicOps.td` to use assemblyFormat.\r\n* Removes print/parse from`AtomcOps.cpp` which is now generated by assemblyFormat\r\n* Adds `Trait` to verify that a pointer operand `foo`'s pointee type matches operand `bar`'s type\r\n* * Updates error message expected in tests from new Trait\r\n* Updates tests to updated format (largely using <operand> in place of \"operand\")\r\n\r\n\r\n", "feature_layers": ["parse", "ir"], "feature_directives": ["for", "atomic", "requires"], "files_changed": [{"filename": "mlir/lib/Dialect/SPIRV/IR/AtomicOps.cpp", "functions": ["getValue", "success"]}]}
{"pr_number": 76833, "url": "https://github.com/llvm/llvm-project/pull/76833", "title": "\"Reapply \"[Sema] Fix crash on invalid code with parenthesized aggrega\u2026", "body": "\u2026te initialization\" (#76272)\"\"\r\n\r\nWith updates the libc++ tests.\r\n\r\nThis reverts commit 2205d23 and relands\r\n86dc6e1 and\r\n7ab16fb.\r\n\r\nOriginal commit was reverted because of failing libc++ tests, see #76232 for the discussion.\r\n\r\nThe errors in the tests are spurious in the first place (coming from initialization of invalid classes), so update the tests to match new behavior that does not show those errors.", "feature_layers": ["sema", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/SemaCXX/crash-GH76228.cpp", "functions": ["a1", "a2", "a4", "a5"]}, {"filename": "clang/test/SemaCXX/paren-list-agg-init.cpp", "functions": ["c"]}]}
{"pr_number": 76882, "url": "https://github.com/llvm/llvm-project/pull/76882", "title": "[NFC][ObjectSizeOffset] Use classes instead of std::pair", "body": "The use of std::pair makes the values it holds opaque. Using classes\r\nimproves this while keeping the POD aspect of a std::pair. As a nice\r\naddition, the \"known\" functions held inappropriately in the Visitor\r\nclasses can now properly reside in the value classes. :-)", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/Analysis/MemoryBuiltins.cpp", "functions": ["SizeOffsetType"]}]}
{"pr_number": 77090, "url": "https://github.com/llvm/llvm-project/pull/77090", "title": "[mlir][Interfaces][NFC] Move region loop detection to `RegionBranchOpInterface`", "body": "`BufferPlacementTransformationBase::isLoop` checks if there a loop in the region branching graph of an operation. This algorithm is similar to `isRegionReachable` in the `RegionBranchOpInterface`. To avoid duplicate code, `isRegionReachable` is generalized, so that it can be used to detect region loops. A helper function `RegionBranchOpInterface::hasLoop` is added.\r\n\r\nThis change also turns a recursive implementation into an iterative one, which is the preferred implementation strategy in LLVM.\r\n\r\nAlso move the `isLoop` to `BufferOptimizations.cpp`, so that we can gradually retire `BufferPlacementTransformationBase`. (This is so that proper error handling can be added to `BufferViewFlowAnalysis`.)\r\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Bufferization/Transforms/BufferOptimizations.cpp", "functions": ["isLegalPlacement", "isLoop"]}, {"filename": "mlir/lib/Interfaces/ControlFlowInterfaces.cpp", "functions": ["isRegionReachable"]}]}
{"pr_number": 77003, "url": "https://github.com/llvm/llvm-project/pull/77003", "title": "[OpenMP] Change `__tgt_device_image` to point to the image", "body": "Summary:\nWe use the OffloadBinary to contain bundled offloading objects used to\nsupport many images / targets at the same time. The `__tgt_device_info`\nstruct used to contain a pointer to this underlying binary format, which\ncontains information about the triple and architecture. We used to parse\nthis in the runtime to do image verification.\n\nRecent changes removed the need for this to be used internally, as we\njust parse it out of the ELF directly. This patch sets the pointers up\nso they point to the ELF without requiring any further parsing.\n", "feature_layers": ["parse", "runtime", "ir"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "clang/tools/clang-linker-wrapper/OffloadWrapper.cpp", "functions": ["Binary"]}]}
{"pr_number": 76949, "url": "https://github.com/llvm/llvm-project/pull/76949", "title": "[clang] [MinGW] Don't look for a GCC in path if the install base has a proper mingw sysroot", "body": "This fixes uses of the MSYS2 clang64 environment compilers, if another set of GCC based compilers are available further back in PATH (which may be explicitly added, or inherited unintentionally from other software installed).\r\n\r\n(The issue in the clang64 environment can be worked around somewhat by installing *-gcc-compat packages which present aliases named <triple>-gcc within the clang64 environment as well.)\r\n\r\nThis fixes https://github.com/msys2/MINGW-packages/issues/11495 and https://github.com/msys2/MINGW-packages/issues/19279.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Driver/ToolChains/MinGW.cpp", "functions": ["if", "looksLikeMinGWSysroot"]}]}
{"pr_number": 77065, "url": "https://github.com/llvm/llvm-project/pull/77065", "title": "[X86][MC] Compress APX Promoted instrs from evex to legacy encoding to save code size.", "body": "In APX, some instructions in legacy space with map 2/3 and VEX space are promoted into EVEX space for EGPR (R16-R31).\r\nEncoding space changes after the promotion, opcode and opcode map may change too sometimes. For these instructions, we add new entries in TD to avoid overcomplicating the assembler and disassembler.\r\n\r\nDuring instruction selection, the promoted variant is selected first to benefit RA.  But EGPR may not be used, and promoted variant usually has a longer code length. In this patch, we reuse the `EvexToVexInstPass` pass to do the compression and rename it to `CompressEvexInstPass` b/c legacy instruction is not in VEX space.\r\n\r\nRFC: https://discourse.llvm.org/t/rfc-design-for-apx-feature-egpr-and-ndd-support/73031", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/X86/X86EvexToNonEvex.cpp", "functions": ["performCustomAdjustments"]}, {"filename": "llvm/lib/Target/X86/X86MCInstLower.cpp", "functions": ["if"]}, {"filename": "llvm/utils/TableGen/X86EVEX2NonEVEXTablesEmitter.cpp", "functions": ["printEVEX2LegacyTable", "checkMatchable", "operator"]}]}
{"pr_number": 77279, "url": "https://github.com/llvm/llvm-project/pull/77279", "title": "[GlobalISel][IRTranslator] Port switch binary tree search optimization.", "body": "This re-uses some code extracted earlier from SelectionDAG into SwitchLoweringUtils\r\n\r\nMuch of the code is a straight port from SDAG's splitWorkItem(), with minor changes needed for GISel.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp", "functions": ["BBI"]}]}
{"pr_number": 74439, "url": "https://github.com/llvm/llvm-project/pull/74439", "title": "[Sema] Warning for _Float16 passed to format specifier '%f'", "body": "According to https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2844.pdf, default argument promotions for _FloatN types has been removed.\r\n\r\nA warning is needed to notice user to promote _Float16 to double explicitly, and then pass it to format specifier '%f', which is consistent with GCC.\r\n\r\nFixes: https://github.com/llvm/llvm-project/issues/68538", "feature_layers": ["sema"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/Sema/attr-format.c", "functions": ["l", "call_no_default_promotion"]}]}
{"pr_number": 77202, "url": "https://github.com/llvm/llvm-project/pull/77202", "title": "[X86] Support EVEX compression for EGPR", "body": "Compress promoted instruction (EVEX) to pre-promotion instruction (legacy/VEX) when R16-R31 is not used.\r\n\r\nAlternative of #77065\r\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/X86/X86MCInstLower.cpp", "functions": ["if"]}]}
{"pr_number": 76819, "url": "https://github.com/llvm/llvm-project/pull/76819", "title": "[MSSA] Don't require clone creation to succeed", "body": "Sometimes, we create a MemoryAccess for an instruction, which is later simplified (e.g. via devirtualization) such that the new instruction has no memory effects anymore.\r\n\r\nIf we later clone the instruction (e.g. during unswitching), then MSSA will not create a MemoryAccess for the new instruction, triggering an assert.\r\n\r\nDisable the assertion (by passing CreationMustSucceed=false) and adjust getDefiningAccessForClone() to work correctly in that case.\r\n\r\nThis PR implements the alternative suggestion by @alinas from https://github.com/llvm/llvm-project/pull/76142.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Analysis/MemorySSAUpdater.cpp", "functions": ["if"]}]}
{"pr_number": 77078, "url": "https://github.com/llvm/llvm-project/pull/77078", "title": "[lld] [MTE] Allow android note for static executables.", "body": "Florian pointed out that we're accidentally eliding the Android note for\nstatic executables, as it's guarded behind the \"can have memtag globals\"\nconditional. Of course, memtag globals are unsupported for static\nexecutables, but we should still allow static binaries to produce the\nAndroid note (as that's the only way they get MTE).\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "lld/ELF/Writer.cpp", "functions": ["hasMemtag"]}]}
{"pr_number": 75844, "url": "https://github.com/llvm/llvm-project/pull/75844", "title": "[SPIR-V] Add pre-headers to loops.", "body": "This is the first of the 7 steps outlined in #75801. This PR explicitely calls the SimplifyLoops pass. Directly following this pass should follow the 6 others required to structurize the IR.\r\n\r\nRunning this pass could generate empty basic-blocks, which are implicit fallthrough to the successor BB.\r\nThere was a specific condition in the SPIR-V ISel which handled implicit fallthrough, but it couldn't work on empty basic-blocks. This commits removes the old logic, and adds this new logic, which checks all basic-blocks for implicit fallthroughs, including empty ones.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp", "functions": ["isImplicitFallthrough"]}, {"filename": "llvm/lib/Target/SPIRV/SPIRVUtils.cpp", "functions": ["isSpvIntrinsic"]}]}
{"pr_number": 77155, "url": "https://github.com/llvm/llvm-project/pull/77155", "title": "[lldb][DWARFASTParserClang] GetClangDeclForDIE: don't create VarDecl for static data members", "body": "With DWARFv5, C++ static data members are represented as `DW_TAG_variable`s (see `faa3a5ea9ae481da757dab1c95c589e2d5645982`).\r\n\r\nIn GetClangDeclForDIE, when trying to parse the `DW_AT_specification` that a static data member's CU-level `DW_TAG_variable` points to, we would try to `CreateVariableDeclaration`. Whereas previously it was a no-op (for `DW_TAG_member`s). However, adding `VarDecls` to RecordDecls for static data members should always be done in `CreateStaticMemberVariable`. The test-case is an exapmle where we would crash if we tried to create a `VarDecl` from within `GetClangDeclForDIE` for a static data member.\r\n\r\nThis patch simply checks whether the `DW_TAG_variable` being parsed is a static data member, and if so, trivially returns from `GetClangDeclForDIE` (as we previously did for `DW_TAG_member`s).", "feature_layers": ["parse", "ast", "parser"], "feature_directives": ["for"], "files_changed": [{"filename": "lldb/source/Plugins/SymbolFile/DWARF/DWARFASTParserClang.cpp", "functions": ["TagIsRecordType"]}, {"filename": "lldb/test/Shell/SymbolFile/DWARF/Inputs/dwo-static-data-member.cpp", "functions": ["main"]}]}
{"pr_number": 76977, "url": "https://github.com/llvm/llvm-project/pull/76977", "title": "[lldb][DWARFIndex][nfc] Factor out fully qualified name query", "body": "This moves the functionally of finding a DIE based on a fully qualified name from SymbolFileDWARF into DWARFIndex itself, so that specializations of DWARFIndex can implement faster versions of this query.", "feature_layers": ["ast"], "feature_directives": [], "files_changed": [{"filename": "lldb/source/Plugins/SymbolFile/DWARF/DWARFIndex.cpp", "functions": ["GetFullyQualifiedTypeImpl", "callback"]}]}
{"pr_number": 77323, "url": "https://github.com/llvm/llvm-project/pull/77323", "title": "[Clang] Fix IsOverload for function templates", "body": "Functions which correspond but have different template parameter lists are not redeclarations.\r\n\r\nFixes a regression introduced by af4751\r\n\r\n(The patch just moves the template parameters check above if the signature check)\r\n\r\nFixes #76358", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CXX/over/over.load/p2-0x.cpp", "functions": ["f"]}]}
{"pr_number": 76211, "url": "https://github.com/llvm/llvm-project/pull/76211", "title": "Replace print-at-pass-number cl::opt with print-before-pass-number", "body": "The existing option prints the IR after the pass, but it's not clear from its name. In this patch I change the option to print the IR before the pass and change the name to make the behavior clear.\r\n\r\nPrinting the IR before the pass is slightly simpler than after as I don't need to worry about printAfterPassInvalidated case. Either before or after the pass would be ok for the original use case this option was introduced for.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Passes/StandardInstrumentations.cpp", "functions": ["StringRef"]}]}
{"pr_number": 77278, "url": "https://github.com/llvm/llvm-project/pull/77278", "title": "[Sema] Clean up -Wc++11-narrowing-const-reference code after #76094. NFC", "body": "", "feature_layers": ["sema"], "feature_directives": [], "files_changed": [{"filename": "clang/lib/Sema/SemaInit.cpp", "functions": ["NarrowingErrs"]}]}
{"pr_number": 76680, "url": "https://github.com/llvm/llvm-project/pull/76680", "title": "Changed Checks from TriviallyCopyable to TriviallyCopyConstructible", "body": "**Overview:**\r\nThis pull request fixes #47355 where in the Clang compiler's range-loop-analysis incorrectly checks for trivial copyability instead of trivial copy constructibility, leading to erroneous warnings.\r\n\r\n**Changes Made:**\r\n- The changes made in this commit address the issue by introducing a new member function `isTriviallyCopyConstructible` in the `CXXRecordDecl` class and implementing it in the associated files `(clang/include/clang/AST/DeclCXX.h, clang/lib/AST/DeclCXX.cpp)`. Additionally, modifications are made in `clang/include/clang/AST/Type.h` and `clang/lib/AST/Type.cpp` to support the new function. The implementation checks for trivial copy constructibility, distinguishing it from the existing `isTriviallyCopyable` check. The issue in `clang/lib/Sema/SemaStmt.cpp` is also addressed by updating the conditional check in the `DiagnoseForRangeConstVariableCopies` function to use the new `isTriviallyCopyConstructibleType` function. Overall, these changes aim to correct the range-loop-analysis by ensuring it checks for trivial copy constructibility rather than trivial copyability.\r\n\r\n**Testing:**\r\n- Tested the updated code.\r\n- Verified that other functionalities remain unaffected.\r\n![Screenshot from 2024-01-01 19-50-20](https://github.com/llvm/llvm-project/assets/76656712/c664f01a-522e-45e4-8363-39f13d8cc241)\r\n\r\n\r\n**Dependencies:**\r\n- No dependencies on other pull requests.\r\n\r\n**References:**\r\n- https://cplusplus.com/reference/type_traits/is_trivially_copy_constructible/\r\n- https://en.cppreference.com/w/cpp/named_req/CopyConstructible\r\n- https://cplusplus.com/reference/type_traits/is_trivially_copyable/\r\n\r\n**CC:**\r\n- @Endilll , @r4nt , @AaronBallman \r\n", "feature_layers": ["sema", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/SemaCXX/warn-range-loop-analysis-trivially-copyable.cpp", "functions": ["test_TriviallyCopyConstructible_64_bytes", "test_TriviallyCopyConstructible_65_bytes"]}, {"filename": "clang/lib/StaticAnalyzer/Checkers/BasicObjCFoundationChecks.cpp", "functions": ["BugType"]}, {"filename": "clang/lib/StaticAnalyzer/Checkers/BlockInCriticalSectionChecker.cpp", "functions": ["IILockGuard"]}, {"filename": "clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp", "functions": ["BugType", "NSObjectII"]}, {"filename": "clang/lib/StaticAnalyzer/Checkers/CloneChecker.cpp", "functions": ["BugType"]}, {"filename": "clang/lib/StaticAnalyzer/Checkers/DivZeroChecker.cpp", "functions": ["BugType"]}, {"filename": "clang/lib/StaticAnalyzer/Checkers/DynamicTypeChecker.cpp", "functions": ["BugType", "initBugType"]}, {"filename": "clang/lib/StaticAnalyzer/Checkers/EnumCastOutOfRangeChecker.cpp", "functions": ["BugType"]}, {"filename": "clang/lib/StaticAnalyzer/Checkers/InvalidatedIteratorChecker.cpp", "functions": ["verifyAccess"]}, {"filename": "clang/lib/StaticAnalyzer/Checkers/IteratorRangeChecker.cpp", "functions": ["isZero"]}, {"filename": "clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp", "functions": ["initBugType"]}, {"filename": "clang/lib/StaticAnalyzer/Checkers/MismatchedIteratorChecker.cpp", "functions": ["verifyMatch"]}, {"filename": "clang/lib/StaticAnalyzer/Checkers/ObjCAtSyncChecker.cpp", "functions": ["BugType"]}, {"filename": "clang/lib/StaticAnalyzer/Checkers/ObjCContainersChecker.cpp", "functions": ["initBugType"]}, {"filename": "clang/lib/StaticAnalyzer/Checkers/ObjCSuperDeallocChecker.cpp", "functions": ["IIdealloc"]}, {"filename": "clang/lib/StaticAnalyzer/Checkers/SimpleStreamChecker.cpp", "functions": ["BugType", "OpenFn"]}, {"filename": "clang/lib/StaticAnalyzer/Checkers/UndefBranchChecker.cpp", "functions": ["BugType", "FindIt"]}, {"filename": "clang/lib/StaticAnalyzer/Checkers/UndefCapturedBlockVarChecker.cpp", "functions": ["BugType"]}, {"filename": "clang/lib/StaticAnalyzer/Checkers/UndefResultChecker.cpp", "functions": ["BugType"]}, {"filename": "clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp", "functions": ["BT_uninitField"]}, {"filename": "clang/lib/StaticAnalyzer/Checkers/VLASizeChecker.cpp", "functions": ["BugType"]}, {"filename": "clang/unittests/StaticAnalyzer/CallEventTest.cpp", "functions": ["BT_uninitField"]}, {"filename": "clang/lib/StaticAnalyzer/Checkers/IteratorModeling.cpp", "functions": ["removeIteratorPosition"]}, {"filename": "libcxx/test/libcxx/ranges/range.adaptors/range.chunk.by/no_unique_address.compile.pass.cpp", "functions": ["begin", "end", "operator"]}, {"filename": "libcxx/test/libcxx/ranges/range.adaptors/range.move.wrap/empty_object.pass.cpp", "functions": ["main"]}, {"filename": "libcxx/test/libcxx/ranges/range.adaptors/range.move.wrap/no_unique_address.pass.cpp", "functions": ["MoveOnlyNotAssignable", "constexpr", "test_no_unique_address", "MoveOnly", "main", "NotCopyAssignable", "NotMoveAssignable"]}, {"filename": "libcxx/test/std/ranges/range.adaptors/range.lazy.split/ctor.range.pass.cpp", "functions": ["times_copied", "RangeWithCounting"]}, {"filename": "libcxx/test/std/ranges/ranges_robust_against_no_unique_address.pass.cpp", "functions": ["begin", "end", "main", "operator", "test", "testOne"]}, {"filename": "clang/test/CodeGen/aarch64-sme-intrinsics/acle_sme_state_funs.c", "functions": ["test_has_sme", "__arm_has_sme", "test_za_disable", "__arm_in_streaming_mode", "test_svundef_za", "test_in_streaming_mode"]}, {"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_qcvtn.c", "functions": ["test_qcvtn_u16_u32_x2", "test_qcvtn_s16_s32_x2", "test_qcvtn_u16_s32_x2"]}, {"filename": "llvm/lib/Analysis/LazyValueInfo.cpp", "functions": ["getValueFromICmpCondition", "getValueFromSimpleICmpCondition", "getValueFromCondition", "if", "intersect"]}, {"filename": "llvm/lib/Target/AArch64/AArch64ISelLowering.cpp", "functions": ["getPTrue"]}, {"filename": "llvm/lib/Target/Hexagon/HexagonISelLowering.cpp", "functions": ["Flags"]}, {"filename": "llvm/lib/Target/PowerPC/PPCISelLowering.cpp", "functions": ["SDValue", "Flags"]}, {"filename": "llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp", "functions": ["isImmTy", "isWaitVAVDst", "isWaitVMVSrc"]}, {"filename": "llvm/unittests/Target/RISCV/RISCVInstrInfoTest.cpp", "functions": ["OS", "expectDIEPrintResult"]}, {"filename": "clang/test/SemaCXX/crash-GH76228.cpp", "functions": ["a1", "a2", "a4", "a5"]}, {"filename": "clang/test/SemaCXX/paren-list-agg-init.cpp", "functions": ["c"]}, {"filename": "llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp", "functions": ["replaceInstUsesWith"]}, {"filename": "mlir/lib/Dialect/EmitC/IR/EmitC.cpp", "functions": ["success", "get", "Attribute", "emitError", "Type"]}, {"filename": "libc/src/stdio/generic/puts.cpp", "functions": ["lock"]}, {"filename": "llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp", "functions": ["if", "isConstantSplatVector"]}, {"filename": "flang/lib/Semantics/resolve-names.cpp", "functions": ["FinishExecutionParts", "Pre"]}, {"filename": "flang/lib/Evaluate/tools.cpp", "functions": ["IsNotifyType", "IsBuiltinDerivedType"]}, {"filename": "clang/lib/CodeGen/CGStmtOpenMP.cpp", "functions": ["if"]}, {"filename": "clang/test/OpenMP/atomic_compare_codegen.cpp", "functions": ["fail_dxevd"]}, {"filename": "mlir/lib/Dialect/Tensor/Transforms/PackAndUnpackPatterns.cpp", "functions": ["failure", "success"]}, {"filename": "flang/lib/Lower/IO.cpp", "functions": ["genIOUnit"]}, {"filename": "llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp", "functions": ["ignoresVXRM"]}, {"filename": "llvm/lib/Transforms/Coroutines/CoroFrame.cpp", "functions": ["if"]}, {"filename": "lldb/tools/lldb-dap/JSONUtils.cpp", "functions": ["v", "TryCreateAutoSummary", "ValueToString", "CreateUniqueVariableNameForDisplay", "strm", "desc", "os_display_value"]}, {"filename": "lldb/tools/lldb-dap/lldb-dap.cpp", "functions": ["desc"]}, {"filename": "clang/lib/Driver/ToolChains/Darwin.cpp", "functions": ["P"]}, {"filename": "flang/lib/Lower/Bridge.cpp", "functions": ["genFIR"]}, {"filename": "flang/lib/Parser/unparse.cpp", "functions": ["Before", "Unparse"]}, {"filename": "polly/lib/Transform/ScheduleOptimizer.cpp", "functions": ["MaxOpGuard"]}, {"filename": "mlir/lib/Conversion/TosaToLinalg/TosaToLinalg.cpp", "functions": ["success"]}, {"filename": "mlir/lib/Conversion/TosaToLinalg/TosaToLinalgNamed.cpp", "functions": ["failure", "success"]}, {"filename": "mlir/lib/Dialect/GPU/Transforms/SubgroupReduceLowering.cpp", "functions": ["success", "OpRewritePattern"]}, {"filename": "mlir/lib/Dialect/GPU/Transforms/Utils.cpp", "functions": ["convertReductionKind"]}, {"filename": "mlir/test/lib/Dialect/GPU/TestGpuRewrite.cpp", "functions": ["PassWrapper"]}, {"filename": "llvm/lib/Transforms/Scalar/ConstraintElimination.cpp", "functions": ["UpperConstantOffset"]}, {"filename": "mlir/lib/Dialect/Linalg/IR/LinalgInterfaces.cpp", "functions": ["failure", "iterators", "inferContractionDimsImpl"]}, {"filename": "mlir/lib/Dialect/SparseTensor/Transforms/SparseGPUCodegen.cpp", "functions": ["isAdmissible24", "isConversionInto24", "isDenseTensor"]}, {"filename": "openmp/libomptarget/plugins-nextgen/cuda/src/rtl.cpp", "functions": ["cuMemAllocAsync", "cuMemFreeAsync"]}, {"filename": "llvm/lib/Object/WasmObjectFile.cpp", "functions": ["getDefinedFunction", "getSymbolValue"]}, {"filename": "clang/lib/Analysis/UnsafeBufferUsage.cpp", "functions": ["classof", "getClaimedVarUseSites", "WarningGadget", "matcher"]}, {"filename": "clang/test/SemaCXX/warn-unsafe-buffer-usage-warning-data-invocation.cpp", "functions": ["data", "hello", "foo", "false_negatives", "subspan", "not_warned_patterns", "cast_without_data", "other_classes", "warned_patterns"]}, {"filename": "mlir/lib/Dialect/Mesh/IR/MeshOps.cpp", "functions": ["failure", "success", "isUnique", "emitError"]}, {"filename": "mlir/lib/Dialect/Mesh/Transforms/Spmdization.cpp", "functions": ["resShapeArr", "shardDimension", "ceilDiv", "sourceShardingPartialAxesSet", "dynamicOffsets", "shardCount", "staticOffsets", "implicitLocOpBuilder", "reshardingRegisterDependentDialects", "unshardDimension", "targetShardingPartialAxesSet"]}, {"filename": "mlir/test/lib/Dialect/Mesh/TestReshardingSpmdization.cpp", "functions": ["runOnOperation", "success", "getArgument", "registerTestMeshReshardingSpmdizationPass", "signalPassFailure", "patterns", "failure", "builder", "getDependentDialects", "getDescription"]}, {"filename": "mlir/tools/mlir-opt/mlir-opt.cpp", "functions": ["registerTestAffineWalk", "registerTestGpuLoweringPasses", "registerTestAffineLoopUnswitchingPass"]}, {"filename": "llvm/lib/Transforms/Utils/SimplifyCFG.cpp", "functions": ["SIW"]}, {"filename": "llvm/lib/Target/RISCV/RISCVISelLowering.cpp", "functions": ["getLMULCost"]}, {"filename": "llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp", "functions": ["fewerElementsVectorSeqReductions"]}, {"filename": "llvm/unittests/CodeGen/GlobalISel/LegalizerHelperTest.cpp", "functions": ["DummyLocObserver"]}, {"filename": "llvm/examples/OrcV2Examples/LLJITWithRemoteDebugging/LLJITWithRemoteDebugging.cpp", "functions": ["JTMB"]}, {"filename": "llvm/examples/OrcV2Examples/LLJITWithRemoteDebugging/RemoteJITUtils.cpp", "functions": ["createStringError", "addDebugSupport"]}, {"filename": "clang/test/Analysis/errno-stdlibraryfunctions.c", "functions": ["lseek", "__typeof", "errno_mkstemp", "typeof", "errno_mkdtemp", "send"]}, {"filename": "llvm/lib/Target/X86/X86ISelLowering.cpp", "functions": ["DL"]}, {"filename": "clang-tools-extra/clangd/unittests/DiagnosticsTests.cpp", "functions": ["final_suspend", "unhandled_exception", "return_value", "from_promise", "foo_coro", "await_suspend", "address", "initial_suspend", "from_address", "await_ready", "get_return_object", "await_resume"]}, {"filename": "mlir/unittests/IR/OpPropertiesTest.cpp", "functions": ["os"]}, {"filename": "clang/test/SemaCXX/template-instantiation.cpp", "functions": ["bar", "foo"]}, {"filename": "llvm/lib/CodeGen/RegisterCoalescer.cpp", "functions": ["updateRegDefsUses", "MIB"]}, {"filename": "mlir/lib/Pass/Pass.cpp", "functions": ["getOpAnchorName"]}, {"filename": "mlir/lib/Pass/PassCrashRecovery.cpp", "functions": ["state", "passOS"]}, {"filename": "mlir/include/mlir/IR/PDLPatternMatch.h.inc", "functions": ["success", "getKindOf", "bool", "getModule", "failure", "processAsArg", "getTypeID", "clear", "dyn_cast", "classof", "processResults", "addConfig", "registerRewriteFunction", "cast", "takeConstraintFunctions", "getConfigID", "print", "storage", "mergeIn", "errorFn", "notifyRewriteEnd", "PDLPatternModule", "getKind", "attachConfigToPatterns", "pdlModule", "takeRewriteFunctions", "push_back", "isa", "takeConfigs", "value", "notifyRewriteBegin"]}, {"filename": "clang/lib/Sema/SemaDecl.cpp", "functions": ["SourceRange", "TemplateArgsPtr"]}, {"filename": "clang/test/CXX/temp/temp.decls/temp.variadic/p5.cpp", "functions": ["InnerFunction", "PrimaryFunction"]}, {"filename": "llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp", "functions": ["haveNoCommonBitsSet"]}, {"filename": "mlir/lib/Conversion/GPUCommon/GPUOpsLowering.cpp", "functions": ["NamedAttrList"]}, {"filename": "llvm/lib/Transforms/Vectorize/LoopVectorize.cpp", "functions": ["if", "fixCrossIterationPHIs", "RdxParts", "FMFG"]}, {"filename": "llvm/lib/Target/AMDGPU/MCTargetDesc/AMDGPUInstPrinter.cpp", "functions": ["if", "formatHex"]}, {"filename": "llvm/lib/Target/AMDGPU/MCTargetDesc/AMDGPUMCCodeEmitter.cpp", "functions": ["getLit16IntEncoding", "getLit32Encoding", "getLit16Encoding"]}, {"filename": "llvm/lib/Target/AMDGPU/SIFoldOperands.cpp", "functions": ["if", "tryFoldImmWithOpSel"]}, {"filename": "llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.cpp", "functions": ["getInlineEncodingV2F16", "isFoldableLiteralV216", "isInlinableLiteralV216", "getInlineEncodingV2I16", "getInlineEncodingV216", "isInlinableLiteralV2I16", "isInlinableIntLiteral", "isInlinableLiteralV2F16", "isInlinableIntLiteralV216"]}, {"filename": "mlir/lib/Dialect/Mesh/Interfaces/ShardingInterface.cpp", "functions": ["splitAxes"]}, {"filename": "llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp", "functions": ["if"]}, {"filename": "mlir/unittests/Dialect/Linalg/LinalgInterfacesTest.cpp", "functions": ["b"]}, {"filename": "llvm/lib/Transforms/InstCombine/InstructionCombining.cpp", "functions": ["replaceOperand"]}, {"filename": "clang/test/CodeGen/avr/avr-unsupported-inline-asm-constraints.c", "functions": ["volatile"]}, {"filename": "clang/test/Analysis/stream-error.c", "functions": ["error_fputc", "error_fdopen"]}, {"filename": "clang/test/Analysis/stream-non-posix-function.c", "functions": ["test_fdopen_non_posix"]}, {"filename": "clang/test/Analysis/stream-note.c", "functions": ["check_note_fdopen"]}, {"filename": "clang/test/Analysis/stream-stdlibraryfunctionargs.c", "functions": ["test_fdopen"]}, {"filename": "clang/test/Analysis/stream.c", "functions": ["f_dopen"]}, {"filename": "llvm/lib/Analysis/InlineCost.cpp", "functions": ["TypeSize"]}, {"filename": "mlir/lib/Analysis/DataFlow/DenseAnalysis.cpp", "functions": ["setToExitState"]}, {"filename": "mlir/unittests/Bytecode/BytecodeTest.cpp", "functions": ["getDialectNamespace", "os", "getAttributeNames", "config", "TestOpPropertiesDialect", "Dialect", "ArrayRef", "getOperationName", "StringLiteral"]}, {"filename": "llvm/lib/CodeGen/TargetLoweringBase.cpp", "functions": ["getOutlineAtomicHelper"]}, {"filename": "clang/lib/Sema/SemaTemplateInstantiate.cpp", "functions": ["TransformLambdaBody"]}, {"filename": "clang/test/SemaTemplate/concepts-out-of-line-def.cpp", "functions": ["foo"]}, {"filename": "llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp", "functions": ["if"]}, {"filename": "llvm/lib/Target/AMDGPU/AMDGPUMachineFunction.cpp", "functions": ["hasLDSKernelArgument", "KernelDynLDSName"]}, {"filename": "clang/lib/AST/Type.cpp", "functions": ["isTriviallyCopyableTypeImpl"]}, {"filename": "clang/utils/TableGen/ClangASTNodesEmitter.cpp", "functions": ["macroHierarchyName", "DeclContexts", "Records"]}, {"filename": "llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp", "functions": ["SL", "DL"]}, {"filename": "llvm/lib/Target/AMDGPU/SIISelLowering.cpp", "functions": ["SL", "lowerFP_EXTEND"]}, {"filename": "clang-tools-extra/test/clang-doc/templates.cpp", "functions": ["function"]}, {"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_cntp.c", "functions": ["test_svcntp_c16_vlx4", "test_svcntp_c32_vlx4", "test_svcntp_c64_vlx2", "test_svcntp_c64_vlx4", "test_svcntp_c16_vlx2", "test_svcntp_c8_vlx4", "test_svcntp_c32_vlx2", "test_svcntp_c8_vlx2"]}, {"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_fclamp.c", "functions": ["test_svclamp_f64", "test_svclamp_f16", "test_svclamp_f32"]}, {"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_pfalse.c", "functions": ["test_svpfalse_c"]}, {"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_psel.c", "functions": ["test_svpsel_lane_b16", "test_svpsel_lane_b8", "test_svpsel_lane_c16", "test_svpsel_lane_c32", "test_svpsel_lane_b64", "test_svpsel_lane_b32", "test_svpsel_lane_c8", "test_svpsel_lane_c64"]}, {"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_sclamp.c", "functions": ["test_svclamp_s32", "test_svclamp_s16", "test_svclamp_s64", "test_svclamp_s8"]}, {"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_uclamp.c", "functions": ["test_svclamp_u8", "test_svclamp_u16", "test_svclamp_u64", "test_svclamp_u32"]}, {"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_while_pn.c", "functions": ["test_svwhilels_c32_vl4", "test_svwhilelt_c8_vl4", "test_svwhilegt_c8_vl2", "test_svwhilegt_c64_vl2", "test_svwhilele_c64_vl4", "test_svwhilehi_c16_vl2", "test_svwhilelt_c16_vl4", "test_svwhilehs_c64_vl2", "test_svwhilehs_c64_vl4", "test_svwhilele_c8_vl2", "test_svwhilelt_c32_vl2", "test_svwhilelt_c64_vl4", "test_svwhilegt_c64_vl4", "test_svwhilege_c32_vl2", "test_svwhilegt_c32_vl2", "test_svwhilegt_c32_vl4", "test_svwhilelo_c8_vl2", "test_svwhilelo_c32_vl4", "test_svwhilehs_c16_vl2", "test_svwhilelo_c16_vl2", "test_svwhilehs_c16_vl4", "test_svwhilehi_c32_vl2", "test_svwhilele_c64_vl2", "test_svwhilelo_c8_vl4", "test_svwhilels_c8_vl2", "test_svwhilege_c8_vl2", "test_svwhilelo_c32_vl2", "test_svwhilehi_c64_vl2", "test_svwhilelt_c32_vl4", "test_svwhilelo_c64_vl4", "test_svwhilehi_c8_vl2", "test_svwhilels_c16_vl4", "test_svwhilels_c32_vl2", "test_svwhilele_c16_vl4", "test_svwhilehs_c8_vl4", "test_svwhilegt_c16_vl2", "test_svwhilels_c8_vl4", "test_svwhilehi_c64_vl4", "test_svwhilels_c16_vl2", "test_svwhilehi_c8_vl4", "test_svwhilels_c64_vl4", "test_svwhilege_c16_vl2", "test_svwhilele_c32_vl2", "test_svwhilelt_c8_vl2", "test_svwhilegt_c8_vl4", "test_svwhilehs_c32_vl4", "test_svwhilehs_c32_vl2", "test_svwhilehi_c32_vl4", "test_svwhilege_c8_vl4", "test_svwhilelo_c64_vl2", "test_svwhilege_c64_vl4", "test_svwhilehs_c8_vl2", "test_svwhilelo_c16_vl4", "test_svwhilelt_c16_vl2", "test_svwhilege_c32_vl4", "test_svwhilege_c64_vl2", "test_svwhilele_c16_vl2", "test_svwhilels_c64_vl2", "test_svwhilelt_c64_vl2", "test_svwhilegt_c16_vl4", "test_svwhilele_c8_vl4", "test_svwhilege_c16_vl4", "test_svwhilehi_c16_vl4", "test_svwhilele_c32_vl4"]}, {"filename": "clang/test/Sema/aarch64-sme2-intrinsics/acle_sme2_imm.cpp", "functions": ["test_bfmlslb_bad_lane"]}, {"filename": "clang/test/Sema/aarch64-sme2-sve2p1-diagnostics.c", "functions": ["svldnt1_s64_x4", "sme2_or_sve2p1_intrinsic_test_sme2", "svldnt1_u8_x2", "sme2_or_sve2p1_intrinsic_test_both_arm_streaming", "svldnt1_u32_x2", "svldnt1_s16_x4", "sme2_or_sve2p1_intrinsic_test_sve2p1", "sme2_or_sve2p1_intrinsic_test_both_no_arm_streaming", "sme2_or_sve2p1_intrinsic_test_sme2_invalid"]}, {"filename": "clang/utils/TableGen/SveEmitter.cpp", "functions": ["if"]}, {"filename": "lldb/source/Plugins/SymbolFile/DWARF/SymbolFileDWARF.cpp", "functions": ["GetTypeUnitSupportFiles", "file", "SupportFile", "source_ref"]}, {"filename": "lldb/test/API/functionalities/inline-sourcefile/main.c", "functions": ["stop", "main", "f"]}, {"filename": "clang/test/SemaTemplate/concepts-lambda.cpp", "functions": ["f1", "requires", "foo"]}, {"filename": "clang/lib/CodeGen/CodeGenFunction.cpp", "functions": ["EmitBranchToCounterBlock"]}, {"filename": "clang/lib/CodeGen/CodeGenPGO.cpp", "functions": ["MappingGen", "Walker", "dataTraverseStmtPost", "dataTraverseStmtPre"]}, {"filename": "clang/lib/CodeGen/CoverageMappingGen.cpp", "functions": ["createBranchRegion", "getCondID", "Count", "popAndReturnCondCount", "isLAnd", "CoverageMappingBuilder", "if", "popRHSifTop", "CGM", "MCDCParams", "popRHS", "Walker", "getNextLOrCondID", "getRegionBitmap", "createDecisionRegion", "getNextLAndCondID", "pushAndAssignIDs", "isMCDCDecision", "pushRHS"]}, {"filename": "clang/test/CoverageMapping/branch-constfolded.cpp", "functions": ["for_2", "for_1", "fand_5", "fand_3", "fand_2", "for_3", "fand_0", "fand_7", "for_8", "constexpr", "for_7", "fand_4", "for_6", "for_0", "fand_1", "fand_6", "for_5", "for_4"]}, {"filename": "clang/test/CoverageMapping/logical.cpp", "functions": ["main"]}, {"filename": "clang/test/CoverageMapping/mcdc-class.cpp", "functions": ["getValue", "bar", "foo", "setValue"]}, {"filename": "clang/test/CoverageMapping/mcdc-error-conditions.cpp", "functions": ["func_conditions"]}, {"filename": "clang/test/CoverageMapping/mcdc-error-nests.cpp", "functions": ["func_split_nest", "bar"]}, {"filename": "clang/test/CoverageMapping/mcdc-logical-scalar-ids.cpp", "functions": ["func_scalar_and", "func_scalar_or", "bar", "func_scalar_mix"]}, {"filename": "clang/test/CoverageMapping/mcdc-logical-stmt-ids-all.cpp", "functions": ["func_do_or", "func_do_and", "func_for_and", "func_while_or", "func_ternary_and", "func_if_or", "func_while_and", "func_if_and", "func_for_or", "func_ternary_or"]}, {"filename": "clang/test/CoverageMapping/mcdc-logical-stmt-ids.cpp", "functions": ["func_if_mix", "func_if_or", "func_if_and"]}, {"filename": "clang/test/Profile/c-mcdc-class.cpp", "functions": ["getValue", "bar", "foo", "setValue"]}, {"filename": "clang/test/Profile/c-mcdc-nested-ternary.c", "functions": ["test"]}, {"filename": "clang/test/Profile/c-mcdc-not.c", "functions": ["test"]}, {"filename": "clang/test/Profile/c-mcdc.c", "functions": ["test"]}, {"filename": "compiler-rt/test/profile/ContinuousSyncMode/image-with-mcdc.c", "functions": ["main", "__llvm_profile_is_continuous_mode_enabled"]}, {"filename": "llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp", "functions": ["VPWidenCastRecipe"]}, {"filename": "llvm/lib/Target/RISCV/MCA/RISCVCustomBehaviour.cpp", "functions": ["opcodeHasEEWAndEMULInfo"]}, {"filename": "mlir/test/lib/Dialect/Test/TestDialect.cpp", "functions": ["failure", "success"]}, {"filename": "libc/startup/linux/aarch64/start.cpp", "functions": ["call_fini_array_callbacks", "call_init_array_callbacks", "init_tls", "set_thread_ptr", "cleanup_tls"]}, {"filename": "libc/startup/linux/aarch64/tls.cpp", "functions": ["init_tls", "cleanup_tls", "set_thread_ptr"]}, {"filename": "libc/startup/linux/do_start.cpp", "functions": ["call_fini_array_callbacks", "call_init_array_callbacks", "do_start"]}, {"filename": "libc/startup/linux/riscv/start.cpp", "functions": ["call_fini_array_callbacks", "call_init_array_callbacks", "init_tls", "set_thread_ptr", "cleanup_tls"]}, {"filename": "libc/startup/linux/riscv/tls.cpp", "functions": ["init_tls", "cleanup_tls", "set_thread_ptr"]}, {"filename": "libc/startup/linux/x86_64/start.cpp", "functions": ["call_fini_array_callbacks", "call_init_array_callbacks", "init_tls", "__volatile__", "set_thread_ptr", "cleanup_tls", "volatile"]}, {"filename": "libc/startup/linux/x86_64/tls.cpp", "functions": ["syscall_impl", "init_tls", "cleanup_tls", "set_thread_ptr"]}, {"filename": "compiler-rt/lib/orc/tests/unit/simple_packed_serialization_test.cpp", "functions": ["OB", "blobSerializationRoundTrip", "IB"]}, {"filename": "llvm/lib/ExecutionEngine/Orc/EPCGenericDylibManager.cpp", "functions": ["Result"]}, {"filename": "llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp", "functions": ["if", "RdxParts", "FMFG"]}, {"filename": "mlir/lib/Dialect/OpenACC/IR/OpenACC.cpp", "functions": ["emitOpError", "success", "getTileValues", "getValuesFromSegments", "getValueInDeviceTypeSegment", "getGangValue", "hasIndependent", "failure", "if", "checkDeviceTypes", "getVectorValue", "getWorkerValue", "arrayAttr", "emitError", "getCollapseValue"]}, {"filename": "mlir/lib/IR/AffineExpr.cpp", "functions": ["visitAffineBinaryOpExpr", "visitSymbolExpr", "AffineExprWalker", "visitDimExpr", "callback", "visitConstantExpr"]}, {"filename": "mlir/test/lib/IR/TestAffineWalk.cpp", "functions": ["registerTestAffineWalk", "runOnOperation", "getArgument", "getDescription", "checkMod"]}, {"filename": "llvm/lib/CodeGen/SelectionDAG/LegalizeFloatTypes.cpp", "functions": ["DL", "GetPromotionOpcodeStrict"]}, {"filename": "llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp", "functions": ["dl"]}, {"filename": "llvm/lib/Target/LoongArch/AsmParser/LoongArchAsmParser.cpp", "functions": ["isSImm20pcaddu18i"]}, {"filename": "llvm/lib/Target/LoongArch/LoongArchExpandPseudoInsts.cpp", "functions": ["expandLoadAddressGot", "expandLoadAddressTLSGD", "expandFunctionCALL", "expandLoadAddressGotLarge", "expandLoadAddressTLSIELarge", "expandLoadAddressPcrelLarge", "expandLoadAddressTLSLD", "expandLoadAddressTLSIE", "expandLoadAddressTLSLDLarge", "expandLoadAddressPcrel", "expandLoadAddressTLSGDLarge"]}, {"filename": "llvm/lib/Target/SPIRV/SPIRVEmitIntrinsics.cpp", "functions": ["insertPtrCastInstr"]}, {"filename": "llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp", "functions": ["isGPRF64AsFPR", "isGPRPF64AsFPR"]}, {"filename": "llvm/lib/CodeGen/BasicBlockPathCloning.cpp", "functions": ["ApplyCloning"]}, {"filename": "llvm/lib/CodeGen/BasicBlockSectionsProfileReader.cpp", "functions": ["BasicBlockSectionsProfileReader", "BasicBlockSectionsProfileReaderWrapperPass"]}, {"filename": "llvm/lib/CodeGen/CodeGenPrepare.cpp", "functions": ["CodeGenPrepareLegacyPass", "getPassName", "getAnalysisUsage", "runOnFunction", "run", "releaseMemory", "_run", "CGP"]}, {"filename": "llvm/lib/Target/X86/X86ISelLoweringCall.cpp", "functions": ["SDValue"]}, {"filename": "mlir/lib/Dialect/Linalg/Transforms/DecomposeLinalgOps.cpp", "functions": ["g"]}, {"filename": "mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp", "functions": ["PatternRewriter", "g", "folder"]}, {"filename": "clang/test/SemaCXX/coro-lifetimebound.cpp", "functions": ["foo", "foo_wrapper", "caller"]}, {"filename": "clang-tools-extra/include-cleaner/tool/IncludeCleaner.cpp", "functions": ["toString", "HeaderFilter"]}, {"filename": "libcxx/test/std/containers/views/views.span/span.elem/at.pass.cpp", "functions": ["test_exceptions", "main", "testSpanAt", "test", "decltype"]}, {"filename": "libcxx/src/fstream.cpp", "functions": ["__filebuf_windows_native_handle"]}, {"filename": "libcxx/test/std/input.output/file.streams/fstreams/filebuf.members/native_handle.assert.pass.cpp", "functions": ["main"]}, {"filename": "libcxx/test/std/input.output/file.streams/fstreams/filebuf.members/native_handle.pass.cpp", "functions": ["decltype", "test", "main"]}, {"filename": "libcxx/test/std/input.output/file.streams/fstreams/fstream.members/native_handle.assert.pass.cpp", "functions": ["main"]}, {"filename": "libcxx/test/std/input.output/file.streams/fstreams/fstream.members/native_handle.pass.cpp", "functions": ["main"]}, {"filename": "libcxx/test/std/input.output/file.streams/fstreams/ifstream.members/native_handle.assert.pass.cpp", "functions": ["main"]}, {"filename": "libcxx/test/std/input.output/file.streams/fstreams/ifstream.members/native_handle.pass.cpp", "functions": ["main"]}, {"filename": "libcxx/test/std/input.output/file.streams/fstreams/ofstream.members/native_handle.assert.pass.cpp", "functions": ["main"]}, {"filename": "libcxx/test/std/input.output/file.streams/fstreams/ofstream.members/native_handle.pass.cpp", "functions": ["main"]}, {"filename": "llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp", "functions": ["Guard"]}, {"filename": "mlir/lib/Dialect/GPU/Pipelines/GPUToNVVMPipeline.cpp", "functions": ["registerGPUToNVVMPipeline"]}, {"filename": "clang/test/SemaCXX/deduced-return-type-cxx14.cpp", "functions": ["parsePrimaryExpr", "parseMulExpr3", "foo", "parse", "f", "parseMulExpr2", "parseMulExpr"]}, {"filename": "clang/test/SemaCXX/cxx1y-init-captures.cpp", "functions": ["h"]}, {"filename": "third-party/benchmark/src/timers.cc", "functions": ["ProcessCPUUsage"]}, {"filename": "libc/test/src/math/smoke/nan_test.cpp", "functions": ["run_test"]}, {"filename": "libc/test/src/math/smoke/nanf_test.cpp", "functions": ["run_test"]}, {"filename": "libc/test/src/math/smoke/nanl_test.cpp", "functions": ["run_test"]}, {"filename": "clang/test/CodeGen/X86/fp128-abi.c", "functions": ["h3", "h4", "h1", "h2"]}, {"filename": "llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp", "functions": ["emitEntry"]}, {"filename": "llvm/lib/IR/AsmWriter.cpp", "functions": ["processDPValueMetadata"]}, {"filename": "llvm/utils/TableGen/MacroFusionPredicatorEmitter.cpp", "functions": ["run", "PE", "if"]}, {"filename": "llvm/utils/TableGen/PredicateExpander.cpp", "functions": ["expandCheckIsVRegOperand"]}, {"filename": "clang/test/SemaCXX/dependent-noexcept-uninstantiated.cpp", "functions": ["f1"]}, {"filename": "llvm/lib/Object/ObjectFile.cpp", "functions": ["if"]}, {"filename": "lldb/test/API/commands/expression/nested/main.cpp", "functions": ["foo", "main"]}, {"filename": "clang/lib/Parse/ParseOpenACC.cpp", "functions": ["ParseOpenACCClauseParams", "expectIdentifierOrKeyword", "ClauseHasRequiredParens", "getOpenACCDefaultClauseKind"]}, {"filename": "clang/test/ParserOpenACC/parse-clauses.c", "functions": ["DefaultClause"]}, {"filename": "llvm/lib/IR/AutoUpgrade.cpp", "functions": ["vstRegex", "LdRegex", "CreateTupleRegex"]}, {"filename": "clang/tools/clang-linker-wrapper/OffloadWrapper.cpp", "functions": ["Binary"]}, {"filename": "clang-tools-extra/clang-tidy/readability/AvoidReturnWithVoidValueCheck.cpp", "functions": ["ClangTidyCheck"]}, {"filename": "clang-tools-extra/test/clang-tidy/checkers/readability/avoid-return-with-void-value.cpp", "functions": ["f7", "f3", "f9", "f5", "f8", "f11", "f10", "f1", "f6", "f4", "f2", "f12", "f13"]}, {"filename": "llvm/lib/ExecutionEngine/Orc/EPCDynamicLibrarySearchGenerator.cpp", "functions": ["AddAbsoluteSymbols"]}, {"filename": "llvm/lib/ExecutionEngine/Orc/ExecutionUtils.cpp", "functions": ["AddAbsoluteSymbols"]}, {"filename": "llvm/unittests/ExecutionEngine/Orc/ObjectLinkingLayerTest.cpp", "functions": ["notifyFailed", "loadDylib", "notifyRemovingResources"]}, {"filename": "mlir/lib/Target/SPIRV/Deserialization/Deserializer.cpp", "functions": ["if"]}, {"filename": "clang/lib/Sema/SemaDeclAttr.cpp", "functions": ["handleCodeModelAttr"]}, {"filename": "clang/test/CodeGen/LoongArch/attributes.cpp", "functions": ["use2", "void", "__attribute__", "use1"]}, {"filename": "clang/test/Sema/attr-model.cpp", "functions": ["__attribute"]}, {"filename": "compiler-rt/lib/sanitizer_common/sanitizer_symbolizer_report.cpp", "functions": ["FrameIsInternal"]}, {"filename": "compiler-rt/lib/tsan/rtl/tsan_report.cpp", "functions": ["FrameIsInternal"]}, {"filename": "llvm/lib/CodeGen/ShadowStackGCLowering.cpp", "functions": ["EE", "getAnalysisUsage", "runOnFunction", "DTU", "doInitialization"]}, {"filename": "llvm/lib/Analysis/MemoryBuiltins.cpp", "functions": ["SizeOffsetAPInt", "APInt", "SizeOffsetValue", "Known", "SizeOffsetType", "getSizeWithOverflow", "combineSizeOffset", "unknown"]}, {"filename": "compiler-rt/lib/asan/asan_suppressions.cpp", "functions": ["symbolized_stack"]}, {"filename": "compiler-rt/lib/sanitizer_common/sanitizer_stacktrace_libcdep.cpp", "functions": ["ExtendDedupToken"]}, {"filename": "llvm/unittests/Object/ELFObjectFileTest.cpp", "functions": ["E5"]}, {"filename": "llvm/lib/Target/X86/X86CompressEVEX.cpp", "functions": ["ArrayRef", "CompressEVEXImpl", "CompressEvexToVexImpl"]}, {"filename": "llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp", "functions": ["getAddr"]}, {"filename": "llvm/utils/TableGen/X86CompressEVEXTablesEmitter.cpp", "functions": ["NewRI", "EVEXRI", "operator", "OldRI", "VEXRI"]}, {"filename": "mlir/lib/Dialect/GPU/IR/GPUDialect.cpp", "functions": ["emitOpError", "success", "sizesRef", "failure", "regionArgsRef"]}, {"filename": "clang-tools-extra/test/clang-tidy/checkers/cppcoreguidelines/missing-std-forward.cpp", "functions": ["lambda_value_reference_capture_list", "lambda_value_reference_auxiliary_var", "lambda_value_reference_capture_list_ref_1", "lambda_value_capture_copy", "lambda_value_reference_capture_list_ref_2", "lambda_value_reference"]}]}
{"pr_number": 77166, "url": "https://github.com/llvm/llvm-project/pull/77166", "title": "[lldb][NFCI] Change return type of BreakpointIDList::GetBreakpointIDAtIndex", "body": "There are 2 motivations here:\r\n1.) There is no need to hand out constant references to BreakpointIDs,\r\n  they are only 8 bytes big. In addition, every use of this method already\r\n  makes a copy anyway.\r\n2.) Each BreakpointIDList held onto an invalid BreakpointID specifically to\r\n  prevent lifetime issues. Returning a value means you can return an\r\n  invalid BreakpointID instead of needing to allocate storage for an\r\n  invalid BreakpointID.", "feature_layers": [], "feature_directives": ["for", "allocate"], "files_changed": [{"filename": "lldb/source/Breakpoint/BreakpointIDList.cpp", "functions": ["BreakpointID", "m_invalid_id"]}]}
{"pr_number": 77120, "url": "https://github.com/llvm/llvm-project/pull/77120", "title": "[clang][modules] Remove `_Private` suffix from framework auto-link hints.", "body": "- [clang][modules] Remove no longer needed autolink test for TBD files.\n- [clang][modules] Remove `_Private` suffix from framework auto-link hints.\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Lex/ModuleMap.cpp", "functions": ["FrameworkName"]}]}
{"pr_number": 75825, "url": "https://github.com/llvm/llvm-project/pull/75825", "title": "[AMDGPU] Add CodeGen support for GFX12 s_mul_u64", "body": "", "feature_layers": ["codegen"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/AMDGPUPostLegalizerCombiner.cpp", "functions": ["applyCombine_s_mul_u64", "matchCombine_s_mul_u64"]}, {"filename": "llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp", "functions": ["ApplyBank"]}, {"filename": "llvm/lib/Target/AMDGPU/SIISelLowering.cpp", "functions": ["splitBinaryVectorOp", "SDValue", "lowerMUL", "SL"]}]}
{"pr_number": 77363, "url": "https://github.com/llvm/llvm-project/pull/77363", "title": "[NFC][msan] Switch allocator interface to use BufferedStackTrace", "body": "We will need it to unwind for fatal errors.\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "compiler-rt/lib/msan/msan_allocator.cpp", "functions": ["MsanDeallocate"]}]}
{"pr_number": 75660, "url": "https://github.com/llvm/llvm-project/pull/75660", "title": "[mlir][spirv] Fix spirv dialect to support Specialization constants as GlobalVar initializer", "body": "Changes include:\r\n\r\n- spirv serialization and deserialization needs handling in cases when GlobalVariableOp initializer is defined using spirv  SpecConstant or SpecConstantComposite op, currently even though it allows SpecConst, it only looked up in for GlobalVariable Map to find initializer symbol reference, change is fixing this and extending the support to SpecConstantComposite as an initializer.\r\n- Adds tests to make sure GlobalVariable can be initialized using specialized constants.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Target/SPIRV/Deserialization/Deserializer.cpp", "functions": ["if"]}, {"filename": "mlir/lib/Target/SPIRV/Serialization/SerializeOps.cpp", "functions": ["emitError"]}]}
{"pr_number": 77371, "url": "https://github.com/llvm/llvm-project/pull/77371", "title": "Revert \"[OpenMP][libomptarget] Enable automatic unified shared memory executi\u2026\"", "body": "Reverts llvm/llvm-project#75999\r\n\r\nlit test is failing.", "feature_layers": [], "feature_directives": ["target"], "files_changed": [{"filename": "openmp/libomptarget/plugins-nextgen/amdgpu/src/rtl.cpp", "functions": ["useAutoZeroCopyImpl", "StrGfxName", "checkIfAPU"]}, {"filename": "openmp/libomptarget/plugins-nextgen/common/src/PluginInterface.cpp", "functions": ["__tgt_rtl_use_auto_zero_copy"]}, {"filename": "openmp/libomptarget/test/mapping/auto_zero_copy.cpp", "functions": ["main"]}]}
{"pr_number": 76871, "url": "https://github.com/llvm/llvm-project/pull/76871", "title": "[mlir][TilingInterface] Allow controlling what fusion is done within tile and fuse", "body": "Currently the `tileConsumerAndFuseProducerGreedilyUsingSCFFor` method greedily fuses through all slices that are generated during the tile and fuse flow. That is not the normal use case. Ideally the caller would like to control which slices get fused and which dont. This patch introduces a new field to the `SCFTileAndFuseOptions` to specify this control.\r\n\r\nThe contol function also allows the caller to specify if the replacement for the fused producer needs to be yielded from within the tiled computation. This allows replacing the fused producers in case they have other uses. Without this the original producers still survive negating the utility of the fusion.\r\n\r\nThe change here also means that the name of the function `tileConsumerAndFuseProducerGreedily...` can be updated. Defering that to a later stage to reduce the churn of API changes.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/test/lib/Interfaces/TilingInterface/TestTilingInterface.cpp", "functions": ["g"]}]}
{"pr_number": 77043, "url": "https://github.com/llvm/llvm-project/pull/77043", "title": "[CommandLine] Do not print empty categories with '--help-hidden'", "body": "If a category has no options associated with it, the `--help-hidden` command still shows that category with the annotation \"This option category has no options\", and this is how it was implemented from the beginning when the categories were introduced, see commit 0537a98878. A feature to hide unrelated options was added later, in https://reviews.llvm.org/D7100. Now, if a tool needs to hide unrelated options that are associated with categories, leaving some of them empty, those categories will still be visible on the `--help-hidden` output, even if they have no use for the tool; see the changes in `llvm/test/tools/llvm-debuginfo-analyzer/cmdline.test` for an example.\r\n\r\nThe patch ensures that only categories with options are shown on both main and hidden help output.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/unittests/Support/CommandLineTest.cpp", "functions": ["Opt2", "Category1", "Opt1", "Category2"]}]}
{"pr_number": 68076, "url": "https://github.com/llvm/llvm-project/pull/68076", "title": "[libc++abi] Handle catch null pointer-to-object", "body": "This addresses cases (currently failing) where we throw a null pointer-to- object and is a proposed fix for\r\nhttps://github.com/llvm/llvm-project/issues/64953\r\n\r\nWe are trying to satisfy the following bullet from the C++ ABI 15.3:\r\n\r\n *  the handler is of type cv1 T* cv2 and E is a pointer type that can be converted to the type of the handler by either or both of:\r\n\r\n    o  a standard pointer conversion (4.10 [conv.ptr]) not involving conversions to private or protected or ambiguous classes.\r\n\r\n    o  a qualification conversion.\r\n\r\nThe existing implementation assesses the ambiguity of bases by computing the offsets to them; ambiguous cases are then when the same base appears at different offsets.  The computation of offset  includes indirecting through the vtables to find the offsets to virtual bases.\r\n\r\nWhen the thrown pointer points to a real object, this is quite efficient since, if the base is found, and it is not ambiguous and on a public path, the offset is needed to return the adjusted pointer (and the indirections are not particularly expensive to compute).\r\n\r\nHowever, when we throw a null pointer-to-object, this scheme is no longer applicable (and the code currently bypasses the relevant computations, leading to the incorrect catches reported in the issue).\r\n\r\n-----\r\n\r\nThe solution proposed here takes a composite approach:\r\n\r\n1. When the pointer-to-object points to a real instance (well, at least, it is determined to be non-null), we use the existing scheme.\r\n\r\n2. When the pointer-to-object is null:\r\n\r\n * We note that there is no real object.\r\n * When we are processing non-virtual bases, we continue to compute the offsets, but for a notional dummy object based at 0.  This is OK, since we never need to access the object content for non-virtual bases.\r\n * When we are processing a path with one or more virtual bases, we remember a cookie corresponding to the inner-most virtual base found so far (and set the notional offset to 0).  Offsets to inner non-virtual bases are then computed as normal.\r\n\r\nA base is then ambiguous iff:\r\n  * There is a recorded virtual base cookie and that is different from the current one or,\r\n  * The non-virtual base offsets differ.\r\n\r\nWhen a handler for a pointer succeeds in catching a base pointer for a thrown null pointer-to-object, we still return a nullptr (so the adjustment to the pointer is not required and need not be computed).\r\n\r\nSince we noted that there was no object when starting the search for ambiguous bases, we know that we can skip the pointer adjustment.\r\n\r\nThis was : Differential Revision: https://reviews.llvm.org/D158769", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "libcxxabi/src/private_typeinfo.cpp", "functions": ["if"]}, {"filename": "libcxxabi/test/catch_null_pointer_to_object_pr64953.pass.cpp", "functions": ["f3", "assert_catches", "assert_catches_bp", "main", "f1", "assert_cannot_catch", "f2"]}]}
{"pr_number": 77012, "url": "https://github.com/llvm/llvm-project/pull/77012", "title": "[Libomptarget] Remove extra cache for offloading entries", "body": "Summary:\nThe offloading entries right now are assumed to be baked into the binary\nitself, and thus always valid whenever the library is executing. This\nmeans that we don't need to copy them to additional storage and can\ninstead simply pass around references to it.\n\nThis is not likely to change in the expected operation of the OpenMP\nlibrary. Additionally, the indirection for the offload entry struct is\nsimply two pointers, so moving it by value is trivial.\n", "feature_layers": ["ir"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "openmp/libomptarget/src/device.cpp", "functions": ["if"]}]}
{"pr_number": 76782, "url": "https://github.com/llvm/llvm-project/pull/76782", "title": "[mlir][spirv] Drop support for SPV_NV_cooperative_matrix", "body": "This extension has been superseded by SPV_KHR_cooperative_matrix which is supported across major vendors GPU like Nvidia, AMD, and Intel.\r\n\r\nGiven that the KHR version has been supported for nearly half a year, drop the NV-specific extension to reduce the maintenance burden and code duplication.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Conversion/GPUToSPIRV/WmmaOpsToSPIRV.cpp", "functions": ["success"]}, {"filename": "mlir/lib/Dialect/SPIRV/IR/CooperativeMatrixOps.cpp", "functions": ["success", "verifyPointerAndCoopMatrixNVType", "verifyCoopMatrixMulAddNV", "failure", "stringifyStorageClass", "getColumnmajor", "getCooperativeMatrixType"]}, {"filename": "mlir/lib/Dialect/SPIRV/IR/SPIRVDialect.cpp", "functions": ["print", "parseCooperativeMatrixNVType", "Type"]}, {"filename": "mlir/lib/Dialect/SPIRV/IR/SPIRVTypes.cpp", "functions": ["new", "getImpl", "elementType", "ref"]}, {"filename": "mlir/lib/Target/SPIRV/Deserialization/Deserializer.cpp", "functions": ["success", "processCooperativeMatrixTypeNV"]}, {"filename": "mlir/lib/Target/SPIRV/Serialization/Serializer.cpp", "functions": ["failure", "success", "prepareConstantInt"]}]}
{"pr_number": 77168, "url": "https://github.com/llvm/llvm-project/pull/77168", "title": "[msan] Unwind stack before fatal reports", "body": "Msan does not unwind stack in malloc without origins, but we still need trace\nfor fatal errors.\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "compiler-rt/lib/msan/msan_allocator.cpp", "functions": ["MsanDeallocate"]}]}
{"pr_number": 76092, "url": "https://github.com/llvm/llvm-project/pull/76092", "title": "[libc] major refactor of startup library", "body": "* separate initialization routines into _start and do_start for all architectures.\r\n* lift do_start as a separate object library to avoid code duplication.\r\n* (addtionally) address the problem of building hermetic libc with -fstack-pointer-*\r\n\r\nThe `crt1.o` is now a merged result of three components:\r\n\r\n```\r\n___\r\n  |___ x86_64\r\n  |      |_______ start.cpp.o    <- _start (loads process initial stack and aligns stack pointer)\r\n  |      |_______ tls.cpp.o      <- init_tls, cleanup_tls, set_thread_pointer (TLS related routines) \r\n  |___ do_start.cpp.o            <- do_start (sets up global variables and invokes the main function) \r\n``` ", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "libc/startup/linux/aarch64/start.cpp", "functions": ["init_tls", "cleanup_tls", "set_thread_ptr"]}, {"filename": "libc/startup/linux/do_start.cpp", "functions": ["call_fini_array_callbacks", "call_init_array_callbacks", "do_start"]}, {"filename": "libc/startup/linux/riscv/start.cpp", "functions": ["init_tls", "cleanup_tls", "set_thread_ptr"]}, {"filename": "libc/startup/linux/x86_64/start.cpp", "functions": ["volatile"]}, {"filename": "libc/startup/linux/aarch64/tls.cpp", "functions": ["init_tls", "cleanup_tls", "set_thread_ptr"]}, {"filename": "libc/startup/linux/riscv/tls.cpp", "functions": ["init_tls", "cleanup_tls", "set_thread_ptr"]}, {"filename": "libc/startup/linux/x86_64/tls.cpp", "functions": ["syscall_impl", "init_tls", "cleanup_tls", "set_thread_ptr"]}]}
{"pr_number": 75999, "url": "https://github.com/llvm/llvm-project/pull/75999", "title": "[OpenMP][libomptarget] Enable automatic unified shared memory executi\u2026", "body": "\u2026on (zero-copy) on MI300A.\r\n\r\nThis patch enables applications that did not request OpenMP unified_shared_memory to run with the same zero-copy behavior, where mapped memory does not result in extra memory allocations and memory copies, but CPU-allocated memory is accessed from the device. The name for this behavior is \"automatic zero-copy\" and it relies on detecting: that the runtime is running on a MI300A, that the user did not select unified_shared_memory in their program, and that XNACK (unified memory support) is enabled in the current GPU configuration. If all these conditions are met, then automatic zero-copy is triggered.\r\n\r\nThis patch is still missing support for global variables, which will be provided in a subsequent patch.", "feature_layers": ["runtime", "ir"], "feature_directives": ["for", "target", "allocate"], "files_changed": [{"filename": "openmp/libomptarget/plugins-nextgen/amdgpu/src/rtl.cpp", "functions": ["useAutoZeroCopyImpl", "StrGfxName", "checkIfAPU"]}, {"filename": "openmp/libomptarget/plugins-nextgen/common/src/PluginInterface.cpp", "functions": ["__tgt_rtl_use_auto_zero_copy"]}, {"filename": "openmp/libomptarget/test/mapping/auto_zero_copy.cpp", "functions": ["main"]}]}
{"pr_number": 77077, "url": "https://github.com/llvm/llvm-project/pull/77077", "title": "[RISCV] Add support predicating for ANDN/ORN/XNOR with short-forward-branch-opt.", "body": "ANDN/ORN/XNOR are like other ALU instructions. It should be able to be\r\npredicated by the cpu that supports short-forward-branch.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVInstrInfo.cpp", "functions": ["getPredicatedOpcode"]}]}
{"pr_number": 75703, "url": "https://github.com/llvm/llvm-project/pull/75703", "title": "Set MaxAtomicSizeInBitsSupported for remaining targets.", "body": "Targets affected:\r\n\r\n- NVPTX and BPF: set to 64 bits.\r\n- ARC, Lanai, and MSP430: set to 0 (they don't implement atomics).\r\n\r\nThose which didn't yet add AtomicExpandPass to their pass pipeline now do so.\r\n\r\nThis will result in larger atomic operations getting expanded to `__atomic_*` libcalls via AtomicExpandPass. On all these targets, this now matches what Clang already does in the frontend.\r\n\r\nThe only targets which do not configure AtomicExpandPass now are:\r\n- DirectX and SPIRV: they aren't normal backends.\r\n- AVR: a single-cpu architecture with no privileged/user divide, which could implement all atomics by disabling/enabling interrupts, regardless of size/alignment. Will be addressed by future work.", "feature_layers": ["ir", "frontend"], "feature_directives": ["for", "single", "atomic", "target"], "files_changed": [{"filename": "llvm/lib/Target/ARC/ARCTargetMachine.cpp", "functions": ["addIRPasses"]}, {"filename": "llvm/lib/Target/Lanai/LanaiTargetMachine.cpp", "functions": ["addIRPasses"]}, {"filename": "llvm/lib/Target/MSP430/MSP430TargetMachine.cpp", "functions": ["addIRPasses"]}]}
{"pr_number": 77261, "url": "https://github.com/llvm/llvm-project/pull/77261", "title": "[ELF] Support R_RISCV_SET_ULEB128/R_RISCV_SUB_ULEB128 in SHF_ALLOC sections", "body": "Complement #72610 (non-SHF_ALLOC sections). GCC-generated\n.gcc_exception_table has the SHF_ALLOC flag and may contain\nR_RISCV_SET_ULEB128/R_RISCV_SUB_ULEB128 relocations.\n", "feature_layers": [], "feature_directives": ["sections"], "files_changed": [{"filename": "lld/ELF/Arch/RISCV.cpp", "functions": ["if", "relocateAlloc"]}, {"filename": "lld/ELF/InputSection.cpp", "functions": ["overwriteULEB128"]}]}
{"pr_number": 75373, "url": "https://github.com/llvm/llvm-project/pull/75373", "title": "Make clang report invalid target versions.", "body": "Clang always silently ignores garbage target versions and this makes debug harder. So clang will report when target versions are invalid.", "feature_layers": [], "feature_directives": ["target"], "files_changed": [{"filename": "clang/unittests/Driver/DriverTest.cpp", "functions": ["Diags", "DiagID", "TheDriver"]}, {"filename": "llvm/lib/TargetParser/Triple.cpp", "functions": ["parseVersionFromName"]}]}
{"pr_number": 76938, "url": "https://github.com/llvm/llvm-project/pull/76938", "title": "[OpenMP] Patch for Support to loop bind clause : Checking Parent Region", "body": "Changes uploaded to the phabricator on Dec 16th are lost because the phabricator is down. Hence re-uploading it to the github.com.\r\n\r\n  Changes to be committed:\r\n \tmodified:   clang/include/clang/Sema/Sema.h\r\n \tmodified:   clang/lib/Sema/SemaOpenMP.cpp\r\n \tmodified:   clang/test/OpenMP/generic_loop_ast_print.cpp\r\n \tmodified:   clang/test/OpenMP/loop_bind_messages.cpp\r\n \tmodified:   clang/test/PCH/pragma-loop.cpp", "feature_layers": ["sema", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Sema/SemaOpenMP.cpp", "functions": ["getOpenMPDirectiveName"]}, {"filename": "clang/test/OpenMP/loop_bind_messages.cpp", "functions": ["parallel_targetfor_with_loop_bind", "teams_loop_reduction", "teams_targetfor_with_loop_bind", "loop_bind_AND_loop_bind", "parallel_for_with_loop_teams_bind", "parallel_nowait", "orphan_loop_teams_bind", "parallel_with_sections_loop", "parallel_for_with_nothing", "thread_loop", "parallel_for_AND_loop_bind", "teams_with_loop_thread_bind", "orphan_loop_no_bind", "orphan_loop_parallel_bind", "teams_loop_distribute", "parallel_targetparallel_with_loop", "orphan_loops", "teams_targetteams_with_loop"]}]}
{"pr_number": 76433, "url": "https://github.com/llvm/llvm-project/pull/76433", "title": "[LoongArch] Support R_LARCH_{ADD,SUB}_ULEB128 for .uleb128 and force relocs when sym is not in section", "body": "1, Follow RISCV 1df5ea29 to support generates relocs for .uleb128 which can not be folded. Unlike RISCV, the located content of LoongArch should be zero. LoongArch fixup uleb128 value by in-place addition and subtraction reloc types named R_LARCH_{ADD,SUB}_ULEB128. The located content can affect the result and R_LARCH_ADD_ULEB128 has enough info to represent the first symbol value, so it needs to be set to zero.\r\n2, Force relocs if sym is not in section so that it can emit relocs for external symbol.\r\n\r\nFixes: https://github.com/llvm/llvm-project/pull/72960#issuecomment-1866844679", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/LoongArch/MCTargetDesc/LoongArchAsmBackend.cpp", "functions": ["fixupLeb128"]}]}
{"pr_number": 74197, "url": "https://github.com/llvm/llvm-project/pull/74197", "title": "AMDGPU: Replace sqrt OpenCL libcalls with llvm.sqrt", "body": "The library implementation is just a wrapper around a call to the intrinsic, but loses metadata. Swap out the call site to the intrinsic so that the lowering can see the !fpmath metadata and fast math flags.\r\n\r\nSince d56e0d07cc5ee8e334fd1ad403eef0b1a771384f, clang started placing !fpmath on OpenCL library sqrt calls. Also don't bother emitting native_sqrt anymore, it's just another wrapper around llvm.sqrt.", "feature_layers": ["ast"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/AMDGPULibCalls.cpp", "functions": ["fold_sqrt"]}]}
{"pr_number": 77311, "url": "https://github.com/llvm/llvm-project/pull/77311", "title": "[AST] Teach TextNodeDumper to print the \"implicit\" bit for coroutine AST nodes", "body": "", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/AST/ast-dump-coroutine.cpp", "functions": ["test2"]}]}
{"pr_number": 75305, "url": "https://github.com/llvm/llvm-project/pull/75305", "title": "[CodeGen] Port `GCLowering` to new pass manager", "body": "", "feature_layers": ["codegen"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/CodeGen/GCRootLowering.cpp", "functions": ["DoLowering"]}]}
{"pr_number": 72245, "url": "https://github.com/llvm/llvm-project/pull/72245", "title": "[AMDGPU] Don't DEALLOC_VGPRS from callable functions", "body": "Callable functions should not send the DEALLOC_VGPRS message, because that might release the VGPRs and scratch allocation before potential scratch stores in the caller have completed.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.cpp", "functions": ["isCallableCC"]}]}
{"pr_number": 75580, "url": "https://github.com/llvm/llvm-project/pull/75580", "title": "[X86] Emit Warnings for frontend options to enable knl/knm specific ISAs.", "body": "Since Knight Landing and Knight Mill microarchitectures are EOL, we\r\nwould like to remove intrinsic supports for its specific ISA in LLVM 19.\r\nIn LLVM 18, we will first emit a warning for the usage.\r\n", "feature_layers": ["ir", "frontend"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/Misc/warning-flags.c", "functions": ["flags"]}]}
{"pr_number": 76724, "url": "https://github.com/llvm/llvm-project/pull/76724", "title": "[mlir] introduce transform.collect_matching", "body": "Introduce a new match combinator into the transform dialect. This\r\noperation collects all operations that are yielded by a satisfactory\r\nmatch into its results. This is a simpler version of `foreach_match`\r\nthat can be inserted directly into existing transform scripts.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Transform/IR/TransformOps.cpp", "functions": ["success", "emitDefiniteFailure", "implementSameInterface", "getOperation", "emitError", "implementSameTransformInterface"]}]}
{"pr_number": 76725, "url": "https://github.com/llvm/llvm-project/pull/76725", "title": "[mlir] add a chapter on matchers to the transform dialect tutorial", "body": "These operations has been available for a while, but were not described\r\nin the tutorial. Add a new chapter on using and defining match\r\noperations.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Transform/IR/TransformOps.cpp", "functions": ["success", "emitDefiniteFailure", "implementSameInterface", "getOperation", "emitError", "implementSameTransformInterface"]}, {"filename": "mlir/examples/transform/Ch4/lib/MyExtension.cpp", "functions": ["emitOpError", "success", "implementSameInterface", "emitSilenceableError", "init", "registerMyExtension", "implementSameTransformInterface"]}, {"filename": "mlir/examples/transform/Ch4/transform-opt/transform-opt.cpp", "functions": ["registerTestTransformDialectExtension", "main"]}]}
{"pr_number": 76710, "url": "https://github.com/llvm/llvm-project/pull/76710", "title": "[RFC][SelectionDAG] Add and use SDNode::getAsZExtVal() helper", "body": "This follows on from #76708, allowing\r\n`cast<ConstantSDNode>(N)->getZExtValue()` to be replaced with just `N->getAsZextVal();`\r\n    \r\nIntroduced via `git grep -l \"cast<ConstantSDNode>\\(.*\\).*getZExtValue\" |\r\nxargs sed -E -i 's/cast<ConstantSDNode>\\((.*)\\)->getZExtValue/\\1->getAsZExtVal/'` and then using `git clang-format` on the result.\r\n\r\nTo me it seems this helper is filling in a logical gap given that the getConstantOperandVal helper already exists, but I'd very much welcome alternate viewpoints.", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp", "functions": ["Flag"]}, {"filename": "llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp", "functions": ["Flags"]}, {"filename": "llvm/lib/Target/RISCV/RISCVISelLowering.cpp", "functions": ["if"]}]}
{"pr_number": 68753, "url": "https://github.com/llvm/llvm-project/pull/68753", "title": "[libc++] Allow running the test suite with optimizations", "body": "This patch adds a configuration of the libc++ test suite that enables optimizations when building the tests. It also adds a new CI configuration to exercise this on a regular basis. This is added in the context of [1], which requires building with optimizations in order to hit the bug.\r\n\r\n[1]: https://github.com/llvm/llvm-project/issues/68552", "feature_layers": ["ir"], "feature_directives": ["requires"], "files_changed": [{"filename": "libunwind/test/libunwind_02.pass.cpp", "functions": ["test", "test_backtrace", "callback"]}, {"filename": "libunwind/test/unw_resume.pass.cpp", "functions": ["test_unw_resume"]}, {"filename": "libunwind/test/unwind_leaffunction.pass.cpp", "functions": ["__volatile__"]}]}
{"pr_number": 77416, "url": "https://github.com/llvm/llvm-project/pull/77416", "title": "[clang]use correct this scope to evaluate noexcept expr", "body": "Fixes: #77411\r\nWhen substituting deduced type, noexcept expr in method should be instantiated and evaluated.\r\nThisScrope should be switched to method context instead of origin sema context", "feature_layers": ["sema"], "feature_directives": [], "files_changed": [{"filename": "clang/test/SemaCXX/cxx1z-noexcept-function-type.cpp", "functions": ["foo"]}]}
{"pr_number": 77367, "url": "https://github.com/llvm/llvm-project/pull/77367", "title": "[mlir] Add global and program memory space handling to the data layout subsystem", "body": "This patch is based on a previous PR https://reviews.llvm.org/D144657 that added alloca address space handling to MLIR's DataLayout and DLTI interface. This patch aims to add identical features to import and access the global and program memory space through MLIR's DataLayout/DLTI system.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/DLTI/DLTI.cpp", "functions": ["Builder"]}, {"filename": "mlir/lib/Interfaces/DataLayoutInterfaces.cpp", "functions": ["Attribute"]}, {"filename": "mlir/unittests/Interfaces/DataLayoutInterfacesTest.cpp", "functions": ["getGlobalMemorySpace", "getProgramMemorySpaceIdentifier", "getProgramMemorySpace", "Attribute", "getGlobalMemorySpaceIdentifier", "Builder"]}]}
{"pr_number": 75925, "url": "https://github.com/llvm/llvm-project/pull/75925", "title": "[DWARFLinker][DWARFLinkerParallel][NFC] Refactor DWARFLinker&DWARFLinkerParallel to have a common library. Part 1.", "body": "This patch is extracted from https://github.com/llvm/llvm-project/pull/74725 .\r\nIt creates DWARFLinkerBase library, places DWARFLinker code into DWARFLinker\\Apple directory, puts code from DWARFLinker\\Apple into 'dwarflinker' namespace, places DWARFLinkerParallel into DWARFLinker\\LLVM directory, updates BOLT to use new library. This patch is NFC.", "feature_layers": ["ir"], "feature_directives": ["parallel"], "files_changed": [{"filename": "llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp", "functions": ["Pool"]}, {"filename": "llvm/lib/DWARFLinker/Parallel/OutputSections.cpp", "functions": ["parseDebugTableName"]}, {"filename": "llvm/lib/DWARFLinkerParallel/DWARFFile.cpp", "functions": ["FileName"]}, {"filename": "llvm/tools/dsymutil/DwarfLinkerForBinary.cpp", "functions": ["Guard"]}, {"filename": "llvm/tools/llvm-dwarfutil/DebugInfoLinker.cpp", "functions": ["ObjectsForLinking"]}]}
{"pr_number": 77329, "url": "https://github.com/llvm/llvm-project/pull/77329", "title": "[flang][OpenMP] Fix unstrucuted control flow inside a collapsed wsloop", "body": "When unstrucuted control flow is used inside a collapsed wsloop, the inner-most (collapsed) loop statements are skipped (loop control is handled by the wsloop operation). However, blocks are still created without knowledge of the loop collapse. Without any loop control code generated for the collapsed loop, no branch would be added at the end of the block for the end-loop statement, resulting in invalid IR (an unterminated block) and for incorrect control flow.\r\n\r\nThe correct behaviour would be to branch unconditionally to the next out-most end-loop statement. This block is already successfully recognised as the successor block.\r\n\r\nThis patch adds an additional condition to add a branch to this successor block. I believe this should only match in cases which previously would have produced an unterminated block and so this should not effect any already working code construct.\r\n\r\nOne alternative solution that was considered was to handle this in the previous else if case where successor == eval.constrolSuccessor. This condition does not match here because the control successor is the beginning of the loop construct, whereas the successor is the next outer-most loop construct. Removing this condition led to numerous test failures.\r\n\r\nThis passes llvm-testsuite and can produce correct results from spec2017 **rate** (no openmp). Please advise if other testing is necessary.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Lower/Bridge.cpp", "functions": ["if"]}]}
{"pr_number": 71481, "url": "https://github.com/llvm/llvm-project/pull/71481", "title": "AMDGPU: Drop amdgpu-no-lds-kernel-id attribute in LDS lowering", "body": "This is in preparation for moving the run of AMDGPUAttributor earlier.\r\nCurrently it infers the lack of the corresponding intrinsic calls,\r\nso if we introduce new ones we need to remove the attribute from any\r\npossible transitive callers. This is more conservative than necessary,\r\nwe could try to identify specific subgraphs where LDS globals are not\r\nused.\r\n\r\nOther options include teaching the attributor to avoid adding it in cases\r\nwhere the lowering may choose the table, but this seems more complex.\r\nAlternatively could add a second run which doesn't seem worth it.\r\n\r\nDepends #71349", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp", "functions": ["removeNoLdsKernelIdFromReachable", "Tmp"]}]}
{"pr_number": 72705, "url": "https://github.com/llvm/llvm-project/pull/72705", "title": "[clang-tidy] Improve performance of misc-const-correctness", "body": "Replaced certain AST matchers in ExprMutationAnalyzer with a more direct utilization of AST classes. The primary bottleneck was identified in the canResolveToExpr AST matcher. Since this matcher was employed multiple times and used recursively, each invocation led to the constant creation and destruction of other matchers within it. Additionally, the continual comparison of DynTypedNode resulted in significant performance degradation.\r\n\r\nThe optimization was tested on the TargetLowering.cpp file. Originally, the check took 156 seconds on that file, but after implementing this enhancement, it now takes approximately 40 seconds, making it nearly four times faster.\r\n\r\nDespite this improvement, there are still numerous issues in this file. To further reduce the computational cost of this class, it is advisable to consider removing the remaining matchers and exploring alternatives such as leveraging RecursiveASTVisitor and increasing the direct use of AST classes.\r\n\r\nCloses #71786", "feature_layers": ["ir", "ast"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "clang/lib/Analysis/ExprMutationAnalyzer.cpp", "functions": ["canExprResolveTo", "canResolveToExprImpl"]}]}
{"pr_number": 75774, "url": "https://github.com/llvm/llvm-project/pull/75774", "title": "[Flang] Generate inline reduction loops for elemental count intrinsics", "body": "This adds a ReductionElementalConversion transform to OptimizedBufferizationPass, taking hlfir::count(hlfir::elemental) and generating the inline loop to perform the count of true elements. This lets us generate a single loop instead of ending up as two plus a temporary.\r\n\r\nThis is currently part of OptimizedBufferization, similar to #74828. I attempted to move it to LowerHLFIRIntrinsics to make it part of the existing lowering, but it hit problems with inlining elementals that contain operations that are being legalized by the same pass.\r\n\r\nAny and All should be able to share the same code with a different function/initial value.", "feature_layers": ["ir"], "feature_directives": ["for", "single"], "files_changed": [{"filename": "flang/lib/Optimizer/HLFIR/Transforms/OptimizedBufferization.cpp", "functions": ["indices"]}]}
{"pr_number": 75239, "url": "https://github.com/llvm/llvm-project/pull/75239", "title": "[OpenMP][NFC] Move mapping related code into OpenMP/Mapping.cpp", "body": "DeviceTy provides an abstraction for \"middle-level\" operations that can be done with a offload device. Mapping was tied into it but is not strictly necessary. Other languages do not track mapping, and even OpenMP can be used completely without mapping. This simply moves the relevant code into the OpenMP/Mapping.cpp as part of a new class MappingInfoTy. Each device still has one, but it does not clutter the device.cpp anymore.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "openmp/libomptarget/src/OpenMP/Mapping.cpp", "functions": ["LG"]}, {"filename": "openmp/libomptarget/src/device.cpp", "functions": ["LG", "notifyDataUnmapped", "notifyDataMapped"]}]}
{"pr_number": 68530, "url": "https://github.com/llvm/llvm-project/pull/68530", "title": "Port CodeGenPrepare to new pass manager", "body": "", "feature_layers": ["codegen"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/CodeGen/CodeGenPrepare.cpp", "functions": ["getPassName", "resetIteratorIfInvalidatedWhileCalling", "getAnalysisUsage", "runOnFunction", "if", "CodeGenPrepareLegacy", "releaseMemory", "IterHandle"]}]}
{"pr_number": 76471, "url": "https://github.com/llvm/llvm-project/pull/76471", "title": "[PGO] Exposing PGO's Counter Reset and File Dumping APIs", "body": "This PR exposes four PGO functions \r\n\r\n- `__llvm_profile_set_filename`\r\n- `__llvm_profile_reset_counters`, \r\n- `__llvm_profile_dump` \r\n- `__llvm_orderfile_dump` \r\n\r\nto user programs through the new header `instr_prof_interface.h` under `compiler-rt/include/profile`. This way, the user can include the header `profile/instr_prof_interface.h` to introduce these four names to their programs. \r\n\r\nAdditionally, this PR defines macro `__LLVM_INSTR_PROFILE_GENERATE` when the program is compiled with profile generation, and defines macro `__LLVM_INSTR_PROFILE_USE` when the program is compiled with profile use. `__LLVM_INSTR_PROFILE_GENERATE` together with `instr_prof_interface.h` define the PGO functions only when the program is compiled with profile generation. When profile generation is off, these PGO functions are defined away and leave no trace in the user's program. \r\n\r\nBackground: https://discourse.llvm.org/t/pgo-are-the-llvm-profile-functions-stable-c-apis-across-llvm-releases/75832", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "compiler-rt/test/profile/instrprof-api.c", "functions": ["bar", "foo", "main"]}, {"filename": "compiler-rt/test/profile/Linux/instrprof-weak-symbol.c", "functions": ["bar", "foo", "main"]}]}
{"pr_number": 77157, "url": "https://github.com/llvm/llvm-project/pull/77157", "title": "[lldb] DWARFDIE: Follow DW_AT_specification when computing CompilerCo\u2026", "body": "\u2026ntext\r\n\r\nFollowing the specification chain seems to be clearly the expected behavior of GetDeclContext(). Otherwise C++ methods have an empty CompilerContext instead of being nested in their struct/class.\r\n\r\nTheprimary motivation for this functionality is the Swift plugin. In order to test the change I added a proof-of-concept implementation of a Module::FindFunction() variant that takes a CompilerContext, expesed via lldb-test.\r\n\r\nrdar://120553412", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "lldb/source/Plugins/SymbolFile/DWARF/DWARFDIE.cpp", "functions": ["GetDeclContextImpl"]}]}
{"pr_number": 75118, "url": "https://github.com/llvm/llvm-project/pull/75118", "title": "[mlir] NamedAttribute utility generator", "body": "All attributes in MLIR are named, inherent attributes have unscoped names and arbitrary attributes should be scoped with a dialect. Current usage is ad-hoc and much of the codebase is sprinkled with constant strings used to lookup and set attributes, leading to potential bugs when names are not updated in all usages.\r\n\r\nThis PR adds a tablegen'd utility wrapper for a NamedAttribute that manages scoped/unscoped name lookup for accessing the attribute on an Operation based on inherentness.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/test/lib/IR/TestNamedAttrs.cpp", "functions": ["getDescription", "getArgument", "runOnOperation", "registerTestNamedAttrsPass"]}, {"filename": "mlir/tools/mlir-opt/mlir-opt.cpp", "functions": ["registerTestNamedAttrsPass"]}]}
{"pr_number": 77182, "url": "https://github.com/llvm/llvm-project/pull/77182", "title": "Port CodeGenPrepare to new pass manager (and BasicBlockSectionsProfil\u2026", "body": "Port CodeGenPrepare to new pass manager and dependency BasicBlockSectionsProfileReader\r\nFixes: #75380", "feature_layers": ["codegen"], "feature_directives": ["sections"], "files_changed": [{"filename": "llvm/lib/CodeGen/BasicBlockPathCloning.cpp", "functions": ["ApplyCloning"]}, {"filename": "llvm/lib/CodeGen/BasicBlockSectionsProfileReader.cpp", "functions": ["BasicBlockSectionsProfileReader", "BasicBlockSectionsProfileReaderWrapperPass"]}, {"filename": "llvm/lib/CodeGen/CodeGenPrepare.cpp", "functions": ["CodeGenPrepareLegacyPass", "getPassName", "getAnalysisUsage", "runOnFunction", "run", "releaseMemory", "_run", "CGP"]}]}
{"pr_number": 77033, "url": "https://github.com/llvm/llvm-project/pull/77033", "title": "[mlir][mesh] Add folding of ClusterShapeOp", "body": "If the mesh has static size on some of the requested axes, the result is substituted with a constant.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/Mesh/Transforms/Simplifications.cpp", "functions": ["populateSimplificationPatterns"]}, {"filename": "mlir/test/lib/Dialect/Mesh/TestFolding.cpp", "functions": ["runOnOperation", "getArgument", "signalPassFailure", "patterns", "registerTestMeshFoldingPass", "getDependentDialects", "getDescription"]}, {"filename": "mlir/tools/mlir-opt/mlir-opt.cpp", "functions": ["registerTestMeshFoldingPass"]}]}
{"pr_number": 77523, "url": "https://github.com/llvm/llvm-project/pull/77523", "title": "[SLP]Improve findReusedOrderedScalars and graph rotation.", "body": "Patch syncs the code in findReusedOrderedScalars with cost\nestimation/codegen. It tries to use similar logic to better determine\nbest order.\nBefore, it just tried to find previously vectorized node without\nchecking if it is possible to use the vectorized value in the shuffle.\nNow it relies on the more generalized version. If it determines, that\na single vector must be reordered (using same mechanism, as codegen and\ncost estimation), it generates better order.\n\nThe comparison between new/ref ordering:\n\nMetric: SLP.NumVectorInstructions\n\nProgram                                                                                                                                                SLP.NumVectorInstructions\n                                                                                                                                                       results                   results0 diff\n                                                                                               test-suite :: MultiSource/Benchmarks/nbench/nbench.test   139.00                    140.00   0.7%\n                                                                             test-suite :: MultiSource/Benchmarks/DOE-ProxyApps-C++/miniFE/miniFE.test   344.00                    346.00   0.6%\n                                                                                        test-suite :: MultiSource/Benchmarks/FreeBench/pifft/pifft.test  1293.00                   1292.00  -0.1%\n                                                                                test-suite :: External/SPEC/CFP2017rate/511.povray_r/511.povray_r.test  5176.00                   5170.00  -0.1%\n                                                                                        test-suite :: External/SPEC/CFP2006/453.povray/453.povray.test  5173.00                   5167.00  -0.1%\n                                                                                test-suite :: External/SPEC/CFP2017rate/510.parest_r/510.parest_r.test 11692.00                  11660.00  -0.3%\n                                                                                     test-suite :: External/SPEC/CINT2006/464.h264ref/464.h264ref.test  1621.00                   1615.00  -0.4%\n                                                                                             test-suite :: External/SPEC/CINT2006/403.gcc/403.gcc.test   795.00                    792.00  -0.4%\n                                                                              test-suite :: External/SPEC/CFP2017rate/526.blender_r/526.blender_r.test 26499.00                  26338.00  -0.6%\n                                                                                               test-suite :: MultiSource/Benchmarks/Bullet/bullet.test  7343.00                   7281.00  -0.8%\n                                                                                          test-suite :: MultiSource/Applications/JM/ldecod/ldecod.test  1104.00                   1094.00  -0.9%\n                                                                                          test-suite :: MultiSource/Applications/JM/lencod/lencod.test  2216.00                   2180.00  -1.6%\n                                                                                            test-suite :: External/SPEC/CFP2006/433.milc/433.milc.test   787.00                    637.00 -19.1%\n\nLess 0% is better.\nMost of the benchmarks see more vectorized code. The first ones just\nhave shuffles removed.\n\nThe ordering analysis still may require some improvements (e.g. for\nalternate nodes), but this one should be produce better results.\n", "feature_layers": ["codegen", "ir"], "feature_directives": ["for", "single", "ordered"], "files_changed": [{"filename": "llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp", "functions": ["Res", "UsedIndices", "IdentityOrder", "ResOrder", "UsedVals", "Order", "UsedPositions", "GatheredScalars", "getReorderingData", "if", "all_of", "fixupOrderingIndices", "Mask", "OrdersType", "ShuffledSubMasks", "ReorderMask"]}]}
{"pr_number": 77388, "url": "https://github.com/llvm/llvm-project/pull/77388", "title": "[libc] Disable Death Tests While Hermetic", "body": "The death test infrastructure seems to depend on operator new, which\nisn't currently supported in our hermetic tests. This patch just\ndisables the death tests in hermetic mode since they only overlap in the\nnan tests.\n", "feature_layers": ["ast"], "feature_directives": [], "files_changed": [{"filename": "libc/test/UnitTest/HermeticTestUtils.cpp", "functions": ["new"]}]}
{"pr_number": 77124, "url": "https://github.com/llvm/llvm-project/pull/77124", "title": "[mlir][sparse][CRunnerUtils] Add shuffle in CRunnerUtils", "body": "Shuffle can generate an array of unique and random numbers from 0 to size-1. It can be used to generate tensors with specified sparsity level.", "feature_layers": ["parse", "ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/ExecutionEngine/CRunnerUtils.cpp", "functions": ["arr"]}]}
{"pr_number": 77434, "url": "https://github.com/llvm/llvm-project/pull/77434", "title": "[clang][Parser] Pop scope prior VarDecl invalidating by invalid init", "body": "Invalid (direct) initializer would invalid `VarDecl` so `InitializerScopeRAII` cannot restore scope stack balance.\r\n\r\nAs with other kind of initializer, `InitializerScopeRAII::pop()` is moved up before `Sema::ActOnInitializerError()` which invalidates the `VarDecl`, so scope can be balanced and current `DeclContext` can be restored.\r\n\r\nFixes #30908", "feature_layers": ["parse", "sema", "ir", "parser"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/Parser/gh30908-scope-balance-on-invalid-var-direct-init-1.cpp", "functions": ["set", "checkRegisters"]}, {"filename": "clang/test/Parser/gh30908-scope-balance-on-invalid-var-direct-init-2.cpp", "functions": ["s"]}]}
{"pr_number": 77194, "url": "https://github.com/llvm/llvm-project/pull/77194", "title": "Changed Checks from TriviallyCopyable to TriviallyCopyConstructible ", "body": "**Overview:**\r\nThis pull request fixes #47355 where in the Clang compiler's range-loop-analysis incorrectly checks for trivial copyability instead of trivial copy constructibility, leading to erroneous warnings.\r\n\r\n**Testing:**\r\n- Tested the updated code.\r\n- Verified that other functionalities remain unaffected.\r\n![Screenshot from 2024-01-01 19-50-20](https://github.com/llvm/llvm-project/assets/76656712/c664f01a-522e-45e4-8363-39f13d8cc241)\r\n\r\n\r\n**Dependencies:**\r\n- No dependencies on other pull requests.\r\n\r\n**References:**\r\n- https://cplusplus.com/reference/type_traits/is_trivially_copy_constructible/\r\n- https://en.cppreference.com/w/cpp/named_req/CopyConstructible\r\n- https://cplusplus.com/reference/type_traits/is_trivially_copyable/\r\n\r\n**CC:**\r\n- @Endilll , @cor3ntin  , @AaronBallman \r\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/SemaCXX/warn-range-loop-analysis-trivially-copyable.cpp", "functions": ["test_TriviallyCopyConstructible_64_bytes", "test_TriviallyCopyConstructible_65_bytes"]}, {"filename": "clang/lib/AST/Type.cpp", "functions": ["isTriviallyCopyableTypeImpl"]}]}
{"pr_number": 71045, "url": "https://github.com/llvm/llvm-project/pull/71045", "title": "[Flang][OpenMP][MLIR] Add support for -nogpulib option", "body": "If -nogpulib option is passed by the user, then the OpenMP device runtime is not used and we should not emit globals to configure debugging at compile-time for the device runtime.\r\n\r\nLink to -nogpulib flag implementation for Clang: https://reviews.llvm.org/D125314      ", "feature_layers": ["runtime", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Target/LLVMIR/Dialect/OpenMP/OpenMPToLLVMIRTranslation.cpp", "functions": ["success"]}]}
{"pr_number": 73108, "url": "https://github.com/llvm/llvm-project/pull/73108", "title": "[AMDGPU][True16] Support V_CEIL_F16.", "body": "As not all fake instructions have their real counterparts implemented\r\nyet, we specify no AssemblerPredicate for UseFakeTrue16Insts to allow\r\nboth fake and real True16 instructions in assembler and disassembler\r\ntests in the -mattr=+real-true16 mode during the transition period.\r\n\r\nSource DPP and desitnation VOPDstOperand_t16 operands are still not\r\nsupported and will be addressed separately.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp", "functions": ["getRegularReg", "if"]}]}
{"pr_number": 77509, "url": "https://github.com/llvm/llvm-project/pull/77509", "title": "[clang] Add tests for CWG1800-1804", "body": "Covers C++ core issues 1800, 1801, 1802, 1803, 1804.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CXX/drs/dr18xx.cpp", "functions": ["f1", "f2", "f3", "f4"]}]}
{"pr_number": 77495, "url": "https://github.com/llvm/llvm-project/pull/77495", "title": "[Libomptarget] Allow the CPU targets to be built without libffi", "body": "Summary:\nThe CPU targets currently rely on `libffi` to invoke the \"kernel\"\nfunctions. Previously we would not build these if this dependency was\nnot found. This patch copies th eapproach used for things like CUDA and\nHSA to dynamically load this if it is not found.\n\nThe one sketchy thing this does is hard-code the default ABI for the\ntarget. These are normally defined on a per-file basis in the FFI\nsource, so I had to fish out the expected values. We only use two types,\nso ideally we will always be able to use the default ABI.\n\nIt's possible we could remove this dependency entirely in the future as\nwell.\n", "feature_layers": ["ir"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "openmp/libomptarget/plugins-nextgen/generic-elf-64bit/dynamic_ffi/ffi.cpp", "functions": ["ffi_init"]}]}
{"pr_number": 77214, "url": "https://github.com/llvm/llvm-project/pull/77214", "title": "[clang][coverage] fixing \"if constexpr\" and \"if consteval\" coverage report", "body": "It was a while since I noticed coverage report is broken for \"if constexpr\" and \"if consteval\" (as shown on first picture).\r\n\r\nMain problem was replacement of non-taken \"if constexpr\" branch with `NullStmt` but such object doesn't have begin/end for source location properly. So I introduced a new constructor for empty `CompoundStmt` and used it.\r\n\r\nWith \"if consteval\" I'm no longer introducing new branch counter for non-taken \"branch\". But in future it would be useful to mark whole gap there as skipped instead. If there is interest I would do it in another PR.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/CodeGen/CoverageMappingGen.cpp", "functions": ["subtractCounters"]}, {"filename": "clang/test/CoverageMapping/if.cpp", "functions": ["check_constexpr_true_without_else", "constexpr", "check_constexpr_true_with_else", "check_constexpr_false_without_else", "check_notconsteval_branch_kept", "check_consteval_branch_discarded", "check_constexpr_false_with_else", "check_consteval_with_else_discarded_then", "check_consteval", "instantiate_consteval", "check_notconsteval_with_else_discarded_else"]}]}
{"pr_number": 73387, "url": "https://github.com/llvm/llvm-project/pull/73387", "title": "[lld][LoongArch] Handle extreme code model relocs according to psABI v2.30", "body": "psABI v2.30 requires the extreme code model instructions sequence (pcalau12i+addi.d+lu32i.d+lu52i.d) to be adjacent.\r\n\r\nSee https://github.com/llvm/llvm-project/pull/71907 and https://github.com/loongson-community/discussions/issues/17 for details.", "feature_layers": ["ir"], "feature_directives": ["for", "requires"], "files_changed": [{"filename": "lld/ELF/Arch/LoongArch.cpp", "functions": ["if"]}, {"filename": "lld/ELF/InputSection.cpp", "functions": ["getLoongArchPageDelta"]}]}
{"pr_number": 77321, "url": "https://github.com/llvm/llvm-project/pull/77321", "title": "[mlir][ArmSME] Add arm_sme.streaming_vl operation", "body": "This operation provides a convenient way to query the streaming vector\r\nlength regardless of the streaming mode. This most useful for functions\r\nthat call/pass data to streaming functions, but are not streaming\r\nthemselves.\r\n\r\nExample:\r\n```mlir\r\n%svl_w = arm_sme.streaming_vl <word>\r\n```\r\n\r\nCreated based on discussion here: https://github.com/llvm/llvm-project/pull/76086#discussion_r1434226352", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Conversion/ArmSMEToLLVM/ArmSMEToLLVM.cpp", "functions": ["success"]}]}
{"pr_number": 77281, "url": "https://github.com/llvm/llvm-project/pull/77281", "title": "[WebAssembly] Correctly consider signext/zext arg flags at function declaration", "body": "This patch fixes WebAssembly's FastISel pass to correctly consider signext/zeroext parameter flags at function declaration.\r\nPreviously, the flags at call sites were only considered during code generation, which caused an interesting bug report #63388 .\r\nThis is problematic especially because in WebAssembly's ABI, either signext or zeroext can be tagged to a function argument, and it must be correctly reflected in the generated code. Unit test https://github.com/llvm/llvm-project/blob/main/llvm/test/CodeGen/WebAssembly/signext-zeroext.ll shows that `i8 zeroext %t` and `i8 signext %t`'s code gen are different.", "feature_layers": ["codegen", "ast"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/Target/WebAssembly/WebAssemblyFastISel.cpp", "functions": ["if"]}]}
{"pr_number": 73964, "url": "https://github.com/llvm/llvm-project/pull/73964", "title": "[AArch64][SVE] Add optimisation for SVE intrinsics with no active lanes", "body": "This patch introduces optimisations for SVE intrinsic function calls which have all false predicates.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp", "functions": ["instCombineSVEVectorMul"]}]}
{"pr_number": 76661, "url": "https://github.com/llvm/llvm-project/pull/76661", "title": "[InstCombine] Fold the `log2_ceil` idiom", "body": "This patch folds the `log2_ceil` idiom:\r\n```\r\n(BW - ctlz(A)) + (is_power2(A) ? 0 : 1) ->\r\nzext(ctpop(A) >u/!= 1) + (ctlz(A, true) ^ (BW - 1)) (canonical form) ->\r\nBW - ctlz(A - 1, false)\r\n```\r\n\r\nAlive2: https://alive2.llvm.org/ce/z/6mSbdi\r\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp", "functions": ["replaceInstUsesWith"]}]}
{"pr_number": 77083, "url": "https://github.com/llvm/llvm-project/pull/77083", "title": "[MLIR][SCF] Add checks to verify that the pipeliner schedule is correct.", "body": "Add a check to validate that the schedule passed to the pipeliner transformation is valid and won't cause the pipeliner to break SSA.\r\n\r\nThis checks that the for each operation in the loop operations are scheduled after their operands.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/SCF/Transforms/LoopPipelining.cpp", "functions": ["verifySchedule"]}]}
{"pr_number": 77463, "url": "https://github.com/llvm/llvm-project/pull/77463", "title": "[mlir][math] Add math.acosh|asin|asinh|atanh op", "body": "Signed-Off By: Vivek Khandelwal <vivekkhandelwal1424@gmail.com>", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/Math/IR/MathOps.cpp", "functions": ["APFloat"]}]}
{"pr_number": 75448, "url": "https://github.com/llvm/llvm-project/pull/75448", "title": "[IR] Fix GEP offset computations for vector GEPs", "body": "Vectors are always bit-packed and don't respect the elements' alignment\r\nrequirements. This is different from arrays. This means offsets of vector GEPs\r\nneed to be computed differently than offsets of array GEPs.\r\n\r\nThis PR fixes many places that rely on an incorrect pattern\r\nthat always relies on `DL.getTypeAllocSize(GTI.getIndexedType())`.\r\nWe replace these by usages of  `GTI.getSequentialElementStride(DL)`, \r\nwhich is a new helper function added in this PR.\r\n\r\nThis changes behavior for GEPs into vectors with element types for which the\r\n(bit) size and alloc size is different. This includes two cases:\r\n\r\n* Types with a bit size that is not a multiple of a byte, e.g. i1.\r\n  GEPs into such vectors are questionable to begin with, as some elements\r\n  are not even addressable.\r\n* Overaligned types, e.g. i16 with 32-bit alignment.\r\n\r\nExisting tests are unaffected, but a miscompilation of a new precommitted test is fixed.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Analysis/InlineCost.cpp", "functions": ["TypeSize"]}]}
{"pr_number": 77490, "url": "https://github.com/llvm/llvm-project/pull/77490", "title": "[mlir][mesh] Add lowering of process multi-index op", "body": "* Rename mesh.process_index -> mesh.process_multi_index.\r\n* Add mesh.process_linear_index op.\r\n* Add lowering of mesh.process_multi_index into an expression using mesh.process_linear_index, mesh.cluster_shape and affine.delinearize_index.\r\n\r\nThis is useful to lower mesh ops and prepare them for further lowering where the runtime may have only the linear index of a device/process. For example in MPI we have a rank (linear index) in a communicator.", "feature_layers": ["runtime", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Mesh/IR/MeshOps.cpp", "functions": ["failure", "success"]}, {"filename": "mlir/lib/Dialect/Mesh/Transforms/Transforms.cpp", "functions": ["failure", "processMultiIndexOpLoweringRegisterDialects", "success", "builder"]}, {"filename": "mlir/test/lib/Dialect/Mesh/TestProcessMultiIndexOpLowering.cpp", "functions": ["runOnOperation", "getArgument", "registerTestMultiIndexOpLoweringPass", "patterns", "getDependentDialects", "getDescription"]}, {"filename": "mlir/tools/mlir-opt/mlir-opt.cpp", "functions": ["registerTestMultiIndexOpLoweringPass"]}]}
{"pr_number": 77528, "url": "https://github.com/llvm/llvm-project/pull/77528", "title": "[Libomptarget] Add error message back in after changes", "body": "Summary:\nMy previous reworking of the image hangling removed the image info which\nwas originally used for this extra error message requested by Ye Luo. I\nhave since added in the necessary ELF facilities to extract it from the\nobject file and can add it back in. It's a little verbose mostly from\nneeding to shuffle around types and potential errors.\n", "feature_layers": [], "feature_directives": ["for", "target"], "files_changed": [{"filename": "openmp/libomptarget/src/omptarget.cpp", "functions": ["Buffer"]}]}
{"pr_number": 77326, "url": "https://github.com/llvm/llvm-project/pull/77326", "title": "[Clang] Wide delimiters ('{{{') for expect strings", "body": "Prior to this commit, it was impossible to use the simple string matching directives to look for any content that contains unbalanced `{{` `}}` pairs, such as:\r\n\r\n```\r\n// expected-note {{my_struct{{1}, 2}}}\r\n```\r\n\r\nWhich would parse like so:\r\n\r\n```\r\n             \"nested\" brace v\r\n// expected-note {{my_struct{{1}, 2}}}\r\n          closes the nested brace  ^ |\r\n                            trailing }\r\n```\r\n\r\nAnd the frontend would complain 'cannot find end ('}}') of expected'.\r\n\r\nAt this snapshot, VerifyDiagnosticConsumer's parser now counts the opening braces and looks for a matching length of closing sigils, allowing the above to be written as:\r\n\r\n```\r\n// expected-note {{{my_struct{{1}, 2}}}}\r\n   opening brace |-|                 |-|\r\n  closing brace is '}}}', found here ^\r\n```\r\n\r\nThis came about as a result of this discussion: https://github.com/llvm/llvm-project/pull/74852#discussion_r1443117644\r\n\r\ncc @erichkeane ", "feature_layers": ["parse", "ir", "frontend", "parser"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Frontend/VerifyDiagnosticConsumer.cpp", "functions": ["OpenBrace", "CloseBrace"]}]}
{"pr_number": 75881, "url": "https://github.com/llvm/llvm-project/pull/75881", "title": "[mlir] Add pattern to bubble up and cancel `vector.shape_cast`", "body": "", "feature_layers": ["ir", "ast"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/Vector/Transforms/VectorTransforms.cpp", "functions": ["failure"]}]}
{"pr_number": 77255, "url": "https://github.com/llvm/llvm-project/pull/77255", "title": "Objective C: use C++ exceptions on MinGW+GNUstep", "body": "The GNUstep Objective C runtime (libobjc2) is adding support for the GNU ABI on Windows (more specifically, MinGW).  The libobjc2 runtime uses C++ exceptions in that configuration; this PR updates clang to act accordingly.\r\n\r\nThe corresponding change to libobjc2 is here: https://github.com/gnustep/libobjc2/pull/267", "feature_layers": ["runtime"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/CodeGen/CGException.cpp", "functions": ["if"]}]}
{"pr_number": 77418, "url": "https://github.com/llvm/llvm-project/pull/77418", "title": "[RISCV] Re-implement Zacas MC layer support to make it usable for CodeGen.", "body": "This changes the register class to GPRPair and adds the destination\r\nregister as a source with a tied operand constraint.\r\n    \r\nParsing for the paired register is done with a custom parser that\r\nchecks for even register and converts it to its pair version. A\r\nbit of care needs to be taken so that we only parse as a pair register\r\nbased on which instruction we're parsing and the mode in the subtarget.\r\nThis allows amocas.w to be parsed correcty in both modes.\r\n    \r\nI've added a FIXME to note that we should be creating pair registers\r\nfor Zdinx on RV32 to match the instructions CodeGen generates.\r\n\r\nStacked on #77408 ", "feature_layers": ["parse", "codegen", "ir", "parser"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp", "functions": ["parseGPRPair"]}]}
{"pr_number": 77514, "url": "https://github.com/llvm/llvm-project/pull/77514", "title": "[mlir] allow inlining complex ops", "body": "Complex ops are pure ops just like the arithmetic ops so they can be inlined.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/Complex/IR/ComplexDialect.cpp", "functions": ["isLegalToInline"]}]}
{"pr_number": 77617, "url": "https://github.com/llvm/llvm-project/pull/77617", "title": "[OpenACC] Implement 'var' parsing correctly, support array sections", "body": "While investigating implementing 'var-list' generically for the variety of clauses that support this syntax (an extensive list!) I discovered that it includes 'compound types' and members of compound types, as well as array sections.\r\n\r\nThis patch genericizes that function, and implements it in terms of an assignment expression, and enables a simplified version of OMP Array Sections for it. OpenACC only supports a startidx + length, so this patch implements that parsing.\r\n\r\nHowever, it is currently still being represented as an OpenMP Array Section, which is semantically very similar.  It is my intent to come back and genericize the OMP Array Sections types (or create a similar expression node) in the future when dealing with Sema.\r\n\r\nAt the moment, the only obvious problem with it is that the diagnostic for using it in the 'wrong' place says OpenMP instead of OpenACC, which I intend to fix when I deal with the AST node changes.", "feature_layers": ["sema", "ast"], "feature_directives": ["for", "sections"], "files_changed": [{"filename": "clang/lib/Parse/ParseExpr.cpp", "functions": ["if"]}, {"filename": "clang/lib/Parse/ParseOpenACC.cpp", "functions": ["ArraySections"]}]}
{"pr_number": 76300, "url": "https://github.com/llvm/llvm-project/pull/76300", "title": "[ci] Set timeout for individual tests and report slowest tests", "body": "There are builds like\r\nhttps://buildkite.com/llvm-project/github-pull-requests/builds/24894\r\n\r\nIt looks like a deadlock in a test, but we can't see which one.\r\n`--timeout=` will make lit kill and report such tests.\r\n\r\n`--time-tests` produces nice report about slowest test, so we can tune\r\nthem over time.\r\n\r\nThe same build as above with new flags\r\nhttps://buildkite.com/llvm-project/github-pull-requests/builds/24961\r\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "compiler-rt/lib/dfsan/dfsan_chained_origin_depot.cpp", "functions": ["ChainedOriginDepotLockBeforeFork"]}, {"filename": "compiler-rt/lib/msan/msan_chained_origin_depot.cpp", "functions": ["ChainedOriginDepotBeforeFork"]}]}
{"pr_number": 77235, "url": "https://github.com/llvm/llvm-project/pull/77235", "title": "[MLIR][Presburger] Implement computation of generating function for unimodular cones", "body": "We implement a function that computes the generating function corresponding to a unimodular cone.\r\nThe generating function for a polytope is obtained by summing these generating functions over all tangent cones.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Analysis/Presburger/Barvinok.cpp", "functions": ["GeneratingFunction"]}, {"filename": "mlir/lib/Analysis/Presburger/Matrix.cpp", "functions": ["transp"]}]}
{"pr_number": 75658, "url": "https://github.com/llvm/llvm-project/pull/75658", "title": "[mlir][tensor] Fold producer linalg transpose with consumer tensor pack", "body": "Successor to https://github.com/llvm/llvm-project/pull/74206 \r\n\r\nPartial fix to https://github.com/openxla/iree/issues/15367 ", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/Tensor/Transforms/PackAndUnpackPatterns.cpp", "functions": ["failure", "success"]}]}
{"pr_number": 76652, "url": "https://github.com/llvm/llvm-project/pull/76652", "title": "[llvm-exegesis] Add tablegen support for validation counters", "body": "This patch adds support in the llvm-exegesis tablegen emitter for validation counters. Full support for validation counters in llvm-exegesis is added in a future patch.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/utils/TableGen/ExegesisEmitter.cpp", "functions": ["getPfmCounterId"]}]}
{"pr_number": 69204, "url": "https://github.com/llvm/llvm-project/pull/69204", "title": "[Driver] Ignore non-clang pch files when -include a.h probes a.h.gch", "body": "Instead of deprecating the \"gch probe\" as in\r\nf726da1193baf51e0a66453cc32dcffb8a9121d4, this makes clang ignore files which are not clang pch files (See discussion on PR #67084).\r\n\r\nThis fixes the issues mentioned in the former patch, with GCC-generated .gch files getting in the way when using clang, while maintaining the probing behavior for builds which rely on that.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Driver/ToolChains/Clang.cpp", "functions": ["gchProbe", "hasClangPchSignature"]}, {"filename": "clang/test/PCH/gch-probe.c", "functions": ["f"]}]}
{"pr_number": 77541, "url": "https://github.com/llvm/llvm-project/pull/77541", "title": "[MLIR][LLVM] DI Expression Rewrite & Legalization", "body": "Add a rewriter for DIExpressions & use it to run legalization patterns before exporting to llvm (because LLVM dialect allows DI Expressions that may not be valid in LLVM IR).\r\n\r\nThe rewriter driver works similarly to the existing mlir rewriter drivers, except it operates on lists of DIExpressionElemAttr (i.e. DIExpressionAttr). Each rewrite pattern transforms a range of DIExpressionElemAttr into a new list of DIExpressionElemAttr. \r\n\r\nIn addition, this PR sets up a place to add legalization patterns that are broadly applicable internally to the LLVM dialect, and they will always be applied prior to export. This PR adds one pattern for merging fragment operators.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/LLVMIR/Transforms/DIExpressionRewriter.cpp", "functions": ["inputs"]}]}
{"pr_number": 67918, "url": "https://github.com/llvm/llvm-project/pull/67918", "title": "[RISCV] Initial ISel support for the experimental zacas extension", "body": "This patch implements the v1.0 extension (ratified) based on AArch64's version.\r\n\r\nIt introduces two register classes (GPRPI64/GPRPI128) and some pseudo instructions for correct register allocation.\r\nThese pseudo instructions will be expanded in the `RISCVExpandAtomicPseudoInsts` pass.\r\n\r\nMigrated from https://reviews.llvm.org/D158956.\r\n", "feature_layers": [], "feature_directives": ["for", "atomic"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp", "functions": ["getAMOCASForRMW64", "getGPRPairEvenReg", "getAMOCASForRMW128", "getAMOCASForRMW32", "expandAMOCAS"]}, {"filename": "llvm/lib/Target/RISCV/RISCVISelLowering.cpp", "functions": ["DL"]}]}
{"pr_number": 72298, "url": "https://github.com/llvm/llvm-project/pull/72298", "title": "[AVR] make the AVR ABI Swift compatible", "body": "This patch is needed to add support to clang's AVR ABI for the Swift language. It is a pre-requisite for adding AVR support to the public Swift compiler itself.\r\n\r\nI'm open to any suggestions how I might create suitable unit tests for this?\r\n\r\n@benshi001 @rjmccall", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/CodeGen/Targets/AVR.cpp", "functions": ["TargetCodeGenInfo"]}]}
{"pr_number": 70190, "url": "https://github.com/llvm/llvm-project/pull/70190", "title": "[analyzer] Loop should contain CXXForRangeStmt", "body": "Static analyze can't report diagnose when statement after a CXXForRangeStmt and enable widen, because `ExprEngine::processCFGBlockEntrance` lacks of CXXForRangeStmt and when `AMgr.options.maxBlockVisitOnPath - 1` equals to `blockCount`, it can't widen. After next iteration, `BlockCount >= AMgr.options.maxBlockVisitOnPath` holds and generate a sink node. Add `CXXForRangeStmt` makes it work.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/Analysis/loop-widening-notes.cpp", "functions": ["test_for_range_loop"]}]}
{"pr_number": 73310, "url": "https://github.com/llvm/llvm-project/pull/73310", "title": "[SelectionDAG] Add space-optimized forms of OPC_CheckComplexPat", "body": "We record the usage of each `ComplexPat` and sort the `ComplexPat`s\nby usage.\n\nFor the top 8 `ComplexPat`s, we will emit a `OPC_CheckComplexPatN`\nto save one byte.\n\nOverall this reduces the llc binary size with all in-tree targets by\nabout 89K.\n", "feature_layers": [], "feature_directives": ["for", "target"], "files_changed": [{"filename": "llvm/utils/TableGen/DAGISelMatcherEmitter.cpp", "functions": ["MatcherEmitter", "if", "CGP"]}]}
{"pr_number": 73319, "url": "https://github.com/llvm/llvm-project/pull/73319", "title": "[SelectionDAG] Add space-optimized forms of OPC_CheckPatternPredicate", "body": "We record the usage of each `PatternPredicate` and sort them by\nusage.\n\nFor the top 8 `PatternPredicate`s, we will emit a\n`OPC_CheckPatternPredicateN` to save one byte.\n\nThe old `OPC_CheckPatternPredicate2` is renamed to\n`OPC_CheckPatternPredicateTwoByte`.\n\nOverall this reduces the llc binary size with all in-tree targets by\nabout 93K.\n\nThis PR is stacked on #73310.\n\n", "feature_layers": [], "feature_directives": ["for", "target"], "files_changed": [{"filename": "llvm/utils/TableGen/DAGISelMatcherEmitter.cpp", "functions": ["if"]}]}
{"pr_number": 77439, "url": "https://github.com/llvm/llvm-project/pull/77439", "title": "[AMDGPU] Don't send DEALLOC_VGPRs after calls", "body": "Calls do not have to wait for VsCnt, so after they return there might still be scratch stores in progress. It's important that we don't send the DEALLOC_VGPR message in that case, since that might release the VGPRs and scratch allocation before those stores are complete.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp", "functions": ["setStateOnFunctionEntryOrReturn", "setNonKernelFunctionInitialState", "setPendingEvent"]}]}
{"pr_number": 76801, "url": "https://github.com/llvm/llvm-project/pull/76801", "title": "[RISCV] Allow vsetvlis with same register AVL in doLocalPostpass", "body": "If we want to delete a vsetvli in the backwards pass, we need to be able to replace the AVL in MI with PrevMI's AVL.\r\nWe currently check to make sure that AVL isn't demanded so that we can clobber it, which works fine for immediate values.\r\n\r\nHowever for registers we need to make sure that we can the instruction defining the AVL also dominates PrevMI. \r\nRather than go all in and use MachineDominatorTree or similar, this handles a simpler case by just checking that the two AVLs are the same virtual register.\r\n\r\nBased off the draft patch in\r\nhttps://github.com/llvm/llvm-project/pull/75544#issuecomment-1858133214.\r\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp", "functions": ["isNonZeroLoadImmediate"]}]}
{"pr_number": 76329, "url": "https://github.com/llvm/llvm-project/pull/76329", "title": "[clangd] Handle lambda scopes inside Node::getDeclContext()", "body": "We used to consider the `DeclContext` for selection nodes inside a lambda as the enclosing scope of the lambda expression, rather than the lambda itself.\r\n\r\nFor example,\r\n\r\n```cpp\r\nvoid foo();\r\nauto lambda = [] {\r\n  return ^foo();\r\n};\r\n```\r\n\r\nwhere `N` is the selection node for the expression `foo()`, `N.getDeclContext()` returns the `TranslationUnitDecl` previously, which IMO is wrong, since the method `operator()` of the lambda is closer.\r\n\r\nIncidentally, this fixes a glitch in add-using-declaration tweaks. (Thanks @HighCommander4 for the test case.)", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang-tools-extra/clangd/unittests/SelectionTests.cpp", "functions": ["foo"]}, {"filename": "clang-tools-extra/clangd/unittests/tweaks/AddUsingTests.cpp", "functions": ["foo", "unrelated"]}]}
{"pr_number": 77586, "url": "https://github.com/llvm/llvm-project/pull/77586", "title": "Add new check: do not return 0; at the end of main() in C++", "body": "**Overview:**\r\nThis pull request fixes #38469 where the issue proposes a new static analysis check in C++ to discourage the explicit return 0; statement at the end of the main() function. As C++ automatically assumes a return 0; in this context, having the explicit statement is redundant. The suggested change aims to enhance code readability by eliminating unnecessary lines in the main() function.\r\n\r\n**Testing:**\r\n- Tested the updated code.\r\n- Verified that other functionalities remain unaffected.\r\n![Screenshot from 2024-01-10 16-53-31](https://github.com/llvm/llvm-project/assets/76656712/818d347e-7325-4d4d-aa0c-bcc611f46931)\r\n\r\n\r\n\r\n**Dependencies:**\r\n- No dependencies on other pull requests.\r\n\r\n**CC:**\r\n- @kirillbobyrev  , @AaronBallman \r\n", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "clang-tools-extra/clang-tidy/readability/DonotreturnzerocheckCheck.cpp", "functions": ["isCPlusPlusOrC99"]}, {"filename": "clang-tools-extra/test/clang-tidy/checkers/readability/DoNotReturnZeroCheck.cpp", "functions": ["main"]}, {"filename": "clang-tools-extra/clang-tidy/misc/ReturnzeroCheck.cpp", "functions": ["isCPlusPlusOrC99"]}, {"filename": "clang-tools-extra/test/clang-tidy/checkers/misc/ReturnZero.cpp", "functions": ["main"]}]}
{"pr_number": 71222, "url": "https://github.com/llvm/llvm-project/pull/71222", "title": "[flang] FDATE extension implementation: get date and time in ctime format", "body": "reference to gfortran fdate https://gcc.gnu.org/onlinedocs/gfortran/FDATE.html\r\nusage:\r\n```fortran\r\nCHARACTER(32) :: time\r\nCALL fdate(time)\r\nWRITE(*,*) time\r\n```\r\n\r\nfdate is used in the ECP proxy application https://proxyapps.exascaleproject.org/app/minismac2d/\r\nhttps://github.com/Mantevo/miniSMAC/blob/f90446714226eeef650b78bce06ca4967792e74d/ref/smac2d.f#L1570", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "flang/runtime/command.cpp", "functions": ["CopyToDescriptor", "RTNAME"]}, {"filename": "flang/runtime/extensions.cpp", "functions": ["FORTRAN_PROCEDURE_NAME"]}, {"filename": "flang/runtime/character.cpp", "functions": ["constexpr"]}]}
{"pr_number": 75394, "url": "https://github.com/llvm/llvm-project/pull/75394", "title": "[sanitizer] Fix asserts in asan and tsan in pthread interceptors.", "body": "Calling one of pthread join/detach interceptor on an already joined/detached thread causes asserts such as:\r\n\r\nAddressSanitizer: CHECK failed: sanitizer_thread_arg_retval.cpp:56 \"((t)) != (0)\" (0x0, 0x0) (tid=1236094)\r\n    #0 0x555555634f8b in __asan::CheckUnwind() compiler-rt/lib/asan/asan_rtl.cpp:69:3\r\n    #1 0x55555564e06e in __sanitizer::CheckFailed(char const*, int, char const*, unsigned long long, unsigned long long) compiler-rt/lib/sanitizer_common/sanitizer_termination.cpp:86:24\r\n    #2 0x5555556491df in __sanitizer::ThreadArgRetval::BeforeJoin(unsigned long) const compiler-rt/lib/sanitizer_common/sanitizer_thread_arg_retval.cpp:56:3\r\n    #3 0x5555556198ed in Join<___interceptor_pthread_tryjoin_np(void*, void**)::<lambda()> > compiler-rt/lib/asan/../sanitizer_common/sanitizer_thread_arg_retval.h:74:26\r\n    #4 0x5555556198ed in pthread_tryjoin_np compiler-rt/lib/asan/asan_interceptors.cpp:311:29\r\n\r\nThe assert are replaced by error codes.", "feature_layers": [], "feature_directives": ["for", "detach"], "files_changed": [{"filename": "compiler-rt/test/sanitizer_common/TestCases/Linux/pthread_join_invalid.cpp", "functions": ["main"]}]}
{"pr_number": 75486, "url": "https://github.com/llvm/llvm-project/pull/75486", "title": "[clang][AArch64] Add a -mbranch-protection option to enable GCS", "body": "-mbranch-protection=gcs (enabled by -mbranch-protection=standard) causes generated objects to be marked with the gcs feature. This is done via the guarded-control-stack module flag, in a similar way to branch-target-enforcement and sign-return-address.\r\n\r\nEnabling GCS causes the GNU_PROPERTY_AARCH64_FEATURE_1_GCS bit to be set on generated objects. No code generation changes are required, as GCS just requires that functions are called using BL and returned from using RET (or other similar variant instructions), which is already the case.", "feature_layers": ["ir"], "feature_directives": ["for", "target", "requires"], "files_changed": [{"filename": "clang/test/CodeGen/aarch64-branch-protection-attr.c", "functions": ["gcs"]}]}
{"pr_number": 77764, "url": "https://github.com/llvm/llvm-project/pull/77764", "title": "Add proper cost computation for llvm.vector.reduce.add", "body": "WIP", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp", "functions": ["if", "getVectorIntrinsicInstrCost"]}]}
{"pr_number": 74628, "url": "https://github.com/llvm/llvm-project/pull/74628", "title": "[flang] GETLOG runtime and extension implementation: get login username", "body": "Get login username, ussage:\r\n```\r\nCHARACTER(32) :: login\r\nCALL getlog(login)\r\nWRITE(*,*) login\r\n```\r\ngetlog is required for an exascale proxyapp.\r\nhttps://proxyapps.exascaleproject.org/app/minismac2d/\r\nhttps://github.com/Mantevo/miniSMAC/blob/f90446714226eeef650b78bce06ca4967792e74d/ref/smac2d.f#L615\r\nhttps://github.com/Mantevo/miniSMAC/blob/f90446714226eeef650b78bce06ca4967792e74d/ref/smac2d.f#L1570", "feature_layers": ["runtime", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/runtime/command.cpp", "functions": ["getlogin_r", "ToErrmsg", "CopyToDescriptor", "RTNAME"]}, {"filename": "flang/runtime/extensions.cpp", "functions": ["getlogin_r", "FORTRAN_PROCEDURE_NAME"]}, {"filename": "flang/runtime/character.cpp", "functions": ["constexpr"]}, {"filename": "flang/unittests/Runtime/CommandTest.cpp", "functions": ["CheckCharEqStr"]}, {"filename": "flang/runtime/tools.cpp", "functions": ["constexpr"]}]}
{"pr_number": 75823, "url": "https://github.com/llvm/llvm-project/pull/75823", "title": "[MemProf] Handle missing tail call frames", "body": "If tail call optimization was not disabled for the profiled binary, the\ncall contexts will be missing frames for tail calls. Handle this by\nperforming a limited search through tail call edges for the profiled\ncallee when a discontinuity is detected. The search depth is adjustable\nbut defaults to 5.\n\nIf we are able to identify a short sequence of tail calls, update the\ngraph for those calls. In the case of ThinLTO, synthesize the necessary\nCallsiteInfos for carrying the cloning information to the backends.\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp", "functions": ["calleeMatchesFunc", "Index"]}]}
{"pr_number": 77005, "url": "https://github.com/llvm/llvm-project/pull/77005", "title": "[TOSA] FFT2D operator", "body": "This PR adds lowering for TOSA Fft2d operator.\r\n\r\n@eric-k256 @GeorgeARM ", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Conversion/TosaToLinalg/TosaToLinalg.cpp", "functions": ["success"]}]}
{"pr_number": 77714, "url": "https://github.com/llvm/llvm-project/pull/77714", "title": "[mlir][spirv] Lower `arith` overflow flags to corresponding SPIR-V op decorations", "body": "", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Conversion/ArithToSPIRV/ArithToSPIRV.cpp", "functions": ["getDecorationString", "success"]}]}
{"pr_number": 76294, "url": "https://github.com/llvm/llvm-project/pull/76294", "title": "[mlir][memref] Transpose: allow affine map layouts in result, extend folder", "body": "Currently, the `memref.transpose` verifier forces the result type of the Op to have an explicit `StridedLayoutAttr` via the method `inferTransposeResultType`. This means that things like the example Op given in the documentation (https://mlir.llvm.org/docs/Dialects/MemRef/#memreftranspose-memreftransposeop) is actually invalid because it uses an `AffineMap` to specify the layout:\r\n```mlir\r\n%1 = memref.transpose %0 (i, j) -> (j, i) : memref<?x?xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d1 * s0 + d0)>>\r\n```\r\n\r\nIt also means that we can't \"un-transpose\" a transposed memref back to the implicit layout form, because the verifier will always enforce the explicit strided layout.\r\n\r\nThis patch makes the following changes:\r\n1. `inferTransposeResultType()` returns a `MemRefType` with canonicalized strided layout, i.e the strides are turned into a linearizing affine expression.\r\n2. The verifier checks whether the canonicalized strided layout of the result Type is identitcal to the infered (also canonical) result type layout. This way, it's only important that the two Types have the same strided layout, not necessarily the same representation of it.\r\n3. The folder is extended to support folding away the trivial case of identity permutation and to fold one transposition into another by composing the permutation maps.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/MemRef/IR/MemRefOps.cpp", "functions": ["canonicalizeStridedLayout", "emitOpError"]}]}
{"pr_number": 77160, "url": "https://github.com/llvm/llvm-project/pull/77160", "title": "[AArch64][SVE2] Generate XAR", "body": "Bitwise exclusive OR and rotate right by immediate\r\n\r\nSelect xar (x, y, imm) for the following pattern:\r\n    or (shl (xor x, y), nBits-imm), (shr (xor x, y), imm)\r\n\r\nThis is essentially:\r\n    rotr (xor(x, y), imm)\r\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AArch64/AArch64ISelLowering.cpp", "functions": ["SDValue", "DL", "LowerROTL"]}, {"filename": "llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp", "functions": ["DL"]}]}
{"pr_number": 77706, "url": "https://github.com/llvm/llvm-project/pull/77706", "title": "[mlir][tosa] Add tosa.dim to the TOSA dialect", "body": "The TOSA Spec defines a tosa.dim operation which is currently missing from the TOSA dialect definition.\r\n\r\nThis change adds:\r\n\r\n1. tosa.dim to the dialect\r\n2. some folding rules for tosa.dim\r\n3. a conversion pattern to tosa-to-tensor for tosa.dim", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Conversion/TosaToTensor/TosaToTensor.cpp", "functions": ["success"]}, {"filename": "mlir/lib/Dialect/Tosa/IR/TosaOps.cpp", "functions": ["success"]}]}
{"pr_number": 77828, "url": "https://github.com/llvm/llvm-project/pull/77828", "title": "[Libomptarget] Fix GPU Dtors referencing possibly deallocated image", "body": "Summary:\nThe constructors and destructors look up a symbol in the ELF quickly to\ndetermine if they need to be run on the GPU. This allows us to avoid the\nvery slow actions required to do the slower lookup using the vendor API.\n\nOne problem occurs with how we handle the lifetime of these images.\nRight now there is no invariant to specify the lifetime of the\nunderlying binary image that is loaded. In the typical case, this comes\nfrom the binary itself in the `.llvm.offloading` section, meaning that\nthe lifetime of the binary should match the executable itself. This\nwould work fine, if it weren't for the fact that the plugin is loaded\nvia `dlopen` and can have a teardown order out of sync with the main\nexecutable.\n\nThis was likely what was occuring when this failed on some systems but\nnot others. A potential solution would be to simply copy images into\nmemory so the runtime does not rely on external references. Another\nwould be to manually zero these out after initialization as to prevent\nthis mistake from happening accidentally. The former has the benefit of\nmaking some checks easier, and allowing for constant initialization be\ndone on the ELF itself (normally we can't do this because writing to a\nconstant section, e.g. .llvm.offloading is a segfault.). The downside\nwould be the extra time required to copy the image in bulk (Although we\nare likely doing this in the vendor runtimes as well).\n\nThis patch went with a quick solution to simply set a boolean value at\ninitialization time if we need to call destructors.\n\nFixes: https://github.com/llvm/llvm-project/issues/77798\n", "feature_layers": ["runtime", "ir"], "feature_directives": ["for", "target", "allocate"], "files_changed": [{"filename": "openmp/libomptarget/plugins-nextgen/amdgpu/src/rtl.cpp", "functions": ["callGlobalCtorDtorCommon", "AMDGPUKernel"]}, {"filename": "openmp/libomptarget/plugins-nextgen/cuda/src/rtl.cpp", "functions": ["callGlobalCtorDtorCommon"]}]}
{"pr_number": 77667, "url": "https://github.com/llvm/llvm-project/pull/77667", "title": "[mlir][openacc][flang] Simplify gang, vector and worker representation", "body": "The IR representation for gang, vector and worker has grown with the support for device_type. This patch simplify the IR representation for gang, vector and worker information on the acc.loop operation.\r\n\r\nWhen the only the keyword is present without any values, the information is printed at the same place than when there is values. The device_type is omitted if there is no values and it is equal to None. Otherwise the full information is displayed. First the keyword only device_type information and then the values with their device_type. ", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/OpenACC/IR/OpenACC.cpp", "functions": ["success", "printSingleDeviceType", "failure", "if", "arrayAttr", "hasDeviceTypeValues"]}]}
{"pr_number": 77802, "url": "https://github.com/llvm/llvm-project/pull/77802", "title": "[flang][openacc] Apply mutually exclusive clauses restriction to routine", "body": "this patch enforce or fix the enforcement of two restrictions from section 2.15.1:\r\n\r\n> Only the gang, worker, vector, seq and bind clauses may follow a device_type clause.\r\n\r\n`seq` was not allowed after `device_type` with the current implementation.\r\n\r\n> Exactly one of the gang, worker, vector, or seq clauses must appear.\r\n\r\nThis was not properly checked. This patch check correctly for mutually exclusion as described in section 2.4. Mutually exclusive clauses may appear on the same directive if they apply for different device_type. \r\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Semantics/check-acc-structure.cpp", "functions": ["if"]}]}
{"pr_number": 77673, "url": "https://github.com/llvm/llvm-project/pull/77673", "title": "[flang][openacc] Do not accept static and num for gang clause on routine dir", "body": "Only the dim argument is allowed on the gang clause for the routine directive. Reject static and num arguments in the semantic check. ", "feature_layers": ["sema", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/OpenACC/IR/OpenACC.cpp", "functions": ["failure", "success", "hasDeviceTypeValues"]}]}
{"pr_number": 75256, "url": "https://github.com/llvm/llvm-project/pull/75256", "title": "[compiler-rt][fuchsia] Preallocate a vmar for sanitizer internals", "body": "In an effort to reduce more mmap fragmentation, allocate a large enough vmar where we can map sanitizer internals via DoAnonymousMmap. Objects being mapped here include asan's FakeStack, LowLevelAllocator mappings, the primary allocator's TwoLevelMap, InternalMmapVector, StackStore, and asan's thread internals. The vmar is large enough to hold the total size of these objects seen in a \"typical\" process lifetime. If the vmar is full, it will fallback to mapping in the root vmar.", "feature_layers": [], "feature_directives": ["for", "allocate"], "files_changed": [{"filename": "compiler-rt/lib/sanitizer_common/sanitizer_fuchsia.cpp", "functions": ["GetSanitizerHeapVmar"]}]}
{"pr_number": 77731, "url": "https://github.com/llvm/llvm-project/pull/77731", "title": "[X86][CodeGen] Support EVEX compression: NDD to nonNDD", "body": "", "feature_layers": ["codegen"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/Target/X86/X86CompressEVEX.cpp", "functions": ["isRedundantNewDataDest"]}]}
{"pr_number": 77864, "url": "https://github.com/llvm/llvm-project/pull/77864", "title": "[CodeGen] Fix ponential memory leak in CodeGenPassBuilderTest", "body": "Found by https://lab.llvm.org/buildbot/#/builders/5/builds/40038.", "feature_layers": ["codegen"], "feature_directives": [], "files_changed": [{"filename": "llvm/unittests/CodeGen/CodeGenPassBuilderTest.cpp", "functions": ["PB"]}]}
{"pr_number": 77204, "url": "https://github.com/llvm/llvm-project/pull/77204", "title": "[mlir][TilingInterface] Move TilingInterface tests to use transform dialect ops.", "body": "In the process a couple of test transform dialect ops are added just\r\nfor testing. These operations are not intended to use as full flushed\r\nout of transformation ops, but are rather operations added for testing.\r\n\r\nA separate operation is added to `LinalgTransformOps.td` to convert a\r\n`TilingInterface` operation to loops using the\r\n`generateScalarImplementation` method implemented by the\r\noperation. Eventually this and other operations related to tiling\r\nusing the `TilingInterface` need to move to a better place (i.e. out\r\nof `Linalg` dialect)", "feature_layers": ["ir"], "feature_directives": ["for", "flush"], "files_changed": [{"filename": "mlir/lib/Dialect/Linalg/TransformOps/LinalgTransformOps.cpp", "functions": ["failure", "emitDefaultDefiniteFailure", "success", "getTarget"]}, {"filename": "mlir/test/lib/Interfaces/TilingInterface/TestTilingInterface.cpp", "functions": ["runOnOperation", "success", "replacements", "getArgument", "filter", "signalPassFailure", "registerTestTilingInterface", "matchDisjunction", "failure", "tilingPatterns", "checkAndNotify", "addTestPatterns", "addFilter", "getDependentDialects", "getDescription", "PassWrapper"]}, {"filename": "mlir/test/lib/Interfaces/TilingInterface/TestTilingInterfaceTransformOps.cpp", "functions": ["dominanceInfo", "failed", "success", "collectTiledAndFusedOps", "failure", "init", "loopOps"]}, {"filename": "mlir/tools/mlir-opt/mlir-opt.cpp", "functions": ["registerTestTilingInterface", "registerTestTilingInterfaceTransformDialectExtension"]}]}
{"pr_number": 68551, "url": "https://github.com/llvm/llvm-project/pull/68551", "title": "[RISCV][LLD] Add RISCV zcmt optimise in linker relaxation", "body": "This patch is moved from https://reviews.llvm.org/D134600\r\n\r\nThis patch implements optimizations for the zcmt extension in lld.\r\n\r\nA new TableJumpSectio has been added.\r\n\r\nScans each R_RISCV_CALL/R_RISCV_CALL_PLT relocType in each section before the linker relaxation, recording the name of the symbol.\r\n\r\nIn finalizeContents the recorded symbol names are sorted in descending order by the number of jumps.\r\n\r\nOptimise and insert a new cm.jt/cm.jalt during the relax process. in the process, we reused the`R_RISCV_JAL` relocType\r\n\r\nco-author: @ScottEgerton", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "lld/ELF/Arch/RISCV.cpp", "functions": ["if"]}, {"filename": "lld/ELF/SyntheticSections.cpp", "functions": ["if"]}]}
{"pr_number": 77807, "url": "https://github.com/llvm/llvm-project/pull/77807", "title": "[mlir][nvgpu] Improve verifier of `ldmatrix`", "body": "PR improves the verifier of `nvgpu.ldmatrix` Op, so `nvgpu-to-nvvm` lowering does not crash.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/NVGPU/IR/NVGPUDialect.cpp", "functions": ["emitError"]}]}
{"pr_number": 77750, "url": "https://github.com/llvm/llvm-project/pull/77750", "title": "[clang][dataflow] Process terminator condition within `transferCFGBlock()`.", "body": "In particular, it's important that we create the \"fallback\" atomic at this point\n(which we produce if the transfer function didn't produce a value for the\nexpression) so that it is placed in the correct environment.\n\nPreviously, we processed the terminator condition in the `TerminatorVisitor`,\nwhich put the fallback atomic in a copy of the environment that is produced as\ninput for the _successor_ block, rather than the environment for the block\ncontaining the expression for which we produce the fallback atomic.\n\nAs a result, we produce different fallback atomics every time we process the\nsuccessor block, and hence we don't have a consistent representation of the\nterminator condition in the flow condition.\n\nThis patch includes a test (authored by ymand@) that fails without the fix.\n", "feature_layers": ["ir"], "feature_directives": ["for", "atomic"], "files_changed": [{"filename": "clang/unittests/Analysis/FlowSensitive/TransferTest.cpp", "functions": ["target", "cond"]}]}
{"pr_number": 77779, "url": "https://github.com/llvm/llvm-project/pull/77779", "title": "[mlir][vector] Support warp distribution of `transfer_read` with dependencies", "body": "Support distribution of `vector.transfer_read` ops when operands are defined inside of the region of `warp_execute_on_lane_0` (except for the buffer from which the op is reading).\r\n\r\nSuch IR was previously not supported. This commit changes the implementation such that indices and the padding value are also distributed.\r\n\r\nThis commit simplifies the implementation considerably: the original implementation created a new `transfer_read` op and then checked if this new op is valid. If not, the rewrite pattern failed. This was a bit hacky. It was also a violation of the rewrite pattern API (detected by `MLIR_ENABLE_EXPENSIVE_PATTERN_API_CHECKS`) because the IR was modified, but the pattern returned \"failure\".", "feature_layers": ["ir"], "feature_directives": ["for", "distribute"], "files_changed": [{"filename": "mlir/lib/Dialect/Vector/Transforms/VectorDistribute.cpp", "functions": ["failure", "additionalResults", "additionalResultTypes", "Value"]}]}
{"pr_number": 77595, "url": "https://github.com/llvm/llvm-project/pull/77595", "title": "[mlir] introduce debug transform dialect extension", "body": "Introduce a new extension for simple print-debugging of the transform dialect scripts. The initial version of this extension consists of two ops that are printing the payload objects associated with transform dialect values. Similar ops were already available in the test extenion and several downstream projects, and were extensively used for testing.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Transform/DebugExtension/DebugExtension.cpp", "functions": ["init"]}, {"filename": "mlir/lib/Dialect/Transform/DebugExtension/DebugExtensionOps.cpp", "functions": ["os"]}, {"filename": "mlir/test/lib/Dialect/Transform/TestTransformDialectExtension.cpp", "functions": ["os"]}, {"filename": "mlir/unittests/Dialect/Transform/Preload.cpp", "functions": ["registerTestTransformDialectExtension"]}]}
{"pr_number": 77909, "url": "https://github.com/llvm/llvm-project/pull/77909", "title": "[mlir][vector] Fix rewrite pattern API violation in `VectorToSCF`", "body": "A rewrite pattern is not allowed to change the IR if it returns \"failure\". This commit fixes `test/Conversion/VectorToSCF/vector-to-scf.mlir` when running with `MLIR_ENABLE_EXPENSIVE_PATTERN_API_CHECKS`.\r\n\r\n```\r\nProcessing operation : 'vector.transfer_read'(0x55823a409a60) {\r\n  %5 = \"vector.transfer_read\"(%arg0, %0, %0, %2, %4) <{in_bounds = [true, true], operandSegmentSizes = array<i32: 1, 2, 1, 1>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>}> : (memref<?x4xf32>, index, index, f32, vector<[4]x4xi1>) -> vector<[4]x4xf32>\r\n\r\n  * Pattern (anonymous namespace)::lowering_n_d_unrolled::UnrollTransferReadConversion : 'vector.transfer_read -> ()' {\r\nTrying to match \"(anonymous namespace)::lowering_n_d_unrolled::UnrollTransferReadConversion\"\r\n    ** Insert  : 'vector.splat'(0x55823a445640)\r\n\"(anonymous namespace)::lowering_n_d_unrolled::UnrollTransferReadConversion\" result 0\r\n  } -> failure : pattern failed to match\r\n\r\nLLVM ERROR: pattern returned failure but IR did change\r\n```", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Conversion/VectorToSCF/VectorToSCF.cpp", "functions": ["failure"]}]}
{"pr_number": 77552, "url": "https://github.com/llvm/llvm-project/pull/77552", "title": "[Sema] Use lexical DC for friend functions when getting constraint instantiation args", "body": "Fixes a crash where the template argument depth computed in the semantic context for a friend FunctionDecl with a constrained parameter is compared against arguments in the lexical context for the purpose of checking if the constraint depends on enclosing template parameters.\r\n\r\nSince getTemplateInstantiationArgs in this case follows the semantic DC for friend FunctionDecls, the resulting depth is incorrect and trips an assertion.\r\n\r\nFixes #75426", "feature_layers": ["sema"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/SemaTemplate/GH75426.cpp", "functions": ["decltype", "f"]}]}
{"pr_number": 72213, "url": "https://github.com/llvm/llvm-project/pull/72213", "title": "[clang] Reapply Handle templated operators with reversed arguments", "body": "Re-applies https://github.com/llvm/llvm-project/pull/69595 with extra [diff](https://github.com/llvm/llvm-project/pull/72213/commits/79181efd0d7aef1b8396d44cdf40c0dfa4054984)\r\n### New changes\r\n\r\nFurther relax ambiguities with a warning for member operators of a template class (primary templates of such ops do not match). Eg:\r\n```cpp\r\ntemplate <class T>\r\nstruct S {\r\n    template <typename OtherT>\r\n    bool operator==(const OtherT &rhs); \r\n};\r\nstruct A : S<int> {};\r\nstruct B : S<bool> {};\r\nbool x = A{} == B{}; // accepted with a warning.\r\n```\r\n\r\nThis is important for making llvm build using previous clang versions in C++20 mode (eg: this makes the commit e558be51bab051d1471d92e967f8a2aecc13567a keep working with a warning instead of an error).\r\n\r\n### Description from https://github.com/llvm/llvm-project/pull/69595\r\n\r\nhttps://github.com/llvm/llvm-project/pull/68999 correctly computed conversion sequence for reversed args to a template operator. This was a breaking change as code, previously accepted in C++17, starts to break in C++20.\r\n\r\nExample:\r\n```cpp\r\nstruct P {};\r\ntemplate<class S> bool operator==(const P&, const S &);\r\n\r\nstruct A : public P {};\r\nstruct B : public P {};\r\nbool check(A a, B b) { return a == b; }  // This is now ambiguous in C++20.\r\n```\r\n\r\nIn order to minimise widespread breakages, as a clang extension, we had\r\npreviously accepted such ambiguities with a warning\r\n(`-Wambiguous-reversed-operator`) for non-template operators. Due to the\r\nsame reasons, we extend this relaxation for template operators.\r\n\r\nFixes https://github.com/llvm/llvm-project/issues/53954", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CXX/over/over.match/over.match.funcs/over.match.oper/p3-2a.cpp", "functions": ["test"]}]}
{"pr_number": 67461, "url": "https://github.com/llvm/llvm-project/pull/67461", "title": "[AMDGPU] Src1 of VOP3 DPP instructions can be SGPR on supported subtargets", "body": "In order to avoid duplicating every dpp pseudo opcode that has src1, we allow it for all opcodes and add manual checks on subtargets that do not support it.", "feature_layers": [], "feature_directives": ["for", "target"], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.cpp", "functions": ["hasDPPSrc1SGPR"]}]}
{"pr_number": 77796, "url": "https://github.com/llvm/llvm-project/pull/77796", "title": "[mlir][Transforms] `GreedyPatternRewriteDriver`: log successful folding", "body": "Similar to successful pattern applications, dump the rewritten IR after each successful folding when running with `-debug`.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp", "functions": ["logSuccessfulFolding"]}]}
{"pr_number": 71310, "url": "https://github.com/llvm/llvm-project/pull/71310", "title": "[mlir][bufferization] Clone simplify fails when input and result type not cast compatiable", "body": "The simplify  of bufferization.clone generates a memref.cast op, but the checks in simplify do not verify whether the operand types and return types of clone op is compatiable, leading to errors. This patch addresses this issue.", "feature_layers": ["ir", "ast"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/Bufferization/IR/BufferizationOps.cpp", "functions": ["failure"]}]}
{"pr_number": 77555, "url": "https://github.com/llvm/llvm-project/pull/77555", "title": "[AArch64][SVE2] Lower OR to SLI/SRI", "body": "Code builds on NEON code and the tests are adapted from NEON tests\nminus the tests for illegal types.\n\nChange-Id: I11325949700fb7433f948bbe3e82dbc71696aecc\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AArch64/AArch64ISelLowering.cpp", "functions": ["C1AsAPInt"]}]}
{"pr_number": 77834, "url": "https://github.com/llvm/llvm-project/pull/77834", "title": "[SCEV] Special case sext in isKnownNonZero", "body": "The existing logic in isKnownNonZero relies on unsigned ranges, which can be problematic when our range calculation is imprecise.  Consider the following:\r\n  %offset.nonzero = or i32 %offset, 1\r\n  -->  %offset.nonzero U: [1,0) S: [1,0)\r\n  %offset.i64 = sext i32 %offset.nonzero to i64\r\n  -->  (sext i32 %offset.nonzero to i64) U: [-2147483648,2147483648)\r\n                                         S: [-2147483648,2147483648)\r\n\r\nNote that the unsigned range for the sext does contain zero in this case despite the fact that it can never actually be zero.\r\n\r\nInstead, we can push the query down one level - relying on the fact that the sext is an invertible operation and that the result can only be zero if the input is.  We could likely generalize this reasoning for other invertible operations, but special casing sext seems worthwhile.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Analysis/ScalarEvolution.cpp", "functions": ["isKnownNonZero"]}]}
{"pr_number": 74077, "url": "https://github.com/llvm/llvm-project/pull/74077", "title": "[flang] Add EXECUTE_COMMAND_LINE runtime and lowering intrinsics implementation", "body": "This patch add support of intrinsics Fortran 2008 EXECUTE_COMMAND_LINE.\r\nThe patch contains both the lowering and the runtime code and works on\r\nboth Windows and Linux. The patch contains a list of commits, to convey\r\nthe authorship and the history of changes. Some implementation specifics\r\nor status has been added to `flang/docs/Intrinsics.md`.\r\n\r\nI have provided a summary of the usage and the options required for the\r\n`EXECUTE_COMMAND_LINE intrinsic`. The intrinsic supports both a synchronous\r\n(by default) and an asynchronous option.\r\n\r\n| System  | Mode  | Implemention              |\r\n|---------|-------|---------------------------|\r\n| Linux   | Sync  | std::system()             |\r\n| Windows | Sync  | std::system()             |\r\n| Linux   | Async | fork()  |\r\n| Windows | Async | CreateProcess             |\r\n\r\nSupport for the SYSTEM GNU extension will be added in a separate PR.\r\n\r\nCo-authored with @jeffhammond\r\n\r\n", "feature_layers": ["runtime", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Optimizer/Builder/Runtime/Execute.cpp", "functions": ["isAbsent"]}, {"filename": "flang/runtime/execute.cpp", "functions": ["CopyCharsToDescriptor"]}, {"filename": "flang/unittests/Runtime/CommandTest.cpp", "functions": ["IntDescriptor", "spaces"]}, {"filename": "flang/runtime/command.cpp", "functions": ["ToErrmsg", "FillWithSpaces", "constexpr", "CheckAndCopyCharsToDescriptor", "CopyCharsToDescriptor", "StringLength", "operator", "CheckAndCopyToDescriptor", "LengthWithoutTrailingSpaces", "CopyToDescriptor"]}, {"filename": "flang/runtime/tools.cpp", "functions": ["ToErrmsg", "LengthWithoutTrailingSpaces", "StringLength", "FillWithSpaces"]}]}
{"pr_number": 77854, "url": "https://github.com/llvm/llvm-project/pull/77854", "title": "[lldb] Adjust DynamicLoaderDarwin::GetThreadLocalData to support changes to TLS on macOS", "body": "TLS implementation on Apple OSes has changed. Instead of acquiring a pthread_key and calling pthread_getspecific, we instead acquire a function pointer and perform a function call with it. This fixes accessing thread local storage on macOS 14 (Sonoma) and newer.\r\n\r\nNote: Some versions of Apple's new linker do not emit debug symbols for TLS symbols. This causes the TLS tests to fail because LLDB and dsymutil expects there to be debug symbols to resolve the relevant TLS block. You may work around this by switching to the older linker or disabling the test until you have a newer version of the new linker.\r\n\r\nrdar://120676969", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "lldb/source/Plugins/DynamicLoader/MacOSX-DYLD/DynamicLoaderDarwin.cpp", "functions": ["data", "exe_ctx"]}]}
{"pr_number": 77757, "url": "https://github.com/llvm/llvm-project/pull/77757", "title": "[Flang][OpenMP] Separate creation of work-sharing and SIMD loops, NFC", "body": "These two constructs were both handled in `genOMP` for loop constructs. There is some shared code between the two, but there are also enough differences to separate these two cases into individual functions.\r\n\r\nThe shared code may be placed into a helper function later if needed.\r\n\r\nRecursive lowering [1/5]", "feature_layers": [], "feature_directives": ["for", "simd"], "files_changed": [{"filename": "flang/lib/Lower/OpenMP.cpp", "functions": ["dsp", "cp", "RetTy"]}]}
{"pr_number": 71919, "url": "https://github.com/llvm/llvm-project/pull/71919", "title": "[clang][Interp] Diagnose reads from non-const global variables", "body": "This fixes a long-standing FIXME item.\r\n\r\nUnfortunately it changes the diagnostic output of the tests added in `cxx23.cpp`, but they were wrong before and are wrong after, so no big deal.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/AST/Interp/Interp.cpp", "functions": ["CheckConstant"]}]}
{"pr_number": 77211, "url": "https://github.com/llvm/llvm-project/pull/77211", "title": "[mlir][arith] Add overflow flags support to arith ops", "body": "Add overflow flags support to the following ops:\r\n* `arith.addi`\r\n* `arith.subi`\r\n* `arith.muli`\r\n\r\nExample of new syntax:\r\n```\r\n%res = arith.addi %arg1, %arg2 overflow<nsw> : i64\r\n```\r\nSimilar to existing LLVM dialect syntax\r\n```\r\n%res = llvm.add %arg1, %arg2 overflow<nsw> : i64\r\n``` \r\n\r\nTablegen canonicalization patterns updated to always drop flags, proper support with tests will be added later.\r\n\r\nUpdated LLVMIR translation as part of this commit as it currenly written in a way that it will crash when new attributes added to arith ops otherwise.\r\n\r\nDiscussion https://discourse.llvm.org/t/rfc-integer-overflow-flags-support-in-arith-dialect/76025", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/Arith/IR/ArithOps.cpp", "functions": ["getDefOverflowFlags"]}]}
{"pr_number": 77550, "url": "https://github.com/llvm/llvm-project/pull/77550", "title": "[CodeGen][NewPM] Port AssignmentTrackingAnalysis to new pass manager", "body": "", "feature_layers": ["codegen"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp", "functions": ["FunctionVarLocs"]}]}
{"pr_number": 77477, "url": "https://github.com/llvm/llvm-project/pull/77477", "title": "[clang-format] TableGen keywords support.", "body": "Add TableGen keywords to the additional keyword list of the formatter.\r\n\r\nThis pull request is the splited part from https://github.com/llvm/llvm-project/pull/76059 .", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/unittests/Format/TokenAnnotatorTest.cpp", "functions": ["Lexer", "Keywords"]}]}
{"pr_number": 75171, "url": "https://github.com/llvm/llvm-project/pull/75171", "title": "[CodeGen] Port `LowerEmuTLS` to new pass manager", "body": "In fact, this pass need `llc` to test. `TargetMachine` seems redundant, because before adding this pass `CodeGenPassBuilder` already checks it:\r\nhttps://github.com/llvm/llvm-project/blob/ed4194bb8dbca5222628c2cddbc032fff57193b5/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h#L590-L592", "feature_layers": ["codegen"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "llvm/lib/CodeGen/LowerEmuTLS.cpp", "functions": ["addEmuTlsVar"]}]}
{"pr_number": 68362, "url": "https://github.com/llvm/llvm-project/pull/68362", "title": "[MLIR][Presburger] Implement Matrix::moveColumns", "body": "", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/unittests/Analysis/Presburger/MatrixTest.cpp", "functions": ["checkMatEqual"]}]}
{"pr_number": 77428, "url": "https://github.com/llvm/llvm-project/pull/77428", "title": "[Clang] [c++20] P1907R1: Support for generalized non-type template ar\u2026", "body": "\u2026guments of scalar type\r\n\r\nInitially https://reviews.llvm.org/D140996\r\n\r\nAuthor: @bolshakov-a\r\n\r\nI do not plan to work on this, but I'm trying to salvage what I can from phabricator. This review, is completely gone. I extracted it from my mails. So this PR is purely to make sure we have a trace.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/AST/ASTImporter.cpp", "functions": ["CheckType", "TemplateArgument"]}, {"filename": "clang/lib/AST/TemplateBase.cpp", "functions": ["Policy", "if", "getSourceStructuralValueExpression", "OS", "getStructuralValueType"]}, {"filename": "clang/lib/Sema/SemaTemplate.cpp", "functions": ["ExprError", "BuildExpressionFromIntegralTemplateArgumentValue", "TemplateArgument", "Diag", "MakeInitList"]}, {"filename": "clang/lib/Sema/SemaTemplateDeduction.cpp", "functions": ["DeducedTemplateArgument"]}, {"filename": "clang/test/CodeGenCXX/mangle-ms-templates.cpp", "functions": ["fn", "f"]}, {"filename": "clang/test/CodeGenCXX/mangle-template.cpp", "functions": ["f"]}, {"filename": "clang/test/Modules/odr_hash.cpp", "functions": ["f"]}, {"filename": "clang/test/SemaTemplate/temp_arg_nontype_cxx1z.cpp", "functions": ["type_affects_identity"]}, {"filename": "clang/tools/libclang/CIndex.cpp", "functions": ["Visit"]}]}
{"pr_number": 77819, "url": "https://github.com/llvm/llvm-project/pull/77819", "title": "[MLIR][Presburger] Helper functions to compute the constant term of a generating function", "body": "We implement two functions that are needed to compute the constant term of a GF.\r\nOne finds a vector not orthogonal to all the non-null vectors in a given set.\r\nOne computes the coefficient of any term in an arbitrary rational function (quotient of two polynomials).", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Analysis/Presburger/Barvinok.cpp", "functions": ["QuasiPolynomial"]}, {"filename": "mlir/unittests/Analysis/Presburger/BarvinokTest.cpp", "functions": ["getC"]}]}
{"pr_number": 78023, "url": "https://github.com/llvm/llvm-project/pull/78023", "title": "Revert \"[InstCombine] Fold `icmp pred (inttoptr X), (inttoptr Y) -> icmp pred X, Y`\"", "body": "Reverts llvm/llvm-project#77832\r\n\r\nTo fix https://lab.llvm.org/buildbot/#/builders/236/builds/8673\r\n\r\nAlso truncation to shorter type looks incorrect.\r\n\r\nIssue for tracking #78024 .", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp", "functions": ["ICmpInst"]}]}
{"pr_number": 75845, "url": "https://github.com/llvm/llvm-project/pull/75845", "title": "[ASan][libc++] Annotating `std::basic_string` with all allocators", "body": "This commit turns on ASan annotations in `std::basic_string` for all allocators by default.\r\n\r\nOriginally suggested here: https://reviews.llvm.org/D146214\r\n\r\nString annotations added here: https://github.com/llvm/llvm-project/pull/72677\r\n\r\nThis commit is part of our efforts to support container annotations with (almost) every allocator. Annotating `std::basic_string` with default allocator is implemented in https://github.com/llvm/llvm-project/pull/72677.\r\n\r\nAdditionally it removes `__begin != nullptr` because `data()` should never return a nullptr. \r\n\r\nSupport in ASan API exists since https://github.com/llvm/llvm-project/commit/1c5ad6d2c01294a0decde43a88e9c27d7437d157. This patch removes the check in std::basic_string annotation member function (__annotate_contiguous_container) to support different allocators.\r\n\r\n You can turn off annotations for a specific allocator based on changes from https://github.com/llvm/llvm-project/commit/2fa1bec7a20bb23f2e6620085adb257dafaa3be0.\r\n\r\nThe motivation for a research and those changes was a bug, found by Trail of Bits, in a real code where an out-of-bounds read could happen as two strings were compared via a call to `std::equal` that took `iter1_begin`, `iter1_end`, `iter2_begin` iterators (with a custom comparison function). When object `iter1` was longer than `iter2`, read out-of-bounds on `iter2` could happen. Container sanitization would detect it.\r\n\r\nIf you have any questions, please email:\r\n- advenam.tacet@trailofbits.com\r\n- disconnect3d@trailofbits.com", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "libcxx/test/libcxx/containers/strings/basic.string/asan.pass.cpp", "functions": ["do_exit", "c", "main"]}, {"filename": "libcxx/test/libcxx/containers/strings/basic.string/asan_turning_off.pass.cpp", "functions": ["main"]}]}
{"pr_number": 78040, "url": "https://github.com/llvm/llvm-project/pull/78040", "title": "[clang] Add test for CWG1350", "body": "Test is based on [P0136R1](https://wg21.link/p0136r1) wording instead of proposed resolution in the issue itself.\r\n\r\nThis patch also expands related CWG1573 test with an additional test case. Existing `3.9` status of 1573 is still relevant even with this new test case.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CXX/drs/dr15xx.cpp", "functions": ["j"]}]}
{"pr_number": 77444, "url": "https://github.com/llvm/llvm-project/pull/77444", "title": "[clang] Add tests for DRs about complete-class context", "body": "[P1787](https://wg21.link/p1787): The intent for CWG2335 (contra those of the older CWG1890, CWG1626, CWG1255, and CWG287) is supported by retaining the unrestricted forward lookup in complete-class contexts (despite current implementation behavior for non-templates).\r\n\r\nWording: The declaration set is the result of a single search in the scope of C for N from immediately after the class-specifier of C if P is in a complete-class context of C or from P otherwise. [Drafting note: The plan for CWG2335 is to describe forbidden dependency cycles among the complete-class contexts of a class. \u2014 end drafting note] ([class.member.lookup]/4)\r\n\r\nComplete-class context is described in [class.mem.general] [p7](http://eel.is/c++draft/class#mem.general-7) and [p8](http://eel.is/c++draft/class#mem.general-8). In this patch I add tests only for CWG issues that fall under current definition of complete-class context, because I'm not sure how CWG1255 and CWG287 are going to work. That's why I skip over them, but mark CWG1308 as superseded by CWG1330.", "feature_layers": [], "feature_directives": ["for", "single"], "files_changed": [{"filename": "clang/test/CXX/drs/dr16xx.cpp", "functions": ["_S_chk"]}, {"filename": "clang/test/CXX/drs/dr18xx.cpp", "functions": ["foo"]}, {"filename": "clang/test/CXX/drs/dr2335.cpp", "functions": ["compute_right"]}]}
{"pr_number": 78046, "url": "https://github.com/llvm/llvm-project/pull/78046", "title": "[mlir][ArmSME] Workaround for old versions of GCC (NFC)", "body": "See: https://github.com/llvm/llvm-project/pull/76086#issuecomment-1890424955", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Conversion/ArmSMEToLLVM/ArmSMEToLLVM.cpp", "functions": ["constexpr"]}]}
{"pr_number": 76086, "url": "https://github.com/llvm/llvm-project/pull/76086", "title": "[mlir][ArmSME] Add rudimentary support for tile spills to the stack", "body": "This adds very basic (and inelegant) support for something like spilling and reloading tiles, if you use more SME tiles than physically exist.\r\n\r\nThis is purely implemented to prevent the compiler from aborting if a function uses too many tiles (i.e. due to bad unrolling), but is expected to perform very poorly.\r\n\r\nCurrently, this works in two stages:\r\n\r\nDuring tile allocation, if we run out of tiles instead of giving up, we switch to allocating 'in-memory' tile IDs. These are tile IDs that start at 16 (which is higher than any real tile ID). A warning will also be emitted for each (root) tile op assigned an in-memory tile ID:\r\n\r\n```\r\nwarning: failed to allocate SME virtual tile to operation, all tile operations will go through memory, expect degraded performance\r\n```\r\n\r\nEverything after this works like normal until `-convert-arm-sme-to-llvm`\r\n\r\nHere the in-memory tile op:\r\n\r\n```mlir\r\narm_sme.tile_op { tile_id = <IN MEMORY TILE> }\r\n```\r\n\r\nIs lowered to:\r\n\r\n```mlir\r\n// At function entry:\r\n%alloca = memref.alloca ... : memref<?x?xty>\r\n\r\n// Around the op:\r\n// Swap the contents of %alloca and tile 0.\r\nscf.for %slice_idx {\r\n  %current_slice = \"arm_sme.intr.read.horiz\" ... <{tile_id = 0 : i32}>\r\n  \"arm_sme.intr.ld1h.horiz\"(%alloca, %slice_idx)  <{tile_id = 0 : i32}>\r\n  vector.store %current_slice, %alloca[%slice_idx, %c0]\r\n}\r\n// Execute op using tile 0.\r\narm_sme.tile_op { tile_id = 0 }\r\n// Swap the contents of %alloca and tile 0.\r\n// This restores tile 0 to its original state.\r\nscf.for %slice_idx {\r\n  %current_slice = \"arm_sme.intr.read.horiz\" ... <{tile_id = 0 : i32}>\r\n  \"arm_sme.intr.ld1h.horiz\"(%alloca, %slice_idx)  <{tile_id = 0 : i32}>\r\n  vector.store %current_slice, %alloca[%slice_idx, %c0]\r\n}\r\n```\r\n\r\nThis is inserted during the lowering to LLVM as spilling/reloading registers is a very low-level concept, that can't really be modeled correctly at a high level in MLIR.\r\n\r\nNote: This is always doing the worst case full-tile swap. This could be optimized to only spill/load data the tile op will use, which could be just a slice. It's also not making any use of liveness, which could allow reusing tiles. But these is not seen as important as correct code should only use the available number of tiles.", "feature_layers": ["ir"], "feature_directives": ["for", "allocate"], "files_changed": [{"filename": "mlir/lib/Conversion/ArmSMEToLLVM/ArmSMEToLLVM.cpp", "functions": ["constexpr"]}, {"filename": "mlir/lib/Dialect/ArmSME/Transforms/TileAllocation.cpp", "functions": ["unsigned", "kTilesInUseAttr"]}]}
{"pr_number": 74140, "url": "https://github.com/llvm/llvm-project/pull/74140", "title": "[clang-tidy] Fix false-positives in readability-container-size-empty", "body": "Added support for size-like method returning signed type, and corrected false positive caused by always-false check for size bellow zero.\r\n\r\nCloses #72619", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang-tools-extra/test/clang-tidy/checkers/readability/container-size-empty.cpp", "functions": ["size", "empty", "f"]}]}
{"pr_number": 76495, "url": "https://github.com/llvm/llvm-project/pull/76495", "title": "[PowerPC] Implement fence builtin", "body": "This builtin will work as barrier for instruction motion (scheduling, etc.)", "feature_layers": [], "feature_directives": ["for", "barrier"], "files_changed": [{"filename": "clang/test/CodeGen/PowerPC/builtins-ppc-xlcompat-sync.c", "functions": ["test_fence", "test_builtin_ppc_fence"]}]}
{"pr_number": 77366, "url": "https://github.com/llvm/llvm-project/pull/77366", "title": "[SHT_LLVM_BB_ADDR_MAP] Updates ELFYaml and adds tests for PGOAnalysisMap.", "body": "New test as mentioned here https://github.com/llvm/llvm-project/pull/77139#discussion_r1443586319", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/unittests/Object/ELFObjectFileTest.cpp", "functions": ["MissingSuccessorEntry", "MissingSuccessorEntryId"]}]}
{"pr_number": 77922, "url": "https://github.com/llvm/llvm-project/pull/77922", "title": "[mlir][Transforms] `OneToNTypeConversion.cpp`: Fix invalid IR", "body": "`buildUnrealizedCast` used to generate invalid `builtin.unrealized_conversion_cast` ops with zero results. This commit fixes `test/Conversion/OneToNTypeConversion/one-to-n-type-conversion.mlir` when running with `MLIR_ENABLE_EXPENSIVE_PATTERN_API_CHECKS`.\r\n\r\n```\r\n  * Pattern (anonymous namespace)::ConvertMakeTupleOp : 'test.make_tuple -> ()' {\r\nTrying to match \"(anonymous namespace)::ConvertMakeTupleOp\"\r\n\r\n[...]\r\n\r\n\"(anonymous namespace)::ConvertMakeTupleOp\" result 1\r\n  } -> success : pattern applied successfully\r\n// *** IR Dump After Pattern Application ***\r\nmlir-asm-printer: Verifying operation: func.func\r\n'builtin.unrealized_conversion_cast' op expected at least one result for cast operation\r\nmlir-asm-printer: 'func.func' failed to verify and will be printed in generic form\r\n\"func.func\"() <{function_type = (i1, i2) -> (i1, i2), sym_name = \"pack_unpack\"}> ({\r\n^bb0(%arg0: i1, %arg1: i2):\r\n  %0 = \"test.make_tuple\"() : () -> tuple<>\r\n  \"builtin.unrealized_conversion_cast\"(%0) {\"__one-to-n-type-conversion_cast-kind__\" = \"target\"} : (tuple<>) -> ()\r\n\r\n[...]\r\n\r\n}) : () -> ()\r\n\r\nwithin split at /usr/local/google/home/springerm/mlir_public/llvm-project/mlir/test/Conversion/OneToNTypeConversion/one-to-n-type-conversion.mlir:1 offset :20:8: error: 'builtin.unrealized_conversion_cast' op expected at least one result for cast operation\r\n  %0 = \"test.make_tuple\"() : () -> tuple<>\r\n       ^\r\nwithin split at /usr/local/google/home/springerm/mlir_public/llvm-project/mlir/test/Conversion/OneToNTypeConversion/one-to-n-type-conversion.mlir:1 offset :20:8: note: see current operation: \"builtin.unrealized_conversion_cast\"(%0) {\"__one-to-n-type-conversion_cast-kind__\" = \"target\"} : (tuple<>) -> ()\r\nLLVM ERROR: IR failed to verify after pattern application\r\n```", "feature_layers": ["ir", "ast"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "mlir/lib/Transforms/Utils/OneToNTypeConversion.cpp", "functions": ["ValueRange"]}]}
{"pr_number": 77277, "url": "https://github.com/llvm/llvm-project/pull/77277", "title": "[Flang][RISCV] Set vscale_range based off zvl*b", "body": "This patch implements the logic (for now, copied from RISCVTargetInfo::getVScaleRange) so that we can compute the vscale_range based off of the zvl*b extension, e.g. using an arch with zvl256b now implies vscale_range(2,1024).\r\n\r\nIt's worth noting that we don't have to exactly copy the behaviour of clang with regards to how it interacts with the -mvscale-min/-mvscale-max flags, but changing it can be left to a future patch.\r\n\r\nThis also adds a guard for +sve so that we only check for it on aarch64, which was the behaviour prior to 898db1136e679\r\n", "feature_layers": [], "feature_directives": ["for", "target"], "files_changed": [{"filename": "flang/lib/Frontend/FrontendActions.cpp", "functions": ["triple", "getAArch64VScaleRange", "getRISCVVScaleRange", "outputErrMsg"]}]}
{"pr_number": 75948, "url": "https://github.com/llvm/llvm-project/pull/75948", "title": "[SPIR-V] Strip convergence intrinsics before ISel", "body": "The structurizer will require the frontend to emit convergence\r\nintrinsics. Once uses to restructurize the control-flow, those\r\nintrinsics shall be removed, as they cannot be converted to\r\nSPIR-V.\r\n\r\nThis commit adds a new pass to the SPIR-V backend which strips those\r\nintrinsics.\r\n\r\nThose 2 new steps are not limited to Vulkan as OpenCL could\r\nalso benefit from not crashing if a convertent operation is in\r\nthe IR (even though the frontend doesn't generate such intrinsics).", "feature_layers": ["ir", "frontend"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/SPIRV/SPIRVStripConvergentIntrinsics.cpp", "functions": ["initializeSPIRVStripConvergentIntrinsicsPass", "runOnFunction", "SPIRVStripConvergentIntrinsics"]}]}
{"pr_number": 77811, "url": "https://github.com/llvm/llvm-project/pull/77811", "title": "[mlir][nvgpu] Add `nvgpu.tma.async.store`", "body": "PR adds `nvgpu.tma.async.store` Op for asynchronous stores using the Tensor Memory Access (TMA) unit.\r\n\r\nIt also implements Op lowering to NVVM dialect. The Op currently performs asynchronous stores of a tile memory region from shared to global memory for a single CTA.", "feature_layers": ["ir"], "feature_directives": ["for", "single"], "files_changed": [{"filename": "mlir/lib/Conversion/NVGPUToNVVM/NVGPUToNVVM.cpp", "functions": ["success", "b"]}, {"filename": "mlir/lib/Dialect/NVGPU/IR/NVGPUDialect.cpp", "functions": ["success", "emitError"]}]}
{"pr_number": 78118, "url": "https://github.com/llvm/llvm-project/pull/78118", "title": "Windows Filesystem fs::status Conditionally Call GetFileAttributes", "body": "Rather than conditionally using the output from GetFileAttributesW move the branch to avoid calling GetFileAttributesW entirely if not required. This avoids hitting IO an extra time for a small performance improvement.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Support/Windows/Path.inc", "functions": ["getStatus"]}]}
{"pr_number": 77195, "url": "https://github.com/llvm/llvm-project/pull/77195", "title": "[SPARC] Consume `tune-cpu` directive in the backend", "body": "This lets the backend read the `tune-cpu` directive that is emitted\nby the frontend.\n\nNo changes are needed for clang as it is already emits it.\n", "feature_layers": ["ir", "frontend"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/Sparc/SparcSubtarget.cpp", "functions": ["SparcGenSubtargetInfo"]}]}
{"pr_number": 67010, "url": "https://github.com/llvm/llvm-project/pull/67010", "title": "[Flang][OpenMP] Create MLIR optimization pass to push index allocations into loop body and remove them if redundant", "body": "This patch adds a Flang-only MLIR optimization pass that aims to remove redundant allocations of loop index variables related to OpenMP loops and improve LLVM IR code generation. The loop operations for which this is implemented and tested are `omp.wsloop` and `omp.simdloop`, and the main ways in which this is approached are to move allocations inside of the loop body (later this avoids having to pass these variables as arguments to an outlined function in LLVM IR) and to use block arguments representing loop indices on the loop region directly instead, if possible.\r\n\r\nThis is done in two stages:\r\n  1. Push allocations (`fir.alloca` and `hlfir.declare`) inside of the loop operation's region. This is only done for allocations that are used to store loop index variables and only used inside of a single loop region. The result of this is that, during MLIR to LLVM IR translation, when the loop operation is lowered by creating a function the allocation does not need to be passed as an additional argument.\r\n  2. Remove allocations and related load and store operations, and access the index through the corresponding block argument. If the previous step is successful, this can also be done if all uses of the allocation are `fir.load` or `fir.store`, meaning that it's not passed as a reference to another function/subprocedure.\r\n\r\nThe pass has been implemented to work with and without HLFIR support enabled, and multiple unit tests have been updated due to this pass running by default.", "feature_layers": ["ir"], "feature_directives": ["for", "single", "simd", "declare"], "files_changed": [{"filename": "flang/lib/Optimizer/Transforms/OMPLoopIndexMemToReg.cpp", "functions": ["process", "runOnOperation", "success", "pushAllocaIntoLoop", "allUsesInLoop", "pushDeclareIntoLoop", "failure", "if", "LoopProcessorHelper", "isDeclareRemovable", "isAllocaRemovable"]}]}
{"pr_number": 77758, "url": "https://github.com/llvm/llvm-project/pull/77758", "title": "[Flang][OpenMP] Push genEval calls to individual operations, NFC", "body": "Introduce `genNestedEvaluations` that will lower all evaluations nested in the given, accouting for a potential COLLAPSE directive.\r\n\r\nRecursive lowering [2/5]", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Lower/OpenMP.cpp", "functions": ["dsp", "cp", "RetTy"]}]}
{"pr_number": 77328, "url": "https://github.com/llvm/llvm-project/pull/77328", "title": "[MLIR][LLVM] Add Continuous Loop Peeling transform to SCF", "body": "This patch adds continuous loop peeling to scf loop transforms in the MLIR backend. This transforms the target loop into a chain of loops, with step sizes that are powers of two and decrease exponentially across subsequent loops.\r\n\r\nThe transform is similar to loop.peel in the effect that it creates a loop with a step (that is power of 2) to divide the range evenly, with the difference that the remaining iterations are spread across similar loops with exponentially decreasing step sizes, with the last loop with step size of 2^0 = 1.\r\n\r\nOriginally authored by Litu Zhou [litu.zhou@huawei.com](mailto:litu.zhou@huawei.com).\r\n\r\nOriginal pull-request was here https://github.com/llvm/llvm-project/pull/71555 \r\nWas closed because of an erroneous force push.", "feature_layers": ["ir", "ast"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "mlir/lib/Dialect/SCF/TransformOps/SCFTransformOps.cpp", "functions": ["failure", "convertSingleIterFor", "success", "guard"]}, {"filename": "mlir/lib/Dialect/SCF/Transforms/LoopSpecialization.cpp", "functions": ["failure"]}]}
{"pr_number": 77338, "url": "https://github.com/llvm/llvm-project/pull/77338", "title": "[Clang] Rename and enable boolean get, set, create and undef for sme2", "body": "This patch renames the get, set, create and undef functions that deal with tuples of booleans to match the ACLE at\r\nhttps://github.com/ARM-software/acle/pull/257/files . It also enables them for SME2.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_create2_bool.c", "functions": ["SVE_ACLE_FUNC", "svcreate2_b"]}, {"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_create4_bool.c", "functions": ["svcreate4_b", "SVE_ACLE_FUNC"]}, {"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_get2_bool.c", "functions": ["svget2_b", "SVE_ACLE_FUNC"]}, {"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_get4_bool.c", "functions": ["SVE_ACLE_FUNC", "svget4_b"]}, {"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_set2_bool.c", "functions": ["SVE_ACLE_FUNC", "svset2_b"]}, {"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_set4_bool.c", "functions": ["SVE_ACLE_FUNC", "svset4_b"]}, {"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_undef_bool.c", "functions": ["svundef2_b", "test_svundef4_b", "test_svundef2_b", "svundef4_b"]}]}
{"pr_number": 76936, "url": "https://github.com/llvm/llvm-project/pull/76936", "title": "[mlir][vector] Add mask to transfer_read/transfer_write when vectorizing", "body": "When we deal with 1-rank vectorization, we can add mask to transfer_read and transfer_write when the iteration is not divisible by the vector size.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/Affine/Transforms/SuperVectorize.cpp", "functions": ["inBounds"]}]}
{"pr_number": 75223, "url": "https://github.com/llvm/llvm-project/pull/75223", "title": "[GlobalISel] Refactor extractParts()", "body": "Moved extractParts() and extractVectorParts() from LegalizerHelper\r\nto Utils to be able to use it in different passes.\r\n\r\nextractParts() will also try to use unmerge when doing irregular\r\nsplits where possible, falling back to extract elements when not.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp", "functions": ["Pieces", "extractParts"]}, {"filename": "llvm/lib/CodeGen/GlobalISel/Utils.cpp", "functions": ["Pieces"]}]}
{"pr_number": 78141, "url": "https://github.com/llvm/llvm-project/pull/78141", "title": "[mlir][SCF] Do not verify step size of `scf.for`", "body": "An op verifier should verify only local properties. This commit removes the verification of `scf.for` step sizes. (Verifiers can check attributes but should not follow SSA values.)  This verification could reject IR that is actually valid, e.g.:\r\n\r\n```mlir\r\nscf.if %always_false {\r\n  // Branch is never entered.\r\n  scf.for ... step %c0 { ... }\r\n}\r\n```\r\n\r\nThis commit fixes `for-loop-peeling.mlir` when running with `MLIR_ENABLE_EXPENSIVE_PATTERN_API_CHECKS`:\r\n```\r\nwithin split at llvm-project/mlir/test/Dialect/SCF/for-loop-peeling.mlir:293 offset :9:3: note: see current operation:\r\n\"scf.for\"(%0, %3, %2) ({\r\n^bb0(%arg1: index):\r\n  %4 = \"arith.index_cast\"(%arg1) : (index) -> i64\r\n  \"memref.store\"(%4, %arg0) : (i64, memref<i64>) -> ()\r\n  \"scf.yield\"() : () -> ()\r\n}) {__peeled_loop__} : (index, index, index) -> ()\r\nLLVM ERROR: IR failed to verify after folding\r\n```\r\n\r\nNote: `%2` is `arith.constant 0 : index`.\r\n", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/SCF/IR/SCF.cpp", "functions": ["emitOpError"]}]}
{"pr_number": 78063, "url": "https://github.com/llvm/llvm-project/pull/78063", "title": "[flang][runtime] Clean up code to unblock development", "body": "Clean up recently-added code to avoid warnings and to eliminate a needless dependence from the Fortran runtime support library on C++ runtimes.", "feature_layers": ["runtime"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/runtime/extensions.cpp", "functions": ["FORTRAN_PROCEDURE_NAME", "GetUsernameEnvVar", "str"]}]}
{"pr_number": 77759, "url": "https://github.com/llvm/llvm-project/pull/77759", "title": "[Flang][OpenMP] Handle SECTION construct from within SECTIONS", "body": "Introduce `createSectionOp`, invoke it from the SECTIONS construct for each nested SECTION construct. This makes it unnecessary to embed OpenMPSectionConstruct inside of OpenMP~~Section~~Construct anymore.\r\n\r\nRecursive lowering [3/5]", "feature_layers": [], "feature_directives": ["for", "sections"], "files_changed": [{"filename": "flang/lib/Lower/OpenMP.cpp", "functions": ["dsp", "cp", "RetTy"]}]}
{"pr_number": 76846, "url": "https://github.com/llvm/llvm-project/pull/76846", "title": "[flang][runtime] Emit leading spaces in NAMELIST output", "body": "As NAMELIST output is a variant of list-directed output, its editing must produce leading spaces on (most) output records to effect carriage control.  These spaces are required by the language standard and implemented by nearly all other Fortran compilers (except GNU).\r\n\r\nFixes https://github.com/llvm/llvm-project/issues/76798.", "feature_layers": ["runtime", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/runtime/namelist.cpp", "functions": ["EmitUpperCase", "EmitWithAdvance"]}]}
{"pr_number": 75832, "url": "https://github.com/llvm/llvm-project/pull/75832", "title": "[AArch64][GlobalISel] Combine vecreduce(ext) to {U/S}ADDLV", "body": "The first commit `[GlobalISel] Refactor extractParts()` is going through review as well (Pull Request [#75223](https://github.com/llvm/llvm-project/pull/75223)).", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/Target/AArch64/GISel/AArch64PreLegalizerCombiner.cpp", "functions": ["if"]}]}
{"pr_number": 76999, "url": "https://github.com/llvm/llvm-project/pull/76999", "title": "[flang][runtime] Treatment of NaN in MAXVAL/MAXLOC/MINVAL/MINLOC", "body": "Detect NaN elements in data and handle them like gfortran does (at runtime); namely, NaN can be returned if all the data are NaNs, but any non-NaN value is preferable.  Ensure that folding returns the same results as runtime computation.\r\n\r\nFixes llvm-test-suite/Fortran/gfortran/regression/maxloc_2.f90 (and probably others).", "feature_layers": ["runtime"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Evaluate/fold-integer.cpp", "functions": ["operator"]}, {"filename": "flang/lib/Evaluate/fold-real.cpp", "functions": ["operator"]}, {"filename": "flang/runtime/extrema.cpp", "functions": ["constexpr"]}]}
{"pr_number": 78074, "url": "https://github.com/llvm/llvm-project/pull/78074", "title": "[SystemZ] Don't use FP Load and Test as comparisons to same reg", "body": "The usage of FP Load and Test instructions as a comparison against zero with\r\nthe assumption that the dest reg will always reflect the source reg is actually\r\nincorrect. Unfortunately, a SNaN will be converted to a QNaN, so the instruction\r\nmay actually change the value as opposed to being a pure register move with a\r\ntest.\r\n\r\nThis patch\r\n- changes instruction selection to always emit FP LT with a scratch def reg, which\r\n   will typically be allocated to the same reg if dead.\r\n- Removes the conversions into FP LT in SystemZElimcompare.\r\n\r\nThe overall impact of this on benchmarks is very limited, just some ~50 more\r\nCOPYs in total.\r\n\r\nI tried checking for a single use on zEC12 and in those cases emit the compare form\r\nthat has two use operands instead of def/use, but when I removed that I saw that it\r\nhad basically no impact (just some ~300 LT using a scratch reg, but no more\r\nspilling/copying). Therefore, this was removed entirely as a simplification.\r\n\r\nI tried removing the \"forward scan\", but that is still valuable with some ~7k L/LG\r\ntransformations.\r\n\r\nThe one open end I am not sure about is the **NoFPExcept** flag? In the POP it says\r\nthat an \"exception is recognized\". Since the LT may actually raise an exception, it\r\nshould not have the NoFPExcept flag. On the other hand, that flag itself should\r\nnot be there unless the input value is guaranteed to not be a NaN..?\r\n\r\n(In emitLoadAndTestCmp0, I first cleared that flag, but then realized that adjustCCMasksForInstr()\r\nin SystemZElimCompare will then bail from the transformation because of this.)\r\n", "feature_layers": ["ir"], "feature_directives": ["for", "single", "allocate"], "files_changed": [{"filename": "llvm/lib/Target/SystemZ/SystemZISelLowering.cpp", "functions": ["emitLoadAndTestCmp0"]}]}
{"pr_number": 77167, "url": "https://github.com/llvm/llvm-project/pull/77167", "title": "[flang][runtime] Better real MOD/MODULO results", "body": "The Fortran standard defines real MOD and MODULO with expressions like MOD(a,p) = a - AINT(a/p)*p.  Unfortunately, these definitions have poor accuracy when a is much larger in magnitude than p, and every Fortran compiler uses better algorithms instead.\r\n\r\nFixes llvm-test-suite/Fortran/gfortran/regression/mod_large_1.f90.", "feature_layers": ["runtime"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/runtime/numeric.cpp", "functions": ["constexpr", "SetExponent"]}]}
{"pr_number": 77362, "url": "https://github.com/llvm/llvm-project/pull/77362", "title": "[flang] Fix semantic checks for MOVE_ALLOC", "body": "The checking of calls to the intrinsic subroutine MOVE_ALLOC is not insisting that its first two arguments be whole allocatable variables or components.  Fix, move the code into check-calls.cpp (a better home for such things), and clean up the tests.\r\n\r\nFixes https://github.com/llvm/llvm-project/issues/77230.", "feature_layers": ["sema", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Evaluate/intrinsics.cpp", "functions": ["CheckForCoindexedObject"]}]}
{"pr_number": 77859, "url": "https://github.com/llvm/llvm-project/pull/77859", "title": "[InstCombine] Add folds for (add/sub/disjoint_or/icmp C, (ctpop (not x)))", "body": "- [InstCombine] Add tests for folding `(add/sub/disjoint_or/icmp C, (ctpop (not x)))`; NFC\r\n- [InstCombine] Add folds for `(add/sub/disjoint_or/icmp C, (ctpop (not x)))`\r\n----\r\n`(ctpop (not x))` <-> `(sub nuw nsw BitWidth(x), (ctpop x))`. The\r\n`sub` expression can sometimes be constant folded depending on the use\r\ncase of `(ctpop (not x))`.\r\n\r\nThis patch adds fold for the following cases:\r\n\r\n`(add/sub/disjoint_or C, (ctpop (not x))`\r\n    -> `(add/sub/disjoint_or C', (ctpop x))`\r\n`(cmp pred C, (ctpop (not x))`\r\n    -> `(cmp swapped_pred C', (ctpop x))`\r\n\r\nWhere `C'` depends on how we constant fold `C` with `BitWidth(x)` for\r\nthe given opcode.\r\n\r\nProofs: https://alive2.llvm.org/ce/z/qUgfF3\r\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/InstCombine/InstructionCombining.cpp", "functions": ["replaceInstUsesWith"]}]}
{"pr_number": 77683, "url": "https://github.com/llvm/llvm-project/pull/77683", "title": "[flang] Catch name resolution error due to global scoping", "body": "In\r\n    CALL FOO\r\n    PRINT *, ABS(FOO)\r\nwe currently resolve the first FOO to a global external subprogram, but then the second FOO is treated as an implicitly typed local variable.  This happens because the name FOO is not present in the local scope.\r\n\r\nFix by adding FOO to the local scope using a place-holding HostAssocDetails symbol whose existence prevents the creation of another FOO in the local scope.  The symbol stored in the parser::Name parse tree nodes or used in typed expressions will all continue to point to the global external subprogram.\r\n\r\nResolves llvm-test-suite/Fortran/gfortran/regression/pr71859.f90.", "feature_layers": ["parse", "ir", "parser"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Evaluate/characteristics.cpp", "functions": ["IsConstantExpr"]}]}
{"pr_number": 78047, "url": "https://github.com/llvm/llvm-project/pull/78047", "title": "[mlir][gpu] Add an offloading handler attribute to `gpu.module`", "body": "This patch adds an optional offloading handler attribute to the`gpu.module` op. This attribute will be used during `gpu-module-to-binary` pass to override the offloading handler used in the `gpu.binary` op.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/GPU/IR/GPUDialect.cpp", "functions": ["failure"]}]}
{"pr_number": 77980, "url": "https://github.com/llvm/llvm-project/pull/77980", "title": "[Libomptarget] Remove temporary files in AMDGPU JIT impl", "body": "Summary:\nThis patch cleans up some of the JIT handling for AMDGPU as well as\nremoving its temporary files. Previously these would be left in the\ntemporary directory after the program was run. This costs some extra\ntime, but the correct solution to avoid that is to create a sufficient\nentrypoint into `ld.lld` that we can simply pass a memory buffer into.\n", "feature_layers": ["ir"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "openmp/libomptarget/plugins-nextgen/amdgpu/src/rtl.cpp", "functions": ["createStringError"]}]}
{"pr_number": 68132, "url": "https://github.com/llvm/llvm-project/pull/68132", "title": "[builtins] Support building the 128-bit float functions on ld80 platforms", "body": "GCC provides these functions (e.g. __addtf3, etc.) in libgcc on x86_64. Since Clang supports float128, we can also enable the existing code by using float128 for fp_t if either __FLOAT128__ or __SIZEOF_FLOAT128__ is defined instead of only supporting these builtins for platforms with 128-bit IEEE long doubles.\r\nThis commit defines a new tf_float typedef that matches a float with attribute((mode(TF)) on each given architecture.\r\n\r\nThere are more tests that could be enabled for x86, but to keep the diff smaller, I restricted test changes to ones that started failing as part of this refactoring.\r\n\r\nThis change has been tested on x86 (natively) and aarch64,powerpc64,riscv64 and sparc64 via qemu-user.\r\n\r\nThis supersedes https://reviews.llvm.org/D98261 and should also cover the changes from https://github.com/llvm/llvm-project/pull/68041.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "compiler-rt/lib/builtins/divtc3.c", "functions": ["__divtc3"]}, {"filename": "compiler-rt/lib/builtins/extenddftf2.c", "functions": ["__extenddftf2", "__extendXfYf2__"]}, {"filename": "compiler-rt/lib/builtins/extendhftf2.c", "functions": ["__extendhftf2", "__extendXfYf2__"]}, {"filename": "compiler-rt/lib/builtins/extendsftf2.c", "functions": ["__extendsftf2", "__extendXfYf2__"]}, {"filename": "compiler-rt/lib/builtins/extendxftf2.c", "functions": ["__extendxftf2"]}, {"filename": "compiler-rt/lib/builtins/multc3.c", "functions": ["__multc3"]}, {"filename": "compiler-rt/lib/builtins/powitf2.c", "functions": ["__powitf2"]}, {"filename": "compiler-rt/lib/builtins/trunctfdf2.c", "functions": ["__trunctfdf2"]}, {"filename": "compiler-rt/lib/builtins/trunctfhf2.c", "functions": ["__truncXfYf2__", "__trunctfhf2"]}, {"filename": "compiler-rt/lib/builtins/trunctfsf2.c", "functions": ["__trunctfsf2"]}, {"filename": "compiler-rt/lib/builtins/trunctfxf2.c", "functions": ["__trunctfxf2"]}, {"filename": "compiler-rt/test/builtins/Unit/addtf3_test.c", "functions": ["main", "__addtf3"]}, {"filename": "compiler-rt/test/builtins/Unit/compiler_rt_fmaxl_test.c", "functions": ["main"]}, {"filename": "compiler-rt/test/builtins/Unit/compiler_rt_logbl_test.c", "functions": ["main"]}, {"filename": "compiler-rt/test/builtins/Unit/compiler_rt_scalbnl_test.c", "functions": ["main"]}, {"filename": "compiler-rt/test/builtins/Unit/divtc3_test.c", "functions": ["test__divtc3", "classify", "main"]}, {"filename": "compiler-rt/test/builtins/Unit/divtf3_test.c", "functions": ["main", "__divtf3"]}, {"filename": "compiler-rt/test/builtins/Unit/extendxftf2_test.c", "functions": ["__extendxftf2"]}, {"filename": "compiler-rt/test/builtins/Unit/floatditf_test.c", "functions": ["__floatditf", "main", "test__floatditf"]}, {"filename": "compiler-rt/test/builtins/Unit/floattitf_test.c", "functions": ["_test__floattitf", "main", "test__floattitf"]}, {"filename": "compiler-rt/test/builtins/Unit/floatunditf_test.c", "functions": ["__floatunditf", "main", "test__floatunditf"]}, {"filename": "compiler-rt/test/builtins/Unit/floatunsitf_test.c", "functions": ["__floatunsitf", "test__floatunsitf", "main"]}, {"filename": "compiler-rt/test/builtins/Unit/floatuntitf_test.c", "functions": ["test__floatuntitf", "_test__floatuntitf", "__floatuntitf"]}, {"filename": "compiler-rt/test/builtins/Unit/trunctfxf2_test.c", "functions": ["__trunctfxf2", "test__trunctfxf2"]}]}
{"pr_number": 78008, "url": "https://github.com/llvm/llvm-project/pull/78008", "title": "[mlir] Attribute add printStripped", "body": "Enable printing without dialect wrapping.\r\n\r\nThis closely matches `AsmPrinter::printStrippedAttrOrType` implementation wise except templating component.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/IR/AsmPrinter.cpp", "functions": ["state", "subPrinter", "printer"]}, {"filename": "mlir/unittests/IR/AttributeTest.cpp", "functions": ["os", "copyCount"]}]}
{"pr_number": 77728, "url": "https://github.com/llvm/llvm-project/pull/77728", "title": "[LoongArch] Add relaxDwarfLineAddr and relaxDwarfCFA to handle the mutable label diff in dwarfinfo", "body": "When linker-relaxation is enabled, part of the label diff in dwarfinfo cannot be computed before static link. Refer to RISCV, we add the relaxDwarfLineAddr and relaxDwarfCFA to add relocations for these label diffs. Calculate whether the label diff is mutable. For immutable label diff, return false and do the other works by its parent function.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/LoongArch/MCTargetDesc/LoongArchAsmBackend.cpp", "functions": ["OS", "uint8_t"]}]}
{"pr_number": 75338, "url": "https://github.com/llvm/llvm-project/pull/75338", "title": "[MachineScheduler] Add option to control reordering for store/load clustering", "body": "Reordering based on the sort order of the MemOpInfo array was disabled in <https://reviews.llvm.org/D72706>. However, it's not clear this is desirable for al targets. It also makes it more difficult to compare the incremental benefit of enabling load clustering in the selectiondag scheduler as well was the machinescheduler, as the sdag scheduler does seem to allow this reordering.\r\n\r\nThis patch adds a parameter that can control the behaviour on a per-target basis.\r\n\r\nSplit out from #73789.", "feature_layers": ["ir"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "llvm/lib/CodeGen/MachineScheduler.cpp", "functions": ["BaseMemOpClusterMutation", "TII"]}]}
{"pr_number": 78175, "url": "https://github.com/llvm/llvm-project/pull/78175", "title": "[mlir][Transforms] `GreedyPatternRewriteDriver`: Better expensive checks encapsulation", "body": "This change moves most IR verification logic (which is part of the expensive checks) into `DebugFingerPrints` and renames the struct to `ExpensiveChecks`. This isolates the debugging logic better from the remaining code.\r\n\r\nThis commit also removes a redundant check: the IR is no longer verified after a failed pattern application. We already assert that the IR did not change. (We know that the IR was valid before the attempted pattern application.)", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp", "functions": ["notifyFoldingSuccess"]}]}
{"pr_number": 78139, "url": "https://github.com/llvm/llvm-project/pull/78139", "title": "[Clang] Only compare template params of potential overload after checking their decl context", "body": "\r\n\r\nFixes a regression from 69066ab3 in which we compared the template lists of potential overloads before checkings their declaration contexts.\r\n\r\nThis would cause a crash when doing constraint substitution as part of that template check, because we would try to refer to not yet instantiated entities (the underlying cause is unclear).\r\n\r\nThis patch reorders (again) when we look at template parameter so we don't when checkings friends in different lexical contexts.\r\n\r\nFixes #77953\r\nFixes #78101", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CXX/over/over.load/p2-0x.cpp", "functions": ["f"]}]}
{"pr_number": 78130, "url": "https://github.com/llvm/llvm-project/pull/78130", "title": "[mlir][vector] Fix invalid IR in `ContractionOpLowering`", "body": "If a rewrite pattern returns \"failure\", it must not have modified the IR. This commit fixes `Dialect/Vector/vector-contract-to-outerproduct-transforms-unsupported.mlir` when running with `MLIR_ENABLE_EXPENSIVE_PATTERN_API_CHECKS`.\r\n\r\n```\r\n  * Pattern (anonymous namespace)::ContractionOpToOuterProductOpLowering : 'vector.contract -> ()' {\r\nTrying to match \"(anonymous namespace)::ContractionOpToOuterProductOpLowering\"\r\n    ** Insert  : 'vector.transpose'(0x5625b3a8cb30)\r\n    ** Insert  : 'vector.transpose'(0x5625b3a8cbc0)\r\n\"(anonymous namespace)::ContractionOpToOuterProductOpLowering\" result 0\r\n  } -> failure : pattern failed to match\r\n} -> failure : pattern failed to match\r\n\r\nLLVM ERROR: pattern returned failure but IR did change\r\n```\r\n\r\nNote: `vector-contract-to-outerproduct-transforms-unsupported.mlir` is merged into `vector-contract-to-outerproduct-matvec-transforms.mlir`. The `greedy pattern application failed` error is not longer produced. This error indicates that the greedy pattern rewrite did not convergence; it does not mean that a pattern could not be applied.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Vector/Transforms/LowerVectorContract.cpp", "functions": ["failure", "outerProd"]}]}
{"pr_number": 77105, "url": "https://github.com/llvm/llvm-project/pull/77105", "title": "[clang-tidy] Handle C++ structured bindings in `performance-for-range-copy`", "body": "Right now we are not triggering on:\r\n\r\n```\r\nfor (auto [x, y] : container) {\r\n  // const-only access\r\n}\r\n```", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang-tools-extra/test/clang-tidy/checkers/performance/for-range-copy.cpp", "functions": ["negativeMutatedBinding", "mutate", "positiveOnlyUsedAsConstBinding"]}]}
{"pr_number": 75273, "url": "https://github.com/llvm/llvm-project/pull/75273", "title": "[mlir][bufferization] Add `BufferizableOpInterface::hasTensorSemantics`", "body": "Add a new interface method to `BufferizableOpInterface`: `hasTensorSemantics`. This method returns \"true\" if the op has tensor semantics and should be bufferized.\r\n\r\nUntil now, we assumed that an op has tensor semantics if it has tensor operands and/or tensor op results. However, there are ops like `ml_program.global` that do not have any results/operands but must still be bufferized (#75103). The new interface method can return \"true\" for such ops.\r\n\r\nThis change also decouples `bufferization::bufferizeOp` a bit from the func dialect.\r\n\r\nDepends on #77574.\r\n", "feature_layers": ["sema", "ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Bufferization/IR/BufferizableOpInterface.cpp", "functions": ["any_of", "isaTensor"]}, {"filename": "mlir/lib/Dialect/Bufferization/Transforms/Bufferize.cpp", "functions": ["any_of", "isaTensor", "hasTensorSemantics"]}, {"filename": "mlir/lib/Dialect/Bufferization/Transforms/FuncBufferizableOpInterfaceImpl.cpp", "functions": ["hasTensorSemantics"]}, {"filename": "mlir/lib/Dialect/Bufferization/Transforms/OneShotAnalysis.cpp", "functions": ["hasTensorSemantics"]}, {"filename": "mlir/lib/Dialect/Bufferization/Transforms/OneShotModuleBufferize.cpp", "functions": ["failure"]}]}
{"pr_number": 78201, "url": "https://github.com/llvm/llvm-project/pull/78201", "title": "[clang] Fix direct-initialization with new expressions for arrays", "body": "Fixes #78183\r\n\r\nJust removed the check entirely. The diagnostic issued for trying to initialize an array (`array initializer must be an initializer list`) is much clearer (than `array 'new' cannot have initialization arguments`).\r\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Sema/SemaExprCXX.cpp", "functions": ["ExprError", "if", "InitRange"]}]}
{"pr_number": 77887, "url": "https://github.com/llvm/llvm-project/pull/77887", "title": "[llvm-exegesis] Refactor Counter to CounterGroup", "body": "This refactoring gets things ready for validation counters where the plan is to reuse the existing Counter infrastructure to contain event groups that consist of a single event that is being measured along with validation counters.", "feature_layers": ["ast"], "feature_directives": ["for", "single"], "files_changed": [{"filename": "llvm/tools/llvm-exegesis/lib/PerfHelper.cpp", "functions": ["Event"]}, {"filename": "llvm/tools/llvm-exegesis/lib/X86/X86Counter.cpp", "functions": ["CounterGroup", "Counter"]}]}
{"pr_number": 77896, "url": "https://github.com/llvm/llvm-project/pull/77896", "title": "[RemoveDIs][DebugInfo][NFC] Add Instruction and convenience functions to DPValue", "body": "This patch adds a set of functions to the DPValue class that conveniently perform some common operations, and some that replicate existing functions on `DbgVariableIntrinsic` and its subclasses. These functions aren't used in this patch, but will be used in patches to come (added in this patch to make review easier - they all perform trivial tasks or exactly replicate the behaviour of existing functions).", "feature_layers": [], "feature_directives": ["task", "for"], "files_changed": [{"filename": "llvm/lib/IR/DebugProgramInstruction.cpp", "functions": ["DPValue"]}]}
{"pr_number": 77900, "url": "https://github.com/llvm/llvm-project/pull/77900", "title": "[llvm-exegesis] Refactor individual counter data to ConfiguredEvent", "body": "This further sets things up for validation events. Having a separate abstraction for a configured event that is setup as a counter allows for much easier creation of more events in the future within a single counter group (like validation counters) without duplicating any code.", "feature_layers": [], "feature_directives": ["for", "single"], "files_changed": [{"filename": "llvm/tools/llvm-exegesis/lib/PerfHelper.cpp", "functions": ["EventCounter", "Event"]}]}
{"pr_number": 78108, "url": "https://github.com/llvm/llvm-project/pull/78108", "title": "[clang-format] Extract utility functions outside of test fixture", "body": "Extract utility functions outside of test fixture for DefinitionBlockSeparatorTest so that these functions can be used by other test fixtures. There are no functional changes.\r\n\r\nThis is a refactoring in preparation of the fix for #42112 ", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/unittests/Format/DefinitionBlockSeparatorTest.cpp", "functions": ["t", "removeEmptyLines"]}]}
{"pr_number": 78028, "url": "https://github.com/llvm/llvm-project/pull/78028", "title": "clang-tidy: Add bugprone-eval-order", "body": "The evaluation order of function or constructor parameters is unspecified, which may be unknown to non-expert C++ developers, and can lead to bugs. Thus, add a clang-tidy check to catch presumed suspect code.\r\n\r\n### Implementation\r\n\r\n* The check prints a warning, when at least two parameters in a call are sourced from any method of a class, and at least one of those method calls is non-`const`. A fix is not offered.\r\n* C++11 constructor list-initialization `[dcl.init.list]` has an evaluation order and can be used to silence this check.\r\n* In case of false positives, the check can be suppressed, or disabled completely.\r\n* `static` methods and global functions may also lead to issues, but they are not considered in this check, for now.\r\n\r\n### Rationale\r\n\r\nThe check is limited to member functions, because presumably the most common issue in real code is some kind of reader object:\r\n\r\n```cpp\r\nstruct Reader {\r\n    char buf[4]{};\r\n    int pos{};\r\n    char Pop() { return buf[pos++]; }\r\n};\r\n\r\nint Calc(char byte1, char byte2) { return byte1 > byte2; };\r\n\r\nint main() {\r\n    Reader r{{1, 2, 3}};\r\n    return Calc(r.Pop(), r.Pop());  // May return 0 or 1\r\n}\r\n```\r\n\r\nhttps://godbolt.org/z/rY5MMnPE3", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang-tools-extra/clang-tidy/bugprone/EvalOrderCheck.cpp", "functions": ["ClangTidyCheck"]}, {"filename": "clang-tools-extra/test/clang-tidy/checkers/bugprone/eval-order.cpp", "functions": ["function", "i", "a", "copy", "Dog", "ci", "cb", "I", "b"]}]}
{"pr_number": 78079, "url": "https://github.com/llvm/llvm-project/pull/78079", "title": "Improve modeling of two functions in StdLibraryFunctionsChecker", "body": "Improve 'errno' modeling of 'opendir' and 'fdopendir'.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "clang/test/Analysis/stream-errno.c", "functions": ["check_fdopendir", "check_opendir"]}]}
{"pr_number": 77911, "url": "https://github.com/llvm/llvm-project/pull/77911", "title": "[flang] fix VLA using malloc and avoid using std::vector, arg input type change to char * from std::byte", "body": "The extension getlog https://github.com/llvm/llvm-project/pull/74628 introduce a issue where in Solarias system, `LOGIN_NAME_MAX` can be undefined. this problem was fixed in https://github.com/llvm/llvm-project/pull/77775. \r\nBut due to the use of variable-length-array (VLA), two further patch went in with the use of `std::vector`. fb09447132cb192a0ef5082d4a4bae30f893e501 and 18734f606635f4f4270f911b68060890ce3dd94a. \r\n\r\nThis fix use malloc (AllocatedOrCrash and FreeMemory) instead, and change the input type from `std::byte *` to `char *`", "feature_layers": [], "feature_directives": ["allocate"], "files_changed": [{"filename": "flang/runtime/extensions.cpp", "functions": ["GetUsernameEnvVar"]}, {"filename": "flang/unittests/Runtime/CommandTest.cpp", "functions": ["input"]}]}
{"pr_number": 77957, "url": "https://github.com/llvm/llvm-project/pull/77957", "title": "[OpenACC} Improve diagnostics for 'tag's on clauses/directives", "body": "The 'cache' directive and various clauses have a 'tag' name that is optional.  This patch cleans up the use of the 'cache' version so that we get a nicer diagnostic, and enables us to do the same with clauses in the same situation.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Parse/ParseOpenACC.cpp", "functions": ["isTokenIdentifierOrKeyword"]}]}
{"pr_number": 78245, "url": "https://github.com/llvm/llvm-project/pull/78245", "title": "[clang][dataflow] Use `ignoreCFGOmittedNodes()` in `setValue()`.", "body": "This is to be consistent with `getValue()`, which also uses\n`ignoreCFGOmittedNodes()`.\n\nBefore this fix, it was not possible to retrieve a `Value` from a \"CFG omitted\"\nnode that had previously been set using `setValue()`; see the accompanying test,\nwhich fails without the fix.\n\nI discovered this issue while running internal integration tests on\nhttps://github.com/llvm/llvm-project/pull/78127.\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/unittests/Analysis/FlowSensitive/DataflowEnvironmentTest.cpp", "functions": ["target", "Env", "f"]}]}
{"pr_number": 77912, "url": "https://github.com/llvm/llvm-project/pull/77912", "title": "[RemoveDIs][DebugInfo] Add DPVAssign variant of DPValue", "body": "This implements the DbgAssignIntrinsic class as a variant of DPValues - unfortunately this involves increasing the size of the `DebugValueUser` storage by 3x, but this is necessary to enable assigns to be represented, and can be offset in a future patch by splitting DPValue into subclasses such that each variant can store only the fields it needs. This patch does not actually create DPVAssigns in any case; future patches will handle this variant in all cases where generic DPValue handling does not. This patch also does not implement tracking support for DIAssignIDs, which is necessary to find DPVAssigns that reference a given DIAssignID; that is added in a subsequent patch.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/IR/DebugProgramInstruction.cpp", "functions": ["DPValue"]}]}
{"pr_number": 77547, "url": "https://github.com/llvm/llvm-project/pull/77547", "title": "[lldb][Progress] Separate title and details", "body": "Per this RFC:\r\nhttps://discourse.llvm.org/t/rfc-improve-lldb-progress-reporting/75717 on improving progress reports, this commit separates the title field and details field so that the title specifies the category that the progress report falls under. The details field is added as a part of the constructor for progress reports and by default is an empty string. Also updates the test to check for details being correctly reported from the event structured data dictionary.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "lldb/source/Core/Progress.cpp", "functions": ["m_title"]}, {"filename": "lldb/source/Plugins/ObjectFile/Mach-O/ObjectFileMachO.cpp", "functions": ["progress"]}, {"filename": "lldb/source/Plugins/SymbolFile/DWARF/ManualDWARFIndex.cpp", "functions": ["progress"]}, {"filename": "lldb/source/Plugins/SymbolFile/DWARF/SymbolFileDWARF.cpp", "functions": ["progress"]}, {"filename": "lldb/source/Plugins/SymbolLocator/Default/SymbolLocatorDefault.cpp", "functions": ["progress"]}]}
{"pr_number": 76777, "url": "https://github.com/llvm/llvm-project/pull/76777", "title": "[RISCV] CodeGen of RVE and ilp32e/lp64e ABIs", "body": "This commit includes the necessary changes to clang and LLVM to support\ncodegen of `RVE` and the `ilp32e`/`lp64e` ABIs.\n\nThe differences between `RVE` and `RVI` are:\n* `RVE` reduces the integer register count to 16(x0-x16).\n* The ABI should be `ilp32e` for 32 bits and `lp64e` for 64 bits.\n\n`RVE` can be combined with all current standard extensions.\n\nThe central changes in ilp32e/lp64e ABI, compared to ilp32/lp64 are:\n* Only 6 integer argument registers (rather than 8).\n* Only 2 callee-saved registers (rather than 12).\n* A Stack Alignment of 32bits (rather than 128bits).\n* ilp32e isn't compatible with D ISA extension.\n\nIf `ilp32e` or `lp64` is used with an ISA that has any of the registers\nx16-x31 and f0-f31, then these registers are considered temporaries.\n\nTo be compatible with the implementation of ilp32e in GCC, we don't use\naligned registers to pass variadic arguments and set stack alignment\\\nto 4-bytes for types with length of 2*XLEN.\n\nFastCC is also supported on RVE, while GHC isn't since there is only one\navaiable register.\n\nDifferential Revision: https://reviews.llvm.org/D70401\n", "feature_layers": ["codegen", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/CodeGen/CodeGenModule.cpp", "functions": ["createRISCVTargetCodeGenInfo"]}, {"filename": "clang/lib/CodeGen/Targets/RISCV.cpp", "functions": ["DefaultABIInfo", "TargetCodeGenInfo"]}, {"filename": "clang/lib/Driver/ToolChains/Arch/RISCV.cpp", "functions": ["if"]}, {"filename": "llvm/lib/Target/RISCV/MCTargetDesc/RISCVTargetStreamer.cpp", "functions": ["if"]}, {"filename": "llvm/lib/Target/RISCV/RISCVFrameLowering.cpp", "functions": ["Align", "getABIStackAlignment"]}, {"filename": "llvm/lib/Target/RISCV/RISCVISelLowering.cpp", "functions": ["StackAlign", "getFastCCArgGPRs", "ArrayRef"]}, {"filename": "llvm/lib/Target/RISCV/RISCVTargetMachine.cpp", "functions": ["LLVMTargetMachine", "computeDataLayout"]}]}
{"pr_number": 76757, "url": "https://github.com/llvm/llvm-project/pull/76757", "title": "[flang] Support \\u Unicode escape sequences", "body": "Support \\uNNNN and \\uNNNNNNNN escape sequences for CHARACTER(KIND=2) and CHARACTER(KIND=4) literal constants for better GNU Fortran compatibility.\r\n\r\nFixes llvm-test-suite/Fortran/gfortran/regression/achar_6.F90 and .../widechar_1.f90.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Parser/characters.cpp", "functions": ["HexadecimalDigitValue"]}]}
{"pr_number": 78159, "url": "https://github.com/llvm/llvm-project/pull/78159", "title": "[clang] Fix CTAD not work for function-type and array-type arguments.", "body": "Fixes https://github.com/llvm/llvm-project/issues/51710.\r\n\r\nWhen transforming a constructor into a corresponding deduction guide, the decayed types (function/array type) were not handled properly which made clang fail to compile valid code. The patch teaches clang handle these decayed type in the transformation.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Sema/SemaTemplate.cpp", "functions": ["if"]}, {"filename": "clang/test/SemaCXX/ctad-decay.cpp", "functions": ["bar", "foo", "test3", "test4", "test1", "test2"]}, {"filename": "clang/test/SemaCXX/cxx1z-class-template-argument-deduction.cpp", "functions": ["test5", "test6"]}]}
{"pr_number": 76746, "url": "https://github.com/llvm/llvm-project/pull/76746", "title": "[clang][dataflow] Fix bug in `Value` comparison.", "body": "Makes value equivalence require that the values have no properties, except in\nthe case of equivalence by pointer equality (if the pointers are equal, nothing\nelse is checked).\n\nFixes issue #76459.\n", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "clang/lib/Analysis/FlowSensitive/Value.cpp", "functions": ["areEquivalentIndirectionValues"]}, {"filename": "clang/unittests/Analysis/FlowSensitive/ValueTest.cpp", "functions": ["V2", "Prop", "V1"]}]}
{"pr_number": 76293, "url": "https://github.com/llvm/llvm-project/pull/76293", "title": "[libc++][print] Enables it on Apple backdeployment.", "body": "As suggested in #73262 this enable the stream printing on Apple backdeployment targets. This omits the check whether the file is a terminal. This is not entirely conforming, but the differences should be minor and are typically not observable.\r\n\r\nFixes https://github.com/llvm/llvm-project/issues/75225", "feature_layers": ["ir"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "libcxx/src/ostream.cpp", "functions": ["__get_ostream_file"]}]}
{"pr_number": 78210, "url": "https://github.com/llvm/llvm-project/pull/78210", "title": "[lldb] Add LLDB_BUG_REPORT_URL macro to allow a different URL for lldb bug reporting.", "body": "This allows release teams to customize the bug report url for lldb. It also removes unnecessary constructions of `llvm::PrettyStackTraceProgram` as it's already constructed inside `llvm::InitLLVM`.", "feature_layers": [], "feature_directives": ["for", "teams"], "files_changed": [{"filename": "lldb/tools/lldb-dap/lldb-dap.cpp", "functions": ["X"]}, {"filename": "lldb/tools/lldb-server/lldb-server.cpp", "functions": ["X"]}]}
{"pr_number": 75842, "url": "https://github.com/llvm/llvm-project/pull/75842", "title": "[mlir][vector] Extend `CreateMaskFolder`", "body": "Extends `CreateMaskFolder` pattern so that the following:\n```mlir\n  %c8 = arith.constant 8 : index\n  %c16 = arith.constant 16 : index\n  %0 = vector.vscale\n  %1 = arith.muli %0, %c16 : index\n  %10 = vector.create_mask %c8, %1 : vector<8x[16]xi1>\n```\n\nis folded as:\n\n```mlir\n  %0 = vector.constant_mask [8, 16] : vector<8x[16]xi1>\n```\n", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/Vector/IR/VectorOps.cpp", "functions": ["failure"]}]}
{"pr_number": 74168, "url": "https://github.com/llvm/llvm-project/pull/74168", "title": "[libcxx] retain a version of basic_string::reserve(0) that shrinks when size()==0", "body": "Old (LLVM >=6) versions of the move assignment operator in basic string used to (indirectly via inlined functions) zero the size of the string then call reserve(0) to deallocate the memory they were holding. Implementing p0966r1 changed this by changing the contract of reserve() to never shrink, leading to memory leaks for code using this older implementation when it calls reserve() in the dylib.\r\n\r\nThis PR attempts to fix this situation by:\r\n\r\n1.    reverting the shrinking behaviour in the restricted case where we reserve(0) on a long zero-sized string (i.e. it has been cleared first)\r\n2.    applying an ABI-tag to reserve with the new behaviour, so uses going forward will always get the C++20+ standard compliant non-shrinking reserve in all cases\r\n\r\nThis could in theory affect some usages of reserve() in code by adding a non compliant deallocation, but there are a number of mitigating factors which make that unlikely:\r\n\r\n- The user needs to have cleared the string and then called reserve(0). This pattern seems unlikely unless you are expecting a deallocation to occur.\r\n- reserve() which calls reserve(0) is deprecated in C++20 and removed in C++26\r\n\r\nFixes https://github.com/llvm/llvm-project/issues/73683", "feature_layers": ["ir"], "feature_directives": ["for", "allocate"], "files_changed": [{"filename": "libcxx/test/libcxx/strings/basic.string/string.modifiers/reserve_with_shrink.pass.cpp", "functions": ["test", "main"]}]}
{"pr_number": 78329, "url": "https://github.com/llvm/llvm-project/pull/78329", "title": "Revert \"[libc][NFC] Refactor FPBits and remove LongDoubleBits specialization (#78192)\"", "body": "This reverts commit fdbf255c96cb18bc1fb08fa7264446bcbbd5fbd0.\n\nCauses build breakage on 32b arm (see reports:\nhttps://github.com/llvm/llvm-project/pull/78192).\n\nThese are reproducible for the 32b arm baremetal target on x86 hosts as well.\n", "feature_layers": [], "feature_directives": ["for", "target"], "files_changed": [{"filename": "libc/test/src/__support/FPUtil/fpbits_test.cpp", "functions": ["UInt128", "u128", "__uint128_t"]}]}
{"pr_number": 78311, "url": "https://github.com/llvm/llvm-project/pull/78311", "title": "[AST] Use APIntStorage to fix memory leak in EnumConstantDecl.", "body": "EnumConstantDecl is allocated by the ASTContext allocator so the destructor is never called.\r\n\r\nThis patch takes a similar approach to IntegerLiteral by using APIntStorage to allocate large APSInts using the ASTContext allocator as well.\r\n\r\nThe downside is that an additional heap allocation and copy of the data needs to be made when calling getInitValue if the APSInt is large.\r\n\r\nFixes #78160.", "feature_layers": ["ast"], "feature_directives": ["allocate"], "files_changed": [{"filename": "clang/lib/AST/Decl.cpp", "functions": ["new", "ValueDecl"]}]}
{"pr_number": 77986, "url": "https://github.com/llvm/llvm-project/pull/77986", "title": "[InstrProf][X86] Set code model for counters global variables", "body": "For the medium/large code models with small/large data splitting,\ninstrumentation-added globals that may vary in size and are assigned\nan explicit section can cause the large section flag to be\ninconsistent, usually meaning that some translation units will use\n32 bit relocations to reference these globals, but the section will be\nlaid out further from text, causing extra relocation pressure.\n\nFor the medium code model, mark these globals as \"small\" since performance may still be important for these globals.\n\nFor the large code model, mark these globals as \"large\" to prevent any sort of relocation pressure.\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Instrumentation/Instrumentation.cpp", "functions": ["if"]}]}
{"pr_number": 77349, "url": "https://github.com/llvm/llvm-project/pull/77349", "title": "[lldb][[DWARFDeclContext] Add function to extract qualified names as vector", "body": "This functionality will support the efforts to implement the IDX_Parent attribute of accelerator table entries, and it will allow us to more easily compare each of the names in a DIE parent chain hierarchy.\r\n\r\nhttps://discourse.llvm.org/t/rfc-improve-dwarf-5-debug-names-type-lookup-parsing-speed/74151/45", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "lldb/unittests/SymbolFile/DWARF/DWARFDIETest.cpp", "functions": ["t"]}]}
{"pr_number": 78080, "url": "https://github.com/llvm/llvm-project/pull/78080", "title": "[Clang][Sema] Extract ellipsis location from CXXFoldExpr for reattaching constraints on NTTPs", "body": "We build up a `CXXFoldExpr` for immediately declared constraints as per C++20 [temp.param]/4. This is done by\r\n`formImmediatelyDeclaredConstraint` where an `EllipsisLoc` is essential to determine whether this is a pack.\r\n\r\nOn the other hand, when attempting to instantiate a class template, member templates might not be instantiated immediately, so we leave them intact. For function templates with NTTPs,  we reattach constraints if possible so that they can be evaluated later. To properly form that, we attempted to extract an ellipsis location if the param per se was a parameter pack. Unfortunately, for the following NTTP case, we seemingly failed to handle:\r\n\r\n```cpp\r\ntemplate <Constraint auto... Pack>\r\nvoid member();\r\n```\r\n\r\nThe NTTPD Pack is neither an `ExpandedParameterPack` nor a `PackExpansion` (its type does not expand anything). As a result, we end up losing track of the constraints on packs, although we have them inside the associated `CXXFoldExpr`.\r\n\r\nThis patch fixes that by extracting the ellipsis location out of the previous constraint expression. Closes https://github.com/llvm/llvm-project/issues/63837.", "feature_layers": ["sema"], "feature_directives": ["for", "declare"], "files_changed": [{"filename": "clang/lib/Sema/SemaTemplateInstantiateDecl.cpp", "functions": ["SourceLocation"]}, {"filename": "clang/test/SemaTemplate/concepts.cpp", "functions": ["bar", "foo"]}]}
{"pr_number": 78083, "url": "https://github.com/llvm/llvm-project/pull/78083", "title": "[clang] Emit error for invalid friend functions under [temp.friend]p9", "body": "Emits an error for friend FunctionDecls that either:\r\n\r\n* are not templates and have a requires clause\r\n* are templates, and have a constrained parameter that depends on a template parameter from an enclosing template\r\n\r\nand are not a definition.\r\n\r\nFor a non-template friend function with a requires clause, if the function is not templated then the original error message indicating that such a function is disallowed is shown instead, as the function will still be rejected if a definition is added.", "feature_layers": ["ir"], "feature_directives": ["for", "requires"], "files_changed": [{"filename": "clang/test/SemaTemplate/GH71595.cpp", "functions": ["g"]}, {"filename": "clang/test/SemaTemplate/concepts-friends.cpp", "functions": ["bar2", "foo", "baz"]}]}
{"pr_number": 78376, "url": "https://github.com/llvm/llvm-project/pull/78376", "title": "[mlir][arith] Add overflow flags support to arith ops", "body": "Add overflow flags support to the following ops:\r\n* `arith.addi`\r\n* `arith.subi`\r\n* `arith.muli`\r\n\r\nExample of new syntax:\r\n```\r\n%res = arith.addi %arg1, %arg2 overflow<nsw> : i64\r\n```\r\nSimilar to existing LLVM dialect syntax\r\n```\r\n%res = llvm.add %arg1, %arg2 overflow<nsw> : i64\r\n```\r\n\r\nTablegen canonicalization patterns updated to always drop flags, proper support with tests will be added later.\r\n\r\nUpdated LLVMIR translation as part of this commit as it currenly written in a way that it will crash when new attributes added to arith ops otherwise.\r\n\r\nAlso lower `arith` overflow flags to corresponding SPIR-V op decorations\r\n\r\nDiscussion\r\nhttps://discourse.llvm.org/t/rfc-integer-overflow-flags-support-in-arith-dialect/76025\r\n\r\nThis effectively rolls forward #77211, #77700 and #77714 while adding a test to ensure the Python usage is not broken. More follow up needed but unrelated to the core change here. The changes here are minimal and just correspond to \"textual namespacing\" ODS side, no C++ or Python changes were needed.\r\n\r\n---------", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Conversion/ArithToSPIRV/ArithToSPIRV.cpp", "functions": ["getDecorationString", "success"]}, {"filename": "mlir/lib/Dialect/Arith/IR/ArithOps.cpp", "functions": ["getDefOverflowFlags"]}]}
{"pr_number": 77733, "url": "https://github.com/llvm/llvm-project/pull/77733", "title": "[X86] Use vXi1 for `k` constraint in inline asm", "body": "Fixes #77172", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/X86/X86ISelLowering.cpp", "functions": ["if"]}]}
{"pr_number": 77999, "url": "https://github.com/llvm/llvm-project/pull/77999", "title": "[lldb] Store SupportFile in LineEntry (NFC)", "body": "Store a SupportFile, rather than a FileSpec, in LineEntry. This commit\r\nworks towards having the SourceManageroperate on SupportFiles so that it\r\ncan (1) validate the Checksum and (2) materialize the content of inline\r\nsource information.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "lldb/source/Symbol/LineEntry.cpp", "functions": ["start_call_site"]}]}
{"pr_number": 77426, "url": "https://github.com/llvm/llvm-project/pull/77426", "title": "[RISCV] Overwrite cpu target features for full arch string in target attribute", "body": "This patch reworks RISCVTargetInfo::initFeatureMap to fix the issue described\nin https://github.com/llvm/llvm-project/pull/74889#pullrequestreview-1773445559\n(and is an alternative to #75804)\n\nWhen a full arch string is specified, a \"full\" list of extensions is now passed\nafter the __RISCV_TargetAttrNeedOverride marker feature, which includes any\nnegative features that disable ISA extensions.\n\nIn initFeatureMap, there are now two code paths:\n\n1. If the arch string was overriden, use the \"full\" list of override features,\nonly adding back any non-isa features that were specified.\n\nUsing the full list of positive and negative features will mean that the\ntarget-cpu will have no effect on the final arch, e.g.\n__attribute__((target(\"arch=rv64i\"))) with -mcpu=sifive-x280 will have the\nfeatures for rv64i, not a mix of both.\n\n2. Otherwise, parse and *append* the list of implied features. By appending, we\nturn back on any features that might have been disabled by a negative\nextension, i.e. this handles the case fixed in #74889.\n", "feature_layers": ["parse"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "clang/lib/Basic/Targets/RISCV.cpp", "functions": ["OverrideFeatures"]}]}
{"pr_number": 78137, "url": "https://github.com/llvm/llvm-project/pull/78137", "title": "[mlir][Tosa]: Add folder to ReciprocalOp of splat constant inputs", "body": "", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/Tosa/Transforms/TosaFolders.cpp", "functions": ["computeReciprocal"]}]}
{"pr_number": 77886, "url": "https://github.com/llvm/llvm-project/pull/77886", "title": "[X86] Add \"Ws\" constraint and \"p\" modifier for symbolic address/label reference", "body": "Printing the raw symbol is useful in inline asm (e.g. getting the C++\r\nmangled name, referencing a symbol in a custom way while ensuring it is\r\nnot optimized out even if internal). Similar constraints are available\r\nin other targets (e.g. \"S\" for aarch64/riscv, \"Cs\" for m68k).\r\n\r\n```\r\nnamespace ns { extern int var, a[4]; }\r\nvoid foo() {\r\n  asm(\".pushsection .xxx,\\\"aw\\\"; .dc.a %p0; .popsection\" :: \"Ws\"(&ns::var));\r\n  asm(\".reloc ., BFD_RELOC_NONE, %p0\" :: \"Ws\"(&ns::a[3]));\r\n}\r\n```\r\n\r\nLink: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=105576\r\n", "feature_layers": [], "feature_directives": ["for", "target"], "files_changed": [{"filename": "clang/test/CodeGen/X86/inline-asm-constraints.c", "functions": ["test_Ws"]}, {"filename": "clang/test/Sema/inline-asm-validate-x86.c", "functions": ["test_W"]}]}
{"pr_number": 78259, "url": "https://github.com/llvm/llvm-project/pull/78259", "title": "[DAGCombine] Add debug counter", "body": "Add a debug counter for DAGCombine. This can help with bisecting which DAG combine introduced a miscompile.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp", "functions": ["SDValue"]}]}
{"pr_number": 78158, "url": "https://github.com/llvm/llvm-project/pull/78158", "title": "[AArch64] Use parseArchExtension function. NFC", "body": "", "feature_layers": ["parse"], "feature_directives": [], "files_changed": [{"filename": "clang/lib/Basic/Targets/AArch64.cpp", "functions": ["StringRef"]}, {"filename": "llvm/lib/TargetParser/AArch64TargetParser.cpp", "functions": ["ArchExtBase"]}]}
{"pr_number": 78192, "url": "https://github.com/llvm/llvm-project/pull/78192", "title": "[libc][NFC] Refactor FPBits and remove LongDoubleBits specialization", "body": "This patch removes the `FPBits` specialization for x86 Extended Precision by moving it up to `FPRep`.\r\nIt also introduces two enums (`Exp` and `Sig`) to represent the exponent and significant parts of the floating point numbers. These enums are used to construct and observe floating point representations.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "libc/test/src/__support/FPUtil/fpbits_test.cpp", "functions": ["UInt128", "u128", "__uint128_t"]}]}
{"pr_number": 72428, "url": "https://github.com/llvm/llvm-project/pull/72428", "title": "[clang][AST] Invalidate DecompositionDecl if it has invalid initializer.", "body": "Fix #67495, #72198\r\n\r\nWe build ill-formed AST nodes for invalid structured binding. For case `int [_, b] = {0, 0};`, the `DecompositionDecl` is valid, and its children `BindingDecl`s are valid but with a NULL type, this breaks clang invariants in many places, and using these `BindingDecl`s can lead to crashes. This patch fixes them by marking the DecompositionDecl and its children invalid.\r\n\r\nCC @ADKaster, @ecnelises", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/AST/ast-dump-invalid-initialized.cpp", "functions": ["pr72198", "GH72198", "f", "pr67495"]}]}
{"pr_number": 77633, "url": "https://github.com/llvm/llvm-project/pull/77633", "title": "[AMDGPU] CodeGen for GFX12 8/16-bit SMEM loads", "body": "", "feature_layers": ["codegen"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp", "functions": ["MemAlign"]}, {"filename": "llvm/lib/Target/AMDGPU/SIISelLowering.cpp", "functions": ["handleByteShortBufferLoads", "DL"]}]}
{"pr_number": 78300, "url": "https://github.com/llvm/llvm-project/pull/78300", "title": "[RemoveDIs][DebugInfo] Make DIAssignID always replaceable", "body": "This patch is a necessary step to allowing the new non-intrinsic debug info to replace llvm.dbg.assign intrinsics. DIAssignIDs must be able to look up the debug assigns that refer to them, which is currently done by finding the MetadataAsValue for that AssignID and then searching the Instruction users of that MAV. This doesn't work for the new debug info however, which does not store direct Value references, and so we can't make use of MAV's lookup, so we instead need to be able to find direct users of DIAssignID. The only way to lookup users of metadata by default is when that metadata is tracked by ReplaceableMetadataImpl (which also suits this case as we want to be able to replace instances of DIAssignID). Currently the only MDNodes that are tracked by ReplaceableMetadataImpl are temporaries, although until recently* DIArgList was an MDNode that was always marked as replaceable; this patch treats DIAssignID the same way, allowing us to track users and RAUW it at any time.\r\n\r\n*Although there were performance issues when doing this with DIArgList that led me to make it no longer inherit from MDNode, the same is _not_ true for DIAssignID; the issue with DIArgList was related to it also being treated as a special case in the RAUW logic, which is not the case for DIAssignID (there is some performance cost to this change in optimized debug-info builds, but to a much lesser extent[0] than the DIArgList situation).\r\n\r\n[0]http://llvm-compile-time-tracker.com/compare.php?from=63342e18dd9cd1d187898fe53a7adf44c2d4481d&to=386217ffee106c78fa2a189b97b31a46cad5e828&stat=instructions:u", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/IR/Verifier.cpp", "functions": ["Write"]}]}
{"pr_number": 77727, "url": "https://github.com/llvm/llvm-project/pull/77727", "title": "[Clang][Sema] improve sema check of clang::musttail attribute", "body": "Call function with no-return attribute generates code with unreachable instruction instead of return and if the call  statement  has  `clang::musttail` attribute, it would crash in `VerifyPass`. Check this condition in Sema ahead.\r\nFix [issue](https://github.com/llvm/llvm-project/issues/76631)", "feature_layers": ["sema"], "feature_directives": [], "files_changed": [{"filename": "clang/test/SemaCXX/PR76631.cpp", "functions": ["throw_int", "int", "throw_int_wrapper"]}]}
{"pr_number": 73017, "url": "https://github.com/llvm/llvm-project/pull/73017", "title": "[APINotes] Upstream dependencies of Sema logic to apply API Notes to decls", "body": "This upstreams more of the Clang API Notes functionality that is currently implemented in the Apple fork: https://github.com/apple/llvm-project/tree/next/clang/lib/APINotes\r\n\r\nThis is the largest chunk of the API Notes functionality in the upstreaming process. I will soon submit a follow-up patch to actually enable usage of this functionality by having a Clang driver flag that enables API Notes, along with tests.\r\n\r\n(it might be easier to review commit-by-commit)", "feature_layers": ["sema"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Sema/SemaDeclAttr.cpp", "functions": ["Result", "handleNSErrorDomain"]}, {"filename": "clang/utils/TableGen/ClangAttrEmitter.cpp", "functions": ["writePCHWrite", "writeDump", "SimpleArgument", "writeHasChildren", "writeDumpChildren", "if", "writePCHReadDecls"]}, {"filename": "clang/lib/Parse/ParseDecl.cpp", "functions": ["L", "LocalScope"]}, {"filename": "clang/lib/Sema/SemaType.cpp", "functions": ["CheckNullabilityTypeSpecifier", "if", "DiagNullabilityKind"]}]}
{"pr_number": 78349, "url": "https://github.com/llvm/llvm-project/pull/78349", "title": "Revert \"[libc++] Fix `regex_search` to match `$` alone with `match_default` flag\"", "body": "The behavior of `std::regex_search` for patterns anchored both to the start and to the end of the input went wrong after merging #77256 . Patterns like `\"^b*$\"` started matching the strings such as `\"a\"`, which is not expected. \r\n\r\nReverts the PR: #77256", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "libcxx/test/std/re/re.const/re.matchflag/match_not_eol.pass.cpp", "functions": ["re"]}]}
{"pr_number": 78313, "url": "https://github.com/llvm/llvm-project/pull/78313", "title": "[RemoveDIs][DebugInfo] Create overloads of debug intrinsic utilities for DPValues", "body": "In preparation for the major chunk of the assignment tracking implementation, this patch adds a new set of overloaded versions of existing functions that take DbgVariableIntrinsics, with the overloads taking DPValues. This is used specifically to allow us to use auto* parameter lambdas to handle both DbgVariableIntrinsics and DPValues, reducing code duplication. This patch doesn't actually add the uses of these functions, so they will initially be unused, but it's easier from a review perspective to verify these functions do what they should be doing here, rather than alongside substantial changes scattered about elsewhere in LLVM.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/IR/DebugInfo.cpp", "functions": ["VariableSlice"]}, {"filename": "llvm/lib/Transforms/Utils/Local.cpp", "functions": ["getDebugValueLoc"]}]}
{"pr_number": 76145, "url": "https://github.com/llvm/llvm-project/pull/76145", "title": "AMDGPU/GlobalISelDivergenceLowering: select divergent i1 phis", "body": "Implement PhiLoweringHelper for GlobalISel in DivergenceLoweringHelper. Use machine uniformity analysis to find divergent i1 phis and select them as lane mask phis in same way SILowerI1Copies select VReg_1 phis. Note that divergent i1 phis include phis created by LCSSA and all cases of uses outside of cycle are actually covered by \"lowering LCSSA phis\". GlobalISel lane masks are registers with sgpr register class and S1 LLT.\r\n\r\nTODO: General goal is that instructions created in this pass are fully instruction-selected so that selection of lane mask phis is not split across multiple passes.\r\n\r\npatch 3 from: https://github.com/llvm/llvm-project/pull/73337", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/CodeGen/MachineUniformityAnalysis.cpp", "functions": ["print", "getAnalysisUsage", "runOnMachineFunction"]}, {"filename": "llvm/lib/Target/AMDGPU/AMDGPUGlobalISelDivergenceLowering.cpp", "functions": ["constrainAsLaneMask", "PhiLoweringHelper", "markAsLaneMask", "Helper"]}, {"filename": "llvm/lib/Target/AMDGPU/SILowerI1Copies.cpp", "functions": ["constrainAsLaneMask", "constrainIncomingRegisterTakenAsIs"]}]}
{"pr_number": 78270, "url": "https://github.com/llvm/llvm-project/pull/78270", "title": "[AArch64][Driver] Better handling of target feature dependencies", "body": "Currently there are several bits of code in the AArch64 driver which attempt to enforce dependencies between optional features in the -march= and -mcpu= options. However, these are based on the list of feature names being enabled/disabled, so they have a lot of logic to consider the order in which features were turned on and off, which doesn't scale well as dependency chains get longer.\r\n\r\nThis patch moves the code handling these dependencies to TargetParser, and changes them to use a Bitset of enabled features. This makes it easy to check which features are enabled, and is converted back to a list of LLVM feature names once all of the command-line options are parsed.\r\n\r\nThe motivating example for this was the -mcpu=cortex-r82+nofp option. Previously, the code handling the dependency between the fp16 and fp16fml extensions did not consider the nofp modifier, so it added +fullfp16 to the feature list. This should have been disabled by the +nofp modifier, and also the backend did follow the dependency between fullfp16 and fp, resulting in fp being turned back on in the backend.\r\n\r\nMost of the dependencies added to AArch64TargetParser.h weren't known about by clang before, I built that list by checking what the backend thinks the dependencies between SubtargetFeatures are.", "feature_layers": ["parse", "parser"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "clang/lib/Driver/ToolChains/Arch/AArch64.cpp", "functions": ["if"]}, {"filename": "llvm/lib/TargetParser/AArch64TargetParser.cpp", "functions": ["ModifierBase"]}]}
{"pr_number": 65731, "url": "https://github.com/llvm/llvm-project/pull/65731", "title": "[AST] Don't merge memory locations in AliasSetTracker", "body": "This changes the AliasSetTracker to track memory locations instead of pointers in its alias sets. The motivation for this is outlined in [an RFC posted on LLVM discourse](https://discourse.llvm.org/t/rfc-dont-merge-memory-locations-in-aliassettracker/73336).\r\n\r\nThis commit does not yet change method names and code comments to refer to \"memory location(s)\" instead of \"pointer(s)\", to keep the changeset focused, and to first gain feedback on the idea. An additional commit can take care of this.\r\n\r\nIn the data structures of the AST implementation, I made the choice to replace the linked list of `PointerRec` entries (that had to go anyway) with a simple flat vector of `MemoryLocation` objects, but for the `AliasSet` objects referenced from a lookup table, I retained the mechanism of a linked list, reference counting, forwarding, etc. The data structures could be revised in a follow-up change.", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Analysis/AliasSetTracker.cpp", "functions": ["any_of"]}, {"filename": "llvm/lib/Analysis/LoopAccessAnalysis.cpp", "functions": ["AccessWrite"]}]}
{"pr_number": 77518, "url": "https://github.com/llvm/llvm-project/pull/77518", "title": "[Flang][MLIR] Add basic initial support for alloca and program address space handling in FIR->LLVMIR codegen", "body": "This is a slightly more slimmed down and up-to-date version of the older PR from here: https://reviews.llvm.org/D144203, written by @jsjodin, which has already under gone some review.\r\n\r\nThis PR places allocas in the alloca address space specified by the provided data layout (default is 0 for all address spaces, unless explicitly specified by the layout), and then will cast these alloca's to the program address space if this address space is different from the allocation address space. For most architectures data layouts, this will be a no-op, as they have a flat address space. But in the case of AMDGPU it will result in allocas being placed in the correct address space (5, private), and then casted into the correct program address space (0, generic). This results in correct (partially, a follow up PR will be forthcoming soon) generation of allocations inside of device code.\r\n\r\nThis PR is in addition to the work by @skatrak in this PR:  https://github.com/llvm/llvm-project/pull/69599 and adds seperate and neccesary functionality of casting alloca's from their address space to the program address space, both are independent PRs, although there is some minor overlap e.g. this PR incorporates some of the useful helper functions from 69599, so whichever lands first will need a minor rebase.\r\n\r\nCo-author: jsjodin", "feature_layers": ["codegen", "ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Optimizer/CodeGen/CodeGen.cpp", "functions": ["getAllocaAddressSpace", "getProgramAddressSpace"]}]}
{"pr_number": 76212, "url": "https://github.com/llvm/llvm-project/pull/76212", "title": "[AMDGPU][GFX12] Default component broadcast store", "body": "For image and buffer stores the default behaviour on GFX12 is to set all unset components to the value of the first component. So if we pass only X component, it will be the same as XXXX, or XY same as XYXX.\r\n\r\nThis patch simplifies the passed vector of components in InstCombine by removing components from the end that are equal to the first component.\r\n\r\nFor image stores it also trims DMask if necessary.", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/AMDGPUInstCombineIntrinsic.cpp", "functions": ["if"]}]}
{"pr_number": 78389, "url": "https://github.com/llvm/llvm-project/pull/78389", "title": "[lldb] Upstream xros support in lldb", "body": "Upstream support for debugging xros applications through LLDB.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "lldb/source/Plugins/Platform/MacOSX/PlatformAppleSimulator.cpp", "functions": ["Terminate", "Initialize", "CreateInstance"]}]}
{"pr_number": 78469, "url": "https://github.com/llvm/llvm-project/pull/78469", "title": "Revert \"[SimplifyCFG] `switch`: Do Not Transform the Default Case if the Condition is Too Wide\"", "body": "Reverts llvm/llvm-project#77831, which depends on #76669, which seriously regresses compilation time / memory usage see https://github.com/llvm/llvm-project/pull/76669#issuecomment-1889271710.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Utils/SimplifyCFG.cpp", "functions": ["SIW"]}]}
{"pr_number": 77707, "url": "https://github.com/llvm/llvm-project/pull/77707", "title": "[llvm] Introduce XROS platform ", "body": "Accepts but otherwise ignores visionOS/XROS target triples as Darwin based platform.\r\n\r\nhttps://developer.apple.com/documentation/visionos", "feature_layers": [], "feature_directives": ["for", "target"], "files_changed": [{"filename": "llvm/lib/TargetParser/Triple.cpp", "functions": ["if"]}]}
{"pr_number": 78373, "url": "https://github.com/llvm/llvm-project/pull/78373", "title": " [llvm] Teach MachO about XROS", "body": "Add support for XROS to encode in Mach-O file formats.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/MC/MCStreamer.cpp", "functions": ["VersionTuple"]}, {"filename": "llvm/unittests/TextAPI/TextStubV4Tests.cpp", "functions": ["OS"]}]}
{"pr_number": 78347, "url": "https://github.com/llvm/llvm-project/pull/78347", "title": "[mlir][openacc][NFC] Use interleaveComma in printers", "body": "Simplify printer code and use llvm::interleaveComma to print comma separated list.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/OpenACC/IR/OpenACC.cpp", "functions": ["if", "printSingleDeviceType"]}]}
{"pr_number": 77988, "url": "https://github.com/llvm/llvm-project/pull/77988", "title": "[lldb] Support changes to TLS on macOS", "body": "I decided to resubmit #77854 but broken up into multiple commits for better reviewability. I recommend reviewing each commit individually, the overall change is quite large.\r\n\r\nrdar://120676969", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "lldb/source/Plugins/DynamicLoader/MacOSX-DYLD/DynamicLoaderDarwin.cpp", "functions": ["exe_ctx"]}]}
{"pr_number": 74770, "url": "https://github.com/llvm/llvm-project/pull/74770", "title": "[driver] Respect the mode the driver is in for autocomplete", "body": "The previous code was always auto-completing options for the clang mode (except for flang which specifically overrode it.)  We have multiple other driver modes, and we appear to parse options based on those modes, so seemingly the obvious thing to do is auto-complete the options we'd accept?\r\n\r\nNote: Advice on how to test this is very welcome.  I don't see any testing in tree for anything except clang, and I don't personally use this auto complete feature at all.", "feature_layers": ["parse"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Driver/Driver.cpp", "functions": ["VisibilityMask"]}]}
{"pr_number": 78181, "url": "https://github.com/llvm/llvm-project/pull/78181", "title": "[AArch64] Improve cost computations for odd vector mem ops.", "body": "Improve cost computaton for odd vector mem ops by breaking them down into smaller power-of-2 parts and sum up the cost of those parts.\r\n\r\nThis fixes the current cost estimates, which for most parts underestimated the cos, due to using getTypeLegalizationCost, which widens to the next power-of-2 in a single step in most cases. This doesn't reflect the actual cost.\r\n\r\nSee https://llvm.godbolt.org/z/vMsnxMf1v for codegen for the tests.\r\n\r\nNote that there is a special case for v3i8, for which current codegen is pretty bad, due to automatic widening to v4i8, which in turn requires the conversion to go through memory ops in the stack. I am planning on fixing that as a follow-up, but I am not yet sure where to best fix this.\r\n\r\nAt the moment, there are almost no cases in which such vector operations will be generated automatically. The motivating case is non-power-of-2 SLP vectorization: https://github.com/llvm/llvm-project/pull/77790", "feature_layers": ["codegen", "ir"], "feature_directives": ["for", "single", "requires"], "files_changed": [{"filename": "llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp", "functions": ["Cost"]}]}
{"pr_number": 77711, "url": "https://github.com/llvm/llvm-project/pull/77711", "title": "[clang][Driver] Don't ignore -gmodules .gch files", "body": "A previous commit (82f75ed) made clang ignore .gch files that were not Clang AST files. This broke `-gmodules`, which embeds the Clang AST into an object file containing debug info.\r\n\r\nThis changes the probing to detect any file format recognized by `llvm::identify_magic()` as potentially containing a Clang AST.\r\n\r\nPrevious PR: https://github.com/llvm/llvm-project/pull/69204", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Driver/ToolChains/Clang.cpp", "functions": ["maybeHasClangPchSignature", "hasClangPchSignature"]}]}
{"pr_number": 78387, "url": "https://github.com/llvm/llvm-project/pull/78387", "title": "[clang] Fix CTAD for aggregates for nested template classes", "body": "Use the template pattern in determining whether to synthesize the aggregate deduction guide, and update DeclareImplicitDeductionGuideFromInitList to substitute outer template arguments.\r\n\r\nFixes #77599", "feature_layers": [], "feature_directives": ["for", "declare"], "files_changed": [{"filename": "clang/lib/Sema/SemaTemplate.cpp", "functions": ["SavedContext"]}]}
{"pr_number": 75883, "url": "https://github.com/llvm/llvm-project/pull/75883", "title": "[Clang] Support MSPropertyRefExpr as placement arg to new-expression", "body": "It seems we were forgetting to call `checkArgsForPlaceholders` on the placement arguments of new-expressions in Sema. I don't think that was intended\u2014at least doing so doesn't seem to break anything\u2014so this pr adds that.\r\n\r\nThis also fixes #65053", "feature_layers": ["sema", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Sema/SemaExpr.cpp", "functions": ["checkArgsForPlaceholders"]}, {"filename": "clang/lib/Sema/SemaExprCXX.cpp", "functions": ["ExprError"]}, {"filename": "clang/test/CodeGenCXX/ms-property-new.cpp", "functions": ["GetX", "new", "main", "GetT", "GetR", "GetY"]}, {"filename": "clang/test/SemaCXX/ms-property-new.cpp", "functions": ["GetX", "new", "main", "GetT", "GetR", "GetY"]}, {"filename": "clang/test/CodeGenCXX/placement-new-ms-__noop.cpp", "functions": ["new", "main"]}, {"filename": "clang/test/SemaCXX/builtin-std-move.cpp", "functions": ["new", "placement_new"]}, {"filename": "clang/test/SemaCXX/placement-new-bound-member-function.cpp", "functions": ["new", "OneArg", "test", "TemplNoArgs", "TemplOneArg", "GetS", "NoArgs"]}, {"filename": "clang/test/SemaCXX/placement-new-builtin.cpp", "functions": ["new", "main"]}, {"filename": "clang/test/SemaCXX/placement-new-matrix.cpp", "functions": ["new", "main"]}, {"filename": "clang/test/SemaCXX/placement-new-ms-__noop.cpp", "functions": ["new", "main"]}]}
{"pr_number": 78348, "url": "https://github.com/llvm/llvm-project/pull/78348", "title": "[X86] Don't respect large data threshold for globals with an explicit section", "body": "If multiple globals are placed in an explicit section, there's a chance\nthat the large data threshold will cause the different globals to be\ninconsistent in whether they're large or small. Mixing sections with\nmismatched large section flags can cause undesirable issues like\nincreased relocation pressure because there may be 32-bit references to\nthe section in some TUs, but the section is considered large since input\nsection flags are unioned and other TUs added the large section flag.\n\nAn explicit code model on the global still overrides the decision. We\ncan do this for globals without any references to them, like what we did\nwith asan_globals in #74514. If we have some precompiled small code\nmodel files where asan_globals is not considered large mixed with\nmedium/large code model files, that's ok because the section is\nconsidered large and placed farther. However, overriding the code model\nfor globals in some TUs but not others and having references to them\nfrom code will still result in the above undesired behavior.\n\nThis mitigates a whole class of mismatched large section flag issues\nlike what #77986 was trying to fix.\n\nThis ends up not adding the SHF_X86_64_LARGE section flag on explicit\nsections in the medium/large code model. This is ok for the large code\nmodel since all references from large text must use 64-bit relocations\nanyway.\n", "feature_layers": ["ir"], "feature_directives": ["for", "sections"], "files_changed": [{"filename": "llvm/lib/Target/TargetMachine.cpp", "functions": ["IsPrefix"]}]}
{"pr_number": 78541, "url": "https://github.com/llvm/llvm-project/pull/78541", "title": "Revert \"[clang] Fix CTAD for aggregates for nested template classes\"", "body": "Reverts llvm/llvm-project#78387\r\n\r\nThe added tests are failing on several build bots.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Sema/SemaTemplate.cpp", "functions": ["SavedContext"]}]}
{"pr_number": 78392, "url": "https://github.com/llvm/llvm-project/pull/78392", "title": "[clang] Upstream XROS support in Clang", "body": "Upstream XROS support in the clang frontend and driver.", "feature_layers": ["frontend"], "feature_directives": [], "files_changed": [{"filename": "clang/lib/Driver/ToolChains/Darwin.cpp", "functions": ["ObjCRuntime", "if"]}]}
{"pr_number": 78436, "url": "https://github.com/llvm/llvm-project/pull/78436", "title": "[Clang] Fix dependency of SourceLocExpr.", "body": "SourceLocExpr that may produce a function name\r\nare marked dependent so that the non-instantiated\r\nname of a function does not get evaluated.\r\n\r\nIn GH78128, the name('s size) is used as\r\ntemplate argument to a `DeclRef` that is not otherwise\r\ndependent, and therefore cached and not transformed when the function is instantiated, leading\r\nto 2 different values existing at the same time for the same function.\r\n\r\nFixes #78128", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/SemaCXX/source_location.cpp", "functions": ["test", "foo", "f"]}]}
{"pr_number": 78092, "url": "https://github.com/llvm/llvm-project/pull/78092", "title": "[clangd] Handle an expanded token range that ends in the `eof` token in TokenBuffer::spelledForExpanded()", "body": "Such ranges can legitimately arise in the case of invalid code, such as a declaration missing an ending brace.\r\n\r\nFixes https://github.com/clangd/clangd/issues/1559", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang-tools-extra/clangd/unittests/DumpASTTests.cpp", "functions": ["Case"]}, {"filename": "clang/unittests/Tooling/Syntax/TokensTest.cpp", "functions": ["main"]}]}
{"pr_number": 70912, "url": "https://github.com/llvm/llvm-project/pull/70912", "title": "[CodeGen] Support start/stop in CodeGenPassBuilder", "body": "Add `-start/stop-before/after` support for CodeGenPassBuilder.\r\nPart of #69879.", "feature_layers": ["codegen"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/unittests/CodeGen/CodeGenPassBuilderTest.cpp", "functions": ["CGPB", "PB", "IROS"]}]}
{"pr_number": 69849, "url": "https://github.com/llvm/llvm-project/pull/69849", "title": "[clang] Bounds checking on unclosed parentheses, brackets or braces in Expanded Tokens", "body": "When getting the AST from clangd, if there is an unclosed token, a segfault or an UB can happen when accessing `File.SpelledTokens` because the supposed closing token is not present, so its index is greater than the vec's size.\r\n\r\nThis fixes the issue by returning a `nullptr` on the function that caused the UB and then checking if the spelled token is null, returning `nullopt` for the whole expanded token.\r\n\r\nFixes https://github.com/clangd/clangd/issues/1559.", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/unittests/Tooling/Syntax/TokensTest.cpp", "functions": ["main"]}]}
{"pr_number": 74537, "url": "https://github.com/llvm/llvm-project/pull/74537", "title": "[AMDGPU] Use alias info to relax waitcounts for LDS DMA", "body": "LDA DMA loads increase VMCNT and a load from the LDS stored must wait on this counter to only read memory after it is written. Wait count insertion pass does not track memory dependencies, it tracks register dependencies. To model the LDS dependency a pseudo register is used in the scoreboard, acting like if LDS DMA writes it and LDS load reads it.\r\n\r\nThis patch adds 8 more pseudo registers to use for independent LDS locations if we can prove they are disjoint using alias analysis.\r\n\r\nFixes: SWDEV-433427", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp", "functions": ["mayWriteLDSThroughDMA"]}]}
{"pr_number": 72242, "url": "https://github.com/llvm/llvm-project/pull/72242", "title": "[clang][ASTImporter] Improve structural equivalence of overloadable operators.", "body": "Operators that are overloadable may be parsed as `CXXOperatorCallExpr` or as `UnaryOperator` (or `BinaryOperator`). This depends on the context and can be different if a similar construct is imported into an existing AST. The two \"forms\" of the operator call AST nodes should be detected as equivalent to allow AST import of these cases.\r\n\r\nThis fix has probably other consequences because if a structure is imported that has `CXXOperatorCallExpr` into an AST with an existing similar structure that has `UnaryOperator` (or binary), the additional data in the `CXXOperatorCallExpr` node is lost at the import (because the existing node will be used). I am not sure if this can cause problems.", "feature_layers": ["parse", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/AST/ASTStructuralEquivalence.cpp", "functions": ["IsStructurallyEquivalent"]}, {"filename": "clang/unittests/AST/StructuralEquivalenceTest.cpp", "functions": ["foo"]}]}
{"pr_number": 78244, "url": "https://github.com/llvm/llvm-project/pull/78244", "title": "[RISCV] Vectorize phi for loop carried @llvm.vector.reduce.fadd", "body": "LLVM vector reduction intrinsics return a scalar result, but on RISC-V vector reduction instructions write the result in the first element of a vector register. So when a reduction in a loop uses a scalar phi, we end up with unnecessary scalar moves:\r\n\r\n```asm\r\nloop:\r\n    vfmv.s.f v10, fa0\r\n    vfredosum.vs v8, v8, v10\r\n    vfmv.f.s fa0, v8\r\n```\r\n\r\nThis mainly affects ordered fadd reductions, since other types of reduction typically use element-wise vectorisation in the loop body. This tries to vectorize any scalar phis that feed into a fadd reduction in RISCVCodeGenPrepare, converting:\r\n\r\n```llvm\r\nloop:\r\n%phi = phi <float> [ ..., %entry ], [ %acc, %loop]\r\n%acc = call float @llvm.vector.reduce.fadd.nxv4f32(float %phi, <vscale x 2 x float> %vec)\r\n```\r\n\r\nto\r\n\r\n```llvm\r\nloop:\r\n%phi = phi <vscale x 2 x float> [ ..., %entry ], [ %acc.vec, %loop]\r\n%phi.scalar = extractelement <vscale x 2 x float> %phi, i64 0\r\n%acc = call float @llvm.vector.reduce.fadd.nxv4f32(float %x, <vscale x 2 x float> %vec)\r\n%acc.vec = insertelement <vscale x 2 x float> poison, float %acc.next, i64 0\r\n```\r\n\r\nWhich eliminates the scalar -> vector -> scalar crossing during instruction selection.\r\n\r\n> [!NOTE]\r\n> The tests were added in a separate commit in this PR, in case they needed reviewed too. The codegen diff should be viewable between the two commits.", "feature_layers": ["codegen", "ir"], "feature_directives": ["for", "ordered"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVCodeGenPrepare.cpp", "functions": ["Builder", "visitIntrinsicInst"]}]}
{"pr_number": 77113, "url": "https://github.com/llvm/llvm-project/pull/77113", "title": "[AArch64][SME] Conditionally do smstart/smstop", "body": "This patch adds conditional enabling/disabling of streaming mode for functions which have both the aarch64_pstate_sm_compatible and aarch64_pstate_sm_body attributes.\r\n\r\nThis combination allows callees to determine if switching streaming mode is required instead of relying on the caller.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AArch64/AArch64ISelLowering.cpp", "functions": ["if"]}]}
{"pr_number": 77513, "url": "https://github.com/llvm/llvm-project/pull/77513", "title": "[VFABI] Move the Vector ABI demangling utility to LLVMCore.", "body": "This fixes #71892 allowing us to check magled names in the IR verifier.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/IR/VFABIDemangler.cpp", "functions": ["Out"]}, {"filename": "llvm/lib/Transforms/Utils/ModuleUtils.cpp", "functions": ["Out"]}, {"filename": "llvm/unittests/Transforms/Utils/VFABIUtils.cpp", "functions": ["SetUp"]}]}
{"pr_number": 77066, "url": "https://github.com/llvm/llvm-project/pull/77066", "title": "[coroutines][coro_lifetimebound] Detect lifetime issues with lambda captures", "body": "### Problem\r\n\r\n```cpp\r\nco_task<int> coro() {\r\n    int a = 1;\r\n    auto lamb = [a]() -> co_task<int> {\r\n        co_return a; // 'a' in the lambda object dies after the iniital_suspend in the lambda coroutine.\r\n    }();\r\n    co_return co_await lamb;\r\n}\r\n```\r\n[use-after-free](https://godbolt.org/z/GWPEovWWc)\r\n\r\nLambda captures (even by value) are prone to use-after-free once the lambda object dies. In the above example, the lambda object appears only as a temporary in the call expression. It dies after the first suspension (`initial_suspend`) in the lambda.\r\nOn resumption in `co_await lamb`, the lambda accesses `a` which is part of the already-dead lambda object.\r\n\r\n---\r\n\r\n### Solution\r\n\r\nThis problem can be formulated by saying that the `this` parameter of the lambda call operator is a lifetimebound parameter. The lambda object argument should therefore live atleast as long as the return object.\r\nThat said, this requirement does not hold if the lambda does not have a capture list. In principle, the coroutine frame still has a reference to a dead lambda object, but it is easy to see that the object would not be used in the lambda-coroutine body due to no capture list.\r\n\r\nIt is safe to use this pattern inside a`co_await` expression due to the lifetime extension of temporaries. Example:\r\n\r\n```cpp\r\nco_task<int> coro() {\r\n    int a = 1;\r\n    int res = co_await [a]() -> co_task<int> { co_return a; }();\r\n    co_return res;\r\n}\r\n```\r\n---\r\n### Background\r\n\r\nThis came up in the discussion with seastar folks on [RFC](https://discourse.llvm.org/t/rfc-lifetime-bound-check-for-parameters-of-coroutines/74253/19?u=usx95). This is a fairly common pattern in continuation-style-passing (CSP) async programming involving futures and continuations. Document [\"Lambda coroutine fiasco\"](https://github.com/scylladb/seastar/blob/master/doc/lambda-coroutine-fiasco.md) by Seastar captures the problem.\r\nThis pattern makes the migration from CSP-style async programming to coroutines very bugprone.\r\n\r\n\r\nFixes https://github.com/llvm/llvm-project/issues/76995 ", "feature_layers": ["ir", "ast"], "feature_directives": ["task", "for", "master"], "files_changed": [{"filename": "clang/test/SemaCXX/coro-lifetimebound.cpp", "functions": ["wrapper1", "member", "value_coro", "wrapper2"]}, {"filename": "clang/lib/Sema/SemaCoroutine.cpp", "functions": ["handleGetReturnObject"]}, {"filename": "clang/lib/Sema/SemaDecl.cpp", "functions": ["methodHasName"]}, {"filename": "clang/test/SemaCXX/coro-return-type-and-wrapper.cpp", "functions": ["new", "get_return_object_on_allocation_failure"]}]}
{"pr_number": 78567, "url": "https://github.com/llvm/llvm-project/pull/78567", "title": "Revert \"[CodeGen] Support start/stop in CodeGenPassBuilder\"", "body": "Reverts llvm/llvm-project#70912. This breaks some bazel tests.", "feature_layers": ["codegen"], "feature_directives": [], "files_changed": [{"filename": "llvm/unittests/CodeGen/CodeGenPassBuilderTest.cpp", "functions": ["CGPB", "PB", "IROS"]}]}
{"pr_number": 78500, "url": "https://github.com/llvm/llvm-project/pull/78500", "title": "[libc][NFC] Introduce a Sign type for FPBits", "body": "Another patch is needed to cover `DyadicFloat` and `NormalFloat` constructors.\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "libc/src/math/generic/powf.cpp", "functions": ["is_odd_integer"]}, {"filename": "libc/test/src/__support/FPUtil/fpbits_test.cpp", "functions": ["negzero"]}]}
{"pr_number": 77294, "url": "https://github.com/llvm/llvm-project/pull/77294", "title": "[clang][Interp] Implement ComplexToReal casts", "body": "Add a new emitComplexReal() helper function and use that for the new casts as well as the old __real implementation.", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/AST/Interp/ByteCodeExprGen.cpp", "functions": ["visit"]}, {"filename": "clang/test/AST/Interp/complex.cpp", "functions": ["ignoredCast"]}]}
{"pr_number": 77892, "url": "https://github.com/llvm/llvm-project/pull/77892", "title": "AMDGPU/GFX12: Add new dot4 fp8/bf8 instructions", "body": "Endoding is VOP3P. Tagged as deep/machine learning instructions. i32 type (v4fp8 or v4bf8 packed in i32) is used for src0 and src1. src0 and src1 have no src_modifiers. src2 is f32 and has src_modifiers: f32 fneg(neg_lo[2]) and f32 fabs(neg_hi[2]).", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp", "functions": ["validateNeg"]}]}
{"pr_number": 76669, "url": "https://github.com/llvm/llvm-project/pull/76669", "title": "[SimplifyCFG] When only one case value is missing, replace default with that case", "body": "When the default branch is the last case, we can transform that branch into a concrete branch with an unreachable default branch.\r\n\r\n```llvm\r\ntarget datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\"\r\ntarget triple = \"x86_64-unknown-linux-gnu\"\r\n\r\ndefine i64 @src(i64 %0) {\r\n  %2 = urem i64 %0, 4\r\n  switch i64 %2, label %5 [\r\n    i64 1, label %3\r\n    i64 2, label %3\r\n    i64 3, label %4\r\n  ]\r\n\r\n3:                                                ; preds = %1, %1\r\n  br label %5\r\n\r\n4:                                                ; preds = %1\r\n  br label %5\r\n\r\n5:                                                ; preds = %1, %4, %3\r\n  %.0 = phi i64 [ 2, %4 ], [ 1, %3 ], [ 0, %1 ]\r\n  ret i64 %.0\r\n}\r\n\r\ndefine i64 @tgt(i64 %0) {\r\n  %2 = urem i64 %0, 4\r\n  switch i64 %2, label %unreachable [\r\n    i64 0, label %5\r\n    i64 1, label %3\r\n    i64 2, label %3\r\n    i64 3, label %4\r\n  ]\r\n\r\nunreachable:                              ; preds = %1\r\n  unreachable\r\n\r\n3:                                                ; preds = %1, %1\r\n  br label %5\r\n\r\n4:                                                ; preds = %1\r\n  br label %5\r\n\r\n5:                                                ; preds = %1, %4, %3\r\n  %.0 = phi i64 [ 2, %4 ], [ 1, %3 ], [ 0, %1 ]\r\n  ret i64 %.0\r\n}\r\n```\r\n\r\nAlive2: https://alive2.llvm.org/ce/z/Y-PGXv\r\n\r\nAfter transform to a lookup table, I believe `tgt` is better code.\r\n\r\nThe final instructions are as follows:\r\n\r\n```asm\r\nsrc:                                    # @src\r\n        and     edi, 3\r\n        lea     rax, [rdi - 1]\r\n        cmp     rax, 2\r\n        ja      .LBB0_1\r\n        mov     rax, qword ptr [8*rdi + .Lswitch.table.src-8]\r\n        ret\r\n.LBB0_1:\r\n        xor     eax, eax\r\n        ret\r\ntgt:                                    # @tgt\r\n        and     edi, 3\r\n        mov     rax, qword ptr [8*rdi + .Lswitch.table.tgt]\r\n        ret\r\n.Lswitch.table.src:\r\n        .quad   1                               # 0x1\r\n        .quad   1                               # 0x1\r\n        .quad   2                               # 0x2\r\n\r\n.Lswitch.table.tgt:\r\n        .quad   0                               # 0x0\r\n        .quad   1                               # 0x1\r\n        .quad   1                               # 0x1\r\n        .quad   2                               # 0x2\r\n```\r\n\r\nGodbolt: https://llvm.godbolt.org/z/borME8znd\r\n\r\nCloses #73446.", "feature_layers": ["ast"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "llvm/lib/Transforms/Utils/SimplifyCFG.cpp", "functions": ["SIW"]}]}
{"pr_number": 77760, "url": "https://github.com/llvm/llvm-project/pull/77760", "title": "[Flang][OpenMP] Push genEval closer to leaf lowering functions", "body": "This moves the lowering of the nested evaluations all the way to the bottom of the call stack.  This PR does not attempt to change the leaf lowering functions beyond placing the call to `genEval` in there.  Whether the nested evaluations should be lowered for any given op depends on the context in which that op is created, hence a `genNested` parameter was added.\r\n\r\nContexts in which nested evaluations should not be lowered are during lowering of composite constructs, such as PARALLEL SECTIONS.  This particular case is considered a block construct tied to the SECTIONS directive, and the lowering code will first create an empty parallel op, and then recursively lower the SECTIONS code.  Similar situations occur when lowering most (if not all) compound/composite constructs.\r\n\r\nRecursive lowering [4/5]", "feature_layers": ["ir"], "feature_directives": ["parallel", "for", "sections"], "files_changed": [{"filename": "flang/lib/Lower/OpenMP.cpp", "functions": ["dsp", "cp", "RetTy"]}]}
{"pr_number": 75467, "url": "https://github.com/llvm/llvm-project/pull/75467", "title": "[OpenMP][USM] Adds test for -fopenmp-force-usm flag", "body": "This adds a basic test to check the correct generation of double indirect access to declare target globals in USM mode vs non-USM mode.\r\nI am a bit unhappy with the way this test is set up, but could not find a better way to do it. Happy to improve that and add more tests then.\r\n\r\nMarked as XFAIL to first land test and then enable in subsequent patch.", "feature_layers": ["ir"], "feature_directives": ["for", "target", "declare"], "files_changed": [{"filename": "clang/test/OpenMP/force-usm.c", "functions": ["main"]}]}
{"pr_number": 78463, "url": "https://github.com/llvm/llvm-project/pull/78463", "title": "[Clang][NFC] Rename CXXMethodDecl::isPure -> is VirtualPure", "body": "To avoid any possible confusion with the notion of pure function and the gnu::pure attribute.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "clang/lib/AST/DeclCXX.cpp", "functions": ["isPureVirtual", "isPure"]}]}
{"pr_number": 78397, "url": "https://github.com/llvm/llvm-project/pull/78397", "title": "[mlir][transform] Add transform.get_operand op", "body": "Similar to `transform.get_result`, except it returns a handle to the operand indicated by `operand_number`, or all operands if no index is given.\r\n\r\nAdditionally updates `get_result` to make the `result_number` optional. This makes the use case of wanting to get all of the results of an operation easier by no longer requiring the user to reconstruct the list of results one-by-one.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Linalg/TransformOps/LinalgMatchOps.cpp", "functions": ["emitSilenceableFailure"]}, {"filename": "mlir/lib/Dialect/Transform/IR/MatchInterfaces.cpp", "functions": ["failure", "success", "emitSilenceableFailure"]}, {"filename": "mlir/lib/Dialect/Transform/IR/TransformOps.cpp", "functions": ["verifyTransformMatchDimsOp"]}]}
{"pr_number": 78435, "url": "https://github.com/llvm/llvm-project/pull/78435", "title": "[flang] fix unsafe memory access using mlir::ValueRange", "body": "When running the `flang/test/HLFIR/simplify-hlfir-intrinsics.fir` test case on AIX we encounter issues building op as they are not found in the mlir context:\r\n```\r\nLLVM ERROR: Building op `arith.subi` but it isn't known in this MLIRContext: the dialect may not be loaded or this operation hasn't been added by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-dialects-management\r\nLLVM ERROR: Building op `hlfir.yield_element` but it isn't known in this MLIRContext: the dialect may not be loaded or this operation hasn't been added by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-dialects-management\r\nLLVM ERROR: Building op `hlfir.yield_element` but it isn't known in this MLIRContext: the dialect may not be loaded or this operation hasn't been added by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-dialects-management\r\n```\r\nThe issue is caused by the \"Merge disjoint stack slots\" pass and the error is not present if the source is built with `-mllvm --no-stack-coloring`  \r\n\r\nThanks to investigation by @stefanp-ibm we found that \"the initializer_list {inputIndices[1], inputIndices[0]} has a lifetime that only exists for the range of the constructor for ValueRange. Once we get to stack coloring we merge the stack slot for that element with another stack slot and then it gets overwritten which corrupts transposedIndices\"\r\n\r\nThe changes below prevents the corruption of transposedIndices and passes the test case.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Optimizer/HLFIR/Transforms/SimplifyHLFIRIntrinsics.cpp", "functions": ["transposedIndices"]}]}
{"pr_number": 69900, "url": "https://github.com/llvm/llvm-project/pull/69900", "title": "[clang][Interp] IndirectMember initializers", "body": "We need to look at the chain of declarations to initialize the right field.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "clang/test/AST/Interp/records.cpp", "functions": ["S2"]}]}
{"pr_number": 78202, "url": "https://github.com/llvm/llvm-project/pull/78202", "title": "[clang][CoverageMapping] Refactor setting MC/DC True/False Condition IDs", "body": "Clean-up of the algorithm that assigns MC/DC True/False control-flow condition IDs when constructing an MC/DC decision region.  This patch creates a common API for setting/getting the condition IDs, making the binary logical operator visitor functions much cleaner.\r\n\r\nThis patch also fixes issue https://github.com/llvm/llvm-project/issues/77873 in which a record's control flow map can be malformed due to an incorrect calculation of the True/False condition IDs.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/CodeGen/CoverageMappingGen.cpp", "functions": ["back", "CGM"]}, {"filename": "clang/test/CoverageMapping/mcdc-logical-stmt-ids-all.cpp", "functions": ["func_ternary_nested_if_3", "func_ternary_nested_if_2", "func_ternary_nested_and_if", "func_if_nested_if", "func_if_nested_and_if_2", "func_if_nested_and_if", "func_ternary_nested_and_if_2", "func_if_nested_if_2", "func_ternary_nested_if", "func_if_nested_if_3"]}]}
{"pr_number": 78361, "url": "https://github.com/llvm/llvm-project/pull/78361", "title": "[mlir][Math] Add pass to legalize math functions to f32-or-higher", "body": "Since most of the operations in the `math` dialect don't have low-precision implementations, add the -math-legalize-to-f32 pass that goes through and brackets low-precision math funcitons (like `math.sin %0 : f16`) with `arith.extf` and `arith.truncf`. This preserves the original semantics of the math operation but allows lowering to proceed.\r\n\r\nVersions of this lowering are already implicitly present in some passes, like ConvertGPUToROCDL. However, because those are implicit rewrites, they hide the floating-point extension and truncation, preventing anyone from writing passes that operate on those implitic extf/truncf pairs.\r\n\r\nExposing this legalization explicitly is needed to allow lowening 8-bit floats on AMD GPUs, as the implementation of extf and truncf on that platform requires the complex logic found in ArithToAMDGPU, which runs before the GPU to ROCDL lowering.", "feature_layers": ["sema", "ir"], "feature_directives": ["for", "requires"], "files_changed": [{"filename": "mlir/lib/Dialect/Math/Transforms/LegalizeToF32.cpp", "functions": ["target", "runOnOperation", "success", "signalPassFailure", "patterns", "newOp", "ConversionPattern"]}]}
{"pr_number": 72442, "url": "https://github.com/llvm/llvm-project/pull/72442", "title": "[LinkerWrapper] Support device binaries in multiple link jobs", "body": "Summary:\nCurrently the linker wrapper strictly assigns a single input binary to a\nsingle link job based off of its input architecture. This is not\nsufficient to implement the AMDGPU target ID correctly as this could\nhave many compatible architectures participating in multiple links. This\npatch introduces the ability to have a single binary input be linked\nmultiple times. For example, given the following, we will now link in\nthe static library where previously we would not. clang foo.c -fopenmp\n--offload-arch=gfx90a llvm-ar rcs libfoo.a foo.o clang foo.c -fopenmp\n--offload-arch=gfx90a:xnack+ libfoo.a This also means that given the\nfollowing we will link the basic input twice, but that's on the user for\nproviding two versions. clang foo.c -fopenmp\n--offload-arch=gfx90a,gfx90a:xnack+ This should allow us to also support\na \"generic\" target in the future for IR without a specific architecture.\n\nThis was revived from https://reviews.llvm.org/D152882. The previous\nissue was that the Window build failed for unknown reasons.\nInvestigating if that is still the case.\n", "feature_layers": ["ir"], "feature_directives": ["for", "single", "target"], "files_changed": [{"filename": "clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp", "functions": ["getDeviceInput"]}]}
{"pr_number": 77433, "url": "https://github.com/llvm/llvm-project/pull/77433", "title": "[X86] Support lowering for APX promoted BMI instructions.", "body": "R16-R31 was added into GPRs in https://github.com/llvm/llvm-project/pull/70958,\r\nThis patch supports the lowering for promoted BMI instructions in EVEX space, enc/dec has been supported in https://github.com/llvm/llvm-project/pull/73899.\r\n\r\nRFC: https://discourse.llvm.org/t/rfc-design-for-apx-feature-egpr-and-ndd-support/73031/4", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/X86/X86ISelDAGToDAG.cpp", "functions": ["GET_EGPR_IF_ENABLED"]}]}
{"pr_number": 76400, "url": "https://github.com/llvm/llvm-project/pull/76400", "title": "[mlir][irdl] Add `irdl.base` op", "body": "The `irdl.base` op represent an attribute constraint that will check that the\r\nbase of a type or attribute is the expected one (e.g. `IntegerType`) .\r\n\r\nExample:\r\n\r\n```mlir\r\nirdl.dialect @cmath {\r\n  irdl.type @complex {\r\n    %0 = irdl.base \"!builtin.integer\"\r\n    irdl.parameters(%0)\r\n  }\r\n\r\n  irdl.type @complex_wrapper {\r\n    %0 = irdl.base @complex\r\n    irdl.parameters(%0)\r\n  }\r\n}\r\n```\r\n\r\nThe above program defines a `cmath.complex` type that expects a single\r\nparameter, which is a type with base name `builtin.integer`, which is the\r\nname of an `IntegerType` type.\r\nIt also defines a `cmath.complex_wrapper` type that expects a single\r\nparameter, which is a type of base type `cmath.complex`.", "feature_layers": ["ir"], "feature_directives": ["single"], "files_changed": [{"filename": "mlir/lib/Dialect/IRDL/IR/IRDL.cpp", "functions": ["emitOpError", "success"]}, {"filename": "mlir/lib/Dialect/IRDL/IRDLVerifiers.cpp", "functions": ["failure", "success", "emitError"]}]}
{"pr_number": 78375, "url": "https://github.com/llvm/llvm-project/pull/78375", "title": "[mlir][flang][openacc] Device type support on acc routine op", "body": "This patch add support for device_type on the acc.routine operation. device_type can be specified on seq, worker, vector, gang and bind information. \r\n\r\nThe support is following the same design than the one for compute operations, data operation and the loop operation. ", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Lower/OpenACC.cpp", "functions": ["constexpr"]}, {"filename": "mlir/lib/Dialect/OpenACC/IR/OpenACC.cpp", "functions": ["getGangDimValue", "success", "getBindNameValue", "hasDeviceType", "failure", "emitError", "hasDeviceTypeValues"]}]}
{"pr_number": 77694, "url": "https://github.com/llvm/llvm-project/pull/77694", "title": "[flang][openacc] Apply mutually exclusive clauses restriction to routine", "body": "this patch enforces or fixes the enforcement of two restrictions from section 2.15.1:\r\n\r\n> Only the gang, worker, vector, seq and bind clauses may follow a device_type clause.\r\n\r\n`seq` was not allowed after `device_type` with the current implementation.\r\n\r\n> Exactly one of the gang, worker, vector, or seq clauses must appear.\r\n\r\nThis was not properly checked. This patch check correctly for mutually exclusion as described in section 2.4. Mutually exclusive clauses may appear on the same directive if they apply for different `device_type` clauses. \r\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Semantics/check-acc-structure.cpp", "functions": ["if"]}]}
{"pr_number": 76126, "url": "https://github.com/llvm/llvm-project/pull/76126", "title": "[mlir][openacc] Add device_type support for data operation", "body": "Following #75864, this patch adds device_type support to the data operation on the async and wait operands and attributes. ", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/OpenACC/IR/OpenACC.cpp", "functions": ["getValuesFromSegments", "getWaitValues", "hasAsyncOnly", "getValueInDeviceTypeSegment", "getAsyncValue"]}]}
{"pr_number": 76892, "url": "https://github.com/llvm/llvm-project/pull/76892", "title": "[mlir][flang][openacc] Support device_type on loop construct", "body": "This is adding support for `device_type` clause representation in the OpenACC MLIR dialect on the acc.loop operation and adjust flang to lower correctly to the new representation. \r\n\r\nEach \"value\" that can be impacted by a `device_type` clause is now associated with an array attribute that carry this information. This includes:\r\n- `worker` clause information\r\n- `gang` clause information\r\n- `vector` clause information\r\n- `collapse` clause information\r\n- `tile` clause information\r\n\r\nThe representation of the `gang` clause information has been updated and all values are now carried in a single operand segment. This segment is then subdivided by `device_type`. Each value in a segment is also associated with a `GangArgType` so it can be differentiated (num/dim/static). This simplify the handling of gang values an limit the number of new attributes needed.\r\n\r\nWhen the clause can be associated with the operation without any value (`gang`, `vector`, `worker`). These are represented by a dedicated attributes with device_type information. \r\n\r\nExtra getter functions are provided to make it easier to retrieve a value based on a device_type. ", "feature_layers": ["ir"], "feature_directives": ["for", "single"], "files_changed": [{"filename": "mlir/lib/Dialect/OpenACC/IR/OpenACC.cpp", "functions": ["emitOpError", "success", "getTileValues", "getValuesFromSegments", "getValueInDeviceTypeSegment", "getGangValue", "hasIndependent", "failure", "if", "checkDeviceTypes", "getVectorValue", "getWorkerValue", "arrayAttr", "emitError", "getCollapseValue"]}]}
{"pr_number": 72476, "url": "https://github.com/llvm/llvm-project/pull/72476", "title": "[flang][openacc] Add ability to link acc.declare_enter with acc.declare_exit ops", "body": "Add a result token to `acc.declare_enter` op that can be feed to `acc.declare_exit` op to represent an implicit declare data region in a function/subroutine. ", "feature_layers": [], "feature_directives": ["declare"], "files_changed": [{"filename": "flang/lib/Lower/OpenACC.cpp", "functions": ["constexpr"]}, {"filename": "mlir/lib/Dialect/OpenACC/IR/OpenACC.cpp", "functions": ["checkDeclareOperands"]}]}
{"pr_number": 74045, "url": "https://github.com/llvm/llvm-project/pull/74045", "title": "[flang][openacc] Add loop expand pass", "body": "`acc.loop` operations get a new design where the induction ranges can be part of the operation directly. The operation can also be a simple wrapper around a loop nest.\r\nThis patch adds a loop-expand pass that can transform a acc.loop operation with induction ranges to a acc.loop operation with a fir.do_loop nest inside.\r\nThis patch depends on two patches that update the design and lowering:\r\n\r\nhttps://github.com/llvm/llvm-project/pull/67355\r\nhttps://github.com/llvm/llvm-project/pull/65417\r\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Optimizer/Transforms/OpenACCLoopExpand.cpp", "functions": ["runOnOperation"]}]}
{"pr_number": 77965, "url": "https://github.com/llvm/llvm-project/pull/77965", "title": "[ORC][MachO] Support common load commands in the platform's mach-o header builder", "body": "Add a HeaderOptions struct that can be used to configure commonly-used\r\nload commands LC_ID_DYLIB, LC_LOAD_DYLIB, and LC_RPATH when setupDylib\r\ncreates a mach-o header.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp", "functions": ["MachOPlatform", "setupJITDylib"]}]}
{"pr_number": 78599, "url": "https://github.com/llvm/llvm-project/pull/78599", "title": "[HEXAGON] Inlining division", "body": "This patch inlines float division function calls for hexagon.\r\n\r\nTests added to check the following\r\n1. Whether the implemented function gets inlined when -fast-math option is used\r\n2. Check that the splat of a constant, when it's used in a fp vector operation that needs to be expanded\r\n3. Check inlining\r\n4. Check no-inlining on optsize\r\n", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp", "functions": ["ResultType", "SelectFDiv", "OpValue1"]}, {"filename": "llvm/lib/Target/Hexagon/HexagonISelLowering.cpp", "functions": ["LowerFDIV", "SDValue"]}]}
{"pr_number": 78135, "url": "https://github.com/llvm/llvm-project/pull/78135", "title": "[dsymutil][llvm-dwarfutil] Rename command line options to avoid using vendor names.", "body": "This patch renames values of dsymutil/llvm-dwarfutil options:\r\n\r\n--linker apple -> --linker classic\r\n--linker llvm -> --linker parallel\r\n\r\nThe purpose to rename options is to avoid using vendor names and to match with library names. It should be safe to rename options at current stage as they are not seemed widely used(we may not preserve backward compatibility).", "feature_layers": [], "feature_directives": ["parallel"], "files_changed": [{"filename": "llvm/tools/llvm-dwarfutil/llvm-dwarfutil.cpp", "functions": ["if"]}]}
{"pr_number": 78360, "url": "https://github.com/llvm/llvm-project/pull/78360", "title": "Ensure that the executable module is ModuleList[0]", "body": "We claim in a couple places that the zeroth element of the module list for a target is the main executable, but we don't actually enforce that in the ModuleList class.  As we saw, for instance, in\r\n\r\n32dd5b20973bde1ef77fa3b84b9f85788a1a303a\r\n\r\nit's not all that hard to get this to be off.  This patch ensures that the first object file of type Executable added to it is moved to the front of the ModuleList.  I also added a test for this.\r\n\r\nIn the normal course of operation, where the executable is added first, this only adds a check for whether the first element in the module list is an executable.  If that's true, we just append as normal.\r\n\r\nNote, the code in Target::GetExecutableModule doesn't actually agree that the zeroth element must be the executable, it instead returns the first Module of type Executable.  But I can't tell whether that was a change in intention or just working around the bug that we don't always maintain this ordering.  But given we've said this in scripting as well as internally, I think we shouldn't change our minds about this.", "feature_layers": ["ir"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "lldb/test/API/functionalities/executable_first/b.cpp", "functions": ["b_function"]}, {"filename": "lldb/test/API/functionalities/executable_first/main.cpp", "functions": ["b_function", "main"]}]}
{"pr_number": 76749, "url": "https://github.com/llvm/llvm-project/pull/76749", "title": "[HLSL][SPIR-V] Add Vulkan to target triple", "body": "Add support for specifying the logical SPIR-V target environment in the triple as Vulkan. When compiling HLSL, this replaces the DirectX Shader Model with a Vulkan environment instead.\r\n\r\nCurrently, the only supported combinations of SPIR-V version and Vulkan environment are:\r\n- Vulkan 1.2 and SPIR-V 1.5\r\n- Vulkan 1.3 and SPIR-V 1.6\r\n\r\nFixes #70051", "feature_layers": ["ir"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "llvm/lib/TargetParser/Triple.cpp", "functions": ["VersionTuple"]}]}
{"pr_number": 76976, "url": "https://github.com/llvm/llvm-project/pull/76976", "title": "[clang] Fix parenthesized list initialization of arrays not working with `new`", "body": "This bug is caused by parenthesized list initialization not being implemented in `CodeGenFunction::EmitNewArrayInitializer(...)`.\r\n\r\nParenthesized list initialization of `struct`s  with `operator new` already works in Clang and is not affected by this bug.\r\n\r\nAdditionally, fix the test new-delete.cpp as it incorrectly assumes that using parentheses with operator new to initialize arrays is illegal for C++ versions >= C++17.\r\n\r\nFixes #68198", "feature_layers": ["codegen"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/CodeGen/CGExprCXX.cpp", "functions": ["if"]}, {"filename": "clang/test/CodeGen/paren-list-agg-init.cpp", "functions": ["foo26", "foo27", "foo25"]}, {"filename": "clang/test/CodeGenCXX/new-array-init.cpp", "functions": ["string_nonconst_paren_extra_paren", "string_nonconst_paren", "string_exact_paren_extension", "fn_paren", "const_exact_paren", "string_exact_paren", "string_sufficient_paren", "const_sufficient_paren"]}, {"filename": "clang/test/SemaCXX/new-delete.cpp", "functions": ["i"]}]}
{"pr_number": 74777, "url": "https://github.com/llvm/llvm-project/pull/74777", "title": "[clang] Add size filter for stack auto init", "body": "Add a clang flag, \"-ftrivial-auto-var-init-max-size=\" so that clang skips auto-init a variable if the auto-init memset size exceeds the flag setting (in bytes). Note that this skipping doesn't apply to runtime-sized variables like VLA. \r\n\r\nConsiderations: \"__attribute__((uninitialized))\" can be used to manually opt variables out. However, there are thousands of large variables (e.g., >=1KB, most of them are arrays and used as buffers) in big codebase. Manually opting them out one by one is not efficient.", "feature_layers": ["runtime"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CodeGenCXX/auto-var-init-size-bound.cpp", "functions": ["foo"]}, {"filename": "clang/lib/CodeGen/CGDecl.cpp", "functions": ["NRVOFlag", "AddrSizePair", "ArrayBegin", "DRE", "llvm_unreachable", "if", "isRedundantBeforeReturn", "emitDestructorCall", "Emit"]}, {"filename": "clang/test/CodeGenCXX/auto-var-init-max-size.cpp", "functions": ["foo"]}]}
{"pr_number": 77637, "url": "https://github.com/llvm/llvm-project/pull/77637", "title": "[clang] Add test for CWG1807", "body": "The test checks that objects in arrays are destructed in reverse order during stack unwinding.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CXX/drs/dr1807.cpp", "functions": ["f"]}]}
{"pr_number": 78269, "url": "https://github.com/llvm/llvm-project/pull/78269", "title": "[flang] Fix seg fault `CodeGenAction::executeAction()`", "body": "If `generateLLVMIR()` fails, we still continue using the module we failed to generate which causes a seg fault if LLVM code-gen failed for some reason or another. This commit fixes this issue.", "feature_layers": ["codegen", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/unittests/Frontend/CodeGenActionTest.cpp", "functions": ["diagnosticsOS", "DummyDialect", "getDialectNamespace", "getAttributeNames", "CodeGenAction", "builder", "loc", "file", "getOperationName", "initialize"]}]}
{"pr_number": 76904, "url": "https://github.com/llvm/llvm-project/pull/76904", "title": "[BOLT] Use continuous output addresses in delta encoding in BAT", "body": "Make output function addresses be delta-encoded wrt last offset in the\r\nprevious function. This reduces the deltas in function start addresses.\r\n\r\nTest Plan:\r\nReduces BAT section size to:\r\n- large binary: 12218860 bytes (0.32x original),\r\n- medium binary: 1606580 bytes (0.27x original),\r\n- small binary: 404 bytes (0.28x original),\r\n", "feature_layers": ["ast"], "feature_directives": [], "files_changed": [{"filename": "bolt/lib/Profile/BoltAddressTranslation.cpp", "functions": ["errorToErrorCode", "make_error_code", "Err"]}]}
{"pr_number": 75882, "url": "https://github.com/llvm/llvm-project/pull/75882", "title": "[ASan][libc++] Turn on ASan annotations for short strings", "body": "This commit turns on ASan annotations in `std::basic_string` for short stings (SSO case).\r\n\r\nOriginally suggested here: https://reviews.llvm.org/D147680\r\n\r\nString annotations added here: https://github.com/llvm/llvm-project/pull/72677\r\n\r\nRequires to pass CI without fails:\r\n- https://github.com/llvm/llvm-project/pull/75845\r\n- https://github.com/llvm/llvm-project/pull/75858\r\n\r\nAnnotating `std::basic_string` with default allocator is implemented in https://github.com/llvm/llvm-project/pull/72677 but annotations for short strings (SSO - Short String Optimization) are turned off there. This commit turns them on. This also removes `_LIBCPP_SHORT_STRING_ANNOTATIONS_ALLOWED`, because we do not plan to support turning on and off short string annotations.\r\n\r\nSupport in ASan API exists since https://github.com/llvm/llvm-project/commit/dd1b7b797a116eed588fd752fbe61d34deeb24e4. You can turn off annotations for a specific allocator based on changes from https://github.com/llvm/llvm-project/commit/2fa1bec7a20bb23f2e6620085adb257dafaa3be0.\r\n\r\nThis PR is a part of a series of patches extending AddressSanitizer C++ container overflow detection capabilities by adding annotations, similar to those existing in `std::vector` and `std::deque` collections. These enhancements empower ASan to effectively detect instances where the instrumented program attempts to access memory within a collection's internal allocation that remains unused. This includes cases where access occurs before or after the stored elements in `std::deque`, or between the `std::basic_string`'s size (including the null terminator) and capacity bounds.\r\n\r\nThe introduction of these annotations was spurred by a real-world software bug discovered by Trail of Bits, involving an out-of-bounds memory access during the comparison of two strings using the `std::equals` function. This function was taking iterators (`iter1_begin`, `iter1_end`, `iter2_begin`) to perform the comparison, using a custom comparison function. When the `iter1` object exceeded the length of `iter2`, an out-of-bounds read could occur on the `iter2` object. Container sanitization, upon enabling these annotations, would effectively identify and flag this potential vulnerability.\r\n\r\nIf you have any questions, please email:\r\n\r\n    advenam.tacet@trailofbits.com\r\n    disconnect3d@trailofbits.com", "feature_layers": ["ir"], "feature_directives": ["for", "requires"], "files_changed": [{"filename": "libcxx/test/libcxx/containers/strings/basic.string/asan_deque_integration.pass.cpp", "functions": ["verify_inside"]}, {"filename": "libcxx/test/libcxx/containers/strings/basic.string/asan_short.pass.cpp", "functions": ["do_exit", "c", "main"]}, {"filename": "libcxx/test/libcxx/containers/strings/basic.string/asan_vector_integration.pass.cpp", "functions": ["verify_inside"]}]}
{"pr_number": 78537, "url": "https://github.com/llvm/llvm-project/pull/78537", "title": "[llvm-lib][Object][COFF] Use ARM64 machine type for import library descriptor objects.", "body": "This is what MSVC lib.exe does. I changed machine type stored in ObjectFactory to native type, while the actual type is passed by argument to functions that need it. Doing it that way requires a few more changes, but prepares us for later -defArm64Native support, which will require import objects to be a mix of ARM64 and ARM64EC types (my prototype looks like this: https://github.com/cjacek/llvm-project/commit/8e7dffe39633d269ef7f3a69899110d068fad0f7).\r\n\r\nMSVC puts descriptor symbols in both regular archive map and EC map, this is not implemented by this PR. That's handled by archive writer, would require some special cases and doesn't seem useful in practice.\r\n\r\ncc @bylaws ", "feature_layers": ["ir"], "feature_directives": ["for", "requires"], "files_changed": [{"filename": "llvm/lib/Object/COFFImportFile.cpp", "functions": ["is64Bit", "OF", "createWeakExternal", "Machine", "NativeMachine"]}]}
{"pr_number": 77442, "url": "https://github.com/llvm/llvm-project/pull/77442", "title": "[RISCV] Assert extensions are sorted at compile time. NFCI", "body": "This replaces verifyTables and assert(llvm::is_sorted) with a constexpr\nstatic_assert, so that adding an extension or implication in the wrong order\nwill be a compile time failure rather than a runtime failure.\n", "feature_layers": ["runtime"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/Support/RISCVISAInfo.cpp", "functions": ["TableChecked", "StringRef", "isSorted", "verifyTables"]}]}
{"pr_number": 78559, "url": "https://github.com/llvm/llvm-project/pull/78559", "title": "[libc++] Speed up ASan tests", "body": "This commit lowers values in `std::vector` tests to as good as previous ones, but faster.\r\nOne tests caused a timeout on buildbots: https://lab.llvm.org/buildbot/#/builders/168/builds/18126/steps/11/logs/stdio \r\nTest added here: https://github.com/llvm/llvm-project/pull/75882", "feature_layers": ["ast"], "feature_directives": [], "files_changed": [{"filename": "libcxx/test/libcxx/containers/strings/basic.string/asan_deque_integration.pass.cpp", "functions": ["d6b", "d6c", "d1a"]}, {"filename": "libcxx/test/libcxx/containers/strings/basic.string/asan_vector_integration.pass.cpp", "functions": ["d6b", "d6c", "d1a"]}]}
{"pr_number": 78627, "url": "https://github.com/llvm/llvm-project/pull/78627", "title": "Revert \"[ASan][libc++] Turn on ASan annotations for short strings\"", "body": "Reverts llvm/llvm-project#75882\r\n\r\nTo recover build bots :\r\nhttps://lab.llvm.org/buildbot/#/builders/239/builds/5361\r\nhttps://lab.llvm.org/buildbot/#/builders/168/builds/18126", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "libcxx/test/libcxx/containers/strings/basic.string/asan_deque_integration.pass.cpp", "functions": ["verify_inside", "d1a", "main", "d7", "d6c", "get_s", "test_string", "test_container", "d6b"]}, {"filename": "libcxx/test/libcxx/containers/strings/basic.string/asan_short.pass.cpp", "functions": ["do_exit", "c", "main"]}, {"filename": "libcxx/test/libcxx/containers/strings/basic.string/asan_vector_integration.pass.cpp", "functions": ["verify_inside", "d1a", "main", "d7", "d6c", "get_s", "test_string", "test_container", "d6b"]}]}
{"pr_number": 72077, "url": "https://github.com/llvm/llvm-project/pull/72077", "title": "[llvm][IR] Add per-global code model attribute", "body": "This adds a per-global code model attribute, which can override the target's code model to access global variables.\r\n\r\nLink: https://discourse.llvm.org/t/how-to-best-implement-code-model-overriding-for-certain-values/71816\r\nLink: https://discourse.llvm.org/t/rfc-add-per-global-code-model-attribute/74944\r\n\r\nSuggested-by: Arthur Eubanks <aeubanks@google.com>", "feature_layers": ["ir"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "llvm/lib/AsmParser/LLParser.cpp", "functions": ["if", "tokError"]}, {"filename": "llvm/lib/Bitcode/Reader/BitcodeReader.cpp", "functions": ["error", "getDecodedCodeModel"]}]}
{"pr_number": 78667, "url": "https://github.com/llvm/llvm-project/pull/78667", "title": "Revert \"[flang] Fix seg fault `CodeGenAction::executeAction()` (#78269)\"", "body": "This reverts commit 99cae9a44fca4cfbd6ee82f196051cbdf6571fa1.\r\n\r\nTemporarily until I reproduce and fix a linker issue:\r\n```\r\nFAILED: tools/flang/unittests/Frontend/FlangFrontendTests\r\n...\r\n/usr/bin/ld: tools/flang/unittests/Frontend/CMakeFiles/FlangFrontendTests.dir/CodeGenActionTest.cpp.o: undefined reference to symbol '_ZN4llvm11LLVMContextC1Ev'\r\n/usr/bin/ld: /work1/omp-nightly/build/git/trunk18.0/build/llvm-project/lib/libLLVMCore.so.18git: error adding symbols: DSO missing from command line\r\n```", "feature_layers": ["codegen", "ir", "frontend"], "feature_directives": [], "files_changed": [{"filename": "flang/unittests/Frontend/CodeGenActionTest.cpp", "functions": ["diagnosticsOS", "DummyDialect", "getDialectNamespace", "getAttributeNames", "CodeGenAction", "builder", "loc", "file", "getOperationName", "initialize"]}]}
{"pr_number": 78674, "url": "https://github.com/llvm/llvm-project/pull/78674", "title": "[HEXAGON] Inlining Division", "body": "This patch inlines float division function calls for hexagon.\r\n\r\nTests added to check the following\r\n\r\n1. Whether the implemented function gets inlined when -fast-math option is used \r\n2. Check that the splat of a constant, when it's used in a fp vector operation that needs to be expanded \r\n3. Check inlining\r\n4. Check no-inlining on optsize", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp", "functions": ["ResultType", "SelectFDiv", "OpValue1"]}, {"filename": "llvm/lib/Target/Hexagon/HexagonISelLowering.cpp", "functions": ["LowerFDIV", "SDValue"]}]}
{"pr_number": 78589, "url": "https://github.com/llvm/llvm-project/pull/78589", "title": "[coroutine] Create coroutine body in the correct eval context", "body": "Fixes: https://github.com/llvm/llvm-project/issues/78290\r\n\r\nSee the bug for more context.\r\n```cpp\r\nGen ACoroutine() {\r\n  if constexpr (0) // remove it make clang compile.\r\n    co_return;\r\n  co_await Gen{};\r\n}\r\n```\r\nWe miss symbol of ctor of promise_type if the first coroutine statement happens to be inside the disabled branch of `if constexpr`.\r\n\r\nThis happens because the promise object is built when we see the first coroutine statement which is present in `ExpressionEvaluationContext::DiscardedStatement` context due to `if constexpr (0)`. This makes clang believe that the promise constructor is only odr-used and not really \"used\".\r\n\r\nThe expr evaluation context for the coroutine body should not be related to the context in which the first coroutine statement appears. We override the context to `PotentiallyEvaluated`.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/SemaCXX/coroutine-promise-ctor.cpp", "functions": ["main"]}]}
{"pr_number": 77317, "url": "https://github.com/llvm/llvm-project/pull/77317", "title": "[mlir][bufferization][NFC] Remove `BufferPlacementTransformationBase`", "body": "`BufferPlacementTransformationBase` makes it difficult to add error handling to `BufferViewFlowAnalysis`. Error handling is added to `BufferViewFlowAnalysis` in a subsequent commit.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Bufferization/Transforms/BufferDeallocation.cpp", "functions": ["dominators", "BufferPlacementTransformationBase"]}, {"filename": "mlir/lib/Dialect/Bufferization/Transforms/BufferOptimizations.cpp", "functions": ["dominators", "BufferPlacementTransformationBase", "aliases"]}, {"filename": "mlir/lib/Dialect/Bufferization/Transforms/BufferUtils.cpp", "functions": ["aliases"]}]}
{"pr_number": 75512, "url": "https://github.com/llvm/llvm-project/pull/75512", "title": "[AMDGPU] Add mark last scratch load pass", "body": "", "feature_layers": ["ast"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/AMDGPUMarkLastScratchLoad.cpp", "functions": ["getAnalysisUsage", "getPassName", "runOnMachineFunction"]}, {"filename": "llvm/lib/Target/AMDGPU/AMDGPUTargetMachine.cpp", "functions": ["addPreStackSlotColoring"]}]}
{"pr_number": 75204, "url": "https://github.com/llvm/llvm-project/pull/75204", "title": "[AMDGPU] Add pseudo scalar trans instructions for GFX12", "body": "", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp", "functions": ["getDefaultMappingVOP", "getDefaultMappingSOP"]}]}
{"pr_number": 75492, "url": "https://github.com/llvm/llvm-project/pull/75492", "title": "[AMDGPU] CodeGen for GFX12 VBUFFER instructions", "body": "", "feature_layers": ["codegen"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/AMDGPUInstructionSelector.cpp", "functions": ["if"]}]}
{"pr_number": 76944, "url": "https://github.com/llvm/llvm-project/pull/76944", "title": "[AMDGPU] Add new cache flushing instructions for GFX12", "body": "", "feature_layers": [], "feature_directives": ["for", "flush"], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp", "functions": ["isCacheInvOrWBInst"]}]}
{"pr_number": 78672, "url": "https://github.com/llvm/llvm-project/pull/78672", "title": "[flang][re-apply] Fix seg fault CodeGenAction::executeAction()", "body": "If `generateLLVMIR()` fails, we still continue using the module we failed to generate which causes a seg fault if LLVM code-gen failed for some reason or another. This commit fixes this issue.\r\n\r\nRe-applies PR #78269 and adds LLVM and MLIR dependencies that were missed in the PR. The missing libs were: `LLVMCore` & `MLIRIR`.\r\n\r\nThis reverts commit 4fc75062745eb5232ea60c37b9ffe61177efa12a.", "feature_layers": ["codegen", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/unittests/Frontend/CodeGenActionTest.cpp", "functions": ["diagnosticsOS", "DummyDialect", "getDialectNamespace", "getAttributeNames", "CodeGenAction", "builder", "loc", "file", "getOperationName", "initialize"]}]}
{"pr_number": 76653, "url": "https://github.com/llvm/llvm-project/pull/76653", "title": "[llvm-exegesis] Add support for validation counters", "body": "This patch adds support for validation counters. Validation counters can be used to measure events that occur during snippet execution like cache misses to ensure that certain assumed invariants about the benchmark actually hold. Validation counters are setup within a perf event group, so are turned on and off at exactly the same time as the \"group leader\" counter that measures the desired value.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/utils/TableGen/ExegesisEmitter.cpp", "functions": ["getPfmCounterId"]}, {"filename": "llvm/tools/llvm-exegesis/lib/BenchmarkResult.cpp", "functions": ["output"]}, {"filename": "llvm/tools/llvm-exegesis/lib/LatencyBenchmarkRunner.cpp", "functions": ["BenchmarkRunner"]}, {"filename": "llvm/tools/llvm-exegesis/lib/PerfHelper.cpp", "functions": ["EventCounter", "Event"]}, {"filename": "llvm/tools/llvm-exegesis/lib/UopsBenchmarkRunner.cpp", "functions": ["ValCounterPortValues", "ValCounterUopsValues"]}, {"filename": "llvm/tools/llvm-exegesis/lib/X86/X86Counter.cpp", "functions": ["CounterGroup", "Counter"]}]}
{"pr_number": 71819, "url": "https://github.com/llvm/llvm-project/pull/71819", "title": "[libc++] Implement LWG3940: std::expected<void, E>::value() also needs E to be copy constructible", "body": "This patch includes the fix for [LWG3940](https://cplusplus.github.io/LWG/issue3940) (`std::expected<void, E>::value()` also needs `E` to be copy constructible)", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "libcxx/test/std/utilities/expected/expected.void/observers/value.lwg3940.compile.fail.cpp", "functions": ["main"]}, {"filename": "libcxx/test/libcxx/utilities/expected/expected.void/value.lwg3940.verify.cpp", "functions": ["main"]}]}
{"pr_number": 73115, "url": "https://github.com/llvm/llvm-project/pull/73115", "title": "[TableGen] Integrate TableGen-based macro fusion", "body": "`Fusion` is inherited from `SubtargetFeature` now. Each definition\r\nof `Fusion` will define a `SubtargetFeature` accordingly.\r\n\r\nMethod `getMacroFusions` is added to `TargetSubtargetInfo`, which\r\nreturns a list of `MacroFusionPredTy` that will be evaluated by\r\nMacroFusionMution.\r\n\r\n`getMacroFusions` will be auto-generated if the target has `Fusion`\r\ndefinitions.   \r\n", "feature_layers": [], "feature_directives": ["target"], "files_changed": [{"filename": "llvm/utils/TableGen/SubtargetEmitter.cpp", "functions": ["emitEnableMacroFusion"]}]}
{"pr_number": 78467, "url": "https://github.com/llvm/llvm-project/pull/78467", "title": "[mlir][llvm] Drop unreachable basic block during import", "body": "This revision updates the LLVM IR import to support unreachable basic blocks. An unreachable block may dominate itself and a value defined inside the block may thus be used before its definition. The import does not support such dependencies. We thus delete the unreachable basic blocks before the import. This is possible since MLIR does not have basic block labels that can be reached using an indirect call and unreachable blocks can indeed be deleted safely.\r\n\r\nAdditionally, add a small poison constant import test.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Target/LLVMIR/ModuleImport.cpp", "functions": ["traversal"]}]}
{"pr_number": 76823, "url": "https://github.com/llvm/llvm-project/pull/76823", "title": "[clang][ExtractAPI] Record availability information only for the target platform", "body": "Currently, ExtractAPI provides availability information for all platforms within a given domain. With this change, we narrow down the output to include availability details only for the specified target platform, so users can generate the symbol graph with only the availability information they need, omitting information of the other platforms.\r\n\r\nThis change reverts the functionality introduced in [`57c9780`](https://github.com/llvm/llvm-project/commit/57c9780).\r\n\r\nrdar://120419037\r\n", "feature_layers": [], "feature_directives": ["for", "target"], "files_changed": [{"filename": "clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp", "functions": ["serializeAvailability"]}]}
{"pr_number": 78554, "url": "https://github.com/llvm/llvm-project/pull/78554", "title": "[mlir][vector] Drop innermost unit dims on transfer_write.", "body": "The revision renames DropInnerMostUnitDims to DropInnerMostUnitDimsTransferRead; adds support for vector.transfer_write.\r\n\r\nIt refactors common methods (i.e., getTransferFoldableInnerUnitDims and getMemRefTypeWithDroppingInnerDims) and uses them in both patterns.\r\n\r\nA vector.transfer_write with inner unit dims will be lowered to vector.shape_cast + memref.subview + vector.transfer_write. E.g.,\r\n\r\n```mlir\r\nvector.transfer_write %arg1, %arg0[%c0, %arg2, %c0, %c0]\r\n {in_bounds = [true, true, true, true]}\r\n : vector<1x16x16x1xf32>, memref<1x512x16x1xf32, strided<[8192, 16, 1, 1], offset: ?>>\r\n```\r\n\r\nwill be lowered to\r\n\r\n```mlir\r\n%subview = memref.subview %arg0\r\n  [0, 0, 0, 0] [1, 512, 16, 1] [1, 1, 1, 1]\r\n  : memref<1x512x16x1xf32, strided<[8192, 16, 1, 1], offset: ?>>\r\n  to memref<1x512x16xf32, strided<[8192, 16, 1], offset: ?>>\r\n%0 = vector.shape_cast %arg1 : vector<1x16x16x1xf32> to vector<1x16x16xf32>\r\nvector.transfer_write %0, %subview[%c0, %arg2, %c0]\r\n  {in_bounds = [true, true, true]}\r\n  : vector<1x16x16xf32>, memref<1x512x16xf32, strided<[8192, 16, 1], offset: ?>>\r\n```", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Vector/Transforms/VectorTransforms.cpp", "functions": ["success", "ArrayAttr", "offsets", "failure", "strides"]}]}
{"pr_number": 78630, "url": "https://github.com/llvm/llvm-project/pull/78630", "title": "[clang-apply-replacements] Deduplicate Implementation of `collectReplacementsFromDirectory` (NFC)", "body": "* Convert `collectReplacementsFromDirectory` into a function template.\r\n* Employ explicit specialization to maintain implementation in the source file.\r\n* Utilize the function template in the source file to eliminate code duplication.\r\n* Update the documentation for the function.\r\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang-tools-extra/clang-apply-replacements/lib/Tooling/ApplyReplacements.cpp", "functions": ["YIn"]}]}
{"pr_number": 78171, "url": "https://github.com/llvm/llvm-project/pull/78171", "title": "[AsmParser] Don't require value numbers to be consecutive", "body": "Currently, the IR parser requires that %n style numbered values are consecutive. This means that the IR becomes invalid as soon as you remove an instruction, argument or block. This makes it very annoying to modify IR without running it through instnamer first.\r\n\r\nI don't think there is any good reason to impose this requirement. This PR relaxes it to allow value IDs to be non-consecutive, but it still keeps the requirement that they're increasing (i.e. you can't skip a value number and then assign it later).\r\n\r\nI've kept the underlying representation the same and added a guard against skipping large ranges to guard against degenerate cases where the NumberedVals vector would become huge. If people prefer, I could change NumberedVals from a vector to a map + a counter instead, in which case we could support arbitrary numbers without large increases in memory usage.\r\n\r\nThis only implements support for skipping numbers for local values. We should extend this to global values in the future as well.", "feature_layers": ["parse", "ir", "parser"], "feature_directives": ["for", "requires"], "files_changed": [{"filename": "llvm/lib/AsmParser/LLParser.cpp", "functions": ["parseFunctionHeader", "PFS"]}]}
{"pr_number": 78601, "url": "https://github.com/llvm/llvm-project/pull/78601", "title": "[X86] movsd/movss/movd/movq - add support for constant comments", "body": "If we're loading a constant value, print the constant (and the zero upper elements) instead of just the shuffle mask\r\n\r\nThis did require me to move the shuffle mask handling into addConstantComments as we can't handle this in the MC layer", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/X86/X86MCInstLower.cpp", "functions": ["CS"]}]}
{"pr_number": 74725, "url": "https://github.com/llvm/llvm-project/pull/74725", "title": "[DWARFLinker][DWARFLinkerParallel][NFC] Refactor DWARFLinker&DWARFLinkerParallel to have a common library.", "body": "This creates DWARFLinkerBase library which shares code between DWARFLinker and DWARFLinkerParallel. Now AddressesMap, DWARFFile, IndexedValuesMap are shared between DWARFLinker implementations.", "feature_layers": [], "feature_directives": ["parallel"], "files_changed": [{"filename": "llvm/lib/DWARFLinker/Apple/DWARFLinker.cpp", "functions": ["guessToolchainBaseDir"]}, {"filename": "llvm/lib/DWARFLinker/Apple/DWARFStreamer.cpp", "functions": ["DwarfStreamer"]}, {"filename": "llvm/lib/DWARFLinker/LLVM/DWARFLinkerCompileUnit.cpp", "functions": ["guessToolchainBaseDir", "isPathAbsoluteOnWindowsOrPosix"]}, {"filename": "llvm/lib/DWARFLinker/LLVM/OutputSections.cpp", "functions": ["parseDebugTableName", "Mem"]}, {"filename": "llvm/lib/DWARFLinkerParallel/DWARFFile.cpp", "functions": ["FileName"]}, {"filename": "llvm/lib/DebugInfo/DWARF/DWARFDebugLine.cpp", "functions": ["isPathAbsoluteOnWindowsOrPosix"]}, {"filename": "llvm/tools/dsymutil/DwarfLinkerForBinary.cpp", "functions": ["Guard", "constexpr"]}, {"filename": "llvm/tools/llvm-dwarfutil/DebugInfoLinker.cpp", "functions": ["ObjectsForLinking", "constexpr"]}, {"filename": "bolt/lib/Rewrite/DWARFRewriter.cpp", "functions": ["emitDIE"]}]}
{"pr_number": 71039, "url": "https://github.com/llvm/llvm-project/pull/71039", "title": "[analyzer][NFC] Rework SVal kind representation", "body": "The goal of this patch is to refine how the `SVal` base and sub-kinds are represented by forming one unified enum describing the possible SVals. This means that the `unsigned SVal::Kind` and the attached bit-packing semantics would be replaced by a single unified enum. This is more conventional and leads to a better debugging experience by default. This eases the need of using debug pretty-printers, or the use of runtime functions doing the printing for us like we do today by calling `Val.dump()` whenever we inspect the values.\r\n\r\nPreviously, the first 2 bits of the `unsigned SVal::Kind` discriminated the following quartet: `UndefinedVal`, `UnknownVal`, `Loc`, or `NonLoc`. The rest of the upper bits represented the sub-kind, where the value represented the index among only the `Loc`s or `NonLoc`s, effectively attaching 2 meanings of the upper bits depending on the base-kind. We don't need to pack these bits, as we have plenty even if we would use just a plan-old `unsigned char`.\r\n\r\nConsequently, in this patch, I propose to lay out all the (non-abstract) `SVal` kinds into a single enum, along with some metadata (`BEGIN_Loc`, `END_Loc`, `BEGIN_NonLoc`, `END_NonLoc`) artificial enum values, similar how we do with the `MemRegions`.\r\n\r\nNote that in the unified `SVal::Kind` enum, to differentiate `nonloc::ConcreteInt` from `loc::ConcreteInt`, I had to prefix them with `Loc` and `NonLoc` to resolve this ambiguity.\r\nThis should not surface in general, because I'm replacing the `nonloc::Kind` enum items with `inline constexpr` global constants to mimic the original behavior - and offer nicer spelling to these enum values.\r\n\r\nSome `SVal` constructors were not marked explicit, which I now mark as such to follow best practices, and marked others as `/*implicit*/` to clarify the intent.\r\nDuring refactoring, I also found at least one function not marked `LLVM_ATTRIBUTE_RETURNS_NONNULL`, so I did that.\r\n\r\nThe `TypeRetrievingVisitor` visitor had some accidental dead code, namely: `VisitNonLocConcreteInt` and `VisitLocConcreteInt`.\r\n\r\nPreviously, the `SValVisitor` expected visit handlers of `VisitNonLocXXXXX(nonloc::XXXXX)` and `VisitLocXXXXX(loc::XXXXX)`, where I felt that envoding `NonLoc` and `Loc` in the name is not necessary as the type of the parameter would select the right overload anyways, so I simplified the naming of those visit functions.\r\n\r\nThe rest of the diff is a lot of times just formatting, because `getKind()` by nature, frequently appears in switches, which means that the whole switch gets automatically reformatted. I could probably undo the formatting, but I didn't want to deviate from the rule unless explicitly requested.", "feature_layers": ["sema", "runtime", "ir", "ast"], "feature_directives": ["for", "single"], "files_changed": [{"filename": "clang/lib/StaticAnalyzer/Core/SValBuilder.cpp", "functions": ["VisitNonLocConcreteInt", "VisitNonLocLazyCompoundVal", "VisitLocAsInteger", "VisitLocMemRegionVal", "VisitLocGotoLabel", "VisitCompoundVal", "VisitNonLocLocAsInteger", "VisitPointerToMember", "VisitLocConcreteInt", "VisitNonLocPointerToMember", "VisitMemRegionVal", "VisitNonLocSymbolVal", "VisitNonLocCompoundVal", "VisitConcreteInt", "VisitSymbolVal", "VisitGotoLabel", "VisitLazyCompoundVal"]}, {"filename": "clang/lib/StaticAnalyzer/Core/SVals.cpp", "functions": ["VisitNonLocConcreteInt", "VisitNonLocLazyCompoundVal", "VisitLocAsInteger", "VisitLocGotoLabel", "VisitLocMemRegionVal", "VisitNonLocLocAsInteger", "VisitCompoundVal", "VisitLocConcreteInt", "VisitMemRegionVal", "VisitNonLocSymbolVal", "VisitNonLocCompoundVal", "VisitConcreteInt", "VisitSymbolVal", "VisitGotoLabel", "VisitLazyCompoundVal"]}, {"filename": "clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp", "functions": ["evalBinOpLL", "VisitNonLocSymbolVal", "VisitSymbolVal", "UnknownVal"]}]}
{"pr_number": 78551, "url": "https://github.com/llvm/llvm-project/pull/78551", "title": "[MLIR][OpenMP] Better error reporting for unsupported `nowait`", "body": "Provides some context for failing to generate LLVM IR for `target enter|exit|update` directives when `nowait` is provided. This is directly helpful for flang users since they would get this error message if they tried to use `nowait`. Before that we had a very generic message.\r\n\r\nThis is a follow-up to https://github.com/llvm/llvm-project/pull/78269, please only review the latest commit (the one with the same commit message as the PR title).\r\n", "feature_layers": ["ir"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "mlir/lib/Target/LLVMIR/Dialect/OpenMP/OpenMPToLLVMIRTranslation.cpp", "functions": ["failure"]}]}
{"pr_number": 78258, "url": "https://github.com/llvm/llvm-project/pull/78258", "title": "[Clang] Refactor diagnostics for SME builtins.", "body": "The arm_sme.td file was still using `IsSharedZA` and `IsPreservesZA`, which should be changed to match the new state attributes added in #76971.\r\n\r\nThis patch adds `IsInZA`, `IsOutZA` and `IsInOutZA` as the state for the Clang builtins and fixes up the code in SemaChecking and SveEmitter to match.\r\n\r\nNote that the code is written in such a way that it can be easily extended with ZT0 state (to follow in a future patch).", "feature_layers": ["sema"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Sema/SemaChecking.cpp", "functions": ["hasSMEZAState", "getSMEState", "hasArmZAState"]}, {"filename": "clang/test/Sema/aarch64-incompat-sm-builtin-calls.c", "functions": ["svread_hor_za8_s8_m"]}, {"filename": "clang/utils/TableGen/SveEmitter.cpp", "functions": ["if"]}]}
{"pr_number": 78081, "url": "https://github.com/llvm/llvm-project/pull/78081", "title": "[libc] Provide sys/queue.h", "body": "This header first appeared in 4.4BSD and is provided by a number of C libraries including Newlib. Several of our embedded projects use this header and so to make LLVM libc a drop-in replacement, we need to provide it as well.\r\n\r\nFor the initial commit, we only implement singly linked variants (SLIST and STAILQ). The doubly linked variants (LIST, TAILQ and CIRCLEQ) can be implemented in the future as needed.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "libc/test/include/sys/queue_test.cpp", "functions": ["match"]}]}
{"pr_number": 73067, "url": "https://github.com/llvm/llvm-project/pull/73067", "title": "[lldb][test] Apply @expectedFailureAll/@skipIf early for debug_info tests", "body": "The @expectedFailureAll and @skipIf decorators will mark the test case as xfail/skip if _all_ conditions passed in match, including debug_info.\n* If debug_info is not one of the matching conditions, we can immediately evaluate the check and decide if it should be decorated.\n* If debug_info *is* present as a match condition, we need to defer whether or not to decorate until when the `LLDBTestCaseFactory` metaclass expands the test case into its potential variants. This is still early enough that the standard `unittest` framework will recognize the test as xfail/skip by the time the test actually runs.\n\nTestDecorators exhibits the edge cases more thoroughly. With the exception of `@expectedFailureIf` (added by this commit), all those test cases pass prior to this commit.\n\nThis is a followup to 212a60ec37322f853e91e171b305479b1abff2f2.\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Sema/SemaChecking.cpp", "functions": ["hasSMEZAState", "getSMEState", "hasArmZAState"]}, {"filename": "clang/test/Sema/aarch64-incompat-sm-builtin-calls.c", "functions": ["new_za", "svread_hor_za8_s8_m"]}, {"filename": "clang/utils/TableGen/SveEmitter.cpp", "functions": ["if"]}, {"filename": "llvm/lib/Target/AArch64/Utils/AArch64SMEAttributes.cpp", "functions": ["hasStreamingInterfaceOrBody"]}]}
{"pr_number": 78351, "url": "https://github.com/llvm/llvm-project/pull/78351", "title": "Re-exec TSan with no ASLR if memory layout is incompatible on Linux", "body": "TSan's shadow mappings only support 30-bits of ASLR entropy on x86 Linux, and\r\nit is not practical to support the maximum of 32-bits (due to pointer\r\ncompression and the overhead of shadow mappings). Instead, this patch\r\nchanges TSan to re-exec without ASLR if it encounters an incompatible\r\nmemory layout, as suggested by Dmitry in https://github.com/google/sanitizers/issues/1716.\r\nIf ASLR is already disabled but the memory layout is still incompatible, it will abort.\r\n\r\nThis patch involves a bit of refactoring, because the old code is:\r\n1. InitializePlatformEarly()\r\n2. InitializeAllocator()\r\n3. InitializePlatform(): CheckAndProtect()\r\n\r\nbut it may already segfault during InitializeAllocator() if the memory\r\nlayout is incompatible, before we get a chance to check in\r\nCheckAndProtect().\r\n\r\nThis patch adds CheckAndProtect() during InitializePlatformEarly(), before\r\nthe allocator is initialized. Naturally, it is necessary to ensure that\r\nCheckAndProtect() does *not* allow the heap regions to be occupied there,\r\nhence we generalize CheckAndProtect() to optionally check the heap\r\nregions. We keep the original behavior of CheckAndProtect() in InitializePlatform()\r\nas a last line of defense.\r\n\r\nWe need to be careful not to prematurely abort if ASLR is disabled but TSan was going to re-exec\r\nfor other reasons (e.g., unlimited stack size); we implement this by\r\nmoving all the re-exec logic into ReExecIfNeeded().\r\n", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "compiler-rt/lib/tsan/rtl/tsan_platform_linux.cpp", "functions": ["ReExecIfNeeded"]}, {"filename": "compiler-rt/lib/tsan/rtl/tsan_platform_posix.cpp", "functions": ["CheckAndProtect"]}]}
{"pr_number": 78398, "url": "https://github.com/llvm/llvm-project/pull/78398", "title": "[mlir][transform] Add an op for replacing values with function calls", "body": "Adds `transform.func.cast_and_call` that takes a set of inputs and\r\noutputs and replaces the uses of those outputs with a call to a function\r\nat a specified insertion point.\r\n\r\nThe idea with this operation is to allow users to author independent IR\r\noutside of a to-be-compiled module, and then match and replace a slice of\r\nthe program with a call to the external function.\r\n\r\nAdditionally adds a mechanism for populating a type converter with a set\r\nof conversion materialization functions that allow insertion of\r\ncasts on the inputs/outputs to and from the types of the function\r\nsignature.\r\n\r\nDepends on #78397", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Func/TransformOps/FuncTransformOps.cpp", "functions": ["builder", "emitSilenceableFailure", "emitDefiniteFailure"]}]}
{"pr_number": 77224, "url": "https://github.com/llvm/llvm-project/pull/77224", "title": "[llvm-exegesis] Make duplicate snippet repetitor produce whole snippets", "body": "Currently, the duplicate snippet repetitor will truncate snippets that do not exactly divide the minimum number of instructions. This patch corrects that behavior by making the duplicate snippet repetitor duplicate the snippet in its entirety until the minimum number of instructions has been reached.\r\n\r\nThis makes the behavior consistent with the loop snippet repetitor, which will execute at least `--num-repetitions` (soon to be renamed `--min-instructions`) instructions.", "feature_layers": ["ir", "ast"], "feature_directives": [], "files_changed": [{"filename": "llvm/unittests/tools/llvm-exegesis/X86/SnippetRepetitorTest.cpp", "functions": ["TestCommon"]}]}
{"pr_number": 78636, "url": "https://github.com/llvm/llvm-project/pull/78636", "title": "[InstCombine] Try to fold trunc(shuffle(zext)) to just a shuffle", "body": "Tries to remove extra trunc/ext instruction for shufflevector\ninstructions.\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp", "functions": ["canEvaluateTruncated"]}]}
{"pr_number": 72542, "url": "https://github.com/llvm/llvm-project/pull/72542", "title": "[BOLT] Use deterministic xxh3 for computing BF/BB hashes", "body": "std::hash and ADT/Hashing::hash_value are non-deterministic functions whose\r\nresults might vary across implementation/process/execution. Using xxh3 instead\r\nfor computing hashes of BinaryFunctions and BinaryBasicBlock for stale profile\r\nmatching.\r\n(A possible alternative is to use ADT/StableHashing.h based on FNV hashing but\r\nxxh3 seems to be more popular in LLVM)\r\n\r\nThis is to address https://github.com/llvm/llvm-project/issues/65241.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "bolt/lib/Core/HashUtilities.cpp", "functions": ["hash_64_to_16"]}]}
{"pr_number": 78812, "url": "https://github.com/llvm/llvm-project/pull/78812", "title": "[mlir][index] Fold `cmp(x, x)` when `x` isn't a constant", "body": "Such cases show up in the middle of optimizations passes, e.g., after some rewrites and then CSE. The current folder can fold such cases when the inputs are constant; this patch improves it to fold even if the inputs are non-constant.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/Index/IR/IndexOps.cpp", "functions": ["compareSameArgs"]}]}
{"pr_number": 78486, "url": "https://github.com/llvm/llvm-project/pull/78486", "title": "[lldb][DWARFUnit] Implement PeekDIEName query", "body": "This allows us to query the AT_Name of a DIE without parsing the entire CU.\r\n\r\nPart of the ongoing effort to support IDX_Parent in accelerator tables [1].\r\n\r\n[1]: https://discourse.llvm.org/t/rfc-improve-dwarf-5-debug-names-type-lookup-parsing-speed/74151/44", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "lldb/unittests/SymbolFile/DWARF/DWARFDIETest.cpp", "functions": ["fourth_die", "fifth_die"]}]}
{"pr_number": 78822, "url": "https://github.com/llvm/llvm-project/pull/78822", "title": "Revert \"[mlir][amdgpu] Shared memory access optimization pass\"", "body": "Reverts llvm/llvm-project#75627 ; it broke the bot: https://lab.llvm.org/buildbot/#/builders/61/builds/53218", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/AMDGPU/IR/AMDGPUDialect.cpp", "functions": ["isSharedMemoryAddressSpace"]}, {"filename": "mlir/lib/Dialect/AMDGPU/Transforms/OptimizeSharedMemory.cpp", "functions": ["failure", "runOnOperation", "success", "builder"]}]}
{"pr_number": 69879, "url": "https://github.com/llvm/llvm-project/pull/69879", "title": "[NewPM][CodeGen] Add NPM support to llc", "body": "Just steal patches shamefully from [D83612](https://reviews.llvm.org/D83612) and [D83613](https://reviews.llvm.org/D83613) by @yuanfang-chen, migrate them to the latest llvm. If it is not the time to land this, feel free to close it.", "feature_layers": ["codegen"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/Target/X86/X86TargetMachine.cpp", "functions": ["addLegalizeMachineIR", "run", "addPostFastRegAllocRewrite", "addILPOpts", "addGlobalInstructionSelect", "addIRTranslator", "addPreISel", "addPreRegAlloc", "addAsmPrinter", "addPreSched2", "addIRPasses", "addPrecedingEmitPass", "addInstSelector", "addPreEmitPass", "addPostRegAlloc", "addRegAssignAndRewriteOptimized", "addRegBankSelect", "addMachineSSAOptimization", "TargetPassConfig"]}, {"filename": "llvm/tools/llc/NewPMDriver.cpp", "functions": ["SI", "DP", "PB", "MFAM"]}, {"filename": "llvm/tools/llc/llc.cpp", "functions": ["DP", "compileModuleWithNewPM", "handleDiagnostics"]}]}
{"pr_number": 78670, "url": "https://github.com/llvm/llvm-project/pull/78670", "title": "Reland \"[clang] Fix CTAD for aggregates for nested template classes\"", "body": "Reland of #78387\r\n\r\nUse the template pattern in determining whether to synthesize the aggregate deduction guide, and update DeclareImplicitDeductionGuideFromInitList to substitute outer template arguments.\r\n\r\nThe tests in the original patch made an assumption about the size of a pointer type, and this led to them failing on targets with 32-bit pointers. The tests have been updated to not depend on the size of any type. This only requires updates to the test file, no functionality has otherwise changed between this and the original patch.", "feature_layers": ["ir"], "feature_directives": ["for", "target", "declare", "requires"], "files_changed": [{"filename": "clang/lib/Sema/SemaTemplate.cpp", "functions": ["SavedContext"]}, {"filename": "clang/test/SemaTemplate/nested-implicit-deduction-guides.cpp", "functions": ["requires"]}]}
{"pr_number": 77474, "url": "https://github.com/llvm/llvm-project/pull/77474", "title": "[CodeGen] Port GlobalMerge to new pass manager", "body": "", "feature_layers": ["codegen"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/CodeGen/GlobalMerge.cpp", "functions": ["FunctionPass", "getPassName", "collectUsedGlobalVariables", "getAnalysisUsage", "TM", "setMustKeepGlobalVariables", "isMustKeepGlobalVariable", "runOnFunction", "run", "GlobalMerge", "doFinalization", "P", "doInitialization"]}, {"filename": "llvm/lib/Passes/PassBuilder.cpp", "functions": ["if", "parseGlobalMergeOptions"]}]}
{"pr_number": 75334, "url": "https://github.com/llvm/llvm-project/pull/75334", "title": "[CodeGen] Port `StackProtector` to new pass manager", "body": "The original `StackProtector` is both transform and analysis pass, break it into two passes now. `getAnalysis<StackProtector>()` could be now replaced by `FAM.getResult<SSPLayoutAnalysis>(F)` in new pass system.", "feature_layers": ["codegen"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/CodeGen/StackProtector.cpp", "functions": ["DTU"]}]}
{"pr_number": 78215, "url": "https://github.com/llvm/llvm-project/pull/78215", "title": "[libc++][any] LWG3305: `any_cast<void>`", "body": "Implements: https://wg21.link/LWG3305\n- https://eel.is/c++draft/any.nonmembers", "feature_layers": ["ast"], "feature_directives": [], "files_changed": [{"filename": "libcxx/test/std/utilities/any/any.nonmembers/any.cast/void.verify.cpp", "functions": ["test"]}]}
{"pr_number": 70595, "url": "https://github.com/llvm/llvm-project/pull/70595", "title": "[clang-tidy] Add readability-redundant-casting check", "body": "Detects explicit type casting operations that involve the same source and destination types, and subsequently recommend their removal. Covers a range of explicit casting operations. Its primary objective is to enhance code readability and maintainability by eliminating unnecessary type casting.\r\n\r\nCloses #67534", "feature_layers": ["ir", "ast"], "feature_directives": [], "files_changed": [{"filename": "clang-tools-extra/clang-tidy/readability/RedundantCastingCheck.cpp", "functions": ["areTypesEquals", "areTypesEqual"]}, {"filename": "clang-tools-extra/test/clang-tidy/checkers/readability/redundant-casting.cpp", "functions": ["testRedundantDependentNTTPCasting", "testRedundantNTTPCasting", "testValidNTTPCasting"]}]}
{"pr_number": 78552, "url": "https://github.com/llvm/llvm-project/pull/78552", "title": "[CodeGen] Add code new pm code stubs for all backends", "body": "Just add dummy methods here, so `llc` will not throw error when building codegen pipeline.", "feature_layers": ["codegen"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AArch64/AArch64CodeGenPassBuilder.cpp", "functions": ["addPreISel", "CodeGenPassBuilder", "addInstSelector", "addAsmPrinter"]}, {"filename": "llvm/lib/Target/AMDGPU/AMDGPUCodeGenPassBuilder.cpp", "functions": ["addPreISel", "CodeGenPassBuilder", "addInstSelector", "addAsmPrinter"]}, {"filename": "llvm/lib/Target/ARC/ARCCodeGenPassBuilder.cpp", "functions": ["addPreISel", "CodeGenPassBuilder", "addInstSelector", "addAsmPrinter"]}, {"filename": "llvm/lib/Target/ARM/ARMCodeGenPassBuilder.cpp", "functions": ["addPreISel", "CodeGenPassBuilder", "addInstSelector", "addAsmPrinter"]}, {"filename": "llvm/lib/Target/AVR/AVRCodeGenPassBuilder.cpp", "functions": ["addPreISel", "CodeGenPassBuilder", "addInstSelector", "addAsmPrinter"]}, {"filename": "llvm/lib/Target/BPF/BPFCodeGenPassBuilder.cpp", "functions": ["addPreISel", "CodeGenPassBuilder", "addInstSelector", "addAsmPrinter"]}, {"filename": "llvm/lib/Target/CSKY/CSKYCodeGenPassBuilder.cpp", "functions": ["addPreISel", "CodeGenPassBuilder", "addInstSelector", "addAsmPrinter"]}, {"filename": "llvm/lib/Target/DirectX/DirectXCodeGenPassBuilder.cpp", "functions": ["addPreISel", "CodeGenPassBuilder", "addInstSelector", "addAsmPrinter"]}, {"filename": "llvm/lib/Target/Hexagon/HexagonCodeGenPassBuilder.cpp", "functions": ["addPreISel", "CodeGenPassBuilder", "addInstSelector", "addAsmPrinter"]}, {"filename": "llvm/lib/Target/Lanai/LanaiCodeGenPassBuilder.cpp", "functions": ["addPreISel", "CodeGenPassBuilder", "addInstSelector", "addAsmPrinter"]}, {"filename": "llvm/lib/Target/LoongArch/LoongArchCodeGenPassBuilder.cpp", "functions": ["addPreISel", "CodeGenPassBuilder", "addInstSelector", "addAsmPrinter"]}, {"filename": "llvm/lib/Target/M68k/M68kCodeGenPassBuilder.cpp", "functions": ["addPreISel", "CodeGenPassBuilder", "addInstSelector", "addAsmPrinter"]}, {"filename": "llvm/lib/Target/MSP430/MSP430CodeGenPassBuilder.cpp", "functions": ["addPreISel", "CodeGenPassBuilder", "addInstSelector", "addAsmPrinter"]}, {"filename": "llvm/lib/Target/Mips/MipsCodeGenPassBuilder.cpp", "functions": ["addPreISel", "CodeGenPassBuilder", "addInstSelector", "addAsmPrinter"]}, {"filename": "llvm/lib/Target/NVPTX/NVPTXCodeGenPassBuilder.cpp", "functions": ["addPreISel", "CodeGenPassBuilder", "addInstSelector", "addAsmPrinter"]}, {"filename": "llvm/lib/Target/PowerPC/PPCCodeGenPassBuilder.cpp", "functions": ["addPreISel", "CodeGenPassBuilder", "addInstSelector", "addAsmPrinter"]}, {"filename": "llvm/lib/Target/RISCV/RISCVCodeGenPassBuilder.cpp", "functions": ["addPreISel", "CodeGenPassBuilder", "addInstSelector", "addAsmPrinter"]}, {"filename": "llvm/lib/Target/SPIRV/SPIRVCodeGenPassBuilder.cpp", "functions": ["addPreISel", "CodeGenPassBuilder", "addInstSelector", "addAsmPrinter"]}, {"filename": "llvm/lib/Target/Sparc/SparcCodeGenPassBuilder.cpp", "functions": ["addPreISel", "CodeGenPassBuilder", "addInstSelector", "addAsmPrinter"]}, {"filename": "llvm/lib/Target/SystemZ/SystemZCodeGenPassBuilder.cpp", "functions": ["addPreISel", "CodeGenPassBuilder", "addInstSelector", "addAsmPrinter"]}, {"filename": "llvm/lib/Target/VE/VECodeGenPassBuilder.cpp", "functions": ["addPreISel", "CodeGenPassBuilder", "addInstSelector", "addAsmPrinter"]}, {"filename": "llvm/lib/Target/WebAssembly/WebAssemblyCodeGenPassBuilder.cpp", "functions": ["addPreISel", "CodeGenPassBuilder", "addInstSelector", "addAsmPrinter"]}, {"filename": "llvm/lib/Target/X86/X86CodeGenPassBuilder.cpp", "functions": ["addPreISel", "CodeGenPassBuilder", "addInstSelector", "addAsmPrinter"]}, {"filename": "llvm/lib/Target/XCore/XCoreCodeGenPassBuilder.cpp", "functions": ["addPreISel", "CodeGenPassBuilder", "addInstSelector", "addAsmPrinter"]}, {"filename": "llvm/lib/Target/Xtensa/XtensaCodeGenPassBuilder.cpp", "functions": ["addPreISel", "CodeGenPassBuilder", "addInstSelector", "addAsmPrinter"]}]}
{"pr_number": 77084, "url": "https://github.com/llvm/llvm-project/pull/77084", "title": "[CodeGen] Allow `CodeGenPassBuilder` to add module pass after function pass", "body": "In fact, there are several backends, e.g. AArch64, AMDGPU etc. add module pass after function pass, this patch removes this constraint. This patch also adds a simple unit test for `CodeGenPassBuilder`.", "feature_layers": ["codegen"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/unittests/CodeGen/CodeGenPassBuilderTest.cpp", "functions": ["run", "name"]}, {"filename": "llvm/lib/Passes/PassBuilder.cpp", "functions": ["run", "name", "Result"]}]}
{"pr_number": 75033, "url": "https://github.com/llvm/llvm-project/pull/75033", "title": "[CodeGen][GC] Remove `GCInfoPrinter`", "body": "This pass is broken and looks like no one uses it.\r\n\r\n```c++\r\nbool Printer::runOnFunction(Function &F) {\r\n  if (F.hasGC())\r\n    return false;\r\n\r\n  GCFunctionInfo *FD = &getAnalysis<GCModuleInfo>().getFunctionInfo(F);\r\n```\r\n```c++\r\nGCFunctionInfo &GCModuleInfo::getFunctionInfo(const Function &F) {\r\n  assert(!F.isDeclaration() && \"Can only get GCFunctionInfo for a definition!\");\r\n  assert(F.hasGC()); // Equivalent to `assert(false);` when called by `Printer::runOnFunction`\r\n```\r\n\r\nSee also #74972.", "feature_layers": ["codegen"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/CodeGen/GCMetadata.cpp", "functions": ["getPassName", "getAnalysisUsage", "runOnFunction", "doFinalization", "LS", "Printer"]}]}
{"pr_number": 76218, "url": "https://github.com/llvm/llvm-project/pull/76218", "title": "[clang-repl] Add a interpreter-specific overload of operator new for C++", "body": "This patch brings back the basic support for C by inserting the required for value printing runtime only when we are in C++ mode. Additionally, it defines a new overload of operator placement new because we can't really forward declare it in a library-agnostic way.\r\n\r\nFixes the issue described in llvm/llvm-project#69072.", "feature_layers": ["runtime", "ir"], "feature_directives": ["for", "declare"], "files_changed": [{"filename": "clang/lib/Interpreter/Interpreter.cpp", "functions": ["new"]}, {"filename": "clang/unittests/Interpreter/InterpreterTest.cpp", "functions": ["AllocateObject"]}]}
{"pr_number": 77943, "url": "https://github.com/llvm/llvm-project/pull/77943", "title": "[clang-tidy] fix modernize-use-auto incorrect fix hints for pointer", "body": "avoid create incorrect fix hints for pointer to array type and pointer to function type Fixes: #77891", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang-tools-extra/test/clang-tidy/checkers/modernize/use-auto-for-pointer.cpp", "functions": ["f", "memberFunctionPointer"]}]}
{"pr_number": 77256, "url": "https://github.com/llvm/llvm-project/pull/77256", "title": "[libc++] Fix `regex_search` to match `$` alone with `match_default` flag", "body": "Using `regex_search` with the regex_constant `match_default` and a simple regex pattern `$` is expected to match general strings such as _\"a\", \"ab\", \"abc\"..._ at `[last, last)` positions.  But, the current implementation fails to do so.\r\n\r\nFixes #75042\r\n", "feature_layers": ["ast"], "feature_directives": [], "files_changed": [{"filename": "libcxx/test/std/re/re.const/re.matchflag/match_not_eol.pass.cpp", "functions": ["re"]}]}
{"pr_number": 68253, "url": "https://github.com/llvm/llvm-project/pull/68253", "title": "[JITLink][RISCV] Implement eh_frame handling", "body": "This requires adding a `NegDelta32` edge kind that cannot be mapped to existing relocations.", "feature_layers": ["ir"], "feature_directives": ["requires"], "files_changed": [{"filename": "llvm/lib/ExecutionEngine/JITLink/ELF_riscv.cpp", "functions": ["makeTargetOutOfRangeError"]}]}
{"pr_number": 78561, "url": "https://github.com/llvm/llvm-project/pull/78561", "title": "[libc++][hardening] In production hardening modes, trap rather than abort", "body": "In the hardening modes that can be used in production (`fast` and `extensive`), make a failed assertion invoke a trap instruction rather than calling verbose abort. In the debug mode, still keep calling verbose abort to provide a better user experience and to allow us to keep our existing testing infrastructure for verifying assertion messages. Since the debug mode by definition enables all assertions, we can be sure that we still check all the assertion messages in the library when running the test suite in the debug mode.\r\n\r\nThe main motivation to use trapping in production is to achieve better code generation and reduce the binary size penalty. This way, the assertion handler can compile to a single instruction, whereas the existing mechanism with verbose abort results in generating a function call that in general cannot be optimized away (made worse by the fact that it's a variadic function, imposing an additional penalty). See the [RFC](https://discourse.llvm.org/t/rfc-hardening-in-libc/73925) for more details. Note that this mechanism can now be completely [overridden at CMake configuration time](https://github.com/llvm/llvm-project/pull/77883).\r\n\r\nThis patch also significantly refactors `check_assertion.h` and expands its test coverage. The main changes:\r\n- when overriding `verbose_abort`, don't do matching inside the function -- just print the error message to `stderr`. This removes the need to set a global matcher and allows to do matching in the parent process after the child finishes;\r\n- remove unused logic for matching source locations and for using wildcards;\r\n- make matchers simple functors;\r\n- introduce `DeathTestResult` that keeps data about the test run, primarily to make it easier to test.\r\n\r\nIn addition to the refactoring, `check_assertion.h` can now recognize when a process exits due to a trap.\r\n", "feature_layers": ["ast"], "feature_directives": ["for", "single"], "files_changed": [{"filename": "libcxx/test/support/test.support/test_check_assertion.pass.cpp", "functions": ["MatchResult", "MakeAnyMatcher"]}]}
{"pr_number": 78200, "url": "https://github.com/llvm/llvm-project/pull/78200", "title": "Warning for incorrect useof 'pure' attribute", "body": "Linked with this issue:\r\n\r\nhttps://github.com/llvm/llvm-project/issues/77482\r\n\r\n@ChuanqiXu9\r\n@cor3ntin \r\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Sema/SemaDecl.cpp", "functions": ["CheckConstPureAttributesUsage"]}, {"filename": "clang/test/Sema/incorrect_pure.cpp", "functions": ["bar", "m", "foo", "A"]}, {"filename": "clang/test/Analysis/call-invalidation.cpp", "functions": ["usePointerConst", "usePointerPure"]}, {"filename": "clang/test/SemaCXX/warn-unused-value-cxx11.cpp", "functions": ["f"]}, {"filename": "clang/test/Sema/attr-print.c", "functions": ["bar", "foo"]}, {"filename": "clang/test/SemaCXX/attr-print.cpp", "functions": ["foo1", "bar", "foo"]}, {"filename": "clang/test/SemaCXX/cxx11-attr-print.cpp", "functions": ["bar", "foo"]}, {"filename": "clang/test/CodeGen/function-attributes.c", "functions": ["f13"]}, {"filename": "clang/test/Import/attr/test.cpp", "functions": ["f"]}, {"filename": "clang/test/Index/attributes.c", "functions": ["const_fn", "pure_fn"]}, {"filename": "clang/test/Import/attr/Inputs/S.cpp", "functions": ["f"]}]}
{"pr_number": 78037, "url": "https://github.com/llvm/llvm-project/pull/78037", "title": "[compiler-rt] Add a prefix on the windows mmap symbols", "body": "For Windows, the compiler-rt profile library contains a polyfill reimplementation of the mmap family of functions.\r\n\r\nPreviously, the runtime library exposed those symbols like, \"mmap\", in the user symbol namespace. This could cause misdetections by configure scripts that check for the \"mmap\" function just by linking, without including headers.\r\n\r\nAdd a prefix on the symbols, and make an undeclared function static.\r\n\r\nThis fixes such an issue reported at https://github.com/mstorsjo/llvm-mingw/issues/390.", "feature_layers": ["runtime"], "feature_directives": ["for", "declare"], "files_changed": [{"filename": "compiler-rt/lib/profile/WindowsMMap.c", "functions": ["lock"]}]}
{"pr_number": 77899, "url": "https://github.com/llvm/llvm-project/pull/77899", "title": "[Flang] Fix for replacing loop uses in LoopVersioning pass", "body": "The added test case has a loop that is versioned, which has a use of the loop in an if block after the loop. The current code replaces all uses of the loop with the new version If, but only if the parent blocks match. As far as I can see it should be safe to replace all the uses, then construct the result for the If with op.op.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Optimizer/Transforms/LoopVersioning.cpp", "functions": ["replaceOuterUses"]}]}
{"pr_number": 78684, "url": "https://github.com/llvm/llvm-project/pull/78684", "title": "[InlineOrder] Fix InlineOrder erase_if implementation", "body": "The InlineOrder Heap stores a CallBase ptr and InlineHistoryID pair. When running the `erase_if` method, InlineHistoryID is always returned with 0. Instead, we should be retrieving it from the `InlineHistoryMap` (similar to what is done in the `pop` implementation). \r\n\r\nThis change is completely harmless because no one is using InlineHistoryID right now as part of the `erase_if` implementation which is currently only used in the ModuleInliner. ", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/Analysis/InlineOrder.cpp", "functions": ["Pred"]}]}
{"pr_number": 77013, "url": "https://github.com/llvm/llvm-project/pull/77013", "title": "[clang-format] Handle templated elaborated type specifier in function\u2026", "body": "\u2026 return type.\r\n\r\nThe behavior now is consistent with the non template version.\r\nEnabled and updated old test.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Format/UnwrappedLineParser.cpp", "functions": ["if"]}]}
{"pr_number": 78103, "url": "https://github.com/llvm/llvm-project/pull/78103", "title": "[clang] Implement CWG1878 \"`operator auto` template\"", "body": "C++14 introduced deduced return type for regular functions, but shortly after [CWG1878](https://wg21.link/cwg1878) was filed and resolved to disallow deduced return types in conversion function templates. So this patch diagnoses such usage of deduced return type in C++14 mode onwards.\r\n\r\nFixes #51776", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CXX/drs/dr18xx.cpp", "functions": ["auto", "decltype"]}, {"filename": "clang/test/SemaCXX/deduced-return-type-cxx14.cpp", "functions": ["auto", "decltype"]}, {"filename": "clang/lib/Sema/SemaDeclCXX.cpp", "functions": ["getReturnTypeLoc"]}]}
{"pr_number": 78306, "url": "https://github.com/llvm/llvm-project/pull/78306", "title": "[mlir][IR] Add `notifyBlockRemoved` callback to listener", "body": "There is already a \"block inserted\" notification (in `OpBuilder::Listener`), so there should also be a \"block removed\" notification.\r\n\r\nThe purpose of this change is to make the listener API more mature. There is currently a gap between what kind of IR changes can be made and what IR changes can be listened to. At the moment, the only way to inform listeners about \"block removal\" is to send a manual `notifyOperationModified` for the parent op (e.g., by wrapping the `eraseBlock(b)` method call in `updateRootInPlace(b->getParentOp())`). This tells the listener that *something* has changed, but it is somewhat of an API abuse.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp", "functions": ["notifyBlockRemoved"]}]}
{"pr_number": 75127, "url": "https://github.com/llvm/llvm-project/pull/75127", "title": "[mlir][bufferization] Buffer deallocation: Make op preconditions stricter", "body": "The buffer deallocation pass checks the IR (\"operation preconditions\") to make sure that there is no IR that is unsupported. In such a case, the pass signals a failure.\r\n\r\nThe pass now rejects all ops with unknown memory effects. We do not know whether such an op allocates memory or not. Therefore, the buffer deallocation pass does not know whether a deallocation op should be inserted or not.\r\n\r\nMemory effects are queried from the `MemoryEffectOpInterface` interface. Ops that do not implement this interface but have the `RecursiveMemoryEffects` trait do not have any side effects (apart from the ones that their nested ops may have).\r\n\r\nUnregistered ops are now rejected by the pass because they do not implement the `MemoryEffectOpInterface` and neither do we know if they have `RecursiveMemoryEffects` or not. All test cases that currently have unregistered ops are updated to use registered ops.\r\n\r\n", "feature_layers": ["ir"], "feature_directives": ["for", "allocate"], "files_changed": [{"filename": "mlir/lib/Dialect/Bufferization/Transforms/OwnershipBasedBufferDeallocation.cpp", "functions": ["regionOperatesOnMemrefValues", "success", "hasBufferSemantics", "hasNeitherAllocateNorFreeSideEffect"]}]}
{"pr_number": 71650, "url": "https://github.com/llvm/llvm-project/pull/71650", "title": "[clang-tidy] Fix handling of functional cast in google-readability-casting", "body": "Fix issue with constructor call being interpreted as functional cast and considered for a replacement\r\nwith static cast or being removed as redundant.\r\n\r\nCloses #57959", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang-tools-extra/test/clang-tidy/checkers/google/readability-casting.cpp", "functions": ["S2"]}]}
{"pr_number": 74145, "url": "https://github.com/llvm/llvm-project/pull/74145", "title": "[llvm][NFC] Refactor AutoUpgrader arm/aarch64", "body": "Arm and AArch64 auto upgrade detection is somewhat intertwined. While there is some comonality in their neon subsets, they're otherwise pretty independent. Rather than continually check for 'arm.' or 'aarch64' prefixes, this refactors the detection to first consume one of those prefixes, and then do the common checks (including 'neon.' detection), and finally do the distinct checks.\r\n\r\nprobably the most complex of my autoupdater changes", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/IR/AutoUpgrade.cpp", "functions": ["vstRegex", "LdRegex"]}]}
{"pr_number": 76267, "url": "https://github.com/llvm/llvm-project/pull/76267", "title": "[AMDGPU] Add an asm directive to track code_object_version", "body": "Named '.amdgcn_code_object_version'. This directive sets the e_ident[ABIVERSION] in the ELF header, and should be used as the assumed COV for the rest of the asm file.\r\n\r\nThis commit also weakens the --amdhsa-code-object-version CL flag. Previously, the CL flag took precedence over the IR flag. Now the IR flag/asm directive take precedence over the CL flag. This is implemented by merging a few COV-checking functions in AMDGPUBaseInfo.h.\r\n\r\n--amdhsa-code-object-version should be removed in the future, but for the moment it is still necessary to control whether AMDGPUDisassembler should print \".amdhsa_uses_dynamic_stack\" or not. I'm planning on updating that to check against the ELF header in a follow-up, after that we should be able to remove the flag (and `getDefaultCodeObjectVersion()`).\r\n\r\nThanks for taking a look!\r\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/MC/ELFObjectWriter.cpp", "functions": ["setOverrideABIVersion", "seenOverrideABIVersion", "getOverrideABIVersion"]}, {"filename": "llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp", "functions": ["TokError", "ParseDirectiveMajorMinor", "ParseDirectiveHSACodeObjectISA", "ParseDirectiveHSACodeObjectVersion", "ParseDirectiveAMDHSACodeObjectVersion"]}, {"filename": "llvm/lib/Target/AMDGPU/MCTargetDesc/AMDGPUAsmBackend.cpp", "functions": ["createAMDGPUELFObjectWriter", "AMDGPUAsmBackend", "ELFAMDGPUAsmBackend"]}, {"filename": "llvm/lib/Target/AMDGPU/MCTargetDesc/AMDGPUTargetStreamer.cpp", "functions": ["Twine", "getEFlagsV3", "EmitHSAMetadata", "getEFlagsV4"]}, {"filename": "llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.cpp", "functions": ["getCodeObjectVersion", "getHsaAbiVersion", "getAMDHSACodeObjectVersion", "if", "getAmdhsaCodeObjectVersion", "isHsaAbiVersion5", "isHsaAbiVersion4", "getDefaultAMDHSACodeObjectVersion", "getELFABIVersion"]}]}
{"pr_number": 77932, "url": "https://github.com/llvm/llvm-project/pull/77932", "title": "[DWARFLinker][NFC] Decrease DWARFLinker dependence on DwarfStreamer.", "body": "This patch is extracted from #74725.\r\n\r\nThe DwarfStreamer interface looks overcomplicated and has unnecessary dependencies:\r\n\r\n1. it contains emitSwiftAST, emitSwiftReflectionSection methods which are not used by DWARFLinker.\r\n\r\n2. its interface uses DWARFLinker classes(CompileUnit) which makes it dependend on DWARFLinker.\r\n\r\n3. it has \"AsmPrinter &getAsmPrinter()\" method which provides very low level interface.\r\n\r\nThis patch avoids creation of DwarfStreamer by DWARFLinker and simplifies interface:\r\n\r\n1. dwarf_linker::classic.\r\n\r\n   Now client of DWARFLinker creates DwarfStreamer and pass it to the DWARFLinker through DwarfEmitter interface. It simplifies dependence. Later it would be good to remove class DwarfStreamer from dwarf_linker::classic completely.\r\n\r\n2. dwarf_linker::parallel.\r\n\r\n   Now client of DWARFLinker sets handler of output debug sections to the DWARFLinker. It simplifies dependence to following small interface:\r\n\r\n```\r\n   using SectionHandlerTy = std::function<void(std::shared_ptr<SectionDescriptorBase> Section)>;\r\n\r\n   virtual void setOutputDWARFHandler(const Triple &TargetTriple, SectionHandlerTy SectionHandler) = 0;\r\n```", "feature_layers": ["ir", "ast"], "feature_directives": ["parallel", "sections", "target"], "files_changed": [{"filename": "llvm/lib/DWARFLinker/Parallel/DWARFLinkerTypeUnit.cpp", "functions": ["emitDebugLine"]}, {"filename": "llvm/tools/dsymutil/DwarfLinkerForBinary.cpp", "functions": ["constexpr"]}]}
{"pr_number": 78689, "url": "https://github.com/llvm/llvm-project/pull/78689", "title": "[X86][APX]Support lowering for APX promoted AMX-TILE instructions", "body": "The enc/dec of promoted AMX-TILE instructions have been supported in https://github.com/llvm/llvm-project/pull/76210.\r\nThis patch support lowering for promoted AMX-TILE instructions and integrate test to existing tests.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/X86/X86ExpandPseudo.cpp", "functions": ["GET_EGPR_IF_ENABLED"]}, {"filename": "llvm/lib/Target/X86/X86InstrInfo.cpp", "functions": ["GET_EGPR_IF_ENABLED"]}]}
{"pr_number": 76555, "url": "https://github.com/llvm/llvm-project/pull/76555", "title": "[LoongArch] Emit function call code sequence as `PCADDU18I+JIRL` in medium code model", "body": "Adjustments made in accordance with psABI v2.30:\r\nhttps://github.com/loongson/la-abi-specs/releases/tag/v2.30\r\n\r\n1. Moved the expansion of relevant pseudo-instructions from `LoongArchPreRAExpandPseudo` pass to `LoongArchExpandPseudo` pass, to ensure that the code sequences of `PseudoLA*_LARGE` instructions and Medium code model's function call are not scheduled.\r\n\r\n2. AsmParser now supports parsing for call36 and tail36 macro instructions.", "feature_layers": ["parse", "ir", "parser"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/LoongArch/AsmParser/LoongArchAsmParser.cpp", "functions": ["isSImm20pcaddu18i"]}, {"filename": "llvm/lib/Target/LoongArch/LoongArchExpandPseudoInsts.cpp", "functions": ["expandLoadAddressGot", "expandLoadAddressTLSGD", "expandFunctionCALL", "expandLoadAddressGotLarge", "expandLoadAddressTLSIELarge", "expandLoadAddressPcrelLarge", "expandLoadAddressTLSLD", "expandLoadAddressTLSIE", "expandLoadAddressTLSLDLarge", "expandLoadAddressPcrel", "expandLoadAddressTLSGDLarge"]}]}
{"pr_number": 68760, "url": "https://github.com/llvm/llvm-project/pull/68760", "title": "[SanitizerCommon] add null check for fopen64 interceptor", "body": "Currently, the interceptor for fopen64 will crash when path is null. Adding the same null check as `fopen()`.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "compiler-rt/test/sanitizer_common/TestCases/fopen64_nullptr.c", "functions": ["fopen64"]}]}
{"pr_number": 78713, "url": "https://github.com/llvm/llvm-project/pull/78713", "title": "[MLIR][NVVM] Explicit Data Type for Output in `wgmma.mma_async`", "body": "The current implementation of `nvvm.wgmma.mma_async` Op deduces the data type of the output matrix from the data type struct member, which can be non-intuitive, especially in cases where types like `2xf16` are packed into `i32`.\r\n\r\nThis PR addresses this issue by improving the Op to include an explicit data type for the output matrix.\r\n\r\nThe modified Op now includes an explicit data type for Matrix-D (<f16>), and looks as follows:\r\n\r\n```\r\n%result = llvm.mlir.undef : !llvm.struct<(struct<(i32, i32, ...\r\nnvvm.wgmma.mma_async\r\n    %descA, %descB, %result,\r\n    #nvvm.shape<m = 64, n = 32, k = 16>,\r\n    D [<f16>, #nvvm.wgmma_scale_out<zero>],\r\n    A [<f16>, #nvvm.wgmma_scale_in<neg>, <col>],\r\n    B [<f16>, #nvvm.wgmma_scale_in<neg>, <col>]\r\n```", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Conversion/NVGPUToNVVM/NVGPUToNVVM.cpp", "functions": ["generateWgmmaType"]}, {"filename": "mlir/lib/Dialect/LLVMIR/IR/NVVMDialect.cpp", "functions": ["emitOpError"]}]}
{"pr_number": 78708, "url": "https://github.com/llvm/llvm-project/pull/78708", "title": "[OpenMP][OMPIRBuilder] Fix LLVM IR codegen for collapsed device loop", "body": "When we generate the loop body function, we need to be sure, that all original loop counters are replaced by the new counter.\r\n\r\nWe need to save all items which use the original loop counter and then perform replacement of the original loop counter. If we don't do it, there is a risk that some values are not updated.", "feature_layers": ["codegen", "ir", "ompirbuilder"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp", "functions": ["Users"]}]}
{"pr_number": 78030, "url": "https://github.com/llvm/llvm-project/pull/78030", "title": "Enable direct methods and fast alloc calls for libobjc2.", "body": "These will be supported in the upcoming 2.2 release and so are gated on that version.\r\n\r\nDirect methods call `objc_send_initialize` if they are class methods that may not have called initialize.  This is guarded by checking for the class flag bit that is set on initialisation in the class.  This bit now forms part of the ABI, but it's been stable for 30+ years so that's fine as a contract going forwards.", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/CodeGen/CGObjCGNU.cpp", "functions": ["MDHelper"]}]}
{"pr_number": 78078, "url": "https://github.com/llvm/llvm-project/pull/78078", "title": "[MLIR][Presburger] Implement function to evaluate the number of terms in a generating function.", "body": "We implement `computeNumTerms()`, which counts the number of terms in a generating function by substituting the unit vector in it.\r\nThis is the main function in Barvinok's algorithm \u2013\u00a0the number of points in a polytope is given by the number of terms in the generating function corresponding to it.\r\nWe also modify the GeneratingFunction class to have `const` getters and improve the simplification of QuasiPolynomials.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Analysis/Presburger/Barvinok.cpp", "functions": ["sum"]}, {"filename": "mlir/unittests/Analysis/Presburger/BarvinokTest.cpp", "functions": ["if"]}, {"filename": "mlir/lib/Analysis/Presburger/QuasiPolynomial.cpp", "functions": ["newAffine", "QuasiPolynomial", "newCoeffs"]}, {"filename": "mlir/lib/Analysis/Presburger/Utils.cpp", "functions": ["sum"]}, {"filename": "mlir/unittests/Analysis/Presburger/UtilsTest.cpp", "functions": ["x", "a", "y", "aVals", "b", "bVals"]}]}
{"pr_number": 76112, "url": "https://github.com/llvm/llvm-project/pull/76112", "title": "[lldb] refactor highlighting function for image lookup command", "body": "Follow-up to #69422.\r\n\r\nThis PR puts all the highlighting settings into a single struct for easier handling\r\n\r\nCo-authored-by: Talha Tahir <talha.tahir@10xengineers.ai>", "feature_layers": ["ir"], "feature_directives": ["for", "single"], "files_changed": [{"filename": "lldb/source/Utility/Stream.cpp", "functions": ["reg_pattern"]}]}
{"pr_number": 78197, "url": "https://github.com/llvm/llvm-project/pull/78197", "title": "[mlir][ArmSME] Add arith-to-arm-sme conversion pass", "body": "Existing 'arith::ConstantOp' conversion and tests are moved from VectorToArmSME. There's currently only a single op that's converted at the moment, but this will grow in the future as things like in-tile add are implemented. Also, 'createLoopOverTileSlices' is moved to ArmSME utils since it's relevant for both conversions.", "feature_layers": ["ir"], "feature_directives": ["for", "single"], "files_changed": [{"filename": "mlir/lib/Conversion/ArithToArmSME/ArithToArmSME.cpp", "functions": ["runOnOperation", "success", "isSplatZero", "signalPassFailure", "patterns", "failure"]}, {"filename": "mlir/lib/Conversion/VectorToArmSME/VectorToArmSME.cpp", "functions": ["isSplatZero", "failure", "success", "g"]}, {"filename": "mlir/lib/Dialect/ArmSME/IR/Utils.cpp", "functions": ["g"]}]}
{"pr_number": 78583, "url": "https://github.com/llvm/llvm-project/pull/78583", "title": "[mlir] Add `mlir_arm_runner_utils` library for use in integration tests", "body": "This adds a new `mlir_arm_runner_utils` library that contains utils specific to Arm/AArch64. This is for use in MLIR integration tests.\r\n\r\nThis initial patch adds `setArmVLBits()` and `setArmSVLBits()`. This allows changing vector length or streaming vector length at runtime (or setting it to a known minimum, i.e. 128-bits).", "feature_layers": ["runtime", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/ExecutionEngine/ArmRunnerUtils.cpp", "functions": ["setArmSVLBits", "setArmVLBits"]}]}
{"pr_number": 78945, "url": "https://github.com/llvm/llvm-project/pull/78945", "title": "[RISCV] Teach RISCVMergeBaseOffset to handle inline asm", "body": "For inline asm with memory operands, we can merge the offset into\nthe second operand of memory constraint operands.\n\nDifferential Revision: https://reviews.llvm.org/D158062\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp", "functions": ["if"]}, {"filename": "llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp", "functions": ["Flags"]}]}
{"pr_number": 76241, "url": "https://github.com/llvm/llvm-project/pull/76241", "title": "[GlobalISel][AArch64] Combine Vector Reduction Add Long", "body": "The first commit `[AArch64][GlobalISel] Pre-Commit for Combine ADDLV(ADDLP)` is going through review as well (Pull Request https://github.com/llvm/llvm-project/pull/75832).\r\n\r\nADDLV(ADDLP) => ADDLV\r\nRemoves unnecessary ADDLP instruction\r\n\r\nADDV(ADDLP) => ADDLV\r\nAlready exists for SDAG, adding for GlobalISel", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AArch64/GISel/AArch64LegalizerInfo.cpp", "functions": ["MIB"]}]}
{"pr_number": 78753, "url": "https://github.com/llvm/llvm-project/pull/78753", "title": "[JITLink][AArch32] Add GOT builder and implement R_ARM_GOT_PREL relocations for ELF", "body": "LLJIT needs this relocation for running deinitializers even if we stick to `-fno-pic` code otherwise. I summarized the logic of `R_ARM_GOT_PREL` in this gist based on a test in LLD: https://gist.github.com/weliveindetail/6dd33d43ea743d6e8a7399d1950c77b7", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/ExecutionEngine/JITLink/aarch32.cpp", "functions": ["uint8_t", "formatv"]}]}
{"pr_number": 78460, "url": "https://github.com/llvm/llvm-project/pull/78460", "title": "[RemoveDIs][DebugInfo] Add interface changes for AT analysis", "body": "This patch adds the preliminary changes for handling DPValues in AssignmentTrackingAnalysis - very few functional changes are included, but internal data structures have been changed to operate with DPValues as well as Instructions, allowing future patches to process DPValues correctly.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp", "functions": ["hasZeroSizedFragment", "resetInsertionPoint", "operator", "getNextNode", "setWedge"]}, {"filename": "llvm/lib/IR/DebugInfo.cpp", "functions": ["VariableSlice", "DebugVariableAggregate"]}, {"filename": "llvm/lib/Transforms/Utils/Local.cpp", "functions": ["getDebugValueLoc"]}]}
{"pr_number": 73558, "url": "https://github.com/llvm/llvm-project/pull/73558", "title": "[mlir][transform] Do not maintain mappings for dead handles", "body": "Do not maintain transform IR <-> payload IR mappings for dead handles, i.e., handles that do not have any further uses.\r\n\r\nThis change reduces the memory overhead of the transform dialect interpreter.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Transform/IR/TransformInterfaces.cpp", "functions": ["success", "happensBefore"]}]}
{"pr_number": 75364, "url": "https://github.com/llvm/llvm-project/pull/75364", "title": "[Sema] Add `-fvisibility-global-new-delete=` option", "body": "By default the implicitly declared replaceable global new and delete\r\noperators are given a default visibility attribute. Previous work, see:\r\nhttps://reviews.llvm.org/D53787, added\r\n`-fvisibility-global-new-delete-hidden` to change this to a hidden\r\nvisibility attribute.\r\n\r\nThis change adds `-fvisibility-global-new-delete=` which controls\r\nwhether (or not) to add an implicit visibility attribute to the implicit\r\ndeclarations for these functions, and what visibility that attribute\r\nwill specify. The option takes 4 values: `force-hidden`,\r\n`force-protected`, `force-default` and `source`. Option values\r\n`force-hidden`, `force-protected` and `force-default` assign hidden,\r\nprotected, and default visibilities respectively; the use of the term\r\nforce in the value names is designed to imply to a user that the semantics\r\nof this option differ significantly from `-fvisibility=`. An option\r\nvalue of `source` implies that no implicit attribute is added; without\r\nthe attribute the replaceable global new and delete operators behave\r\nnormally (like other functions) with respect to visibility attributes,\r\npragmas and options.\r\n\r\nThe motivation for the `source` value is to facilitate users who intend\r\nto replace these functions either for a single linkage unit or a limited\r\nset of linkage units. `-fvisibility-global-new-delete=source` can be \r\napplied globally to the compilations in a build where the existing\r\n`-fvisibility-global-new-delete-hidden` cannot, as it conflicts with a\r\ncommon pattern where these functions are dynamically imported.\r\n\r\nThe existing `-fvisibility-global-new-delete-hidden` is now a deprecated\r\nspelling of `-fvisibility-global-new-delete=force-hidden`\r\n\r\nThe command line help for these options is rendered as:\r\n\r\n```\r\n  -fvisibility-global-new-delete-hidden\r\n                          Give global C++ operator new and delete declarations hidden visibility\r\n\r\n  -fvisibility-global-new-delete=<value>\r\n                          The visibility for global C++ operator new and delete declarations. If\r\n                          'source' is specified the visibility is not adjusted\r\n```\r\n\r\nA release note has been added for these changes.\r\n\r\n`-fvisibility-global-new-delete=source` will be set by default for PS5.\r\nPS5 users that want the normal toolchain behaviour will be able to\r\nsupply `-fvisibility-global-new-delete=force-default`.\r\n", "feature_layers": ["sema"], "feature_directives": ["for", "single", "declare"], "files_changed": [{"filename": "clang/test/CodeGenCXX/visibility-global-new-delete.cpp", "functions": ["delete", "__typeof__"]}]}
{"pr_number": 78473, "url": "https://github.com/llvm/llvm-project/pull/78473", "title": "[UnrollAnalyzerTest] Remove dependency to pass managers", "body": "Remove use of LegacyPassManager in the UnrollAnalyzerTest unit test.\r\n\r\nGiven that the goal isn't to test pass manager interfaces, and since the LoopUnrollAnalyzer isn't even implemented as a pass, we do not really need the complexity of using a pass manager. Instead we just make sure that we run LoopUnrollAnalyzer and other needed analyses standalone (without any pass manager). This was inspired by the LoopInfoTest unit test.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "llvm/unittests/Analysis/UnrollAnalyzerTest.cpp", "functions": ["runUnrollAnalyzer"]}]}
{"pr_number": 69673, "url": "https://github.com/llvm/llvm-project/pull/69673", "title": "[libc++] Ensure that `std::expected` has no tail padding", "body": "Currently `std::expected` can have some padding bytes in its tail due to `[[no_unique_address]]`. Those padding bytes can be used by other objects. For example, in the current implementation:\r\n\r\n```c++\r\nsizeof(std::expected<std::optional<int>, bool>) == sizeof(std::expected<std::expected<std::optional<int>, bool>, bool>);\r\n```\r\n\r\n...so the data layout of an `std::expected<std::expected<std::optional<int>, bool>, bool>` can look like this:\r\n\r\n```\r\n            +-- optional \"has value\" flag\r\n            |        +--padding\r\n/---int---\\ |        |\r\n00 00 00 00 01 00 00 00\r\n               |  |\r\n               |  +- \"outer\" expected \"has value\" flag\r\n               |\r\n               +- expected \"has value\" flag\r\n\r\n```\r\n\r\nThis is problematic because `emplace()`ing the \"inner\" expected can not only overwrite the \"inner\" expected \"has value\" flag (issue <https://github.com/llvm/llvm-project/issues/68552>) but _also_ the tail padding where other objects might live.\r\n\r\n@philnik777 proposed to add a `char __padding_[]` array to the end of the `expected` to make sure that the `expected` itself never has any tail padding bytes that might get used by other objects.\r\n\r\nThis is an ABI breaking change because\r\n`sizeof(std::expected<std::optional<int>, bool>) < sizeof(std::expected<std::expected<std::optional<int>, bool>, bool>);` afterwards. The data layout will change in the following cases where tail padding can be reused by other objects:\r\n\r\n```c++\r\nclass foo : std::expected<std::optional<int>, bool> {\r\n  bool b;\r\n};\r\n```\r\n\r\nor using `[[no_unique_address]]`:\r\n\r\n```c++\r\nstruct foo {\r\n  [[no_unique_address]] std::expected<std::optional<int>, bool> e;\r\n  bool b;\r\n};\r\n```\r\n\r\nFixes: #70494", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "libcxx/test/libcxx/utilities/expected/expected.expected/no_unique_address.compile.pass.cpp", "functions": ["bool"]}, {"filename": "libcxx/test/libcxx/utilities/expected/expected.void/no_unique_address.compile.pass.cpp", "functions": ["bool"]}, {"filename": "libcxx/test/std/utilities/expected/expected.expected/assign/assign.U.pass.cpp", "functions": ["e1"]}, {"filename": "libcxx/test/std/utilities/expected/expected.expected/assign/assign.copy.pass.cpp", "functions": ["e1"]}, {"filename": "libcxx/test/std/utilities/expected/expected.expected/assign/assign.move.pass.cpp", "functions": ["e1"]}, {"filename": "libcxx/test/std/utilities/expected/expected.expected/swap/member.swap.pass.cpp", "functions": ["x"]}, {"filename": "libcxx/test/std/utilities/expected/expected.void/assign/assign.unexpected.copy.pass.cpp", "functions": ["un"]}, {"filename": "libcxx/test/std/utilities/expected/expected.void/assign/assign.unexpected.move.pass.cpp", "functions": ["un"]}]}
{"pr_number": 78359, "url": "https://github.com/llvm/llvm-project/pull/78359", "title": "[LinkerWrapper] Handle AMDGPU Target-IDs correctly when linking", "body": "Summary:\nThe linker wrapper's job is to sort various embedded inputs into a list\nof files that participate in a single link job. So far, this has been\ncompletely 1-to-1, that is, each input file participates in exactly one\nlink job. However, support for AMD's target-id requires that one input\nfile may participate in multiple link jobs. For example, if given a\n`gfx90a` static library and a `gfx90a:xnack+` object file input, we\nshould link the gfx90a` target into the `gfx90a:xnack+` job. These are\nconsidered separate CPUs that can be mutually linked more or less.\n\nThis patch adds the necessary logic to make this happen. It primarily\nreworks the logic to copy relevant input files into a separate list. So,\nit moves construction of the final list of link jobs into the extraction\nphase. We also need to copy the files in the case that it is needed more\nthan once, as the entire workflow expects ownership of said file.\n", "feature_layers": ["ir"], "feature_directives": ["for", "single", "target", "requires"], "files_changed": [{"filename": "clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp", "functions": ["getDeviceInput"]}, {"filename": "llvm/lib/Object/OffloadBinary.cpp", "functions": ["T"]}]}
{"pr_number": 78736, "url": "https://github.com/llvm/llvm-project/pull/78736", "title": "[DebugInfo][RemoveDIs] Adjust AMDGPU passes to work with DPValues", "body": "This patch tweaks two AMDGPU passes to use iterators rather than instruction pointers for expressing an insertion point. This is needed to accurately support DPValues, the non-instruction storage object for debug-info.\r\n\r\nTwo tests were sensitive to this change (variable assignments were being put in the wrong place), and I've added extra run-lines with the \"try new debug-info...\" flag. These get tested on our public buildbot to ensure they continue to work accurately.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/AMDGPULowerKernelArguments.cpp", "functions": ["Builder"]}]}
{"pr_number": 78369, "url": "https://github.com/llvm/llvm-project/pull/78369", "title": "[llvm-jitlink] Allow optional stub-kind filter in stub_addr() expressions", "body": "We use `jitlink-check` lines in LIT tests as the primary tool for testing JITLink backends. Parsing and evaluation of the expressions is implemented in `RuntimeDyldChecker`. The `stub_addr(obj, name)` expression allows to obtain the linker-generated stub for the external symbol `name` in object file `obj`. This is limiting JITLink backends to a single stub for an external symbol.\r\n\r\nThis patch adds support for an index parameter: `stub_addr(obj, name, index=0)`. It allows us to inspect more than a single stub in our tests and, respectively, it enables JITLink backends to emit multiple stubs. This is necessary for the AArch32 backend, which must be able to emit two different kinds of stubs depending on the instruction set state (Arm/Thumb) of the relocation site. Since the new parameter is optional, we don't have to update existing tests.", "feature_layers": ["runtime"], "feature_directives": ["for", "single"], "files_changed": [{"filename": "llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp", "functions": ["GetGOTInfo"]}, {"filename": "llvm/tools/llvm-jitlink/llvm-jitlink.cpp", "functions": ["KindNameMatcher", "detectStubKind"]}, {"filename": "llvm/tools/llvm-rtdyld/llvm-rtdyld.cpp", "functions": ["GetStubInfo"]}]}
{"pr_number": 77761, "url": "https://github.com/llvm/llvm-project/pull/77761", "title": "[Flang][OpenMP] Restructure recursive lowering in `createBodyOfOp`", "body": "This brings `createBodyOfOp` to its final intended form. First, input privatization is performed, then the recursive lowering takes place, and finally the output privatization (lastprivate) is done.\r\n\r\nThis enables fixing a known issue with infinite loops inside of an OpenMP region, and the fix is included in this patch.\r\n\r\nFixes https://github.com/llvm/llvm-project/issues/74348.\r\n\r\nRecursive lowering [5/5]", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Lower/OpenMP.cpp", "functions": ["proc"]}]}
{"pr_number": 78584, "url": "https://github.com/llvm/llvm-project/pull/78584", "title": "[clang][ExtractAPI] Ensure typedef to pointer types are preserved", "body": "When generating declaration fragments for types that use typedefs to pointer types ensure that we keep the user-defined typedef form instead of desugaring the typedef.\r\n\r\nrdar://102137655", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/ExtractAPI/DeclarationFragments.cpp", "functions": ["TypedefResolver"]}, {"filename": "clang/test/ExtractAPI/typedef.c", "functions": ["baz", "foo"]}]}
{"pr_number": 78676, "url": "https://github.com/llvm/llvm-project/pull/78676", "title": "[HEXAGON] Inlining Division", "body": "This patch inlines float division function calls for hexagon.\r\n\r\nTests added to check the following\r\n\r\nWhether the implemented function gets inlined when -fast-math option is used Check that the splat of a constant, when it's used in a fp vector operation that needs to be expanded Check inlining\r\nCheck no-inlining on optsize", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp", "functions": ["ResultType", "SelectFDiv", "OpValue1"]}, {"filename": "llvm/lib/Target/Hexagon/HexagonISelLowering.cpp", "functions": ["LowerFDIV", "SDValue"]}]}
{"pr_number": 77512, "url": "https://github.com/llvm/llvm-project/pull/77512", "title": "[OpenMP] Enable automatic unified shared memory on MI300A.", "body": "This patch enables applications that did not request OpenMP unified_shared_memory to run with the same zero-copy behavior, where mapped memory does not result in extra memory allocations and memory copies, but CPU-allocated memory is accessed from the device. The name for this behavior is \"automatic zero-copy\" and it relies on detecting: that the runtime is running on a MI300A, that the user did not select unified_shared_memory in their program, and that XNACK (unified memory support) is enabled in the current GPU configuration. If all these conditions are met, then automatic zero-copy is triggered.\r\n\r\nThis patch also introduces an environment variable OMPX_APU_MAPS that, if set, triggers automatic zero-copy also on non APU GPUs (e.g., on discrete GPUs).\r\nThis patch is still missing support for global variables, which will be provided in a subsequent patch.", "feature_layers": ["runtime", "ir"], "feature_directives": ["for", "allocate"], "files_changed": [{"filename": "openmp/libomptarget/plugins-nextgen/amdgpu/src/rtl.cpp", "functions": ["getTargetTripleAndFeatures", "ISAName", "TripleTarget", "useAutoZeroCopyImpl", "StrGfxName", "checkIfAPU"]}, {"filename": "openmp/libomptarget/plugins-nextgen/common/src/PluginInterface.cpp", "functions": ["__tgt_rtl_use_auto_zero_copy"]}, {"filename": "openmp/libomptarget/test/mapping/auto_zero_copy.cpp", "functions": ["main"]}]}
{"pr_number": 78800, "url": "https://github.com/llvm/llvm-project/pull/78800", "title": "[mlir][openacc][NFC] Cleanup hasOnly functions for device_type support", "body": "Just a cleanup for all the `has.*Only()` function to avoid code duplication", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/OpenACC/IR/OpenACC.cpp", "functions": ["hasDeviceType", "hasDeviceTypeValues"]}]}
{"pr_number": 75067, "url": "https://github.com/llvm/llvm-project/pull/75067", "title": "[symbolizer] Support symbol+offset lookup", "body": "GNU addr2line supports lookup by symbol name in addition to the existing address lookup. llvm-symbolizer starting from e144ae54dcb96838a6176fd9eef21028935ccd4f supports lookup by symbol name. This change extends this lookup with possibility to specify optional offset.\r\n\r\nNow the address for which source information is searched for can be specified with offset:\r\n\r\n    llvm-symbolize --obj=abc.so \"SYMBOL func_22+0x12\"\r\n\r\nIt decreases the gap in features of llvm-symbolizer and GNU addr2line. This lookup now is supported for code only.\r\n\r\nMigrated from: https://reviews.llvm.org/D139859.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/DebugInfo/Symbolize/Symbolize.cpp", "functions": ["findSymbolCommon"]}, {"filename": "llvm/tools/llvm-symbolizer/llvm-symbolizer.cpp", "functions": ["makeStringError"]}, {"filename": "llvm/unittests/ProfileData/MemProfTest.cpp", "functions": ["findSymbol"]}]}
{"pr_number": 74054, "url": "https://github.com/llvm/llvm-project/pull/74054", "title": "[ARM][FPEnv] Lowering of fpmode intrinsics", "body": "LLVM intrinsics `get_fpmode`, `set_fpmode` and `reset_fpmode` operate control modes, the bits of FP environment that affect FP operations. On ARM these bits are in FPSCR together with the status bits. The implementation of these intrinsics produces code close to that of functions `fegetmode` and `fesetmode` from GLIBC.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/Target/ARM/ARMISelLowering.cpp", "functions": ["LowerSET_FPMODE", "LowerRESET_FPMODE"]}]}
{"pr_number": 77150, "url": "https://github.com/llvm/llvm-project/pull/77150", "title": "[Libomptarget] Move target table handling out of the plugins", "body": "Summary:\r\nThis patch removes the bulk of the handling of the\r\n`__tgt_offload_entries` out of the plugins itself. The reason for this\r\nis because the plugins themselves should not be handling this\r\nimplementation detail of the OpenMP runtime. Instead, we expose two new\r\nplugin API functions to get the points to a device pointer for a global\r\nas well as a kernel type.\r\n\r\nThis required introducing a new type to represent a binary image that\r\nhas been loaded on a device. We can then use this to load the addresses\r\nas needed. The creation of the mapping table is then handled just in\r\n`libomptarget` where we simply look up each address individually. This\r\nshould allow us to expose these operations more generically when we\r\nprovide a separate API.", "feature_layers": ["runtime", "ir"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "openmp/libomptarget/plugins-nextgen/amdgpu/src/rtl.cpp", "functions": ["DeviceImageTy", "constructKernel"]}, {"filename": "openmp/libomptarget/plugins-nextgen/common/src/PluginInterface.cpp", "functions": ["addEntry", "HostGlobal", "DeviceGlobal"]}, {"filename": "openmp/libomptarget/plugins-nextgen/cuda/src/rtl.cpp", "functions": ["DeviceImageTy", "constructKernel"]}, {"filename": "openmp/libomptarget/plugins-nextgen/generic-elf-64bit/src/rtl.cpp", "functions": ["DeviceImageTy", "constructKernel"]}]}
{"pr_number": 78811, "url": "https://github.com/llvm/llvm-project/pull/78811", "title": "[lldb-dap] Add a CMake variable for defining a welcome message", "body": "lldb-dap instances managed by other extensions benefit from having a welcome message with, for example, a basic user guide or a troubleshooting message.\nThis PR adds a cmake variable for defining such message in a simple way. This message appears upon initialization but before initCommands are executed, as they might cause a failure and prevent the message from being displayed.\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "lldb/tools/lldb-dap/lldb-dap.cpp", "functions": ["PrintWelcomeMessage"]}]}
{"pr_number": 78574, "url": "https://github.com/llvm/llvm-project/pull/78574", "title": "[RemoveDIs][DebugInfo] Remove redundant DPVAssigns", "body": "DPValues are already supported by most of the utilities that remove redundant debug info after certain passes; the exception to this is `removeUndefDbgAssignsFromEntryBlock`, which applies only to llvm.dbg.assigns which were previously unimplemented for DPValues. Now that DPVAssigns exist, we have to support removing redundant instances in the same way, which this patch implements.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Utils/BasicBlockUtils.cpp", "functions": ["remomveUndefDbgAssignsFromEntryBlock", "removeUndefDbgAssignsFromEntryBlock", "DPValuesRemoveUndefDbgAssignsFromEntryBlock", "DebugVariable"]}]}
{"pr_number": 67355, "url": "https://github.com/llvm/llvm-project/pull/67355", "title": "[mlir][openacc] Update acc.loop to be a proper loop like operation", "body": "The initial design of the `acc.loop` was to be an operation that encapsulates a loop like operation. This was an early design and we now want to change it so the `acc.loop` operation becomes a real loop-like operation by implementing the LoopLikeInterface.\r\n\r\nDifferential Revision: https://reviews.llvm.org/D159229\r\n\r\nThis patch is just moved from Phabricator to github", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/OpenACC/IR/OpenACC.cpp", "functions": ["failure", "success", "emitError"]}]}
{"pr_number": 78610, "url": "https://github.com/llvm/llvm-project/pull/78610", "title": "[CGProfile] Use callee's PGO name when caller->callee is an indirect call.", "body": "- With PGO, indirect call edges are constructed using value profiles, and the profile address is mapped to a function's PGO name. The PGO name is computed using a functions linkage before LTO internalization or global promotion.\r\n- With ThinLTO, local functions [could be promoted](https://github.com/llvm/llvm-project/blob/2663d2cb9c9361f0b234c40a0f50c7ba0748eb26/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp#L288) to have external linkage; and with [full](https://github.com/llvm/llvm-project/blob/2663d2cb9c9361f0b234c40a0f50c7ba0748eb26/llvm/lib/LTO/LTO.cpp#L1328) or [thin](https://github.com/llvm/llvm-project/blob/2663d2cb9c9361f0b234c40a0f50c7ba0748eb26/llvm/lib/LTO/LTO.cpp#L448) LTO, global functions could be internalized. Edge construction should use a function's PGO name before its linkage is updated.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Passes/PassBuilder.cpp", "functions": ["parseSinglePassOption", "parseCGProfilePassOptions"]}]}
{"pr_number": 74337, "url": "https://github.com/llvm/llvm-project/pull/74337", "title": "[libc++] Fix noexcept behaviour of operator new helper functions ", "body": "This patch removes the noexcept specifier introduced in #69407 since the \r\nStandard allows a new handler to throw an exception of type bad_alloc \r\n(or derived from it). With the noexcept specifier on the helper functions, \r\nwe would immediately terminate the program.\r\n\r\nThe patch also adds tests for the case that had regressed.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "libcxx/src/new.cpp", "functions": ["operator_new_impl", "operator_new_aligned_impl"]}, {"filename": "libcxxabi/src/stdlib_new_delete.cpp", "functions": ["operator_new_impl", "operator_new_aligned_impl"]}, {"filename": "libcxxabi/test/test_memory_alloc.pass.cpp", "functions": ["my_new_handler", "main"]}, {"filename": "libcxxabi/test/test_memory_alloc1.pass.cpp", "functions": ["my_bad_alloc"]}, {"filename": "libcxxabi/test/test_memory_alloc2.pass.cpp", "functions": ["my_bad_alloc"]}, {"filename": "libcxxabi/test/test_memory_alloc3.pass.cpp", "functions": ["my_bad_alloc"]}, {"filename": "libcxxabi/test/test_memory_alloc4.pass.cpp", "functions": ["my_bad_alloc"]}, {"filename": "libcxxabi/test/test_memory_alloc_nothrow1.pass.cpp", "functions": ["my_bad_alloc"]}, {"filename": "libcxxabi/test/test_memory_alloc_nothrow2.pass.cpp", "functions": ["my_bad_alloc"]}, {"filename": "libcxxabi/test/test_memory_alloc_nothrow3.pass.cpp", "functions": ["my_bad_alloc"]}, {"filename": "libcxxabi/test/test_memory_alloc_nothrow4.pass.cpp", "functions": ["my_bad_alloc"]}]}
{"pr_number": 78773, "url": "https://github.com/llvm/llvm-project/pull/78773", "title": "[lldb][NFCI] Remove EventData* param from BroadcastEvent", "body": "BroadcastEvent currently takes its EventData* param and shoves it into an Event object, which takes ownership of the pointer and places it into a shared_ptr to manage the lifetime.\r\n\r\nInstead of relying on `new` and passing raw pointers around, I think it would make more sense to create the shared_ptr up front.", "feature_layers": ["ast"], "feature_directives": [], "files_changed": [{"filename": "lldb/source/Plugins/Process/gdb-remote/ProcessGDBRemote.cpp", "functions": ["EventDataBytes"]}, {"filename": "lldb/source/Target/Process.cpp", "functions": ["EventDataStructuredData"]}, {"filename": "lldb/source/Target/Target.cpp", "functions": ["TargetEventData"]}, {"filename": "lldb/source/Target/Thread.cpp", "functions": ["ThreadEventData"]}]}
{"pr_number": 75647, "url": "https://github.com/llvm/llvm-project/pull/75647", "title": "[AMDGPU] Adding the amdgpu-num-work-groups function attribute", "body": "A new function attribute named amdgpu-num-work-groups is added. This attribute allows programmers to let the compiler know the number of workgroups to be launched and do optimizations based on that information.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.cpp", "functions": ["getUnsignedIntegerAttribute"]}]}
{"pr_number": 78706, "url": "https://github.com/llvm/llvm-project/pull/78706", "title": "[RemoveDIs][DebugInfo] Add support for DPValues to LoopStrengthReduce", "body": "This patch trivially extends support for DbgValueInst recovery to DPValues in LoopStrengthReduce; they are handled identically, so this is mostly done by reusing the DbgValueInst code (using templates or auto-parameter lambdas to reduce actual code duplication).", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp", "functions": ["DbgRef", "DVI"]}]}
{"pr_number": 78605, "url": "https://github.com/llvm/llvm-project/pull/78605", "title": "Added settings for DEBUGINFOD cache location and timeout", "body": "I've been working on more/better configuration for improving DEBUGINFOD support. This is the first (and easiest) slice of the work.\r\n\r\nI've added `timeout` and `cache-path` settings that can override the DEBUGINFOD library defaults (and environment variables.) I also renamed the `plugin.symbol-locator.debuginfod.server_urls` setting to `server-urls` to be more consistent with the rest of LLDB's settings (the underscore switch is switched to a hyphen)\r\n\r\nI've got a few tests that validate the cache-path setting (as a side-effect), but they've exposed a few bugs that I'll be putting up a separate PR for (which will include the tests).", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "lldb/source/Plugins/SymbolLocator/Debuginfod/SymbolLocatorDebuginfod.cpp", "functions": ["GetCachePath"]}, {"filename": "llvm/lib/Debuginfod/Debuginfod.cpp", "functions": ["getDebuginfodCacheKey", "getCachedOrDownloadDebuginfo", "getCachedOrDownloadArtifact", "getCachedOrDownloadExecutable", "getDebuginfodDebuginfoUrlPath", "uniqueKey", "getDebuginfodExecutableUrlPath"]}]}
{"pr_number": 76449, "url": "https://github.com/llvm/llvm-project/pull/76449", "title": "[libc++][format] P2637R3: Member `visit` (`std::basic_format_arg`)", "body": "Implements parts of: `P2637R3` https://wg21.link/P2637R3 (https://eel.is/c++draft/variant.visit)\r\n\r\nImplements:\r\n`basic_format_arg.visit()`\r\n`basic_format_arg.visit<R>()`\r\nDeprecates:\r\n`std::visit_format_arg()`\r\n\r\nThe tests are as close as possible to the non-member function tests.\r\n\r\nTo land after: https://github.com/llvm/llvm-project/pull/76447, https://github.com/llvm/llvm-project/pull/76268", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "libcxx/test/std/utilities/format/format.arguments/format.args/visit.pass.cpp", "functions": ["test", "main"]}, {"filename": "libcxx/test/std/utilities/format/format.arguments/format.arg/visit_format_arg.deprecated.verify.cpp", "functions": ["test"]}, {"filename": "libcxx/test/std/utilities/format/format.arguments/format.arg/visit_format_arg.pass.cpp", "functions": ["test_handle", "constexpr", "main", "test_string_view", "test"]}, {"filename": "libcxx/test/std/utilities/format/format.arguments/format.arg/visit.pass.cpp", "functions": ["constexpr"]}, {"filename": "libcxx/test/std/utilities/format/format.arguments/format.arg/visit.return_type.pass.cpp", "functions": ["test_handle", "make_expected_result", "constexpr", "test_string_view", "test", "decltype"]}, {"filename": "libcxx/test/std/utilities/format/format.arguments/format.args/get.pass.cpp", "functions": ["constexpr"]}]}
{"pr_number": 73775, "url": "https://github.com/llvm/llvm-project/pull/73775", "title": "[libc++] Diagnoses insufficiently aligned pointers for std::assume_aligned during constant evaluation", "body": "This is a `libc++` enhancement when violating alignment assumption for `__builtin_assume_aligned`.\r\n\r\nFixes #64078", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "libcxx/test/libcxx/utilities/memory/ptr.align/assume_aligned.const_eval.verify.cpp", "functions": ["test"]}]}
{"pr_number": 78845, "url": "https://github.com/llvm/llvm-project/pull/78845", "title": "[libc++] Fix `regex_search` to match `$` alone with `match_default` flag", "body": "Using `regex_search` with the regex_constant `match_default` and a simple regex pattern `$` is expected to match general strings such as _\"a\", \"ab\", \"abc\"..._ at `[last, last)` positions.  But, the current implementation fails to do so.\r\n\r\nFixes #75042\r\n", "feature_layers": ["ast"], "feature_directives": [], "files_changed": [{"filename": "libcxx/test/std/re/re.const/re.matchflag/match_not_eol.pass.cpp", "functions": ["re"]}]}
{"pr_number": 78991, "url": "https://github.com/llvm/llvm-project/pull/78991", "title": "[Clang] Update feature test macros for Clang 18", "body": "* Set `__cpp_auto_cast`, as per https://github.com/cplusplus/CWG/issues/281\r\n* Support `__has_extension(cxx_generalized_nttp)` in C++20 as the feature isn't stable enough for a feature test macro\r\n* Support `__has_extension(cxx_explicit_this_parameter)` in c++23 as the feature isn't stable enough for a feature test macro", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/Lexer/has_extension_cxx.cpp", "functions": ["has_explicit_this_parameter", "has_generalized_nttp"]}]}
{"pr_number": 74794, "url": "https://github.com/llvm/llvm-project/pull/74794", "title": "[clang-format][NFC] Clean up the driver and getStyle() in Format.cpp", "body": "", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/tools/clang-format/ClangFormat.cpp", "functions": ["format", "dumpConfig"]}]}
{"pr_number": 78330, "url": "https://github.com/llvm/llvm-project/pull/78330", "title": "Fix a bug in implementation of Smith's algorithm used in complex div.", "body": "This patch fixes a bug in Smith's algorithm (thanks to @andykaylor who detected it) and makes sure that last option in command line rules.", "feature_layers": ["ast"], "feature_directives": [], "files_changed": [{"filename": "clang/lib/CodeGen/CGExprComplex.cpp", "functions": ["if"]}, {"filename": "clang/lib/Driver/ToolChains/Clang.cpp", "functions": ["RenderComplexRangeOption"]}, {"filename": "clang/test/CodeGen/smiths-complex-div.c", "functions": ["div"]}]}
{"pr_number": 76571, "url": "https://github.com/llvm/llvm-project/pull/76571", "title": "[OpenMP][USM] Introduces -fopenmp-force-usm flag", "body": "This flag forces the compiler to generate code for OpenMP target regions as if the user specified the #pragma omp requires unified_shared_memory in each source file.\r\n\r\nThe option does not have a -fno-* friend since OpenMP requires the unified_shared_memory clause to be present in all source files. Since this flag does no harm if the clause is present, it can be used in conjunction. My understanding is that USM should not be turned off selectively, hence, no -fno- version.\r\n\r\nIn favor of https://github.com/llvm/llvm-project/pull/75468, sorry for the noise and confusion.", "feature_layers": ["ir"], "feature_directives": ["for", "target", "requires"], "files_changed": [{"filename": "clang/test/OpenMP/force-usm.c", "functions": ["main"]}, {"filename": "openmp/libomptarget/test/offloading/force-usm.cpp", "functions": ["main"]}]}
{"pr_number": 76348, "url": "https://github.com/llvm/llvm-project/pull/76348", "title": "[Clang] Implement the 'counted_by' attribute", "body": "The 'counted_by' attribute is used on flexible array members. The\r\nargument for the attribute is the name of the field member holding the\r\ncount of elements in the flexible array. This information is used to\r\nimprove the results of the array bound sanitizer and the\r\n'__builtin_dynamic_object_size' builtin. The 'count' field member must\r\nbe within the same non-anonymous, enclosing struct as the flexible array\r\nmember. For example:\r\n\r\n```\r\n  struct bar;\r\n  struct foo {\r\n    int count;\r\n    struct inner {\r\n      struct {\r\n        int count; /* The 'count' referenced by 'counted_by' */\r\n      };\r\n      struct {\r\n        /* ... */\r\n        struct bar *array[] __attribute__((counted_by(count)));\r\n      };\r\n    } baz;\r\n  };\r\n```\r\n\r\nThis example specifies that the flexible array member 'array' has the\r\nnumber of elements allocated for it in 'count':\r\n\r\n```\r\n  struct bar;\r\n  struct foo {\r\n    size_t count;\r\n     /* ... */\r\n    struct bar *array[] __attribute__((counted_by(count)));\r\n  };\r\n```\r\n\r\nThis establishes a relationship between 'array' and 'count';\r\nspecifically that 'p->array' must have *at least* 'p->count' number of\r\nelements available. It's the user's responsibility to ensure that this\r\nrelationship is maintained throughout changes to the structure.\r\n\r\nIn the following, the allocated array erroneously has fewer elements\r\nthan what's specified by 'p->count'. This would result in an\r\nout-of-bounds access not not being detected:\r\n\r\n```\r\n  struct foo *p;\r\n\r\n  void foo_alloc(size_t count) {\r\n    p = malloc(MAX(sizeof(struct foo),\r\n                   offsetof(struct foo, array[0]) + count *\r\n                       sizeof(struct bar *)));\r\n    p->count = count + 42;\r\n  }\r\n```\r\n\r\nThe next example updates 'p->count', breaking the relationship\r\nrequirement that 'p->array' must have at least 'p->count' number of\r\nelements available:\r\n\r\n```\r\n  void use_foo(int index, int val) {\r\n    p->count += 42;\r\n    p->array[index] = val; /* The sanitizer can't properly check this access */\r\n  }\r\n```\r\n\r\nIn this example, an update to 'p->count' maintains the relationship\r\nrequirement:\r\n\r\n```\r\n  void use_foo(int index, int val) {\r\n    if (p->count == 0)\r\n      return;\r\n    --p->count;\r\n    p->array[index] = val;\r\n  }\r\n```", "feature_layers": ["ir", "ast"], "feature_directives": ["for", "allocate"], "files_changed": [{"filename": "clang/lib/AST/Expr.cpp", "functions": ["if"]}, {"filename": "clang/lib/CodeGen/CGBuiltin.cpp", "functions": ["CountCountedByAttrs"]}, {"filename": "clang/lib/CodeGen/CGExpr.cpp", "functions": ["IsExpectedRecordDecl", "if", "DName", "Visit", "SanScope"]}, {"filename": "clang/lib/Sema/SemaDeclAttr.cpp", "functions": ["MemResult", "OrdResult", "handleCountedByAttr", "Filter"]}, {"filename": "clang/test/CodeGen/attr-counted-by.c", "functions": ["__attribute__", "test15"]}, {"filename": "clang/test/Sema/attr-counted-by.c", "functions": ["__counted_by"]}]}
{"pr_number": 76822, "url": "https://github.com/llvm/llvm-project/pull/76822", "title": "[lli] Revisit Orc debug output tests", "body": "Integrate in-memory debug-info dumps into the `--orc-lazy-debug` command-line option instead of exposing built-in functions to be called from JITed code. This reduces overall amount of code (removing `ExecutionUtils.cpp`) and seems cleaner anyway.\r\n\r\nAll existing items of `OrcDumpKind` work on IR level and run in the IR-transform step of the JIT. The newly added `DumpDebugDescriptor` and `DumpDebugObjects` must run after debug-registration and thus are deferred to the Object-transform step of the JIT. This separation is the major side-effect of the patch.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/tools/lli/ExecutionUtils.cpp", "functions": ["dumpDebugObjects", "TestOut", "dumpDebugDescriptor"]}, {"filename": "llvm/tools/lli/lli.cpp", "functions": ["Mangle"]}]}
{"pr_number": 78814, "url": "https://github.com/llvm/llvm-project/pull/78814", "title": "Ensure bitmap for ternary condition is updated before visiting children", "body": "This is a fix for MC/DC issue https://github.com/llvm/llvm-project/issues/78453 in which a ConditionalOperator that evaluates a complex condition was incorrectly updating its global bitmap after visiting its LHS and RHS children.  This was wrong because if the LHS or RHS also evaluate a complex condition, the MCDC temporary bitmap value will get corrupted.  The fix is to ensure that the bitmap is updated prior to visiting the LHS and RHS.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/Profile/c-mcdc-logicalop-ternary.c", "functions": ["test"]}]}
{"pr_number": 78859, "url": "https://github.com/llvm/llvm-project/pull/78859", "title": "[clang-tidy] Ignore user-defined literals in google-runtime-int", "body": "User-defined literals do not accept u?intXX(_t)? variables. So the check should not emit a warning.\r\n\r\nFixes #54546 #25214", "feature_layers": ["runtime"], "feature_directives": [], "files_changed": [{"filename": "clang-tools-extra/test/clang-tidy/checkers/google/runtime-int.cpp", "functions": ["some_value"]}]}
{"pr_number": 74840, "url": "https://github.com/llvm/llvm-project/pull/74840", "title": "[VP][RISCV] Introduce llvm.vp.minimum/maximum intrinsics", "body": "Although there are predicated versions of minnum/maxnum, the ones for minimum/maximum are currently missing. This patch introduces these intrinsics and implements their lowering to RISC-V.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVISelLowering.cpp", "functions": ["lowerFMAXIMUM_FMINIMUM", "SplitVPOp"]}]}
{"pr_number": 78371, "url": "https://github.com/llvm/llvm-project/pull/78371", "title": "[JITLink][AArch32] Multi-stub support for armv7/thumbv7", "body": "We want to emit stubs that match the instruction set state of the relocation site. This is important for branches that have no built-in switch for the instruction set state. It's the case for Jump24 relocations. Relocations on instructions support switching on the fly should be fixed up in a relaxation step in the future. This affects Call relocations on `BL`/`BLX` instructions.\r\n\r\nIn this patch, the StubManager gains a second stub symbol slot for each target and selects which one to use based on the relocation type. For testing, we select the appropriate slot with a stub-kind filter, i.e. `arm` or `thumb`. With that we implements Armv7 stubs and test that we can have both kinds of stubs for a single external symbol.", "feature_layers": [], "feature_directives": ["for", "single", "target"], "files_changed": [{"filename": "llvm/lib/ExecutionEngine/JITLink/aarch32.cpp", "functions": ["formatv", "Template", "createStubArmv7", "needsStub"]}, {"filename": "llvm/tools/llvm-jitlink/llvm-jitlink.cpp", "functions": ["Pos", "M", "matchEqual", "done", "matchMask"]}]}
{"pr_number": 79044, "url": "https://github.com/llvm/llvm-project/pull/79044", "title": "[JITLink][AArch32] Implement R_ARM_PREL31 and process .ARM.exidx sections", "body": "`R_ARM_PREL31` is a 31-bits relative data relocation where the most-significant bit is preserved. It's used primarily in `.ARM.exidx` sections, which we skipped processing until now, because we didn't support the relocation type. This was implemented in RuntimeDyld with https://reviews.llvm.org/D25069 and I implemented it in a similar way in JITLink in order to reach feature parity.", "feature_layers": ["runtime"], "feature_directives": ["sections"], "files_changed": [{"filename": "llvm/lib/ExecutionEngine/JITLink/ELF_aarch32.cpp", "functions": ["excludeSection"]}, {"filename": "llvm/lib/ExecutionEngine/JITLink/aarch32.cpp", "functions": ["makeTargetOutOfRangeError"]}]}
{"pr_number": 79064, "url": "https://github.com/llvm/llvm-project/pull/79064", "title": "[lldb][NFCI] Remove Broadcaster::BroadcastEvent overload with EventData param", "body": "There are 3 variants of BroadcastEvent:\r\n1. Takes an Event\r\n2. Takes an event type\r\n3. Takes an event type and event data.\r\n\r\nThe latter 2 just create an Event (with the event type, and if available, the event data) and then pass it along to the internal broadcasting logic.\r\n\r\nThere's no good reason to have all 3 of these, there aren't a lot of different ways to actually create an event object. Forcing callees to create an Event if they want to broadcast an event with event data seems reasonable.", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "lldb/source/Target/Process.cpp", "functions": ["event_receipt_sp"]}]}
{"pr_number": 69498, "url": "https://github.com/llvm/llvm-project/pull/69498", "title": "[libc++] Fix the behavior of throwing `operator new` under -fno-exceptions", "body": "In D144319, Clang tried to land a change that would cause some functions that are not supposed to return nullptr to optimize better. As reported in https://reviews.llvm.org/D144319#4203982, libc++ started seeing failures in its CI shortly after this change was landed.\r\n\r\nAs explained in D146379, the reason for these failures is that libc++'s throwing `operator new` can in fact return nullptr when compiled with exceptions disabled. However, this contradicts the Standard, which clearly says that the throwing version of `operator new(size_t)` should never return nullptr. This is actually a long standing issue. I've previously seen a case where LTO would optimize incorrectly based on the assumption that `operator new` doesn't return nullptr, an assumption that was violated in that case because libc++.dylib was compiled with -fno-exceptions.\r\n\r\nUnfortunately, fixing this is kind of tricky. The Standard has a few requirements for the allocation functions, some of which are impossible to satisfy under -fno-exceptions:\r\n1. `operator new(size_t)` must never return nullptr\r\n2. `operator new(size_t, nothrow_t)` must call the throwing version and return nullptr on failure to allocate\r\n3. We can't throw exceptions when compiled with -fno-exceptions\r\n\r\nIn the case where exceptions are enabled, things work nicely. `new(size_t)` throws and `new(size_t, nothrow_t)` uses a try-catch to return nullptr. However, when compiling the library with -fno-exceptions, we can't throw an exception from `new(size_t)`, and we can't catch anything from `new(size_t, nothrow_t)`. The only thing we can do from `new(size_t)` is actually abort the program, which does not make it possible for `new(size_t, nothrow_t)` to catch something and return nullptr.\r\n\r\nThis patch makes the following changes:\r\n1. When compiled with -fno-exceptions, the throwing version of `operator new` will now abort on failure instead of returning nullptr on failure. This resolves the issue that the compiler could mis-compile based on the assumption that nullptr is never returned. This constitutes an API and ABI breaking change for folks compiling the library with -fno-exceptions (which is not the general public, who merely uses libc++ headers but use a shared library that has already been compiled). This should mostly impact vendors and other folks who compile libc++.dylib themselves.\r\n\r\n2. When the library is compiled with -fexceptions, the nothrow version of `operator new` has no change. When the library is compiled with -fno-exceptions, the nothrow version of `operator new` will now check whether the throwing version of `operator new` has been overridden. If it has not been overridden, then it will use an implementation equivalent to that of the throwing `operator new`, except it will return nullptr on failure to allocate (instead of terminating). However, if the throwing `operator new` has been overridden, it is now an error NOT to also override the nothrow `operator new`. Indeed, there is no way for us to implement a valid nothrow `operator new` without knowing the exact implementation of the throwing version.\r\n\r\nIn summary, this change will impact people who fall into the following intersection of conditions:\r\n- They use the libc++ shared/static library built with `-fno-exceptions`\r\n- They do not override `operator new(..., std::nothrow_t)`\r\n- They override `operator new(...)` (the throwing version)\r\n- They use `operator new(..., std::nothrow_t)`\r\n\r\nWe believe this represents a small number of people.\r\n\r\nFixes #60129\r\nrdar://103958777\r\n\r\nDifferential Revision: https://reviews.llvm.org/D150610", "feature_layers": ["ir"], "feature_directives": ["for", "allocate"], "files_changed": [{"filename": "libcxx/src/new.cpp", "functions": ["new", "operator_new_impl", "operator_new_aligned_impl", "__throw_bad_alloc_shim"]}, {"filename": "libcxx/test/libcxx/language.support/support.dynamic/assert.nothrow_new_not_overridden_fno_exceptions.pass.cpp", "functions": ["new", "delete", "main"]}, {"filename": "libcxx/test/libcxx/language.support/support.dynamic/new_dont_return_nullptr.pass.cpp", "functions": ["main"]}, {"filename": "libcxxabi/src/stdlib_new_delete.cpp", "functions": ["operator_new_impl", "__throw_bad_alloc_shim", "new", "delete", "operator_new_aligned_impl"]}]}
{"pr_number": 78962, "url": "https://github.com/llvm/llvm-project/pull/78962", "title": "[LoongArch] Add definitions and feature 'frecipe' for FP approximation intrinsics/builtins", "body": "This PR adds definitions and 'frecipe' feature for FP approximation intrinsics/builtins. In additions, this adds and complements relative testcases.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CodeGen/LoongArch/builtin-dbl-approximate.c", "functions": ["__builtin_loongarch_frsqrte_d", "frecipe_d_alia", "frsqrte_d", "frecipe_d", "frsqrte_d_alia", "__frecipe_d", "__frsqrte_d", "__builtin_loongarch_frecipe_d"]}, {"filename": "clang/test/CodeGen/LoongArch/builtin-flt-approximate.c", "functions": ["__frecipe_s", "frsqrte_s", "frsqrte_s_alia", "__frsqrte_s", "frecipe_s_alia", "__builtin_loongarch_frsqrte_s", "frecipe_s", "__builtin_loongarch_frecipe_s"]}, {"filename": "clang/test/CodeGen/LoongArch/lasx/builtin-approximate-alias.c", "functions": ["xvfrsqrte_d", "xvfrecipe_d", "xvfrecipe_s", "xvfrsqrte_s"]}, {"filename": "clang/test/CodeGen/LoongArch/lasx/builtin-approximate.c", "functions": ["xvfrecipe_s", "xvfrsqrte_s", "__attribute__", "xvfrsqrte_d", "xvfrecipe_d"]}, {"filename": "clang/test/CodeGen/LoongArch/lsx/builtin-approximate-alias.c", "functions": ["vfrecipe_s", "vfrecipe_d", "vfrsqrte_d", "vfrsqrte_s"]}, {"filename": "clang/test/CodeGen/LoongArch/lsx/builtin-approximate.c", "functions": ["vfrecipe_d", "vfrsqrte_s", "vfrecipe_s", "__attribute__", "vfrsqrte_d"]}, {"filename": "clang/test/CodeGen/LoongArch/intrinsic-la64-error.c", "functions": ["test_feature"]}]}
{"pr_number": 77405, "url": "https://github.com/llvm/llvm-project/pull/77405", "title": "[libc++][hardening] Categorize assertions related to strict weak ordering", "body": "If a user passes a comparator that doesn't satisfy strict weak ordering\r\n(see https://eel.is/c++draft/algorithms#alg.sorting.general) to\r\na sorting algorithm, the algorithm can produce an incorrect result or even lead\r\nto an out-of-bounds access. Unfortunately, comprehensively validating\r\nthat a given comparator indeed satisfies the strict weak ordering\r\nrequirement is prohibitively expensive (see [the related RFC](https://discourse.llvm.org/t/rfc-strict-weak-ordering-checks-in-the-debug-libc/70217)).\r\nAs a result, we have three independent sets of checks:\r\n\r\n- assertions that catch out-of-bounds accesses within the algorithms'\r\n  implementation. These are relatively cheap; however, they cannot catch\r\n  the underlying cause and cannot prevent the case where an invalid\r\n  comparator would result in an incorrectly-sorted sequence without\r\n  actually triggering an OOB access;\r\n\r\n- debug comparators that wrap a given comparator and on each comparison\r\n  check that if `(a < b)`, then `!(b < a)`, where `<` stands for the\r\n  user-provided comparator. This performs up to 2x number of comparisons\r\n  but doesn't affect the algorithmic complexity. While this approach can\r\n  find more issues, it is still a heuristic;\r\n\r\n- a comprehensive check of the comparator that validates up to 100\r\n  elements in the resulting sorted sequence (see the RFC above for\r\n  details). The check is expensive but the 100 element limit can somewhat\r\n  compensate for that, especially for large values of `N`.\r\n\r\nThe first set of checks is enabled in the fast hardening mode while the\r\nother two are only enabled in the debug mode.\r\n\r\nThis patch also removes the\r\n`_LIBCPP_DEBUG_STRICT_WEAK_ORDERING_CHECK` macro that\r\npreviously was used to selectively enable the 100-element check.\r\nNow this check is enabled unconditionally in the debug mode.\r\n\r\nAlso, introduce a new category\r\n`_LIBCPP_ASSERT_SEMANTIC_REQUIREMENT`. This category is\r\nintended for checking the semantic requirements from the Standard.\r\nTypically, these are hard or impossible to completely validate, so\r\nthese checks are expected to be heuristic in nature and potentially\r\nquite expensive.\r\n\r\nSee https://reviews.llvm.org/D150264 for additional background.\r\nFixes #71496\r\n", "feature_layers": ["sema", "ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "libcxx/test/libcxx/algorithms/alg.sorting/assert.sort.invalid_comparator.pass.cpp", "functions": ["check_nan_floats", "results", "ComparisonResults", "generate_float_data", "v", "comparison_results", "main", "check_oob_sort_read", "size", "check_oob_nth_element_read", "compare", "check_irreflexive", "floats"]}, {"filename": "libcxx/test/libcxx/algorithms/alg.sorting/assert.sort.invalid_comparator/assert.sort.invalid_comparator.oob.pass.cpp", "functions": ["check_oob_sort_read", "fixture", "check_oob_nth_element_read", "main"]}, {"filename": "libcxx/test/libcxx/algorithms/alg.sorting/assert.sort.invalid_comparator/assert.sort.invalid_comparator.pass.cpp", "functions": ["check_nan_floats", "results", "fixture", "generate_float_data", "v", "main", "check_oob_sort_read", "check_oob_nth_element_read", "floats", "check_irreflexive"]}]}
{"pr_number": 76788, "url": "https://github.com/llvm/llvm-project/pull/76788", "title": "[llvm-exegesis] Add additional validation counters", "body": "This patch adds support for additional types of validation counters and also adds mappings between these new validation counter types and physical counters on the hardware for microarchitectures that I have the ability to test on.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/tools/llvm-exegesis/lib/BenchmarkResult.cpp", "functions": ["if"]}]}
{"pr_number": 78690, "url": "https://github.com/llvm/llvm-project/pull/78690", "title": "[mlir][bufferization] Simplify helper `potentiallyAliasesMemref`", "body": "This commit simplifies a helper function in the ownership-based buffer deallocation pass. Fixes a potential double-free (depending on the scheduling of patterns).\r\n", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/Bufferization/Transforms/BufferDeallocationSimplification.cpp", "functions": ["otherMemrefs"]}]}
{"pr_number": 75583, "url": "https://github.com/llvm/llvm-project/pull/75583", "title": "[mlir] support non-interprocedural dataflow analyses", "body": "The core implementation of the dataflow anlysis framework is interpocedural by design. While this offers better analysis precision, it also comes with additional cost as it takes longer for the analysis to reach the fixpoint state. Add a configuration mechanism to the dataflow solver to control whether it operates inteprocedurally or not to offer clients a choice.\r\n\r\nAs a positive side effect, this change also adds hooks for explicitly processing external/opaque function calls in the dataflow analyses, e.g., based off of attributes present in the the function declaration or call operation such as alias scopes and modref available in the LLVM dialect.\r\n\r\nThis change should not affect existing analyses and the default solver configuration remains interprocedural.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Analysis/DataFlow/DenseAnalysis.cpp", "functions": ["visitCallOperation", "setToExitState"]}, {"filename": "mlir/lib/Analysis/DataFlow/SparseAnalysis.cpp", "functions": ["visitExternalCallImpl"]}, {"filename": "mlir/test/lib/Analysis/DataFlow/TestDenseBackwardDataFlowAnalysis.cpp", "functions": ["DenseBackwardDataFlowAnalysis", "propagateIfChanged", "solver"]}, {"filename": "mlir/test/lib/Analysis/DataFlow/TestDenseForwardDataFlowAnalysis.cpp", "functions": ["propagateIfChanged", "DenseForwardDataFlowAnalysis", "LastModifiedAnalysis", "solver"]}, {"filename": "mlir/test/lib/Analysis/DataFlow/TestSparseBackwardDataFlowAnalysis.cpp", "functions": ["SparseBackwardDataFlowAnalysis", "solver"]}]}
{"pr_number": 78127, "url": "https://github.com/llvm/llvm-project/pull/78127", "title": "[clang][dataflow] Process terminator condition within `transferCFGBlock()`.", "body": "In particular, it's important that we create the \"fallback\" atomic at this point\n(which we produce if the transfer function didn't produce a value for the\nexpression) so that it is placed in the correct environment.\n\nPreviously, we processed the terminator condition in the `TerminatorVisitor`,\nwhich put the fallback atomic in a copy of the environment that is produced as\ninput for the _successor_ block, rather than the environment for the block\ncontaining the expression for which we produce the fallback atomic.\n\nAs a result, we produce different fallback atomics every time we process the\nsuccessor block, and hence we don't have a consistent representation of the\nterminator condition in the flow condition.\n\nThis patch includes a test (authored by ymand@) that fails without the fix.\n", "feature_layers": ["ir"], "feature_directives": ["for", "atomic"], "files_changed": [{"filename": "clang/lib/Analysis/FlowSensitive/TypeErasedDataflowAnalysis.cpp", "functions": ["StmtToEnv", "Env"]}, {"filename": "clang/unittests/Analysis/FlowSensitive/SignAnalysisTest.cpp", "functions": ["fun", "foo"]}, {"filename": "clang/unittests/Analysis/FlowSensitive/TransferTest.cpp", "functions": ["target", "cond"]}]}
{"pr_number": 77945, "url": "https://github.com/llvm/llvm-project/pull/77945", "title": "Reapply [TLI] Fix replace-with-veclib crash with invalid arguments", "body": "Fix a crash of `replace-with-veclib` pass, when the arguments of the TLI mapping do not match the original call.\r\nNow, it simply ignores such cases.\r\n\r\nTest require assertions as it accesses programmatically the debug log.\r\n\r\n# Reapplies:\r\n- Reverted PR: #77112\r\n- Originally submitted by commit 9fdc568824b0, and then reverted by a300b2403784, as it was causing some [linking issues](https://lab.llvm.org/buildbot/#/builders/234/builds/17734)", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "llvm/unittests/Analysis/ReplaceWithVecLibTest.cpp", "functions": ["parseIR", "run", "getLastLine"]}]}
{"pr_number": 76386, "url": "https://github.com/llvm/llvm-project/pull/76386", "title": "[llvm-objdump] Add support for symbolizing PGOBBAddrMap Info", "body": "This patch adds in support for symbolizing PGO information contained within the SHT_LLVM_BB_ADDR_MAP section in llvm-objdump. The outputs are simply the raw values contained within the section.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/tools/llvm-objdump/llvm-objdump.cpp", "functions": ["PGOSS"]}]}
{"pr_number": 78963, "url": "https://github.com/llvm/llvm-project/pull/78963", "title": "[Coverage] getMaxBitmapSize: Scan `max(BitmapIdx)` instead of the last `Decision`", "body": "In `CoverageMapping.cpp:getMaxBitmapSize()`, \r\nthis assumed that the last `Decision` has the maxmum `BitmapIdx`.\r\n\r\nLet it scan `max(BitmapIdx)`.\r\n\r\nNote that `<=` is used insted of `<`, because `BitmapIdx == 0` is valid\r\nand `MaxbitmapID` is `unsigned`. `BitmapIdx` is unique in the record.\r\n\r\nFixes #78922", "feature_layers": ["ast"], "feature_directives": [], "files_changed": [{"filename": "llvm/test/tools/llvm-cov/Inputs/mcdc-maxbs.c", "functions": ["sub", "main", "__llvm_profile_write_file"]}]}
{"pr_number": 78980, "url": "https://github.com/llvm/llvm-project/pull/78980", "title": "[RemoveDIs][DebugInfo] Handle DPVAssigns in AssignmentTrackingLowering", "body": "Following on from the previous patch [6aeb7a7](https://github.com/llvm/llvm-project/commit/6aeb7a71d40faed14820523b5be24ff93a4e9bf9), this patch adds the necessary code to process the DPV equivalents of llvm.dbg.assign intrinsics. Most of the content of this patch is simply duplicating existing functionality, using generic code for simple functions and PointerUnions where storage is required. The most complex changes are in the places that iterate over instructions, as iterating over DPValues between instructions is different to iterating over instructions that may or may not be debug intrinsics; this is most complex in `AssignmentTrackingLowering::process`, where I've added some comments to explain the state of the program at each key point depending on whether we are operating on intrinsics or DPValues.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp", "functions": ["processDPValue", "Status", "ProcessDbgValueImpl", "makeNoneOrPhi", "makeFromMemDef", "AssignRecord", "make", "Assignment", "if", "emitDbgValue", "ProcessDbgAssignImpl", "processDbgValue", "processDbgAssign"]}]}
{"pr_number": 79020, "url": "https://github.com/llvm/llvm-project/pull/79020", "title": "[MC][X86] Merge lane/element broadcast comment printers.", "body": "This is /almost/ NFC - the only annoyance is that for some reason we were using \"<C1,C2,..>\" for ConstantVector types unlike all other cases - these now use the same \"[C1,C2,..]\" format as the other constant printers.\r\n\r\nI don't think we have any reason to keep this diff, but I'm putting up this PR just in case there's a reason I've forgotten.", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/X86/X86MCInstLower.cpp", "functions": ["if", "CS"]}]}
{"pr_number": 75804, "url": "https://github.com/llvm/llvm-project/pull/75804", "title": "[RISCV] Update TargetAttr target-cpu override rule", "body": "Address question from https://github.com/llvm/llvm-project/pull/74889\r\n\r\n---\r\n\r\nThe target-cpu will infer its target-feature during backend codegen, it will make TargetAttr doesn't work.\r\n\r\nThis patch implement the following override rule\r\n\r\nby \r\n\r\n1. When implying Full-Arch-String in target attribute, replace target-cpu with baseline cpu to make sure backend doesn't infer other target feature.\r\n2. Keep mcpu in tune-cpu during Attr-cpu,Attr-tune not present.\r\n\r\n## Driver with march, mcpu\r\n|No. | Attr-arch                            | Attr-cpu  | Attr-tune      | target-cpu | target-feature | tune-cpu | \r\n|---| ------------------------------|  --------  | --------------|-------------- |---------------| -------------|\r\n|1|  No  |    No    |   No  |   mcpu   | march | No |\r\n|2|  Full-Arch-String  |    No    |   No    |   generic-rv32/rv64   | attr-arch | mcpu |\r\n|3|  Full-Arch-String  |    Yes    |   No    |   generic-rv32/rv64   | attr-arch | attr-cpu |\r\n|4|  Full-Arch-String  |    No    |   Yes    |   generic-rv32/rv64   | attr-arch | attr-tune |\r\n|5|  Full-Arch-String  |    Yes    |   Yes    |   generic-rv32/rv64   | attr-arch | attr-tune |\r\n|6|  Adding-Extension  |    No    |   No  |   mcpu   | march + attr-arch | No |\r\n|7|  Adding-Extension  |    Yes    |   No  |   mcpu   | march + attr-arch | attr-cpu |\r\n|8|  Adding-Extension  |    No   |   Yes   |   mcpu   | march + attr-arch | attr-tune |\r\n|9|  Adding-Extension  |    Yes   |   Yes   |   mcpu   | march + attr-arch | attr-tune |\r\n|10|  No  |    Yes   |   No   |   attr-cpu   | attr-cpu | No |\r\n|11|  No  |    Yes   |   Yes   |   attr-cpu   | attr-cpu | attr-tune |\r\n|12|  No  |    No  |   Yes   |   mcpu   | march | attr-tune |\r\n\r\n## Note\r\n\r\nThis patch assumes that target-cpu is only used to infer target-feature and tune-cpu in the backend. If there are other purposes for target-cpu,  then this patch need to find the alternative solution.\r\n", "feature_layers": ["codegen"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "clang/test/CodeGen/RISCV/riscv-func-attr-target-mcpu-rv32.c", "functions": ["testDefault"]}, {"filename": "clang/test/CodeGen/RISCV/riscv-func-attr-target-mcpu-rv64.c", "functions": ["testDefault"]}, {"filename": "clang/lib/Basic/Targets/RISCV.cpp", "functions": ["if"]}]}
{"pr_number": 77853, "url": "https://github.com/llvm/llvm-project/pull/77853", "title": "[openmp] Fix warnings when building on Windows with latest MSVC or Clang ToT", "body": "There are quite a few compilation warnings when building openmp on Windows with the latest Visual Studios 2022 version 17.8.4. This PR fixes all of them. I've followed the same (implicit) guidelines for disabling warnings as in other parts of LLVM.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "openmp/runtime/src/kmp_affinity.cpp", "functions": ["KMP_I18N_STR"]}, {"filename": "openmp/runtime/src/kmp_io.cpp", "functions": ["is_console"]}]}
{"pr_number": 78982, "url": "https://github.com/llvm/llvm-project/pull/78982", "title": "[RemoveDIs][DebugInfo] Handle DPVAssigns in Assignment Tracking excluding lowering", "body": "This patch adds support for DPVAssigns across all of AssignmentTrackingAnalysis except for AssignmentTrackingLowering, which is implemented in a separate patch. This patch includes handling DPValues in MemLocFragFill, the removal of redundant DPValues as part of AssignmentTrackingAnalysis (which is different to the version in `BasicBlockUtils.cpp`), and preventing the DPVAssigns from being directly emitted in SelectionDAG (just as we don't emit llvm.dbg.assigns directly, but receive a set of locations from AssignmentTrackingAnalysis' output).", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp", "functions": ["Key"]}]}
{"pr_number": 78995, "url": "https://github.com/llvm/llvm-project/pull/78995", "title": "[llvm-reduce][DebugInfo] Support reducing non-instruction debug-info", "body": "LLVM will shortly be able to represent variable locations without encoding information into intrinsics -- they'll be stored as DPValue objects instead. We'll still need to be able to llvm-reduce these variable location assignments just like we can with intrinsics today, thus, here's an llvm-reduce pass that enumerates and reduces the DPValue objects.\r\n\r\nThe test for this is paradoxically written with dbg.value intrinsics: this is because we're changing all the core parts of LLVM to support this first, with the textual IR format coming last. Until that arrives, testing the llvm-reduce'ing of DPValues needs the added test using intrinsics. We should be able to drop the variable assignment using %alsoloaded using this method. As with the other llvm-reduce tests, I've got one set of check lines for making the reduction happen as desired, and the other set to check the final output.", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/tools/llvm-reduce/deltas/ReduceDPValues.cpp", "functions": ["extractDPValuesFromModule"]}]}
{"pr_number": 78285, "url": "https://github.com/llvm/llvm-project/pull/78285", "title": "[PGO] Reland PGO's Counter Reset and File Dumping APIs #76471", "body": "https://github.com/llvm/llvm-project/pull/76471 caused buildbot failures on Windows. For more details, see https://github.com/llvm/llvm-project/issues/77546. \r\n\r\nThis PR revises the test and relands https://github.com/llvm/llvm-project/pull/76471. ", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "compiler-rt/test/profile/Linux/instrprof-weak-symbol.c", "functions": ["main"]}, {"filename": "compiler-rt/test/profile/instrprof-api.c", "functions": ["bar", "foo", "main"]}]}
{"pr_number": 78788, "url": "https://github.com/llvm/llvm-project/pull/78788", "title": "[AArch64][FMV] Support feature MOPS in Function Multi Versioning.", "body": "The patch adds support for FEAT_MOPS (Memory Copy and Memory Set instructions) in Function Multi Versioning. The bits [19:16] of the system register ID_AA64ISAR2_EL1 indicate whether FEAT_MOPS is implemented in AArch64 state. This information is accessible via ELF hwcaps.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CodeGen/attr-target-version.c", "functions": ["__attribute__"]}, {"filename": "clang/test/Sema/attr-target-clones-aarch64.c", "functions": ["__attribute__"]}, {"filename": "clang/test/SemaCXX/attr-target-version.cpp", "functions": ["__attribute__"]}]}
{"pr_number": 75627, "url": "https://github.com/llvm/llvm-project/pull/75627", "title": "[mlir][amdgpu] Shared memory access optimization pass", "body": "It implements transformation to optimize accesses to shared memory.\r\n\r\nReference: https://reviews.llvm.org/D127457\r\n\r\n_This change adds a transformation and pass to the NvGPU dialect that\r\nattempts to optimize reads/writes from a memref representing GPU shared\r\nmemory in order to avoid bank conflicts. Given a value representing a\r\nshared memory memref, it traverses all reads/writes within the parent op\r\nand, subject to suitable conditions, rewrites all last dimension index\r\nvalues such that element locations in the final (col) dimension are\r\ngiven by newColIdx = col % vecSize + perm[row](col / vecSize, row)\r\nwhere perm is a permutation function indexed by row and vecSize\r\nis the vector access size in elements (currently assumes 128bit\r\nvectorized accesses, but this can be made a parameter). This specific\r\ntransformation can help optimize typical distributed & vectorized accesses\r\ncommon to loading matrix multiplication operands to/from shared memory._", "feature_layers": ["ir", "ast"], "feature_directives": ["for", "distribute"], "files_changed": [{"filename": "mlir/lib/Dialect/AMDGPU/IR/AMDGPUDialect.cpp", "functions": ["isSharedMemoryAddressSpace"]}, {"filename": "mlir/lib/Dialect/AMDGPU/Transforms/OptimizeSharedMemory.cpp", "functions": ["failure", "runOnOperation", "success", "builder"]}, {"filename": "mlir/lib/Dialect/AMDGPU/Transforms/Utils.cpp", "functions": ["getIndicesImpl", "getIndices", "setIndices", "setIndicesImpl", "operationWithIndices"]}]}
{"pr_number": 78986, "url": "https://github.com/llvm/llvm-project/pull/78986", "title": "[RemoveDIs][DebugInfo] Handle DPVAssign in most transforms", "body": "This patch trivially updates various opt passes to handle DPVAssigns. In all cases, this means some combination of generifying existing code to handle DPValues and DbgAssignIntrinsics, iterating over DPValues where previously we did not, or duplicating code for DbgAssignIntrinsics to the equivalent DPValue function (in inlining and salvageDebugInfo).", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Utils/Local.cpp", "functions": ["salvageDbgAssignAddress"]}, {"filename": "llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp", "functions": ["clear", "empty"]}, {"filename": "llvm/lib/Transforms/Utils/ValueMapper.cpp", "functions": ["if"]}]}
{"pr_number": 79142, "url": "https://github.com/llvm/llvm-project/pull/79142", "title": "[libc][NFC] Remove `FPBits` cast operator", "body": "The semantics for casting can range from \"bitcast\" (same representation) to \"different representation\", to \"type promotion\". Here we remove the cast operator and force usage of `get_val` as the only function to get the floating point value, making the intent clearer and more consistent.", "feature_layers": ["sema", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "libc/utils/MPFRWrapper/MPFRUtils.cpp", "functions": ["MPFRNumber"]}]}
{"pr_number": 79148, "url": "https://github.com/llvm/llvm-project/pull/79148", "title": "[RemoveDIs][DebugInfo] Enable creation of DPVAssigns, update outstanding AT tests", "body": "This is the final patch for DPVAssign support, implementing the actual creation of DPVAssigns and allowing them to be converted along with dbg.values and dbg.declares. Numerous tests landed in previous patches will no longer be rotten after this patch lands (previously they would trivially pass due to DPVAssigns not actually being used), and a further batch of tests have been added here that require the changes in this patch before they pass.", "feature_layers": ["ir"], "feature_directives": ["for", "declare"], "files_changed": [{"filename": "llvm/lib/IR/DebugInfo.cpp", "functions": ["DebugVariableAggregate"]}]}
{"pr_number": 79072, "url": "https://github.com/llvm/llvm-project/pull/79072", "title": "[RISCV] Exploit register boundaries when lowering shuffle with exact vlen", "body": "If we have a shuffle which is larger than m1, we may be able to split it into a series of individual m1 shuffles.  This patch starts with the subcase where the mask allows a 1-to-1 mapping from source register to destination register - each with a possible permutation of their own. We can potentially extend this later, thought in practice this seems to already catch a number of the most interesting cases.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVISelLowering.cpp", "functions": ["SDValue", "convertFromScalableVector", "DL"]}]}
{"pr_number": 79180, "url": "https://github.com/llvm/llvm-project/pull/79180", "title": "[RISCV] Recurse on first operand of two operand shuffles", "body": "This is the first step towards an alternate shuffle lowering design for the general two vector argument case.  The goal is to leverage the existing lowering for single vector permutes to avoid as many of the vrgathers as required - even if we do need the other.\r\n\r\nThis patch handles only the first argument, and is arguably a slightly weird half-step.  However, the test changes from the full two argument recurse patch are a lot harder to reason about.  Taking this half step gives much more easily reviewable changes, and is thus worthwhile.  I intend to post the patch for the second argument once this has landed.", "feature_layers": ["ir"], "feature_directives": ["for", "single"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVISelLowering.cpp", "functions": ["convertFromScalableVector"]}]}
{"pr_number": 76287, "url": "https://github.com/llvm/llvm-project/pull/76287", "title": " [LTO] Drop the weak function if there is a non-weak global symbol ", "body": "Alternative to #76040.\r\n\r\nThis PR only implements the handling of the weak function.\r\n\r\nWe should also be able to use `.lto_discard` to handle weak asm symbols. However, we may require additional effort to enhance the maintenance of `.lto_discard`.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Linker/LinkModules.cpp", "functions": ["dropWeakGVForAsm", "getLinkedToGlobal", "changeDefToDecl", "GlobalVariable"]}, {"filename": "llvm/lib/Object/ModuleSymbolTable.cpp", "functions": ["TT"]}]}
{"pr_number": 74677, "url": "https://github.com/llvm/llvm-project/pull/74677", "title": "[SampleProfile] Add option to limit number of (indirect) call target and inlined callsites when reading a Sample Profile", "body": "Add option to limit number of (indirect) call target and inlined callsites when reading a Sample Profile\r\n\r\nSample profile generated in production environment can contain entries with a huge amount of indirect call targets or inlined callsites due to usages like Listener pattern, CRTP, etc. This will cause a combinatorial blow up when constructing the call graph from the profile for inlining, slowing down the compilation time by 10+ times.\r\n\r\nSince we actually don't inline indirect call for more than a few call targets, a limit is added to sample profile parsing so that it will only keep the top N indirect call targets or inlined callsites, ranking by sample count. Lowest is dropped first.\r\n\r\nUse -sample-profile-call-target-max and\r\n-sample-profile-inline-callsite-max to control the max number to kept, default is 3.\r\n\r\nThis option also works on llvm-profdata merge, but it only controls the input reader, not the output after merging multiple profiles", "feature_layers": ["ir"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "llvm/lib/ProfileData/SampleProfReader.cpp", "functions": ["CalledFunction"]}]}
{"pr_number": 79061, "url": "https://github.com/llvm/llvm-project/pull/79061", "title": "[clang][FatLTO] Avoid UnifiedLTO until it can support WPD/CFI", "body": "Currently, the UnifiedLTO pipeline seems to have trouble with several\nLTO features, like SplitLTO units, which means we cannot use important\noptimizations like Whole Program Devirtualization or security hardening\ninstrumentation like CFI.\n\nThis patch reverts FatLTO to using distinct pipelines for Full LTO and\nThinLTO. It still avoids module cloning, since that was error prone.\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Passes/PassBuilder.cpp", "functions": ["parseEmbedBitcodePassOptions"]}]}
{"pr_number": 79206, "url": "https://github.com/llvm/llvm-project/pull/79206", "title": "[misc-coroutine-hostile-raii] Use getOperand instead of getCommonExpr.", "body": "We were previously allowlisting awaitable types returned by `await_transform` instead of the type of the operand of the `co_await` expression.\r\n\r\nThis previously used to give false positives and not respect the `AllowedAwaitablesList` flag when `await_transform` is used. See added test cases for such examples.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang-tools-extra/test/clang-tidy/checkers/misc/coroutine-hostile-raii.cpp", "functions": ["unhandled_exception", "await_transform", "RAIISafeSuspendTest2", "initial_suspend", "retAwaitable", "get_return_object", "final_suspend"]}]}
{"pr_number": 76610, "url": "https://github.com/llvm/llvm-project/pull/76610", "title": "[libc++] <experimental/simd> Add load constructor for class simd/simd_mask", "body": "", "feature_layers": [], "feature_directives": ["for", "simd"], "files_changed": [{"filename": "libcxx/test/std/experimental/simd/simd.class/simd_ctor_load.pass.cpp", "functions": ["main", "operator"]}, {"filename": "libcxx/test/std/experimental/simd/simd.mask.class/simd_mask_ctor_load.pass.cpp", "functions": ["main", "operator"]}]}
{"pr_number": 74153, "url": "https://github.com/llvm/llvm-project/pull/74153", "title": "[mlir][ArithToAMDGPU] Add option for saturating truncation to fp8", "body": "Many machine-learning applications (and most software written at AMD) expect the operation that truncates floats to 8-bit floats to be saturatinng. That is, they expect `truncf 256.0 : f32 to f8E4M3FNUZ` to yield `240.0`, not `NaN`, and similarly for negative numbers. However, the underlying hardware instruction that can be used for this truncation implements overflow-to-NaN semantics.\r\n\r\nTo enable handling this usecase, we add the saturate-fp8-truncf option to ArithToAMDGPU (off by default), which causes the requisite clamping code to be emitted. Said clamping code ensures that Inf and NaN are passed through exactly (and thus trancate to NaN).\r\n\r\nPer review feedback, this commit efactors\r\ncreateScalarOrSplatConstant() to the Arith dialect utilities and uses\r\nit in this code. It also fixes naming of existing patterns and\r\nswitches from vector.extractelement/insertelement to\r\nvector.extract/insert.", "feature_layers": ["sema", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Conversion/ArithToAMDGPU/ArithToAMDGPU.cpp", "functions": ["failure"]}]}
{"pr_number": 79232, "url": "https://github.com/llvm/llvm-project/pull/79232", "title": "[mlir] Add example of `printAlias` to test dialect (NFC)", "body": "Follow-up from previous pull request. Motivate the API change with an attribute that decides between sugaring a sub-attribute or using an alias", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/test/lib/Dialect/Test/TestAttributes.cpp", "functions": ["printConditionalAlias", "success", "parseConditionalAlias"]}]}
{"pr_number": 68932, "url": "https://github.com/llvm/llvm-project/pull/68932", "title": "[AMDGPU] Emit a waitcnt instruction after each memory instruction", "body": "This patch implements a new command-line option for the backend, namely, amdgpu-waitcnt-for-all-mem-op. When this option is specified, a \"waitcnt 0\" instruction is generated after each memory load/store instruction.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp", "functions": ["insertWaitcntAfterMemOp"]}]}
{"pr_number": 79099, "url": "https://github.com/llvm/llvm-project/pull/79099", "title": "[ELF] Implement R_RISCV_TLSDESC for RISC-V", "body": "Support\nR_RISCV_TLSDESC_HI20/R_RISCV_TLSDESC_LOAD_LO12_I/R_RISCV_TLSDESC_ADD_LO12_I/R_RISCV_TLSDESC_CALL.\nLOAD_LO12_I/ADD_LO12_I/CALL relocations reference a label at the HI20\nlocation, which requires special handling. We save the value of HI20 to\nbe reused.\n\nFor -no-pie/-pie links, TLSDESC to initial-exec or local-exec\noptimizations are eligible. Implement the relevant hooks\n(R_RELAX_TLS_GD_TO_LE, R_RELAX_TLS_GD_TO_IE). AUIPC/L[DW] for\ninitial-exec uses GOT offsets, which may be adjusted in the presence of\nlinker relaxation.\n\n```\n// TLSDESC to LE/IE optimization\n.Ltlsdesc_hi2:\n  auipc a4, %tlsdesc_hi(c)                      # if R_RISCV_RELAX: remove; otherwise, NOP\n  load  a5, %tlsdesc_load_lo(.Ltlsdesc_hi2)(a4) # if R_RISCV_RELAX: remove; otherwise, NOP\n  addi  a0, a4, %tlsdesc_add_lo(.Ltlsdesc_hi2)\n  jalr  t0, 0(a5), %tlsdesc_call(.Ltlsdesc_hi2)\n  add   a0, a0, tp\n```\n\n* `riscv64-tlsdesc.s` is inspired by `i386-tlsdesc-gd.s` (https://reviews.llvm.org/D112582).\n* `riscv64-tlsdesc-relax.s` tests linker relaxation.\n* `riscv-tlsdesc-gd-mixed.s` is inspired by `x86-64-tlsdesc-gd-mixed.s` (https://reviews.llvm.org/D116900).\n\nDO NOT SUBMIT: rebase after #66915 lands", "feature_layers": ["ir"], "feature_directives": ["for", "requires"], "files_changed": [{"filename": "lld/ELF/Arch/RISCV.cpp", "functions": ["tlsdescToLe", "tlsdescToIe"]}]}
{"pr_number": 77049, "url": "https://github.com/llvm/llvm-project/pull/77049", "title": "[RISCV] Allow VCIX with SE to reorder", "body": "This patch allows VCIX instructions that have side effect to be reordered\r\nwith memory and other side effecting instructions. However we don't want\r\nVCIX instructions to be reordered with each other, so we propose a dummy\r\nregister called VCIX_STATE and make these instructions implicitly define and use\r\nit.", "feature_layers": [], "feature_directives": ["ordered"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVISelLowering.cpp", "functions": ["getVCIXISDNodeVOID", "if", "getVCIXISDNodeWCHAIN", "DL"]}]}
{"pr_number": 79250, "url": "https://github.com/llvm/llvm-project/pull/79250", "title": "[LoongArch] Check lsx/lasx features when running builtin tests", "body": "This patch refers to the following test:\r\nclang/test/CodeGen/LoongArch/intrinsic-la32-error.c", "feature_layers": ["codegen"], "feature_directives": [], "files_changed": [{"filename": "clang/test/CodeGen/LoongArch/lasx/builtin-error.c", "functions": ["test_feature"]}, {"filename": "clang/test/CodeGen/LoongArch/lsx/builtin-error.c", "functions": ["test_feature"]}]}
{"pr_number": 74686, "url": "https://github.com/llvm/llvm-project/pull/74686", "title": "[ELF] Change .debug_names tombstone value to UINT32_MAX/UINT64_MAX", "body": "`clang -g -gpubnames -fdebug-types-section` now emits .debug_names\nsection with references to local type unit entries defined in COMDAT\n.debug_info sections.\n\n```\n.section        .debug_info,\"G\",@progbits,5657452045627120676,comdat\n.Ltu_begin0:\n...\n\n.section        .debug_names,\"\",@progbits\n...\n// DWARF32\n.long   .Ltu_begin0                     # Type unit 0\n// DWARF64\n// .long   .Ltu_begin0                     # Type unit 0\n```\n\nWhen `.Ltu_begin0` is relative to a non-prevailing .debug_info section,\nthe relocation resolves to 0, which is a valid offset within the\n.debug_info section.\n\n```\ncat > a.cc <<e\nstruct A { int x; };\ninline A foo() { return {1}; }\nint main() { foo(); }\ne\ncat > b.cc <<e\nstruct A { int x; };\ninline A foo() { return {1}; }\nvoid use() { foo(); }\ne\nclang++ -g -gpubnames -fdebug-types-section -fuse-ld=lld a.cc b.cc -o old\n```\n```\n% llvm-dwarfdump old\n...\n  Local Type Unit offsets [\n    LocalTU[0]: 0x00000000\n  ]\n...\n  Local Type Unit offsets [\n    LocalTU[0]: 0x00000000  // indistinguishable from a valid offset within .debug_info\n  ]\n```\n\nhttps://dwarfstd.org/issues/231013.1.html proposes that we use a\ntombstone value instead to inform consumers. This patch implements the\nidea. The second LocalTU entry will now use 0xffffffff.\n\nhttps://reviews.llvm.org/D84825 has a TODO that we should switch the\ntombstone value for most `.debug_*` sections to UINT64_MAX. We have\npostponed the change for more than three years for consumers to migrate.\nAt some point we shall make the change, so that .debug_names is no long\ndifferent from other debug section that is not .debug_loc/.debug_ranges.\n", "feature_layers": [], "feature_directives": ["for", "sections"], "files_changed": [{"filename": "lld/ELF/InputSection.cpp", "functions": ["if"]}]}
{"pr_number": 79162, "url": "https://github.com/llvm/llvm-project/pull/79162", "title": "[mlir][vector] Support scalable vec in `TransferReadAfterWriteToBroadcast`", "body": "Makes `TransferReadAfterWriteToBroadcast` correctly propagate\nscalability flags.\n", "feature_layers": ["ir", "ast"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/Vector/IR/VectorOps.cpp", "functions": ["broadcastScalableFlags"]}]}
{"pr_number": 70922, "url": "https://github.com/llvm/llvm-project/pull/70922", "title": "[NewPM][CodeGen][llc] Add NPM support", "body": "Add new pass manager support to `llc`. Users can use `--passes=pass1,pass2...` to run mir passes, and use `--enable-new-pm` to run default codegen pipeline.\r\nThis patch is taken from [D83612](https://reviews.llvm.org/D83612), the original author is @yuanfang-chen.\r\n", "feature_layers": ["codegen", "ir"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/Target/X86/X86CodeGenPassBuilder.cpp", "functions": ["addPreISel", "CodeGenPassBuilder", "addInstSelector", "addAsmPrinter"]}, {"filename": "llvm/unittests/CodeGen/CodeGenPassBuilderTest.cpp", "functions": ["addPreISel", "CodeGenPassBuilder", "CGPB", "PB", "addAsmPrinter", "MIROS", "IROS", "SetUpTestCase", "addInstSelector", "SetUp"]}, {"filename": "llvm/tools/llc/NewPMDriver.cpp", "functions": ["MIRSOS", "PB", "MFAM", "SI", "IRSOS"]}, {"filename": "llvm/tools/llc/llc.cpp", "functions": ["DP", "handleDiagnostics", "compileModuleWithNewPM", "PassPipeline2"]}]}
{"pr_number": 78414, "url": "https://github.com/llvm/llvm-project/pull/78414", "title": "[AMDGPU][GFX12] VOP encoding and codegen - add support for v_cvt fp8/\u2026", "body": "\u2026bf8 instructions\r\n\r\n    Add VOP1, VOP1_DPP8, VOP1_DPP16, VOP3, VOP3_DPP8, VOP3_DPP16\r\n    instructions that were supported on GFX940 (MI300):\r\n    - V_CVT_F32_FP8\r\n    - V_CVT_F32_BF8\r\n    - V_CVT_PK_F32_FP8\r\n    - V_CVT_PK_F32_BF8\r\n    - V_CVT_PK_FP8_F32\r\n    - V_CVT_PK_BF8_F32\r\n    - V_CVT_SR_FP8_F32\r\n    - V_CVT_SR_BF8_F32", "feature_layers": ["codegen"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.cpp", "functions": ["isVOP1Cvt_F32_Fp8_Bf8_e64", "isCvt_F32_Fp8_Bf8_e64"]}]}
{"pr_number": 78482, "url": "https://github.com/llvm/llvm-project/pull/78482", "title": "AMDGPU/GlobalISelDivergenceLowering: select divergent i1 phis", "body": "Implement PhiLoweringHelper for GlobalISel in DivergenceLoweringHelper. Use machine uniformity analysis to find divergent i1 phis and select them as lane mask phis in same way SILowerI1Copies select VReg_1 phis. Note that divergent i1 phis include phis created by LCSSA and all cases of uses outside of cycle are actually covered by \"lowering LCSSA phis\". GlobalISel lane masks are registers with sgpr register class and S1 LLT.\r\n\r\nTODO: General goal is that instructions created in this pass are fully instruction-selected so that selection of lane mask phis is not split across multiple passes.\r\n\r\npatch 3 from: https://github.com/llvm/llvm-project/pull/73337", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/CodeGen/MachineUniformityAnalysis.cpp", "functions": ["print", "getAnalysisUsage", "runOnMachineFunction"]}, {"filename": "llvm/lib/Target/AMDGPU/AMDGPUGlobalISelDivergenceLowering.cpp", "functions": ["markAsLaneMask", "buildRegCopyToLaneMask", "constrainAsLaneMask", "PhiLoweringHelper", "Helper"]}, {"filename": "llvm/lib/Target/AMDGPU/AMDGPUInstructionSelector.cpp", "functions": ["selectPHI"]}, {"filename": "llvm/lib/Target/AMDGPU/SILowerI1Copies.cpp", "functions": ["constrainAsLaneMask", "constrainIncomingRegisterTakenAsIs"]}]}
{"pr_number": 79156, "url": "https://github.com/llvm/llvm-project/pull/79156", "title": "[flang] Set assumed-size last extent to -1", "body": "Currently lowering sets the extents of assumed-size array to \"undef\" which was OK as long as the value was not expected to be read.\r\n\r\nBut when interfacing with the runtime and when passing assumed-size to assumed-rank, this last extent may be read and must be -1 as specified in the BIND(C) case in 18.5.3 point 5.\r\n\r\nSet this value to -1, and update all the lowering code that was looking for an undef defining op to identify assumed-size: much safer to propagate and use semantic info here, the previous check actually did not work if the array was used in an internal procedure (defining op not visible anymore).\r\n\r\n@clementval and @agozillon, I left assumed-size extent to zero in the acc/omp bounds op as it was, please double check that is what you want (I can imagine -1 may create troubles here, and 0 makes some sense as it would lead to no data transfer).\r\n\r\nThis also allows removing special cases in UBOUND/LBOUND lowering.\r\n\r\nAlso disable allocation of cray pointee. This was never intended and would now lead to crashes with the -1 value for assumed-size cray pointee.", "feature_layers": ["sema", "runtime", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Lower/ConvertVariable.cpp", "functions": ["getAssumedSizeExtent"]}, {"filename": "flang/lib/Optimizer/Builder/BoxValue.cpp", "functions": ["isUndefOp"]}, {"filename": "flang/lib/Optimizer/Transforms/ArrayValueCopy.cpp", "functions": ["isAssumedSize"]}]}
{"pr_number": 79041, "url": "https://github.com/llvm/llvm-project/pull/79041", "title": "[FatLTO] output of -ffat-lto-objects -S should be assembly.", "body": "Fat lto with -c compiles to an object file with the IR embedded in a section of the object, the combination of fat-lto with -S should then produce an assembly file equivalent of that. The IR output can still be genreated by using both -S and -emit-llvm.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "clang/lib/Driver/Driver.cpp", "functions": ["if"]}]}
{"pr_number": 78760, "url": "https://github.com/llvm/llvm-project/pull/78760", "title": "[DebugNames] Implement Entry::GetParentEntry query", "body": "This commit introduces a helper function to DWARFAcceleratorTable::Entry which follows DW_IDX_Parent attributes to returns the corresponding parent Entry in the table.\r\n\r\nIt is tested by enhancing dwarfdump so that it now prints:\r\n\r\n1. When data is corrupt.\r\n2. When parent information is present, but the parent is not indexed.\r\n3. The parent entry offset, when the parent is present and indexed. This is printed in terms a real entry offset (the same that gets printed at the start of each entry: \"Entry @ 0x...\"), instead of the encoded number in the table (which is an offset from the start off the Entry list). This makes it easy to visually inspect the dwarfdump and check what the parent is.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/DebugInfo/DWARF/DWARFAcceleratorTable.cpp", "functions": ["lookup"]}]}
{"pr_number": 70996, "url": "https://github.com/llvm/llvm-project/pull/70996", "title": "DEBUGINFOD based DWP acquisition for LLDB", "body": "I've plumbed the LLVM DebugInfoD client into LLDB, and added automatic downloading of DWP files to the SymbolFileDWARF.cpp plugin. If you have DEBUGINFOD_URLS set to a space delimited set of web servers, LLDB will try to use them as a last resort when searching for DWP files. If you do *not* have that environment variable set, nothing should be changed. There's also a setting, per @clayborg 's suggestion, that will override the environment variable, or can be used instead of the environment variable. The setting is why I also needed to add an API to the llvm-debuginfod library\r\n\r\n### Test Plan:\r\n\r\nSuggestions are welcome here. I should probably have some positive and negative tests, but I wanted to get the diff up for people who have a clue what they're doing to rip it to pieces before spending too much time validating the initial implementation.", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Debuginfod/Debuginfod.cpp", "functions": ["WriteGuard", "setDefaultDebuginfodUrls", "ReadGuard"]}, {"filename": "lldb/source/Plugins/SymbolLocator/Debuginfod/SymbolLocatorDebuginfod.cpp", "functions": ["build_id", "GetFileForModule", "FileSpec"]}, {"filename": "lldb/source/Core/PluginManager.cpp", "functions": ["kSymbolLocatorPluginName", "GetSettingForPlugin"]}]}
{"pr_number": 76140, "url": "https://github.com/llvm/llvm-project/pull/76140", "title": "[AMDGPU] Architected SGPRs for GFX12", "body": "Enable architected SGPRs and add a new @llvm.amdgcn.wave.id intrinsic.\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/SIISelLowering.cpp", "functions": ["getPreloadedValue"]}]}
{"pr_number": 79197, "url": "https://github.com/llvm/llvm-project/pull/79197", "title": "[RISCV] Recurse on second operand of two operand shuffles", "body": "This builds on bdc41106ee48dce59c500c9a3957af947f30c8c3.\r\n\r\nThis change completes the migration to a recursive shuffle lowering strategy where when we encounter an unknown two argument shuffle, we lower each operand as a single source permute, and then use a vselect (i.e. a vmerge) to combine the results.  This relies for code quality on the post-isel combine which will aggressively fold that vmerge back into the materialization of the second operand if possible.\r\n\r\nNote: The change includes only the most immediately obvious of the stylistic cleanup.  There's a bunch of code movement that this enables that I'll do as a separate patch as rolling it into this creates an unreadable diff.", "feature_layers": [], "feature_directives": ["for", "single"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVISelLowering.cpp", "functions": ["convertFromScalableVector"]}]}
{"pr_number": 79259, "url": "https://github.com/llvm/llvm-project/pull/79259", "title": "[ConstraintElimination] Use std::move in the constructor (NFC)", "body": "Moving the contents of Coefficients saves 0.43% of heap allocations\nduring the compilation of a large preprocessed file, namely\nX86ISelLowering.cpp, for the X86 target.\n", "feature_layers": [], "feature_directives": ["for", "target"], "files_changed": [{"filename": "llvm/lib/Transforms/Scalar/ConstraintElimination.cpp", "functions": ["Coefficients"]}]}
{"pr_number": 79298, "url": "https://github.com/llvm/llvm-project/pull/79298", "title": "[clang] Incorrect IR involving the use of bcopy", "body": "This patch addresses the issue regarding the call of bcopy function in a conditional expression.\r\nIt is analogous to the already accepted patch which deals with the same problem, just regarding the bzero function [0].\r\n\r\nHere is the testcase which illustrates the issue:\r\n\r\n```\r\nvoid bcopy(const void *, void *, unsigned long);\r\nvoid foo(void);\r\n\r\nvoid test_bcopy() {\r\n  char dst[20];\r\n  char src[20];\r\n  int _sz = 20, len = 20;\r\n  return (_sz\r\n          ? ((_sz >= len)\r\n             ? bcopy(src, dst, len)\r\n             : foo())\r\n          : bcopy(src, dst, len));\r\n}\r\n```\r\n\r\nWhen processing it with clang, following issue occurs:\r\n\r\nInstruction does not dominate all uses!\r\n  %arraydecay2 = getelementptr inbounds [20 x i8], ptr %dst, i64 0, i64 0, !dbg !38\r\n  %cond = phi ptr [ %arraydecay2, %cond.end ], [ %arraydecay5, %cond.false3 ], !dbg !33\r\nfatal error: error in backend: Broken module found, compilation aborted!\r\n\r\nThis happens because an incorrect phi node is created. It is created because bcopy function call is lowered to the call of llvm.memmove intrinsic and function memmove returns void *. Since llvm.memmove is called in two places in the same return statement, clang creates a phi node in the final basic block for the return value and that phi node is incorrect. However, bcopy function should return void in the first place, so this phi node is unnecessary. This is what this patch addresses. An appropriate test is also added and no existing tests fail when applying this patch.\r\n\r\nAlso, this crash only happens when LLVM is configured with -DLLVM_ENABLE_ASSERTIONS=On option.\r\n\r\n[0] https://reviews.llvm.org/D39746", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CodeGen/builtins.c", "functions": ["test_conditional_bcopy", "foo", "__builtin_bcopy"]}]}
{"pr_number": 75865, "url": "https://github.com/llvm/llvm-project/pull/75865", "title": "[lldb] Improve maintainability and readability for ValueObject methods", "body": "As I worked through changes to another PR (https://github.com/llvm/llvm-project/pull/74912), I couldn't help but rewrite a few methods for readability, maintainability, and possibly some behavior correctness too.\r\n\r\n1. Exiting early instead of nested `if`-statements, which:\r\n\t- Reduces indentation levels for all subsequent lines\r\n\t- Treats missing pre-conditions similar to an error\r\n\t- Clearly indicates that the full length of the method is the \"happy path\".\r\n2. Explicitly return empty Value Object shared pointers for those error (like) situations, which\r\n\t- Reduces the time it takes a maintainer to figure out what the method actually returns based on those conditions.\r\n\r\n3. Converting a mix of `if` and `if`-`else`-statements around an enum into one `switch` statement, which:\r\n\t- Consolidates the former branching logic\r\n\t- Lets the compiler warn you of a (future) missing enum case\r\n\t- This one may actually change behavior slightly, because what was an early test for one enum case, now happens later on in the `switch`.\r\n\r\n4. Consolidating near-identical, \"copy-pasta\" logic into one place, which:\r\n\t- Separates the common code to the diverging paths.\r\n\t- Highlights the differences between the code paths.\r\n\r\n\r\n\r\nrdar://119833526\r\n", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "lldb/source/Core/ValueObject.cpp", "functions": ["ValueObjectSP", "exe_ctx", "name", "index_const_str"]}]}
{"pr_number": 79205, "url": "https://github.com/llvm/llvm-project/pull/79205", "title": "[CMake/Bazel] Support usage of opt driver as a library", "body": "In Bazel, Clang current separates the clang executable into a clang-driver library, and the actual clang executable. This allows downstream users to make their own variations of clang, without having to redo/maintain separate build pipelines.\r\n\r\nThis adds the same for opt for both CMake and Bazel.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/tools/opt/opt.cpp", "functions": ["toString", "shouldPinPassToLegacyPM", "ToolOutputFile", "TargetIRAnalysis", "GetCodeGenOptLevel", "runPassPipeline", "main", "ModuleTriple", "EmitModuleHash", "if", "TLII", "M2", "X", "shouldForceLegacyPM", "TimeTracer", "PassPipeline2"]}, {"filename": "llvm/tools/opt/optdriver.cpp", "functions": ["toString", "shouldPinPassToLegacyPM", "ToolOutputFile", "TargetIRAnalysis", "GetCodeGenOptLevel", "TimeTrace", "ModuleTriple", "EmitModuleHash", "if", "TLII", "M2", "X", "Force", "shouldForceLegacyPM", "TimeTracer", "PassPipeline2"]}]}
{"pr_number": 78958, "url": "https://github.com/llvm/llvm-project/pull/78958", "title": "[mlir][Target] Teach dense_resource conversion to LLVMIR Target", "body": "This patch adds support for translating dense_resource attributes to LLVMIR Target.\r\nThe support added is similar to how DenseElementsAttr is handled, except we\r\ndon't need to handle splats.\r\n\r\nAnother possible way of doing this is adding iteration on dense_resource, but that is\r\nnon-trivial as DenseResourceAttr is not meant to be something you should directly\r\naccess. It has subclasses which you are supposed to use to iterate on it.", "feature_layers": ["ir"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "mlir/lib/Target/LLVMIR/ModuleTranslation.cpp", "functions": ["data", "buildSequentialConstant"]}]}
{"pr_number": 78345, "url": "https://github.com/llvm/llvm-project/pull/78345", "title": "[mlir][sparse] setup `SparseIterator` to help generating code to traverse a sparse tensor level.", "body": "", "feature_layers": ["parse", "ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/Transforms/Utils/LoopEmitter.cpp", "functions": ["genAlloca", "SELECT", "guard", "CMPI", "innerArgs", "ADDI"]}, {"filename": "mlir/lib/Dialect/SparseTensor/Transforms/Utils/SparseTensorLevel.cpp", "functions": ["yieldVals", "whileArgs"]}]}
{"pr_number": 79161, "url": "https://github.com/llvm/llvm-project/pull/79161", "title": "[LAA] Drop alias scope metadata that is not valid across iterations", "body": "LAA currently adds memory locations with their original AATags to AST. However, scoped alias AATags may be valid only within one loop iteration, while LAA reasons across iterations.\r\n\r\nFix this by determining which alias scopes are defined inside the loop, and drop AATags that reference these scopes.\r\n\r\nFixes https://github.com/llvm/llvm-project/issues/79137.", "feature_layers": ["ir", "ast"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/Analysis/LoopAccessAnalysis.cpp", "functions": ["Accesses", "TheLoop", "adjustLoc"]}]}
{"pr_number": 78728, "url": "https://github.com/llvm/llvm-project/pull/78728", "title": "[AMDGPU] Update isLegalAddressingMode for GFX12 SMEM loads", "body": "", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/SIISelLowering.cpp", "functions": ["isLegalGlobalAddressingMode"]}]}
{"pr_number": 76119, "url": "https://github.com/llvm/llvm-project/pull/76119", "title": "[Modules] [HeaderSearch] Don't reenter headers if it is pragma once ", "body": "Close https://github.com/llvm/llvm-project/issues/73023\r\n\r\nThe direct issue of https://github.com/llvm/llvm-project/issues/73023 is that we entered a header which is marked as pragma once since the compiler think it is OK if there is controlling macro.\r\n\r\nIt doesn't make sense. I feel like it should be sufficient to skip it after we see the '#pragma once'.\r\n\r\nFrom the context, it looks like the workaround is primarily for ObjectiveC. So we might need reviewers from OC.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/Modules/pr73023.cpp", "functions": ["foo", "sizeof"]}]}
{"pr_number": 76709, "url": "https://github.com/llvm/llvm-project/pull/76709", "title": "[X86][MC] Support Enc/Dec for NF BMI instructions", "body": "Promoted BMI instructions were supported in #73899", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/X86/Disassembler/X86Disassembler.cpp", "functions": ["isNF", "isNFnotMap4"]}]}
{"pr_number": 79247, "url": "https://github.com/llvm/llvm-project/pull/79247", "title": "[mlir][tensor] Enhance SimplifyPackToExpandShape for unit dim cases.", "body": "Progress on https://github.com/openxla/iree/issues/16181", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Tensor/Transforms/PackAndUnpackPatterns.cpp", "functions": ["getNumGtOneDims", "success", "failure", "isPack1DSrc"]}]}
{"pr_number": 79103, "url": "https://github.com/llvm/llvm-project/pull/79103", "title": "[RISCV][CostModel] Refine Arithmetic reduction costs", "body": "This patch is split off from #77342\r\n\r\n- Correct for CodeSize cost that 1 instruction is not included. 3 is from {VMV.S, ReductionOp, VMV.X}\r\n- Add SplitCost\r\n Unordered reduction chain a series of VADD/VFADD/... which scales with LMUL.\r\n Ordered reductions chain a series of VFREDOSUMs.\r\n- Use MVT to estimate VL.", "feature_layers": [], "feature_directives": ["for", "ordered"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp", "functions": ["getRISCVInstructionCost"]}]}
{"pr_number": 70338, "url": "https://github.com/llvm/llvm-project/pull/70338", "title": "[clang-format] Option to ignore macro definitions", "body": "Sometimes macro definitions contain a layout we don't want to change in any context. This PR adds a new style option `IgnorePPDefinitions` that prevents clang-format from touching macro definitions.\r\n\r\nThis PR addresses issue #67991 \r\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Format/UnwrappedLineFormatter.cpp", "functions": ["LineContainsPPDefinition"]}]}
{"pr_number": 77744, "url": "https://github.com/llvm/llvm-project/pull/77744", "title": "[RISCV] Implement foward inserting save/restore FRM instructions.", "body": "Previously, RISCVInsertReadWriteCSR inserted an FRM swap for any value other than 7 and restored the original value right after the vector instruction. This is inefficient if multiple vector instructions use the same rounding mode or if the next vector instruction uses a different explicit rounding mode.\r\n\r\nThis patch implements a local optimization to solve the above problem. We assume the starting rounding mode of the basic block is \"dynamic.\" When iterating through a basic block and encountering an instruction whose rounding mode is not the same as the current rounding mode, we change the current rounding mode and save the current rounding mode if needed. And we may need to restore FRM when encountering function call, inline asm and some uses of FRM.\r\n\r\nThe advanced version of this is to perform cross basic block analysis for the starting rounding mode of each basic block.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVInsertReadWriteCSR.cpp", "functions": ["emitWriteRoundingModeOpt"]}]}
{"pr_number": 76004, "url": "https://github.com/llvm/llvm-project/pull/76004", "title": "[TableGen] Add predicates for immediates comparison", "body": "These predicates can be used to represent `<`, `<=`, `>`, `>=`.\n\nAnd a predicate for `in range` is added.\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/utils/TableGen/PredicateExpander.cpp", "functions": ["expandCheckImmOperandLT", "expandCheckImmOperandGT"]}]}
{"pr_number": 66505, "url": "https://github.com/llvm/llvm-project/pull/66505", "title": "ValueTracking: Identify implied fp classes by general fcmp", "body": "    Previously we could recognize exact class tests performed by\r\n    an fcmp with special values (0s, infs and smallest normal).\r\n    Expand this to recognize the implied classes by a compare with a general\r\n    constant. e.g. fcmp ogt x, 1 implies positive and non-0.\r\n    \r\n    The API should be better merged with fcmpToClassTest but that\r\n    made the diff way bigger, will try to do that in a future\r\n    patch.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Analysis/ValueTracking.cpp", "functions": ["fcmpImpliesClass"]}]}
{"pr_number": 78988, "url": "https://github.com/llvm/llvm-project/pull/78988", "title": "[mlir][IR] Add rewriter API for moving operations", "body": "The pattern rewriter documentation states that \"*all* IR mutations [...] are required to be performed via the `PatternRewriter`.\" This commit adds two functions that were missing from the rewriter API: `moveOpBefore` and `moveOpAfter`.\r\n\r\nAfter an operation was moved, the `notifyOperationInserted` callback is triggered. This allows listeners such as the greedy pattern rewrite driver to react to IR changes.\r\n\r\nThis commit narrows the discrepancy between the kind of IR modification that can be performed and the kind of IR modifications that can be listened to.\r\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Optimizer/HLFIR/Transforms/BufferizeHLFIR.cpp", "functions": ["notifyOperationInserted"]}, {"filename": "mlir/lib/Dialect/Bufferization/Transforms/Bufferize.cpp", "functions": ["notifyOperationInserted"]}, {"filename": "mlir/lib/Dialect/Linalg/TransformOps/LinalgTransformOps.cpp", "functions": ["notifyOperationInserted"]}, {"filename": "mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp", "functions": ["notifyOperationInserted"]}, {"filename": "mlir/test/lib/IR/TestClone.cpp", "functions": ["notifyOperationInserted"]}, {"filename": "mlir/test/lib/Transforms/TestConstantFold.cpp", "functions": ["notifyOperationInserted"]}]}
{"pr_number": 79325, "url": "https://github.com/llvm/llvm-project/pull/79325", "title": "[AMDGPU] New llvm.amdgcn.wave.id intrinsic", "body": "This is only valid on targets with architected SGPRs.\n", "feature_layers": [], "feature_directives": ["target"], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp", "functions": ["legalizeWaveID"]}, {"filename": "llvm/lib/Target/AMDGPU/SIISelLowering.cpp", "functions": ["SL", "lowerWaveID"]}]}
{"pr_number": 79179, "url": "https://github.com/llvm/llvm-project/pull/79179", "title": "[flang] Lower struct ctor with character allocatable components", "body": "There is no need to gather the length parameters from the parameter symbols when facing a deferred length allocatable components in a structure constructor, the length is set as part of the assignment given the value.\r\n\r\nRemove the checks for derived type runtime info symbols, this is not relevant for what is being tested here.", "feature_layers": ["runtime"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Lower/ConvertExprToHLFIR.cpp", "functions": ["hasDeferredCharacterLength"]}]}
{"pr_number": 74828, "url": "https://github.com/llvm/llvm-project/pull/74828", "title": "[Flang] Minloc elemental intrinsic lowering", "body": "Currently the lowering of a minloc intrinsic with a mask will look something like\r\n```\r\n  %e = hlfir.elemental %shape ({\r\n    ...\r\n  })\r\n  %m = hlfir.minloc %array mask %e\r\n  hlfir.assign %m to %result\r\n  hlfir.destroy %m\r\n```\r\nThe elemental will be expanded into a temporary+loop, the minloc into a\r\nFortranAMinloc call (which hopefully gets simplified to a specialized call that\r\ncan be inlined at the call site), and the assign might get expanded to a\r\nFortranAAssign. The assign we could inline too, but it would be better to\r\ngenerate the entire construct as single loop if we can - one that performs the\r\nminloc calculation with the mask elemental computed inline and assigns directly\r\nto the output array.\r\n\r\nThis patch attempt to do that, adding a hlfir version of the expansion code\r\nfrom SimplifyIntrinsics that turns an assign+minloc+elemental into a single\r\ncombined loop nest. It attempts to reuse the methods in genMinlocReductionLoop\r\nfor constructing the loop with a modified loop body. The declaration for the\r\nfunction is currently in Optimizer/Support/Utils.h, but there might be a better\r\nplace for it.\r\n\r\nIt is currently added as port of the OptimizedBufferizationPass. I originally\r\nhad it as part of the SimplifyHLFIRIntrinsics pass, but there were already some\r\nmethods doing similar things in OptimizedBufferization. It just needs to happen\r\nbefore the elementals are expanded. I think I would like to do a similar thing\r\nfor maxloc and any/all/count too if this looks OK. I will rebase over #74436\r\nonce that goes in.", "feature_layers": ["ir"], "feature_directives": ["for", "single"], "files_changed": [{"filename": "flang/lib/Optimizer/HLFIR/Transforms/OptimizedBufferization.cpp", "functions": ["if"]}, {"filename": "flang/lib/Optimizer/Transforms/SimplifyIntrinsics.cpp", "functions": ["resultShape"]}]}
{"pr_number": 79262, "url": "https://github.com/llvm/llvm-project/pull/79262", "title": "[mlir][tensor] Enhance SimplifyUnPackToCollapseShape for unit dim cases.", "body": "Progress on https://github.com/openxla/iree/issues/16181", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Tensor/Transforms/PackAndUnpackPatterns.cpp", "functions": ["failure", "success", "isPack1DSrc"]}]}
{"pr_number": 67948, "url": "https://github.com/llvm/llvm-project/pull/67948", "title": "[clang] Add test for CWG472", "body": "https://cplusplus.github.io/CWG/issues/472.html\r\nIt has drafting status, but I think CWG has reached consesus on the behavior.\r\nRelated: #16602 ", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CXX/drs/dr4xx.cpp", "functions": ["f"]}]}
{"pr_number": 79172, "url": "https://github.com/llvm/llvm-project/pull/79172", "title": "[mlir][ArmSME] Refactor ArmSMEToSCF to used shared loop-building helper (NFC)", "body": "This will make fixing a bug (next patch) a change to one place, rather than fixing three separate rewrites.\r\n\r\nNote: `TileLoadOpWithMaskAndPadZeroConversion` has been merged into `TileLoadOpConversion`, since after this change those two rewrites were pretty much identical.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Conversion/ArmSMEToSCF/ArmSMEToSCF.cpp", "functions": ["g", "success", "guard"]}]}
{"pr_number": 79164, "url": "https://github.com/llvm/llvm-project/pull/79164", "title": "[reland][mlir][amdgpu] Shared memory access optimization pass", "body": "- Reland: https://github.com/llvm/llvm-project/pull/75627\r\n\r\n- Reproduced then fixed the build issue", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/AMDGPU/IR/AMDGPUDialect.cpp", "functions": ["isSharedMemoryAddressSpace"]}, {"filename": "mlir/lib/Dialect/AMDGPU/Transforms/OptimizeSharedMemory.cpp", "functions": ["failure", "runOnOperation", "success", "builder"]}]}
{"pr_number": 77763, "url": "https://github.com/llvm/llvm-project/pull/77763", "title": "[SelectionDAG] Add space-optimized forms of OPC_CheckPredicate", "body": "We record the usage of each `Predicate` and sort them by usage.\r\n\r\nFor the top 8 `Predicate`s, we will emit a `PC_CheckPredicateN` to\r\nsave one byte.\r\n\r\nOverall this reduces the llc binary size with all in-tree targets by\r\nabout 61K.\r\n\r\nThis is a recommit of 1a57927, which was reverted in bc98c31.\r\n\r\nThe CI failures occurred when doing expensive checks (with option\r\n`LLVM_ENABLE_EXPENSIVE_CHECKS` being ON).\r\n\r\nThe key point here is that we need stable sorting result in the\r\ntest, but doing expensive checks uncovered the non-determinism of\r\n`llvm::sort`. So `llvm::sort` is changed to `llvm::stable_sort`\r\nin this revised patch.\r\n\r\nAnd we use `llvm::MapVector` to keep insertion order.", "feature_layers": [], "feature_directives": ["for", "target"], "files_changed": [{"filename": "llvm/utils/TableGen/DAGISelMatcherEmitter.cpp", "functions": ["Pred", "if", "PredFn", "getNodePredicate"]}]}
{"pr_number": 75414, "url": "https://github.com/llvm/llvm-project/pull/75414", "title": "[libc] Move printf long double to simple calc", "body": "The Ryu algorithm is very fast with its table, but that table grows too\nlarge for long doubles. This patch adds a method of calculating the\ndigits of long doubles using just wide integers and fast modulo\noperations. This results in significant performance improvements vs the\nprevious int calc mode, while taking up a similar amound of peak memory.\nIt will be slow in some %e/%g cases, but reasonable fast for %f with no\nloss of accuracy.\n\n", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "libc/test/src/stdio/sprintf_test.cpp", "functions": ["r"]}]}
{"pr_number": 79235, "url": "https://github.com/llvm/llvm-project/pull/79235", "title": "[Object][Wasm] Allow parsing of GC types in type and table sections", "body": "This change allows a WasmObjectFile to be created from a wasm file even if it uses typed funcrefs and GC types.\r\nIt does not significantly change how lib/Object models its various internal types (e.g. WasmSignature,\r\nWasmElemSegment), so LLVM does not really \"support\" or understand such files, but it is sufficient to parse\r\nthe type, global and element sections, discarding types that are not understood. This is useful for low-level binary\r\ntools such as nm and objcopy, which use only limited aspects of the binary (such as function definitions) or deal\r\nwith sections as opaque blobs.\r\n\r\nThis is done by allowing `WasmValType` to have a value of `OTHERREF` (representing any unmodeled reference\r\ntype), and adding a field to `WasmSignature` indicating it's a placeholder for an unmodeled reference type (since\r\nthere is a 1:1 correspondence between WasmSignature objects and types in the type section). \r\nThen the object file parsers for the type and element sections are expanded to parse encoded reference types and\r\ndiscard any unmodeled fields.", "feature_layers": ["parse", "parser"], "feature_directives": ["for", "sections"], "files_changed": [{"filename": "llvm/lib/Object/WasmObjectFile.cpp", "functions": ["parseValType"]}]}
{"pr_number": 76178, "url": "https://github.com/llvm/llvm-project/pull/76178", "title": "Allow the use of `if constexpr` in dialects after C++11.", "body": "This change enables that by disabling the C++17 extensions warning\nin the test suite and by adding documentation and testing for the use of\nthis extension.\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "libcxx/test/libcxx/extensions/test-cxx17-extensions.pass.cpp", "functions": ["CheckIfConstexpr", "main", "constexpr"]}]}
{"pr_number": 79468, "url": "https://github.com/llvm/llvm-project/pull/79468", "title": "[RISCV] Disable exact VLEN splitting for bitrotate shuffles", "body": "If we have a bitrotate shuffle, this is also by definition a vreg splitable shuffle when exact VLEN is known.  However, there's no profit to be had from splitting the wider bitrotate lowering into individual m1 pieces.  We'd rather leave it the higher lmul to reduce code size.\r\n\r\nThis is a general problem for any linear-in-LMUL shuffle expansions when the vreg splitting still has to do linear work per piece.  On first reflection it seems like element rotation might have the same interaction, but in that case, splitting can be done via a set of whole register moves (which may get folded into the consumer depending) which at least as good as a pair of slideup/slidedown.  I think that bitrotate is the only shuffle expansion we have that actually needs handled here.", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVISelLowering.cpp", "functions": ["SDValue", "DL"]}]}
{"pr_number": 78637, "url": "https://github.com/llvm/llvm-project/pull/78637", "title": "[AArch64] Combine store (trunc X to <3 x i8>) to sequence of ST1.b.", "body": "Improve codegen for (trunc X to <3 x i8>) by converting it to a sequence of 3 ST1.b, but first converting the truncate operand to either v8i8 or v16i8, extracting the lanes for the truncate results and storing them.\r\n\r\nAt the moment, there are almost no cases in which such vector operations will be generated automatically. The motivating case is non-power-of-2 SLP vectorization: https://github.com/llvm/llvm-project/pull/77790", "feature_layers": ["codegen", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AArch64/AArch64ISelLowering.cpp", "functions": ["SDValue", "DL"]}]}
{"pr_number": 79334, "url": "https://github.com/llvm/llvm-project/pull/79334", "title": "[tsan] Lazily call 'personality' to minimize sandbox violations", "body": "My previous patch, \"Re-exec TSan with no ASLR if memory layout is incompatible on Linux (#78351)\" (0784b1eefa36d4acbb0dacd2d18796e26313b6c5) hoisted the 'personality' call, to\nshare the code between Android and non-Android Linux. Unfortunately, this eager call to\n'personality' may trigger sandbox violations on non-Android Linux.\n\nThis patch fixes the issue by only calling 'personality' on non-Android Linux if the\nmemory mapping is incompatible. This may still cause a sandbox violation, but only if it\nwas going to abort anyway due to an incompatible memory mapping.\n\n(The behavior on Android Linux is unchanged by this patch or the previous patch.)\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "compiler-rt/test/sanitizer_common/TestCases/Linux/sandbox_forbidden_functions.cpp", "functions": ["main"]}]}
{"pr_number": 79239, "url": "https://github.com/llvm/llvm-project/pull/79239", "title": "[ELF] Implement R_RISCV_TLSDESC for RISC-V", "body": "Support\nR_RISCV_TLSDESC_HI20/R_RISCV_TLSDESC_LOAD_LO12/R_RISCV_TLSDESC_ADD_LO12/R_RISCV_TLSDESC_CALL.\nLOAD_LO12/ADD_LO12/CALL relocations reference a label at the HI20\nlocation, which requires special handling. We save the value of HI20 to\nbe reused. Two interleaved TLSDESC code sequences, which compilers do\nnot generate, are unsupported.\n\nFor -no-pie/-pie links, TLSDESC to initial-exec or local-exec\noptimizations are eligible. Implement the relevant hooks\n(R_RELAX_TLS_GD_TO_LE, R_RELAX_TLS_GD_TO_IE): the first two instructions\nare converted to NOP while the latter two are converted to a GOT load or\na lui+addi.\n\nThe first two instructions, which would be converted to NOP, are removed\ninstead in the presence of relaxation. Relaxation is eligible as long as\nthe R_RISCV_TLSDESC_HI20 relocation has a pairing R_RISCV_RELAX,\nregardless of whether the following instructions have a R_RISCV_RELAX.\nIn addition, for the TLSDESC to LE optimization (`lui a0,<hi20>; addi a0,a0,<lo12>`),\n`lui` can be removed (i.e. use the short form) if hi20 is 0.\n\n```\n// TLSDESC to LE/IE optimization\n.Ltlsdesc_hi2:\n  auipc a4, %tlsdesc_hi(c)                      # if relax: remove; otherwise, NOP\n  load  a5, %tlsdesc_load_lo(.Ltlsdesc_hi2)(a4) # if relax: remove; otherwise, NOP\n  addi  a0, a4, %tlsdesc_add_lo(.Ltlsdesc_hi2)  # if LE && !hi20 {if relax: remove; otherwise, NOP}\n  jalr  t0, 0(a5), %tlsdesc_call(.Ltlsdesc_hi2)\n  add   a0, a0, tp\n```\n\nThe implementation carefully ensures that an instruction unrelated to\nthe current TLSDESC code sequence, if immediately follows a removable\ninstruction (HI20 or LOAD_LO12 OR (LE-specific) ADD_LO12), is not\nconverted to NOP.\n\n* `riscv64-tlsdesc.s` is inspired by `i386-tlsdesc-gd.s` (https://reviews.llvm.org/D112582).\n* `riscv64-tlsdesc-relax.s` tests linker relaxation.\n* `riscv-tlsdesc-gd-mixed.s` is inspired by `x86-64-tlsdesc-gd-mixed.s` (https://reviews.llvm.org/D116900).\n\nLink: https://github.com/riscv-non-isa/riscv-elf-psabi-doc/pull/373\n", "feature_layers": ["ir"], "feature_directives": ["for", "requires"], "files_changed": [{"filename": "lld/ELF/Arch/RISCV.cpp", "functions": ["tlsdescToLe", "tlsdescToIe"]}]}
{"pr_number": 79373, "url": "https://github.com/llvm/llvm-project/pull/79373", "title": "[NVPTX] Add support for -march=native in standalone NVPTX", "body": "Summary:\nWe support `--target=nvptx64-nvidia-cuda` as a way to target the NVPTX\narchitecture from standard CPU. This patch simply uses the existing\nsupport for handling `--offload-arch=native` to also apply to the\nstandalone toolchain.\n", "feature_layers": [], "feature_directives": ["for", "target"], "files_changed": [{"filename": "clang/lib/Driver/ToolChains/Cuda.cpp", "functions": ["getArchName"]}]}
{"pr_number": 78764, "url": "https://github.com/llvm/llvm-project/pull/78764", "title": "[mlir][flang][openacc] Add device_type support for update op", "body": "Add support for device_type information on the acc.update operation and update lowering from Flang. ", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/OpenACC/IR/OpenACC.cpp", "functions": ["failure"]}]}
{"pr_number": 79496, "url": "https://github.com/llvm/llvm-project/pull/79496", "title": "[BOLT] Report input staleness", "body": "It's beneficial to have uniform reporting in both `infer-stale-profile`\r\non and off cases, primarily for logging purposes.\r\n\r\nWithout this change, BOLT would report \"input\" staleness in\r\n`infer-stale-profile=0` case (without matching), and \"output\" staleness\r\nin `infer-stale-profile=1` case (after matching).\r\n\r\nThis change makes BOLT report \"input\" staleness in both cases. \"Output\"\r\nstaleness information is printed separately with \"BOLT-INFO: inferred\r\nprofile...\"", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "bolt/lib/Passes/BinaryPasses.cpp", "functions": ["format"]}]}
{"pr_number": 78522, "url": "https://github.com/llvm/llvm-project/pull/78522", "title": "[flang][runtime] Catch error on Ew.0 output editing", "body": "An Ew.0(Ee) or Ew.0(Ee) output edit descriptor with a scale factor of zero is an error condition, unless the output edit descriptor was originally Gw.0(Ee), list-directed, or just E0/D0 with no .d part.\r\n\r\nFixes https://github.com/llvm/llvm-project/issues/78390.", "feature_layers": ["runtime", "ir"], "feature_directives": [], "files_changed": [{"filename": "flang/runtime/edit-output.cpp", "functions": ["EditEorDOutput", "EditFOutput"]}]}
{"pr_number": 79395, "url": "https://github.com/llvm/llvm-project/pull/79395", "title": "[BOLT][DWARF] Add option to specify DW_AT_comp_dir", "body": "Added an --comp-dir-override option that overrides DW_AT_comp_dir in the unit die. This allows for llvm-bolt to be invoked from any category and still find .dwo files.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "bolt/lib/Rewrite/DWARFRewriter.cpp", "functions": ["if"]}]}
{"pr_number": 78944, "url": "https://github.com/llvm/llvm-project/pull/78944", "title": "[ELF] Add internal InputFile", "body": "Based on https://reviews.llvm.org/D45375 . Introduce a new InputFile\nkind `InternalKind`, use it for\n\n* `ctx.internalFile`: for linker-defined symbols and some synthesized `Undefined`\n* `createInternalFile`: for symbol assignments and --defsym\n\nI picked \"internal\" instead of \"synthetic\" to avoid confusion with\nSyntheticSection.\n\nCurrently a symbol's file is one of: nullptr, ObjKind, SharedKind,\nBitcodeKind, BinaryKind. Now it's non-null (I plan to add an\n`assert(file)` to Symbol::Symbol and change `toString(const InputFile *)`\nseparately).\n\nDebugging and error reporting gets improved. The immediate user-facing\ndifference is more descriptive \"File\" column in the --cref output. This\npatch may unlock further simplification.\n\nCurrently each symbol assignment gets its own\n`createInternalFile(cmd->location)`. Two symbol assignments in a linker\nscript do not share the same file. Making the file the same would be\nnice, but would require non trivial code.\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "lld/ELF/LinkerScript.cpp", "functions": ["newSym"]}, {"filename": "lld/ELF/Relocations.cpp", "functions": ["dummy"]}, {"filename": "lld/ELF/Target.cpp", "functions": ["dummy"]}]}
{"pr_number": 78745, "url": "https://github.com/llvm/llvm-project/pull/78745", "title": "[flang][runtime] Use std::fmod for most MOD/MODULO", "body": "The new accurate algorithm for real MOD and MODULO in the runtime is not as fast as std::fmod(), which is also accurate.  So use std::fmod() for those floating-point types that it supports.\r\n\r\nFixes https://github.com/llvm/llvm-project/issues/78641.", "feature_layers": ["runtime", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/runtime/numeric.cpp", "functions": ["constexpr"]}]}
{"pr_number": 76905, "url": "https://github.com/llvm/llvm-project/pull/76905", "title": "[BOLT] Deduplicate equal offsets in BAT", "body": "Encode BRANCHENTRY bits as bitmask for deduplicated entries.\n\nReduces BAT section size:\n- large binary: to 11834216 bytes (0.31x original),\n- medium binary: to 1565584 bytes (0.26x original),\n- small binary: to 336 bytes (0.23x original).\n\nTest Plan: Updated bolt/test/X86/bolt-address-translation.test\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "bolt/lib/Profile/BoltAddressTranslation.cpp", "functions": ["errorToErrorCode", "make_error_code", "Err"]}]}
{"pr_number": 78854, "url": "https://github.com/llvm/llvm-project/pull/78854", "title": "[flang] Get base objects right in definability checker", "body": "The utility function GetRelevantObject() seems to be just wrong for definability checks for the \"base object\" of a designator, and that's all for which it is (now?) used.  This leads to some false error messages in Whizard when data-refs with multiple pointer components are defined.  Simplify, and add more test cases.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Semantics/definable.cpp", "functions": ["WhyNotDefinableBase", "WhyNotDefinable", "WhyNotDefinableLast", "GetRelevantSymbol", "DefinesComponentPointerTarget"]}]}
{"pr_number": 68926, "url": "https://github.com/llvm/llvm-project/pull/68926", "title": "[SystemZ][z/OS] This change adds support for the PPA2 section in zOS", "body": "This PR adds support for the PPA2 fields.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp", "functions": ["getProductID"]}]}
{"pr_number": 79364, "url": "https://github.com/llvm/llvm-project/pull/79364", "title": "[flang] Improve USE merging of homonymous types, interfaces, and proc\u2026", "body": "\u2026edures\r\n\r\nFortran allows a generic interface to have the same name as a derived type in the same scope.  It also allows a generic interface to have the same name as one of its specific procedures.\r\n\r\nWhen two modules define the same name, possibly more than once each, things get exciting.  The standard is not clear, and other compilers do variously different things.  We are currently emitting some errors prematurely for some usage in pfUnit due to how it combines two versions of a package together via USE association.\r\n\r\nThis patch handles combinations of derived types and generic interfaces and their specific procedures in a more principled way.  Errors due to ambiguity are deferred to actual usage of derived types and specific procedures -- and when they're not used, the program is unambiguous and no error issues.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Semantics/resolve-names.cpp", "functions": ["HadUseError"]}]}
{"pr_number": 79098, "url": "https://github.com/llvm/llvm-project/pull/79098", "title": "[mlir][bufferization] Fix SimplifyClones with dealloc before cloneOp", "body": "The SimplifyClones pass relies on the assumption that the deallocOp follows the cloneOp. However, a crash occurs when there is a redundantDealloc preceding the cloneOp. This PR addresses the issue by ensuring the presence of deallocOp after cloneOp. The verification is performed by checking if the loop of the sub sequent node of cloneOp reaches the tail of the list.\r\n\r\nFix #74306", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Bufferization/IR/BufferizationOps.cpp", "functions": ["failure"]}]}
{"pr_number": 76551, "url": "https://github.com/llvm/llvm-project/pull/76551", "title": "[RISCV] Support __riscv_v_fixed_vlen for vbool types.", "body": "This adopts a similar behavior to AArch64 SVE, where bool vectors are represented as a vector of chars with 1/8 the number of elements. This ensures the vector always occupies a power of 2 number of bytes.\r\n\r\nA consequence of this is that vbool64_t, vbool32_t, and vool16_t can only be used with a vector length that guarantees at least 8 bits.", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/AST/ASTContext.cpp", "functions": ["if"]}, {"filename": "clang/test/CodeGen/attr-riscv-rvv-vector-bits-bitcast.c", "functions": ["read_bool1", "write_bool1", "__attribute__"]}, {"filename": "clang/test/CodeGen/attr-riscv-rvv-vector-bits-call.c", "functions": ["__riscv_vmand", "__attribute__", "call_bool4_ff", "call_bool1_ss", "call_bool4_fs", "call_bool1_fs", "call_bool4_ss", "call_bool1_ff"]}, {"filename": "clang/test/CodeGen/attr-riscv-rvv-vector-bits-cast.c", "functions": ["from_vbool32_t", "to_vbool32_t", "to_vbool1_t", "__attribute__", "to_vbool4_t", "from_vbool1_t", "from_vbool4_t"]}, {"filename": "clang/test/CodeGen/attr-riscv-rvv-vector-bits-codegen.c", "functions": ["test_bool1", "__riscv_vadd", "__attribute__", "address_of_array_idx_bool4", "test_bool4", "address_of_array_idx_bool1", "address_of_array_idx_bool32", "test_bool32"]}, {"filename": "clang/test/CodeGen/attr-riscv-rvv-vector-bits-globals.c", "functions": ["read_global_bool4", "read_global_bool1", "write_global_bool4", "read_global_bool32", "write_global_bool32", "__attribute__", "write_global_bool1"]}, {"filename": "clang/test/CodeGen/attr-riscv-rvv-vector-bits-types.c", "functions": ["__attribute__"]}, {"filename": "clang/test/CodeGenCXX/riscv-mangle-rvv-fixed-vectors.cpp", "functions": ["bool64", "bool16", "bool4", "bool1", "__attribute__", "bool2", "bool8", "bool32"]}, {"filename": "clang/test/Sema/attr-riscv-rvv-vector-bits.c", "functions": ["to_fixed_bool1_t__from_vuint8m1_t", "__attribute__"]}]}
{"pr_number": 70012, "url": "https://github.com/llvm/llvm-project/pull/70012", "title": "[RISCV] Macro-fusion support for veyron-v1 CPU.", "body": "Support was added for the following fusions:\r\n  auipc-addi, slli-srli, ld-add\r\nSome parts of the code became repetative, so small refactoring of existing lui-addi fusion was done.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVMacroFusion.cpp", "functions": ["checkRegisters", "isLDADD"]}]}
{"pr_number": 77874, "url": "https://github.com/llvm/llvm-project/pull/77874", "title": "[mlir][TilingInterface] Use `LoopLikeOpInterface` in tiling using SCF to unify tiling with `scf.for` and `scf.forall`.", "body": "Using `LoopLikeOpInterface` as the basis for the implementation unifies all the tiling logic for both `scf.for` and `scf.forall`. The only difference is the actual loop generation. This is a follow up to https://github.com/llvm/llvm-project/pull/72178\r\nInstead of many entry points for each loop type, the loop type is now passed as part of the options passed to the tiling method.\r\n\r\nThis is a breaking change with the following changes\r\n\r\n1) The `scf::tileUsingSCFForOp` is renamed to `scf::tileUsingSCF`\r\n2) The `scf::tileUsingSCFForallOp` is deprecated. The same\r\n   functionality is obtained by using `scf::tileUsingSCF` and setting\r\n   the loop type in `scf::SCFTilingOptions` passed into this method to\r\n   `scf::SCFTilingOptions::LoopType::ForallOp` (using the\r\n   `setLoopType` method).\r\n3) The `scf::tileConsumerAndFusedProducerGreedilyUsingSCFForOp` is\r\n   renamed to `scf::tileConsumerAndFuseProducerUsingSCF`. The use of\r\n   the `controlFn` in `scf::SCFTileAndFuseOptions` allows implementing\r\n   any strategy with the default callback implemeting the greedy fusion.\r\n4) The `scf::SCFTilingResult` and `scf::SCFTileAndFuseResult` now use\r\n   `SmallVector<LoopLikeOpInterface>`.\r\n5) To make `scf::ForallOp` implement the parts of\r\n   `LoopLikeOpInterface` needed, the `getOutputBlockArguments()`\r\n   method is replaced with `getRegionIterArgs()`\r\n\r\nThese changes now bring the tiling and fusion capabilities using `scf.forall` on par with what was already supported by `scf.for` ", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/SCF/IR/SCF.cpp", "functions": ["g", "resultStride"]}, {"filename": "mlir/lib/Dialect/SCF/Transforms/TileUsingInterface.cpp", "functions": ["g", "resultStride"]}, {"filename": "mlir/test/lib/Interfaces/TilingInterface/TestTilingInterfaceTransformOps.cpp", "functions": ["failure", "failed", "success", "loopOps"]}, {"filename": "mlir/lib/Transforms/Utils/LoopInvariantCodeMotionUtils.cpp", "functions": ["failure"]}]}
{"pr_number": 79109, "url": "https://github.com/llvm/llvm-project/pull/79109", "title": "[PowerPC] Diagnose invalid combination with Altivec, VSX and soft-float", "body": "Moved from https://reviews.llvm.org/D126302\r\n\r\nThe current behaviour with these three options is quite undesirable:\r\n-mno-altivec -mvsx allows VSX to override no Altivec, thereby turning on both\r\n-msoft-float -maltivec causes a crash if an actual Altivec instruction is required because soft float turns of Altivec\r\n-msoft-float -mvsx is also accepted with both Altivec and VSX turned off (potentially causing crashes as above)\r\n\r\nThis patch diagnoses these impossible combinations in the driver so the user does not end up with surprises in terms of their options being ignored or silently overridden.\r\n\r\nFixes https://github.com/llvm/llvm-project/issues/55556", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "clang/test/CodeGen/PowerPC/attr-target-ppc.c", "functions": ["__attribute__"]}]}
{"pr_number": 77293, "url": "https://github.com/llvm/llvm-project/pull/77293", "title": "[X86] Support promoted ENQCMD, KEYLOCKER and USERMSR", "body": "R16-R31 was added into GPRs in https://github.com/llvm/llvm-project/pull/70958,\r\nThis patch supports the promoted ENQCMD, KEYLOCKER and USER-MSR instructions in EVEX space.\r\n\r\nRFC: https://discourse.llvm.org/t/rfc-design-for-apx-feature-egpr-and-ndd-support/73031/4", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/utils/TableGen/X86DisassemblerTables.cpp", "functions": ["if"]}, {"filename": "llvm/lib/Target/X86/Disassembler/X86Disassembler.cpp", "functions": ["consume"]}]}
{"pr_number": 78088, "url": "https://github.com/llvm/llvm-project/pull/78088", "title": "[Clang][Sema] fix crash of attribute transform", "body": "Try to fix [issue](https://github.com/llvm/llvm-project/issues/73619)\r\n\r\n1. During transforming `FunctionProtoType`, if `ThisContext` is `nullptr` and `CurrentContext` is `ClassTemplateSpecializationDecl`, Constructor of `CXXThisScopeRAII` and `Sema::getCurrentThisType` won't set `CXXThisTypeOverride` of Sema. This will lead to building `this` in `RebuildCXXThisExpr` with a invalid type(NULL type) and cause crash.\r\n2. During transforming attribute type, if `modifiedType` of attribute type is changed, `EquivalentType` need to be transformed. If `EquivalentType` is `FunctionProtoType`, its `ParamVarDecl` will not be copyed(but parameter num does) and will not be instanced in `TransformFunctionTypeParams` since `ParamVarDecl` is `nullptr`. This will lead to crash in `findInstantiationOf`(can't find the instance of `ParamVarDecl`).\r\n\r\nThis patch tries to fix these issues above.\r\n\r\n1. If `CurrentContext` is `ClassTemplateSpecializationDecl`, Use it.\r\n2. Use `EquivalentTypeLoc` instead of `EquivalentType` since it has parameter info. But, if use current `TypeLocBuilder`, it will crash in `TypeLocBuilder::push` since `LastType` is mismatch. Use an auxiliary `TypeLocBuilder` instead and get transformed `EquivalentType`.", "feature_layers": ["sema", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/Sema/attr-lifetimebound-no-crash.cpp", "functions": ["main"]}]}
{"pr_number": 79472, "url": "https://github.com/llvm/llvm-project/pull/79472", "title": "[mlir][IR] Change `notifyBlockCreated` to `notifyBlockInserted`", "body": "This change makes the callback consistent with `notifyOperationInserted`: both now notify about IR insertion, not IR creation. See also #78988.\r\n\r\nThis change also simplifies the dialect conversion: it is no longer necessary to override the `inlineRegionBefore` method. All information that is necessary for rollback is provided with the `notifyBlockInserted` callback.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Optimizer/HLFIR/Transforms/BufferizeHLFIR.cpp", "functions": ["notifyBlockCreated"]}, {"filename": "mlir/lib/Transforms/Utils/DialectConversion.cpp", "functions": ["notifyCreatedBlock"]}, {"filename": "mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp", "functions": ["notifyBlockCreated"]}]}
{"pr_number": 77885, "url": "https://github.com/llvm/llvm-project/pull/77885", "title": "[LoopInterchange] Forbid interchange if load store type wider than element type", "body": "Consider the following case, interchange is not valid as the store type(int) is wider than the array element type(char).\r\n\r\n    char p[7];\r\n    for (int j = 0; j < 2; ++j)\r\n      for (int i = 0; i < 2; ++i)\r\n        *((int*)&p[2*i+j]) = 2*i+j+1;", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Scalar/LoopInterchange.cpp", "functions": ["isWiderLoadStore"]}]}
{"pr_number": 79074, "url": "https://github.com/llvm/llvm-project/pull/79074", "title": "[flang][runtime] Implement SLEEP intrinsic", "body": "This intrinsic is a gnu extension. See\r\nhttps://gcc.gnu.org/onlinedocs/gfortran/SLEEP.html\r\n\r\nThis intrinsic is used in minighost: https://github.com/Mantevo/miniGhost/blob/c2102b521568a74862fa5abb074b1fc8041fc222/ref/MG_UTILS.F#L606", "feature_layers": ["runtime"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/runtime/extensions.cpp", "functions": ["RTNAME"]}]}
{"pr_number": 78113, "url": "https://github.com/llvm/llvm-project/pull/78113", "title": "[VPlan] Add new VPScalarCastRecipe, use for IV & step trunc.", "body": "Add a new recipe to model scalar cast instructions, without relying on an underlying instruction.\r\n\r\nThis allows creating scalar casts, without  relying on an underlying instruction (like the current \r\nVPReplicateRecipe). The new recipe is used to explicitly model both truncating the induction step \r\nand the VPDerivedIVRecipe, thus simplifying both the recipe and code needed to introduce it.\r\n\r\nTruncating VPWidenIntOrFpInductionRecipes should also be modeled using the new recipe, as \r\nfollow-up.\r\n ", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp", "functions": ["TypeInfo"]}, {"filename": "llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp", "functions": ["isUniformAcrossVFsAndUFs"]}]}
{"pr_number": 79401, "url": "https://github.com/llvm/llvm-project/pull/79401", "title": "[RISCV] Refine cost on Min/Max reduction with i1 type", "body": "It is split off from #77342.\r\nInstCombine transform min/max reduction with i1 into arithmetic reduction,\r\nso this patch reuses the cost logic in arithmetic reduction cost function.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp", "functions": ["getArithmeticReductionCost"]}]}
{"pr_number": 79569, "url": "https://github.com/llvm/llvm-project/pull/79569", "title": "[AArch64] Add CodeGen support for FEAT_CPA", "body": "CPA stands for Checked Pointer Arithmetic and is part of the 2023 MTE architecture extensions for A-profile.\r\nThe new CPA instructions perform regular pointer arithmetic (such as base register + offset) but check for overflow in the most significant bits of the result.\r\n\r\nIn this patch we intend to capture the semantics of pointer arithmetic when it is not folded into loads/stores, then generate the appropriate CPA instructions.\r\n\r\nMode details about the extension can be found at:\r\n* https://community.arm.com/arm-community-blogs/b/architectures-and-processors-blog/posts/arm-a-profile-architecture-developments-2023\r\n* https://developer.arm.com/documentation/ddi0602/2023-09/", "feature_layers": ["sema", "codegen"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AArch64/AArch64TargetMachine.cpp", "functions": ["getSubtargetImpl"]}]}
{"pr_number": 79439, "url": "https://github.com/llvm/llvm-project/pull/79439", "title": "[AMDGPU][NFC] Rename the reg-or-imm operand predicates to match their class names.", "body": "No need to have two names for the same thing. Also simplifies operand definitions.\r\n\r\nPart of <https://github.com/llvm/llvm-project/issues/62629>.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp", "functions": ["isAISrc_128F16", "isVSrcTB16_Lo128", "isVISrc_1024F16", "isVISrc_64F16", "isVSrcF64", "isAISrc_512B32", "isVISrc_128_f32", "isAISrc_64_f64", "isVCSrcB16", "isVISrc_512F32", "isVSrcFake16F16_Lo128", "isAISrc_1024B32", "isVCSrc_v2f16", "isVSrc_b16", "isVSrc_v2f32", "isAISrc_512_b32", "isVSrc_v2f16", "isVCSrc_v2b16", "isVSrcF16", "isVSrcFake16_f16_Lo128", "isVISrc_64_f64", "isAISrc_256_f64", "isVCSrc_b32", "isVCSrcF64", "isSCSrc_b64", "isAISrc_128F32", "isVISrc_256_f32", "isAISrc_1024_f32", "isVISrc_512F16", "isVCSrcF16", "isVSrcB16", "isAISrc_512_f32", "isAISrc_512F32", "isAISrc_128_f32", "isVSrc_f16", "isVCSrc_f16", "isVSrcFake16B16_Lo128", "isAISrc_64F64", "isVSrcTB16", "isVCSrcF32", "isSSrcB64", "isVSrcV2FP32", "isSSrcOrLdsB32", "isVSrcTF16_Lo128", "isVCSrc_b16", "isVISrc_64_b32", "isVCSrc_f32", "isVISrc_128B32", "isSSrcF64", "isVSrcT_b16", "isAISrc_128B32", "isSSrcOrLds_b32", "isVISrc_256_f64", "isAISrc_256F64", "isVISrc_1024_f32", "isSSrc_b16", "isVSrcTF16", "isAISrc_1024F32", "isSSrcB32", "isVISrc_1024B32", "isVISrc_256F32", "isSSrc_b32", "isVISrc_256B32", "isVISrc_128F32", "isVSrc_v2b16", "isVSrcV2INT32", "isVSrcT_b16_Lo128", "isVSrcF32", "isSSrc_f32", "isVSrcT_f16", "isVISrc_128_f16", "isAISrc_512F16", "isVISrc_512B32", "isSCSrcB32", "isSSrc_f16", "isVISrc_64F64", "isAISrc_128_b32", "isSSrc_b64", "isVISrc_256F64", "isSCSrcB64", "isVSrcV2B16", "isSSrcF32", "isAISrc_1024F16", "isVSrc_f32", "isVSrcT_f16_Lo128", "isVCSrcV2B16", "isVSrcB32", "isVISrc_128F16", "isVSrcB64", "isSSrcB16", "isVSrcV2F16", "isSCSrcB16", "isVISrc_64B32", "isVISrc_128_b32", "isVISrc_1024F32", "isVSrc_f64", "isAISrc_1024_b32", "isVSrcFake16_b16_Lo128", "isVISrc_512_f32", "isSSrcF16", "isVSrc_b64", "isVCSrcB32", "isVISrc_1024_b32", "isVSrc_b32", "isVSrc_v2b32", "isSCSrc_b32", "isVISrc_256_b32", "isVISrc_64_f16", "isVCSrcV2F16", "isReg", "isVISrc_512_b32"]}]}
{"pr_number": 79337, "url": "https://github.com/llvm/llvm-project/pull/79337", "title": "[flang][Runtime] Add SIGNAL intrinisic", "body": "The intrinsic is defined as a GNU extension here:\r\nhttps://gcc.gnu.org/onlinedocs/gfortran/SIGNAL.html\r\n\r\nAnd as an IBM extension here:\r\nhttps://www.ibm.com/docs/en/xffbg/121.141?topic=procedures-signali-proc-extension\r\n\r\nThe IBM version provides a compatible subset of the functionality offered by the GNU version. This patch supports most of the GNU features, but not calling SIGNAL as a function. We don't currently support intrinsics being both subroutines and functions and this change seemed too large to be justified by a non-standard intrinsic.\r\n\r\nI have not found open source code using this intrinsic. This is needed for a proprietary code base.", "feature_layers": ["runtime"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/runtime/extensions.cpp", "functions": ["RTNAME"]}]}
{"pr_number": 79145, "url": "https://github.com/llvm/llvm-project/pull/79145", "title": "[flang] Lower passing non assumed-rank/size to assumed-ranks", "body": "Start implementing assumed-rank support as described in https://github.com/llvm/llvm-project/blob/main/flang/docs/AssumedRank.md\r\n\r\nThis commit holds the minimal support for lowering calls to procedure with assumed-rank arguments where the procedure implementation is done in C.\r\n\r\nThe case for passing assumed-size to assumed-rank is left TODO since it will be done a change in assumed-size lowering that is better done in another patch.\r\n\r\nImplementation of Fortran procedure with assumed-rank arguments is still TODO.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Lower/CallInterface.cpp", "functions": ["getBounds"]}, {"filename": "flang/lib/Lower/ConvertCall.cpp", "functions": ["lowerBounds", "isBindcCall"]}]}
{"pr_number": 79484, "url": "https://github.com/llvm/llvm-project/pull/79484", "title": "[mlir][mesh] Rename cluster to mesh", "body": "Rename\r\n* Op mesh.cluster -> mesh.mesh\r\n* Op mesh.cluster_shape -> mesh.mesh_shape\r\n* variables and attributes.\r\n\r\nThe name `mesh` is more specific to what it really represents. It is a mesh of devices.\r\nThe name `cluster` implies a broader posibility of device configurations. When just the word `mesh` is used the meaning can often be inferred from the context whether it refers to the mesh dialect or a device mesh. The full name can be used when needed.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/Mesh/IR/MeshOps.cpp", "functions": ["emitOpError"]}]}
{"pr_number": 71417, "url": "https://github.com/llvm/llvm-project/pull/71417", "title": "[clang][NFC] Refactor `CXXNewExpr::InitializationStyle` (re-land)", "body": "This patch converts CXXNewExpr::InitializationStyle into a scoped enum at namespace scope. It also affirms the status quo by adding a new enumerator to represent implicit initializer.\r\n\r\nThis is a re-land of https://github.com/llvm/llvm-project/pull/71322", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "clang/lib/Sema/SemaExprCXX.cpp", "functions": ["if"]}]}
{"pr_number": 76997, "url": "https://github.com/llvm/llvm-project/pull/76997", "title": "[SeperateConstOffsetFromGEP] Handle `or disjoint` flags", "body": "This commit extends separate-const-offset-from-gep to look at the newly-added `disjoint` flag on `or` instructions so as to preserve additional opportunities for optimization.\r\n\r\nThe tests were pre-committed in #76972.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp", "functions": ["Extractor", "ConstantOffsetExtractor", "Find", "IP"]}]}
{"pr_number": 79256, "url": "https://github.com/llvm/llvm-project/pull/79256", "title": "[Driver,CodeGen] Support -mtls-dialect=", "body": "GCC supports -mtls-dialect= for several architectures to select TLSDESC.\nThis patch supports the following values\n\n* x86: \"gnu\". \"gnu2\" (TLSDESC) is not supported yet.\n* RISC-V: \"trad\" (general dynamic), \"desc\" (TLSDESC, see #66915)\n\nAArch64 toolchains seem to support TLSDESC from the beginning, and the\ngeneral dynamic model has poor support. Nobody seems to use the option\n-mtls-dialect= at all, so we don't bother with it.\nThere also seems very little interest in AArch32's TLSDESC support.\n\nTLSDESC does not change IR, but affects object file generation. Without\na backend option the option is a no-op for in-process ThinLTO.\n\nThere seems no motivation to have fine-grained control mixing trad/desc\nfor TLS, so we just pass -mllvm, and don't bother with a modules flag\nmetadata or function attribute.\n\nCo-authored-by: Paul Kirth <paulkirth@google.com>\n", "feature_layers": ["codegen", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CodeGen/RISCV/tls-dialect.c", "functions": ["use"]}]}
{"pr_number": 66915, "url": "https://github.com/llvm/llvm-project/pull/66915", "title": "[RISCV] Support Global Dynamic TLSDESC in the RISC-V backend", "body": "This patch adds basic TLSDESC support for the global dynamic case in the RISC-V backend.\r\n\r\nSpecifically, we add new relocation types for TLSDESC, as prescribed in \r\nhttps://github.com/riscv-non-isa/riscv-elf-psabi-doc/pull/373, and add a new pseudo instruction \r\nto simplify code generation.\r\n\r\nThis patch does not try to optimize the local dynamic case, which can be improved in separate\r\npatches. Linker side changes will also be handled separately.\r\n\r\nThe current implementation is only enabled when passing the new `-enable-tlsdesc` codegen flag.", "feature_layers": ["codegen"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp", "functions": ["isTLSDESCCallSymbol", "checkPseudoTLSDESCCall"]}, {"filename": "llvm/lib/Target/RISCV/RISCVExpandPseudoInsts.cpp", "functions": ["expandLoadTLSDescAddress"]}, {"filename": "llvm/lib/Target/RISCV/RISCVISelLowering.cpp", "functions": ["SDValue", "getDynamicTLSAddr", "DL"]}]}
{"pr_number": 67624, "url": "https://github.com/llvm/llvm-project/pull/67624", "title": "[ORC] Unify symbol mapping logic to IRLayer", "body": "Remove the old `IRSymbolMapper` and unifies symbol mapping logic to `IRLayer`. Allows clients to provide their own version of an `IRSymbolMapper` function for custom mappings.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/ExecutionEngine/Orc/CompileOnDemandLayer.cpp", "functions": ["HC", "formatv", "extractSubModule", "Mangle"]}, {"filename": "llvm/lib/ExecutionEngine/Orc/CompileUtils.cpp", "functions": ["irManglingOptionsFromTargetOptions"]}, {"filename": "llvm/lib/ExecutionEngine/Orc/Layer.cpp", "functions": ["IRMaterializationUnit", "getSymbolInfo"]}, {"filename": "llvm/lib/ExecutionEngine/Orc/Mangling.cpp", "functions": ["Mangle"]}]}
{"pr_number": 79045, "url": "https://github.com/llvm/llvm-project/pull/79045", "title": "[lldb][NFCI] Remove EventData* parameter from BroadcastEventIfUnique", "body": "Instead of passing the data to BroadcastEventIfUnique to create an Event object on the behalf of the caller, the caller can create the Event up-front.", "feature_layers": ["ast"], "feature_directives": [], "files_changed": [{"filename": "lldb/source/Target/Process.cpp", "functions": ["ProcessEventData"]}]}
{"pr_number": 78380, "url": "https://github.com/llvm/llvm-project/pull/78380", "title": "[-Wcompletion-handler] Fix a non-termination issue", "body": "The analysis goes to infinity on the example below:\r\n\r\n```\r\n// Suppose f is a callable that should be called exactly once:\r\ndo {\r\n    escape(f);    \r\n    f(); \r\n} while (cond);\r\n```\r\n\r\nA simplified CFG will look like this:\r\n```\r\nB0:  loop entry -> B1\r\nB1:  loop body -> B0, B2\r\nB2:  exit\r\n```\r\n\r\nThe analysis goes backwards so it starts from `B2`  with output state `NotCalled`.  Then `B1`'s output state is `DefinitelyCalled` (Note that  `escape` is visited but it only overrides error states).   Next,  `B0` outputs `DefinitelyCalled` as well.  Then `B1` is visited again:  the input is the join over `DefinitelyCalled` and `NotCalled` resulting in `MaybeCalled`; it gets updated to `Reported` at `f()` and `Escape` later at `escape(f)`.    So `B0` now outputs `Escape` as well.  Then again,  the input of `B1` is the join over `Escape` and `NotCalled` resulting in `NotCalled`, and so on to the infinity.\r\n\r\nThe key issue is that the `join` operator defines a partial order over the states, in which `Escape < any error states`.  Meanwhile, the analyzer allows `Escape` to override error states during a CFG Block visit.  Therefore, the output state of a CFG block can change from a \"greater\" state to a \"smaller\" state (i.e., it does not change monotonically).\r\n\r\nMy humble understand of why to design the states this way is that if `Escape` happens on a single path, we do not report anything on that path for being less noisy while `Escape` on one path should not prevent the analyzer from warning the other paths.\r\nTo preserve such an idea,  I propose to use sets of states as CFG block outputs.  The set is finite and grows in one direction, so it guarantees termination.   For obtaining an input from such an output,  a single state can be \"extracted\" from a state set.  The extraction is basically a join over the set and it will let `Escape` to override error states.", "feature_layers": ["ir"], "feature_directives": ["for", "single"], "files_changed": [{"filename": "clang/lib/Analysis/CalledOnceCheck.cpp", "functions": ["add", "size", "getState", "update", "summaryStatus"]}]}
{"pr_number": 77515, "url": "https://github.com/llvm/llvm-project/pull/77515", "title": "[RISCV] Support Global Dynamic TLSDESC in the RISC-V backend", "body": "This patch adds basic TLSDESC support for the global dynamic case in the\nRISC-V backend by adding new relocation types for TLSDESC, as prescribed\nin https://github.com/riscv-non-isa/riscv-elf-psabi-doc/pull/373.\n\nWe also add a new pseudo instruction to simplify code generation.\n\nPossible improvements for the local dynamic case will be addressed in separate\npatches.\n\nThe current implementation is only enabled when passing the\n-riscv-enable-tlsdesc flag.\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp", "functions": ["isTLSDESCCallSymbol", "checkPseudoTLSDESCCall"]}, {"filename": "llvm/lib/Target/RISCV/RISCVExpandPseudoInsts.cpp", "functions": ["expandLoadTLSDescAddress"]}, {"filename": "llvm/lib/Target/RISCV/RISCVISelLowering.cpp", "functions": ["SDValue", "DL"]}]}
{"pr_number": 79624, "url": "https://github.com/llvm/llvm-project/pull/79624", "title": "[lldb] Fix progress reporting for SymbolLocatorDebugSymbols", "body": "This fixes two issues related to the DebugSymbols symbol locator:\r\n\r\n  1. Only the default symbol locator plugin reports progress. On Darwin, which uses the DebugSymbols framework we need to report the same progress form the corresponding SymbolLocator plugin.\r\n\r\n  2. Forceful dSYM lookups, for example when using `add-dsym`, use a different code path that currently does not report progress, which is confusing. Here the progress event can be more specific and specify its downloading a symbol file rather than just locating it as we'll always shell out to dsymForUUID or its equivalent.\r\n\r\nrdar://121629777", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "lldb/source/Plugins/SymbolLocator/DebugSymbols/SymbolLocatorDebugSymbols.cpp", "functions": ["progress"]}]}
{"pr_number": 77148, "url": "https://github.com/llvm/llvm-project/pull/77148", "title": "[-Wunsafe-buffer-usage] Add a new warning for uses of std::span two-parameter constructors", "body": "The PR contains two commits:\r\n1. adding a new waring under a sub-group of `-Wunsafe-buffer-usage`\r\n2. teach the analyzer to be quiet on some benign cases", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Analysis/UnsafeBufferUsage.cpp", "functions": ["AreSameDRE", "stmt"]}, {"filename": "clang/lib/Sema/AnalysisBasedWarnings.cpp", "functions": ["ignoreUnsafeBufferInContainer"]}, {"filename": "clang/test/SemaCXX/warn-unsafe-buffer-usage-in-container-span-construct.cpp", "functions": ["notWarnSafeCases"]}]}
{"pr_number": 71224, "url": "https://github.com/llvm/llvm-project/pull/71224", "title": "[ValueTracking] Improve ananlysis of PHI nodes.", "body": "In general, phi node `p = phi [%v0, %bb0], ..., [%v_n, %bb_n]` is not equal to `%x` if each of `%v0, ..., %v_n` is not equal to `%x`.  If `x` happens to be also a `phi` node in the same basic block, we check that that the incomming values for the same predecessors are not equal.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Analysis/ValueTracking.cpp", "functions": ["isNonEqualPhisSameBB"]}]}
{"pr_number": 73654, "url": "https://github.com/llvm/llvm-project/pull/73654", "title": "[X86][tablgen] Auto-gen broadcast tables", "body": "1. Add TB_BCAST_SH for FP16\r\n2. Auto-gen 4 broadcast tables BroadcastTable[1-4]\r\n\r\nissue: https://github.com/llvm/llvm-project/issues/66360", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/utils/TableGen/X86FoldTablesEmitter.cpp", "functions": ["addEntryWithFlags", "MemInst"]}]}
{"pr_number": 79568, "url": "https://github.com/llvm/llvm-project/pull/79568", "title": "[Concepts] Traverse the instantiation chain for parameter injection inside a constraint scope", "body": "We preserve the trailing requires-expression during the lambda\r\nexpression transformation. In order to get those referenced parameters\r\ninside a requires-expression properly resolved to the instantiated\r\ndecls, we intended to inject these 'original' `ParmVarDecls` to the\r\ncurrent instantiaion scope, at `Sema::SetupConstraintScope`.\r\n\r\nThe previous approach seems to overlook nested instantiation chains,\r\nleading to the crash within a nested lambda followed by a requires clause.\r\n\r\nThis fixes https://github.com/llvm/llvm-project/issues/73418.", "feature_layers": ["sema", "ir"], "feature_directives": ["for", "requires"], "files_changed": [{"filename": "clang/test/SemaTemplate/concepts-lambda.cpp", "functions": ["foo"]}]}
{"pr_number": 78274, "url": "https://github.com/llvm/llvm-project/pull/78274", "title": "[Clang][Sema] Diagnose function/variable templates that shadow their own template parameters", "body": "Previously, we skipped through template parameter scopes (until we hit a declaration scope) prior to redeclaration lookup for declarators. For template declarations, the meant that their template parameters would not be found and shadowing would not be diagnosed. With these changes applied, the following declarations are correctly diagnosed:\r\n```cpp\r\ntemplate<typename T> void T(); // error: declaration of 'T' shadows template parameter\r\ntemplate<typename U> int U; // error: declaration of 'U' shadows template parameter\r\n```\r\n\r\nThe reason for skipping past non-declaration & template parameter scopes prior to lookup appears to have been because `GetTypeForDeclarator` needed this adjusted scope... but it doesn't actually use this parameter anymore. ~I added a separate commit that removes it from the declaration and all call sites. Since `ActOnTypeName` is essentially a wrapper around `GetTypeForDeclarator`, I removed the `Scope*` parameter from it as well.~ see #78325\r\n\r\nThe scope adjustment now happens prior to calling `ActOnFunctionDeclarator`/`ActOnVariableDeclarator`/`ActOnTypedefDeclarator` (just in case they depend on this behavior... I didn't check in depth).", "feature_layers": ["sema", "ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CXX/temp/temp.res/temp.local/p6.cpp", "functions": ["T", "V"]}]}
{"pr_number": 79371, "url": "https://github.com/llvm/llvm-project/pull/79371", "title": "[Sema] Substitute parameter packs when deduced from function arguments", "body": "This pull request would solve https://github.com/llvm/llvm-project/issues/78449 .\r\nThere is also a discussion about this on stackoverflow: https://stackoverflow.com/questions/77832658/stdtype-identity-to-support-several-variadic-argument-lists .\r\n\r\nThe following program is well formed:\r\n```cpp\r\n#include <type_traits>\r\n\r\ntemplate <typename... T>\r\nstruct args_tag\r\n{\r\n    using type = std::common_type_t<T...>;\r\n};\r\n\r\ntemplate <typename... T>\r\nvoid bar(args_tag<T...>, std::type_identity_t<T>..., int, std::type_identity_t<T>...) {}\r\n\r\n// example\r\nint main() {\r\n    bar(args_tag<int, int>{}, 4, 8, 15, 16, 23);\r\n}\r\n```\r\n\r\nbut Clang rejects it, while GCC and MSVC doesn't. The reason for this is that, in `Sema::DeduceTemplateArguments` we are not prepared for this case. \r\n\r\n# Substitution/deduction of parameter packs\r\nThe logic that handles substitution when we have explicit template arguments (`SubstituteExplicitTemplateArguments`) does not work here, since the types of the pack are not pushed to `ParamTypes` before the loop starts that does the deduction.\r\nThe other \"candidate\" that may could have handle this case would be the loop that does the deduction for trailing packs, but we are not dealing with trailing packs here.\r\n\r\n# Solution proposed in this PR\r\nThe solution proposed in this PR works similar to the trailing pack deduction. The main difference here is the end of the deduction cycle.\r\nWhen a non-trailing template pack argument is found, whose type is not explicitly specified and the next type is not a pack type, the length of the previously deduced pack is retrieved (let that length be `s`). After that the next `s` arguments are processed in the same way as in the case of non trailing packs.\r\n\r\n# Another possible solution\r\nThere is another possible approach that would be less efficient. In the loop when we get to an element of `ParamTypes` that is a pack and could be substituted because the type is deduced from a previous argument, then `s` number of arg types would be inserted before the current element of `ParamTypes` type. Then we would \"cancel\" the processing of the current element, first process the previously inserted elements and the after that re-process the current element.\r\nBasically we would do what `SubstituteExplicitTemplateArguments` does but during deduction.\r\n\r\n# Adjusted test cases\r\nIn `clang/test/CXX/temp/temp.fct.spec/temp.deduct/temp.deduct.call/p1-0x.cpp` there is a test case named `test_pack_not_at_end` that should work, but still does not. This test case is relevant because the note for the error message has changed.\r\nThis is what the test case looks like currently:\r\n```cpp\r\ntemplate<typename ...Types>\r\nvoid pack_not_at_end(tuple<Types...>, Types... values, int); // expected-note {{<int *, double *> vs. <int, int>}}\r\n\r\nvoid test_pack_not_at_end(tuple<int*, double*> t2) {\r\n  pack_not_at_end(t2, 0, 0, 0); // expected-error {{no match}}\r\n  // FIXME: Should the \"original argument type must match deduced parameter\r\n  // type\" rule apply here?\r\n  pack_not_at_end<int*, double*>(t2, 0, 0, 0); // ok\r\n}\r\n\r\n```\r\n\r\nThe previous note said (before my changes):\r\n```\r\ndeduced conflicting types for parameter 'Types' (<int *, double *> vs. <>)\r\n````\r\nThe current note says (after my changesand also clang 14 would say this if the pack was not trailing):  \r\n```\r\ndeduced conflicting types for parameter 'Types' (<int *, double *> vs. <int, int>)\r\n```\r\nGCC says: \r\n```\r\nerror: no matching function for call to \u2018pack_not_at_end(std::tuple<int*, double*>&, int, int, int)\u2019\r\n   70 |     pack_not_at_end(t2, 0, 0, 9); // expected-error {{no match}}\r\n````", "feature_layers": ["sema", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Sema/SemaTemplateDeduction.cpp", "functions": ["getSavedPackSizeIfAllEqual"]}, {"filename": "clang/test/CXX/temp/temp.fct.spec/temp.deduct/temp.deduct.call/p1-0x.cpp", "functions": ["pack_not_at_end"]}, {"filename": "clang/test/SemaTemplate/deduction.cpp", "functions": ["call_foo2", "foo2"]}]}
{"pr_number": 73511, "url": "https://github.com/llvm/llvm-project/pull/73511", "title": "[clang, SystemZ] Pass HasDef flag to getMinGlobalAlign().", "body": "External symbols created from a linker script may not get the ABI minimum alignment and must therefore be treated as unaligned by the compiler.\r\n\r\nTo implement this, getMinGlobalAlign() (and getAlignOfGlobalVar) gets a second parameter 'HasDef', which lets SystemZTargetInfo::getMinGlobalAlign() handle this.\r\n\r\nMy first idea was to pass a VarDecl to getMinGlobalAlign(), and assume the value to be external only in cases of (VD && !VD->hasDefiniton()). I got however link problems with 'ninja check', so opted to pass a boolean 'HasDef' instead. In SemaOpenMP.cpp the check with VD was added, and in CodeGenModule.cpp 'true' is\r\npassed for strings (which I am hoping is correct as the strings seem to be passed to the functions which makes it look like they are being created for the module...)\r\n\r\nThe assumption generally would then be that everything is generated for the module except for a VarDecl that returns false in hasDefinition().\r\n\r\nThis is controlled by a new CL option '-munaligned-symbols', where I looked at -munaligned-access (e.g. RISCVTargetInfo::handleTargetFeatures() / FastUnalignedAccess).\r\n\r\nSystemZ:\r\n\r\n- Test: I reused Andreas' test for GCC and also added cases of char arrays and structs, but not sure if those are relevant/needed after all as they just worked without any extra handling...\r\n\r\n- The backend seems to emit a GOT lookup also for the external and aligned cases - I suppose this is because the linker will fixup those...", "feature_layers": ["sema", "codegen", "ir", "ast"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "clang/lib/AST/ASTContext.cpp", "functions": ["getTargetInfo"]}, {"filename": "clang/test/CodeGen/SystemZ/unaligned-symbols.c", "functions": ["foo5", "foo4", "foo6", "foo2", "__attribute__", "foo1", "foo3", "foo0", "foo7"]}]}
{"pr_number": 78612, "url": "https://github.com/llvm/llvm-project/pull/78612", "title": "[flang][runtime] Validate pointer DEALLOCATE", "body": "The standard requires a compiler to diagnose an incorrect use of a pointer in a DEALLOCATE statement.  The pointer must be associated with an entire object that was allocated as a pointer (not allocatable) by an ALLOCATE statement.\r\n\r\nImplement by appending a validation footer to pointer allocations. This is an extra allocated word that encodes the base address of the allocation.  If it is not found after the data payload when the pointer is deallocated, signal an error.  There is a chance of a false positive result, but that should be vanishingly unlikely.\r\n\r\nThis change requires all pointer allocations (not allocatables) to take place in the runtime in PointerAllocate(), which might be slower in cases that could otherwise be handled with a native memory allocation operation.  I believe that memory allocation of pointers is less common than with allocatables, which are not affected.  If this turns out to become a performance problem, we can inline the creation and initialization of the footer word.\r\n\r\nFixes https://github.com/llvm/llvm-project/issues/78391.", "feature_layers": ["runtime", "ir"], "feature_directives": ["for", "allocate", "requires"], "files_changed": [{"filename": "flang/runtime/pointer.cpp", "functions": ["ReturnError"]}]}
{"pr_number": 79722, "url": "https://github.com/llvm/llvm-project/pull/79722", "title": "Revert \"[mlir][complex] Prevent underflow in complex.abs\"", "body": "Reverts llvm/llvm-project#76316\r\n\r\nBuildbot test is broken.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Conversion/ComplexToStandard/ComplexToStandard.cpp", "functions": ["b"]}]}
{"pr_number": 73158, "url": "https://github.com/llvm/llvm-project/pull/73158", "title": "[VPlan] Implement cloning of VPlans.", "body": "This patch implements cloning for VPlans and recipes. Cloning is used in the epilogue vectorization path, to clone the VPlan for the main vector loop. This means we won't re-use a VPlan when executing the VPlan for the epilogue vector loop, which in turn will enable us to perform optimizations based on UF & VF.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Vectorize/VPlan.cpp", "functions": ["VPlan", "VPRegionBlock"]}]}
{"pr_number": 79591, "url": "https://github.com/llvm/llvm-project/pull/79591", "title": "[AArch64][GlobalISel] Lower Shuffle Vector to REV", "body": "Add lowering for i16 and i32 vectors for Shuffle Vector instructions with REV mask", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AArch64/GISel/AArch64PostLegalizerLowering.cpp", "functions": ["if"]}]}
{"pr_number": 75343, "url": "https://github.com/llvm/llvm-project/pull/75343", "title": "[AArch64] merge index address with large offset into base address", "body": "A case for this transformation, https://gcc.godbolt.org/z/nhYcWq1WE\r\nFold\r\n```\r\n  mov     w8, #56952\r\n  movk    w8, #15, lsl #16\r\n  ldrb    w0, [x0, x8]\r\n```\r\ninto\r\n```\r\n  add     x0, x0, 1036288\r\n  ldrb    w0, [x0, 3704]\r\n```\r\n\r\nOnly LDRBBroX is supported for the first time.\r\nNote: The AArch64DAGToDAGISel is difficult to check the loop invariant, which may bring in regression.\r\nFix https://github.com/llvm/llvm-project/issues/71917", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AArch64/AArch64LoadStoreOptimizer.cpp", "functions": ["tryToMergeIndexLdSt", "getBaseAddressOpcode", "isMergeableIndexLdSt"]}]}
{"pr_number": 76316, "url": "https://github.com/llvm/llvm-project/pull/76316", "title": "[mlir][complex] Prevent underflow in complex.abs", "body": "`complex.abs` op may causes the underflow issue with the large input. We can prevent the problem by using the algorithm listed in [\"ALGORITHM 312 ABSOLUTE VALUE AND SQUARE ROOT OF A COMPLEX NUMBER\"](https://dl.acm.org/doi/pdf/10.1145/363717.363780) as well as the `complex.sqrt`. \r\n\r\nSee: https://github.com/llvm/llvm-project/issues/62011", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Conversion/ComplexToStandard/ComplexToStandard.cpp", "functions": ["b"]}]}
{"pr_number": 78603, "url": "https://github.com/llvm/llvm-project/pull/78603", "title": "[SPIR-V] Cast ptr kernel args to i8* when used as Store's value operand", "body": "Handle a special case when StoreInst's value operand is a kernel argument of a pointer type. Since these arguments could have either a basic element type (e.g. float*) or OpenCL builtin type (sampler_t), bitcast the StoreInst's value operand to default pointer element type (i8).\r\n\r\nThis pull request addresses the issue https://github.com/llvm/llvm-project/issues/72864", "feature_layers": ["ir", "ast"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/Target/SPIRV/SPIRVMetadata.cpp", "functions": ["getOCLKernelArgAttribute"]}]}
{"pr_number": 79525, "url": "https://github.com/llvm/llvm-project/pull/79525", "title": "[mlir][openacc][flang] Support wait devnum and clean async/wait IR", "body": "- Support wait(devnum: ) with device_type support on all operations that require it\r\n  - devnum value is stored as the first value of waitOperands in its device_type sub-segment. The hasWaitDevnum attribute     inform which sub-segment has a wait(devnum) value.\r\n- Make async/wait information homogenous on compute ops, data and update op.\r\n  - Unify operands/attributes names across operations and use the same custom parser/printer", "feature_layers": ["parse", "ir", "parser"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/OpenACC/IR/OpenACC.cpp", "functions": ["success", "getValuesFromSegments", "getWaitDevnum", "hasDeviceType", "failure", "getWaitDevnumValue", "checkWaitAndAsyncConflict", "getValueInDeviceTypeSegment", "emitError"]}]}
{"pr_number": 75895, "url": "https://github.com/llvm/llvm-project/pull/75895", "title": "Add option to turn off optimization for X86 assembler", "body": "There are use cases that we are not expecting the assembler to produce the exact instructions without any optimizations.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp", "functions": ["AsmOptimize"]}]}
{"pr_number": 79752, "url": "https://github.com/llvm/llvm-project/pull/79752", "title": "[mlir][vector] Drop inner unit dims for transfer ops on dynamic shapes.", "body": "", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Vector/Transforms/VectorTransforms.cpp", "functions": ["offsets", "strides"]}]}
{"pr_number": 76090, "url": "https://github.com/llvm/llvm-project/pull/76090", "title": "[VPlan] Replace VPRecipeOrVPValue with VP2VP recipe simplification.", "body": "Move simplification of VPBlendRecipes from early VPlan construction to VPlan-to-VPlan based recipe simplification. This simplifies initial construction.\r\n\r\nNote that some in-loop reduction tests are failing at the moment, due to the reduction predicate being created after the reduction recipe. I will provide a patch for that soon.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Vectorize/LoopVectorize.cpp", "functions": ["tryToWidenMemory", "toVPRecipeResult", "tryToWidenCall", "VPBlendRecipe", "VPWidenCastRecipe", "tryToWiden"]}]}
{"pr_number": 72629, "url": "https://github.com/llvm/llvm-project/pull/72629", "title": "[mlir][llvm] Add c interface ext wrapper for host bare ptr as well.", "body": "Quick addition to the funcs need to emit wrapper for the c interface. Doesn't convert anything but providing wrappers with \"_mlir_ciface_\" prefix.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Conversion/FuncToLLVM/FuncToLLVM.cpp", "functions": ["guard"]}]}
{"pr_number": 79655, "url": "https://github.com/llvm/llvm-project/pull/79655", "title": "intrinsic to generate a bfi instruction", "body": "BFI: Bit Field Insert copies any number of low order bits from a\r\nregister into the same number of adjacent bits at any position\r\nin the destination register.\r\n\r\nThis PR generates the BFI instruction by implementing an intrinsic\r\nfunction that can be invoked from the LLVM-IR.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp", "functions": ["DL"]}]}
{"pr_number": 78286, "url": "https://github.com/llvm/llvm-project/pull/78286", "title": "Apply kind code check on exitstat and cmdstat ", "body": "When testing on gcc, both exitstat and cmdstat must be a kind=4 integer, e.g. DefaultInt. This patch changes the input arg requirement from `AnyInt` to `TypePattern{IntType, KindCode::greaterOrEqualToKind, n}`.\r\n\r\nThe standard stated in 16.9.73\r\n - EXITSTAT (optional) shall be a scalar of type integer with a decimal exponent range of at least nine.\r\n - CMDSTAT (optional) shall be a scalar of type integer with a decimal exponent range of at least four.\r\n \r\n```fortran\r\nprogram bug\r\n  implicit none\r\n  integer(kind = 2) :: exitstatvar\r\n  integer(kind = 4) :: cmdstatvar \r\n  character(len=256) :: msg\r\n  character(len=:), allocatable :: command\r\n  command='echo hello'\r\n  call execute_command_line(command, exitstat=exitstatvar, cmdstat=cmdstatvar)\r\nend program\r\n```\r\nWhen testing the above program with exitstatvar kind<4, an error would occur:\r\n```\r\n$ ../build-release/bin/flang-new test.f90 \r\nerror: Semantic errors in test.f90\r\n./test.f90:8:47: error: Actual argument for 'exitstat=' has bad type or kind 'INTEGER(2)'\r\n    call execute_command_line(command, exitstat=exitstatvar)\r\n```\r\n\r\nWhen testing the above program with exitstatvar kind<2, an error would occur:\r\n```\r\n$ ../build-release/bin/flang-new test.f90 \r\nerror: Semantic errors in test.f90\r\n./test.f90:8:47: error: Actual argument for 'cmdstat=' has bad type or kind 'INTEGER(1)'\r\n    call execute_command_line(command, cmdstat=cmdstatvar)\r\n```\r\n\r\nTest file for this semantics has been added to `flang/test/Semantic`\r\nFixes: https://github.com/llvm/llvm-project/issues/77990", "feature_layers": ["sema", "ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/runtime/tools.cpp", "functions": ["IsValidIntDescriptor"]}]}
{"pr_number": 78716, "url": "https://github.com/llvm/llvm-project/pull/78716", "title": "[Clang][AST] Fix a crash on attaching doc comments", "body": "This crash is basically caused by calling\r\n`ASTContext::getRawCommentForDeclNoCacheImp` with its input arguments `RepresentativeLocForDecl` and `CommentsInTheFile` refering to different files. A reduced reproducer is provided in this patch.\r\n\r\nAfter the source locations for instantiations of funtion template are corrected in the commit 256a0b298c68b89688b80350b034daf2f7785b67, the variable `CommitsInThisFile` in the function\r\n`ASTContext::attachCommentsToJustParsedDecls` would refer to the source file rather than the header file for implicit function template instantiation. Therefore, in the first loop in `ASTContext::attachCommentsToJustParsedDecls`, `D` should also be adjusted for relevant scenarios like the second loop.\r\n\r\nFixes #67979 \r\nFixes #68524\r\nFixes #70550", "feature_layers": ["parse", "ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/AST/ast-crash-doc-function-template.cpp", "functions": ["Foo", "Bar"]}]}
{"pr_number": 73122, "url": "https://github.com/llvm/llvm-project/pull/73122", "title": "[AMDGPU] Lazily emit waitcnts on function entry", "body": "Instead of emitting s_waitcnt 0 on entry to a function, just remember\nthat the counters are in an unknown state and let the pass emit the\nwaitcnts naturally before the first use of any register that might need\nit.\n\nDelay the s_waitcnts could have a small performance improvement, and in\nsome cases allows them to be combined with other waits which can have a\nsmall code size improvement.\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp", "functions": ["setNonEntryFunctionInitialState", "setPendingEvent"]}]}
{"pr_number": 75785, "url": "https://github.com/llvm/llvm-project/pull/75785", "title": "remove redundant waitcnts", "body": "- [AMDGPU] Add new test case for #72830\n- [AMDGPU] Promote all soft waitcnts at the end of SIInsertWitcnts\n- [AMDGPU] Do not promote soft waitcnts during SIInsertWaitcnts\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp", "functions": ["promoteSoftWaitCnt"]}]}
{"pr_number": 78581, "url": "https://github.com/llvm/llvm-project/pull/78581", "title": "[dsymutil] Add --linker parallel to more tests.", "body": "This patch adds check for parallel linker to tests located in the root of test/tools/dsymutil. To pass NoOutput tests it is necessary to add 'Verbose' parameter to the AddressesMap interface (This is necessary to print debug output only once, parallel linker can call to AddressesMap several times for the same address, before this patch such calls would lead to debug output which does not match with debug output of --linker classic).", "feature_layers": [], "feature_directives": ["parallel", "for"], "files_changed": [{"filename": "llvm/tools/dsymutil/DwarfLinkerForBinary.cpp", "functions": ["hasValidRelocationAt"]}]}
{"pr_number": 79546, "url": "https://github.com/llvm/llvm-project/pull/79546", "title": "[flang] Add support for COSD/SIND", "body": "Added support for COSD and SIND. This is quick fix. ATAND, TAND, COSD and SIND needs to be revisited to make it a runtime call. This patch has code changes and test cases.", "feature_layers": ["runtime"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Optimizer/Builder/IntrinsicCall.cpp", "functions": ["getRuntimeCallGenerator"]}]}
{"pr_number": 79723, "url": "https://github.com/llvm/llvm-project/pull/79723", "title": "[TableGen] Extend OPC_ExtractField/OPC_CheckField start value widths.", "body": "Both OPC_ExtractField and OPC_CheckField are currently defined to take an unsigned 8-bit start value. On some architectures with long instruction words, this value can silently overflow, resulting in a bad decoder table.\r\n\r\nThis patch changes each to take a ULE128B-encoded start value instead. Additionally, a range assertion is added for the 8-bit length to prominently notify a user in case that field ever overflows.\r\n\r\nThis problem isn't currently exposed upstream since all in-tree targets use small instruction words (i.e., bitwidth <= 64 bits). It does show up in at least one downstream target with instructions > 64 bits long.", "feature_layers": ["ast"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "llvm/utils/TableGen/DecoderEmitter.cpp", "functions": ["S"]}]}
{"pr_number": 68703, "url": "https://github.com/llvm/llvm-project/pull/68703", "title": "[LiveDebugVariables] Add basic verification", "body": "Add a basic implementation of verifyAnalysis that just checks that the\r\nanalysis does not refer to any SlotIndexes for instructions that have\r\nbeen deleted. This was useful for diagnosing some SlotIndexes-related\r\nproblems caused by #67038.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/CodeGen/LiveDebugVariables.cpp", "functions": ["verify"]}]}
{"pr_number": 79110, "url": "https://github.com/llvm/llvm-project/pull/79110", "title": "[AMDGPU] Fix mul combine for MUL24", "body": "MUL24 can now return  a i64 for i32 operands, but the combine was never updated to handle this case. Extend the operand when rewriting the ADD to handle it.\r\n\r\nFixes SWDEV-436654", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp", "functions": ["performMulCombine", "SDValue"]}]}
{"pr_number": 79559, "url": "https://github.com/llvm/llvm-project/pull/79559", "title": "[Flang][OpenMP] Use simdloop operation only for omp simd pragma", "body": "OpenMP standard differentiates between omp simd (2.9.3.1) and omp do/for simd (2.9.3.2 for OpenMP 5.0 standard) pragmas. The first one describes the loop which needs to be vectorized. The second pragma describes the loop which needs to be workshared between existing threads. Each thread can use SIMD instructions to execute its chunk of the loop.\r\n\r\nThat's why we need to model\r\n```\r\n!$omp simd\r\n  do-loop\r\n```\r\nas `omp.simdloop` operation and add compiler hints for vectorization.\r\n\r\nThe worksharing loop:\r\n!$omp do simd\r\n  do-loop\r\nshould be represented as worksharing loop (`omp.wsloop`).\r\n\r\nCurrently Flang denotes both type of OpenMP pragmas by `omp.simdloop` operation. In consequence we cannot differentiate between: \r\n```\r\n!$omp parallel simd\r\n   do-loop\r\n```\r\nand\r\n```\r\n!$omp parallel do simd\r\n   do-loop\r\n ```\r\nThe second loop should be workshared between multiple threads. The first one describes the loop which needs to be redundantly executed by multiple threads. Current Flang implementation does not perform worksharing for `!$omp do simd` pragma and generates valid code only for first case.\r\n\r\n@skatrak will propose detailed MLIR representation of `!$omp do simd` pragma", "feature_layers": ["ir"], "feature_directives": ["parallel", "for", "simd"], "files_changed": [{"filename": "flang/lib/Lower/OpenMP.cpp", "functions": ["isWorkshareSimdConstruct"]}]}
{"pr_number": 74309, "url": "https://github.com/llvm/llvm-project/pull/74309", "title": "[flang] add SYSTEM runtime and lowering intrinsics support", "body": "Calls std::system() function and pass the command,\r\ncmd on Windows or shell on Linux.\r\nCommand parameter is required, exitstatus is optional.\r\ncall system(command)\r\ncall system(command, exitstatus)\r\n\r\nOnce https://github.com/llvm/llvm-project/pull/74077 has been merged, this will be rebased on that change. Functions will move from `command.cpp` to `execute.cpp`", "feature_layers": ["runtime", "ir"], "feature_directives": [], "files_changed": [{"filename": "flang/runtime/command.cpp", "functions": ["RTNAME"]}, {"filename": "flang/unittests/Runtime/CommandTest.cpp", "functions": ["IntDescriptor"]}, {"filename": "flang/runtime/execute.cpp", "functions": ["RTNAME"]}]}
{"pr_number": 79778, "url": "https://github.com/llvm/llvm-project/pull/79778", "title": "[flang] Use DataLayout for computing type size in LoopVersioning.", "body": "The existing type size computation in LoopVersioning does not work\r\nfor REAL*10, because the compute element size is 10 bytes,\r\nwhich violates the power-of-two assertion.\r\nWe'd better use the DataLayout for computing the storage size\r\nof each element of an array of the given type.\r\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Optimizer/CodeGen/Target.cpp", "functions": ["getSizeAndAlignment"]}, {"filename": "flang/lib/Optimizer/Dialect/FIRType.cpp", "functions": ["getTypeSizeAndAlignment"]}, {"filename": "flang/lib/Optimizer/Transforms/LoopVersioning.cpp", "functions": ["if"]}]}
{"pr_number": 78224, "url": "https://github.com/llvm/llvm-project/pull/78224", "title": "[DirectX] Rename DXILOperationCommon.h to DXILABI.h. NFC", "body": "This is a good place to put all of the ABI-sensitive DXIL values that\nwe'll need in both reading and writing contexts.\n", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "llvm/utils/TableGen/DXILEmitter.cpp", "functions": ["parameterTypeNameToKind"]}]}
{"pr_number": 78225, "url": "https://github.com/llvm/llvm-project/pull/78225", "title": "[DirectX] Move DXIL ResourceKind and ElementType to DXILABI.h. NFC", "body": "", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "llvm/utils/TableGen/DXILEmitter.cpp", "functions": ["parameterTypeNameToKind"]}]}
{"pr_number": 79660, "url": "https://github.com/llvm/llvm-project/pull/79660", "title": "[AMDGPU] Do not emit arch dependent macros with unspecified cpu", "body": "Summary:\nCurrently, the AMDGPU toolchain accepts not passing `-mcpu` as a means\nto create a sort of \"generic\" IR. The resulting IR will not contain any\ntarget dependent attributes and can then be inserted into another\nprogram via `-mlink-builtin-bitcode` to inherit its attributes.\n\nHowever, there are a handful of macros that can leak incorrect\ninformation when compiling for an unspecified architecture. Currently,\nthings like the wavefront size will default to 64, which is actually\nvariable. We should not expose these macros unless it is known.\n", "feature_layers": ["ir"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "clang/lib/Basic/Targets/AMDGPU.cpp", "functions": ["getArchNameR600"]}]}
{"pr_number": 79504, "url": "https://github.com/llvm/llvm-project/pull/79504", "title": "[Support] Report EISDIR when opening a directory", "body": "The test `llvm/unittests/Support/CommandLineTest.cpp` that handles errors in expansion of response files was previously disabled for AIX. Originally the code was dependent on read returning EISDIR which occurs on platforms such as Linux. However, other platforms such as AIX follow POSIX in reporting EISDIR only if write access is requested when opening a directory as a file. This change introduces an implementation that checks the validity of the path in `llvm/lib/Support/CommandLine.cpp` instead of relying on read.\r\n\r\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Support/Unix/Path.inc", "functions": ["make_error_code"]}]}
{"pr_number": 79802, "url": "https://github.com/llvm/llvm-project/pull/79802", "title": "[llvm-exegesis] Remove llvm prefix where unnecessary", "body": "This patch removes the llvm:: prefix within llvm-exegesis where it is not necessary. This is most occurrences of the prefix within exegesis as exegesis is within the llvm namespace. This patch makes things more consistent as the vast majority of the code did not use the llvm:: prefix for anything.", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/tools/llvm-exegesis/lib/LatencyBenchmarkRunner.cpp", "functions": ["findMean", "findMax", "computeVariance", "findMin"]}, {"filename": "llvm/tools/llvm-exegesis/lib/Mips/Target.cpp", "functions": ["getScratchMemoryRegister"]}, {"filename": "llvm/tools/llvm-exegesis/lib/Target.cpp", "functions": ["strcmp"]}]}
{"pr_number": 79727, "url": "https://github.com/llvm/llvm-project/pull/79727", "title": "[llvm-cov] Simplify and optimize MC/DC computation", "body": "Update code from https://reviews.llvm.org/D138847\n\n`buildTestVector` is a standard DFS (walking a reduced ordered binary\ndecision diagram). Avoid shouldCopyOffTestVectorFor{True,False}Path\ncomplexity and redundant `Map[ID]` lookups.\n\n`findIndependencePairs` unnecessarily uses four nested loops (n<=6) to\nfind independence pairs. Instead, enumerate the two execution vectors\nand find the number of mismatches. This algorithm can be optimized using\nthe marking function technique described in _Efficient Test Coverage\nMeasurement for MC/DC,  2013_, but this may be overkill.\n", "feature_layers": ["ir"], "feature_directives": ["for", "ordered"], "files_changed": [{"filename": "llvm/lib/ProfileData/Coverage/CoverageMapping.cpp", "functions": ["buildTestVector", "matchTestVectors"]}]}
{"pr_number": 79768, "url": "https://github.com/llvm/llvm-project/pull/79768", "title": "[NVPTX] Add 'activemask' builtin and intrinsic support", "body": "Summary:\nThis patch adds support for getting the 'activemask' instruction's value\nwithout needing to use inline assembly. See the relevant PTX reference\nfor details.\n\nhttps://docs.nvidia.com/cuda/parallel-thread-execution/index.html#parallel-synchronization-and-communication-instructions-activemask\n", "feature_layers": [], "feature_directives": ["parallel", "for"], "files_changed": [{"filename": "clang/test/CodeGen/builtins-nvptx.c", "functions": ["activemask"]}]}
{"pr_number": 79888, "url": "https://github.com/llvm/llvm-project/pull/79888", "title": "[NVPTX] Add builtin support for 'nanosleep' PTX instrunction", "body": "Summary:\nThis patch adds a builtin for the `nanosleep` PTX function. It takes\neither an immediate or a register and sleeps for [0, 2t] nanoseconds\ngiven t. More information at the documentation:\nhttps://docs.nvidia.com/cuda/parallel-thread-execution/index.html#miscellaneous-instructions-nanosleep\n", "feature_layers": [], "feature_directives": ["parallel", "for"], "files_changed": [{"filename": "clang/test/CodeGen/builtins-nvptx.c", "functions": ["nvvm_nanosleep"]}]}
{"pr_number": 79777, "url": "https://github.com/llvm/llvm-project/pull/79777", "title": "[NVPTX] Add builtin for 'exit' handling", "body": "Summary:\nThe PTX ISA has always supported the 'exit' instruction to terminate\nindividual threads. This patch adds a builtin to handle it. See the PTX\ndocumentation for further details.\nhttps://docs.nvidia.com/cuda/parallel-thread-execution/index.html#control-flow-instructions-exit\n", "feature_layers": [], "feature_directives": ["parallel", "for"], "files_changed": [{"filename": "clang/test/CodeGen/builtins-nvptx.c", "functions": ["exit"]}]}
{"pr_number": 73018, "url": "https://github.com/llvm/llvm-project/pull/73018", "title": "[clang] Fix a bug with qualified name lookup into current instantiation", "body": "Due to d0d2ee0e4bbe915d649e983c12d37bcfcf58823c clang doesn't perform qualified name lookup into the current instantiation when it has dependent bases, because of that `getTypeName` call always returns null for unknown specialization case. When there is a `typename` keyword, `DependentNameType` is constructed instead of simply returning null.\r\nThis change attempts to do the same in case of `typename` absence.\r\n\r\nFixes https://github.com/llvm/llvm-project/issues/13826", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Sema/SemaDecl.cpp", "functions": ["CreateParsedType"]}]}
{"pr_number": 79032, "url": "https://github.com/llvm/llvm-project/pull/79032", "title": "Reland: [libc++][format] P2637R3: Member visit (std::basic_format_arg) #76449", "body": "Deleted the offending test case.\r\n\r\n`libcxx/test/std/utilities/format/format.arguments/format.arg/visit.return_type.pass.cpp`\r\nlines: 134-135:   \r\n>   test<Context, bool, long>(true, 192812079084L);\r\n     test<Context, bool, long>(false, 192812079084L);\r\n     \r\n Relands: https://github.com/llvm/llvm-project/pull/76449\r\n Reverted in: https://github.com/llvm/llvm-project/commit/02f95b77515fe18ed1076b94cbb850ea0cf3c77e", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "libcxx/test/std/utilities/format/format.arguments/format.arg/visit.pass.cpp", "functions": ["test_handle", "constexpr", "main", "test_string_view", "test"]}, {"filename": "libcxx/test/std/utilities/format/format.arguments/format.arg/visit.return_type.pass.cpp", "functions": ["test_handle", "make_expected_result", "constexpr", "main", "test_string_view", "test", "decltype"]}, {"filename": "libcxx/test/std/utilities/format/format.arguments/format.arg/visit_format_arg.deprecated.verify.cpp", "functions": ["test"]}, {"filename": "libcxx/test/std/utilities/format/format.arguments/format.args/get.pass.cpp", "functions": ["constexpr"]}]}
{"pr_number": 79896, "url": "https://github.com/llvm/llvm-project/pull/79896", "title": "[flang] Silence bogus USE statement error", "body": "When there are multiple USE statement for a particular module using renaming, it is necessary to collect a set of all of the original renaming targets before processing any of USE statements that don't have ONLY: clauses.\r\n\r\nCurrently, if there is a name in the module that can't be added to the current scope -- due to a conflict with an internal or module subprogram, or with a previously use-associated name -- the compiler will emit a bogus error message even if that conflicting name appear on a later USE statement of the same module as the target of a renaming.\r\n\r\nThe new regression test case added with this patch provides a motivating example.", "feature_layers": [], "feature_directives": ["for", "target"], "files_changed": [{"filename": "flang/lib/Semantics/resolve-names.cpp", "functions": ["AddUseRename", "CollectUseRenames", "EraseRenamedUse"]}]}
{"pr_number": 79915, "url": "https://github.com/llvm/llvm-project/pull/79915", "title": "[libc] remove stdc_leading_zeros for now", "body": "The type generic macro had numerous issues.\n\nThe include test is broken for GCC.\n\n    libc/test/include/stdbit_test.cpp:34:13: error: \u2018_Generic\u2019 was not declared in this scope\n       34 |   EXPECT_EQ(stdc_leading_zeros(0ULL), static_cast<unsigned long long>(0xAF));\n          |             ^~~~~~~~~~~~~~~~~~\n\nAlso, -Wc11-extensions (and thus -Wno-c11-extensions) are clang-only.\n\n    cc1plus: note: unrecognized command-line option \u2018-Wno-c11-extensions\u2019 may\n    have been intended to silence earlier diagnostics\n\nAnd the hermetic test seems to be getting our generated stdbit.h, but the unit\ntests does not.\n\nI'll investigate this more later, but let's get the build bots back to green.\n", "feature_layers": ["ast"], "feature_directives": ["for", "declare"], "files_changed": [{"filename": "libc/test/include/stdbit_test.cpp", "functions": ["stdc_leading_zeros_us", "stdc_leading_zeros_ui", "stdc_leading_zeros_uc", "stdc_leading_zeros_ul", "stdc_leading_zeros_ull"]}]}
{"pr_number": 79927, "url": "https://github.com/llvm/llvm-project/pull/79927", "title": "[flang] Restore error status for many indistinguishable specifics", "body": "A recent patch to allow pFUnit to compile softened the diagnostic about indistinguishable specific procedures to a portability warning. It turns out that this was overkill -- for specific procedures containing no optional or unlimited polymorphic dummy data arguments, a diagnosis of \"indistinguishable\" can still be a hard error.\r\n\r\nSo adjust the analysis to be tri-state: two procedures are either definitely distinguishable, definitely indistinguishable without optionals or unlimited polymorphics, or indeterminate.  Emit errors as before for the definitely indistinguishable cases; continue to emit portability warnings for the indeterminate cases.\r\n\r\nWhen this patch is merged, all but one of the dozen or so tests that I disabled in llvm-test-suite can be re-enabled.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Evaluate/characteristics.cpp", "functions": ["DistinguishableOpOrAssign", "Distinguishable", "AnyOptionalData", "AnyUnlimitedPolymorphicData"]}]}
{"pr_number": 79494, "url": "https://github.com/llvm/llvm-project/pull/79494", "title": "[mlir][Vector] Add patterns for efficient i4 -> i8 conversion emulation", "body": "This PR adds new patterns to improve the generated vector code for the emulation of any conversion that have to go through an i4 -> i8 type extension (only signed extensions are supported for now). This will impact any i4 -> i8/i16/i32/i64 signed extensions as well as sitofp i4 -> f8/f16/f32/f64.\r\n\r\nThe asm code generated for the supported cases is significantly better after this PR for both x86 and aarch64.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Vector/Transforms/VectorEmulateNarrowType.cpp", "functions": ["commonConversionPrecondition", "success", "failure"]}]}
{"pr_number": 79928, "url": "https://github.com/llvm/llvm-project/pull/79928", "title": "[TextAPI] Introduce granularity for handling ObjC Interface symbols", "body": "ObjCInterfaceRecords roughly align to the objc-classes key in tbd-files. They condensely represent up to 3 symbols. The problem here is that when represented this way, we lose granularity when these symbols could have different linkages or outright don't exist. This can happen frequently in interoptable code generated by the swift compiler. This adds fields and utility functions to express unique properties for these symbols. If the record does represent the same properties across all of its symbols, it will be treated the same in the TBD. Otherwise it will be printed in global's section.\r\n\r\nReviewed seperately before by Juergen Ributzka", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/TextAPI/RecordsSlice.cpp", "functions": ["addObjCInterface"]}, {"filename": "llvm/lib/TextAPI/Symbol.cpp", "functions": ["parseSymbol"]}, {"filename": "llvm/unittests/TextAPI/TextStubV5Tests.cpp", "functions": ["OS"]}]}
{"pr_number": 79937, "url": "https://github.com/llvm/llvm-project/pull/79937", "title": "[mlir][spirv] Clean up map-memref-storage-class pass", "body": "Clean up the code before making more substantial changes. NFC modulo extra error checking and physical storage buffer storage class handling.\r\n\r\n* Add switch case for physical storage buffer\r\n* Handle type conversion failures\r\n* Inline methods to reduce scrolling\r\n* Other minor cleanups", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Conversion/MemRefToSPIRV/MapMemRefStorageClassPass.cpp", "functions": ["MapMemRefStorageClassPass"]}]}
{"pr_number": 77438, "url": "https://github.com/llvm/llvm-project/pull/77438", "title": "[AMDGPU] CodeGen for GFX12 S_WAIT_* instructions", "body": "Update SIMemoryLegalizer and SIInsertWaitcnts to use separate wait\ninstructions per counter (e.g. S_WAIT_LOADCNT) and split VMCNT into\nseparate LOADCNT, SAMPLECNT and BVHCNT counters.\n", "feature_layers": ["codegen"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp", "functions": ["getWait", "setNoWait", "dbgs", "counterTypeForInstr", "enum_seq", "isNormalMode", "promoteSoftWaitCnt", "inst_counter_types", "WaitcntGenerator", "getCounterRef", "addWait", "ST", "eventCounter"]}, {"filename": "llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.cpp", "functions": ["getBvhcntBitMask", "getLoadcntBitMask", "packBits", "encodeLoadcntDscnt", "encodeStorecntDscnt", "getKmcntBitWidth", "getStorecntBitMask", "getDscntBitShift", "getBvhcntBitWidth", "getDscntBitWidth", "decodeStorecntDscnt", "getLoadcntStorecntBitShift", "getSamplecntBitMask", "encodeWaitcnt", "getDscntBitMask", "decodeLoadcntDscnt", "getKmcntBitMask", "getStorecntBitWidth", "getSamplecntBitWidth", "getLoadcntBitWidth"]}]}
{"pr_number": 78992, "url": "https://github.com/llvm/llvm-project/pull/78992", "title": "[mlir][ODS] Add `ConstantEnumCase`", "body": "Specifying an enum case of an enum attr currently requires the use of either `NativeCodeCall` or a `ConstantAttr` specifying the full C++ name of the enum case. The disadvantages of both are less readable code due to including C++ expressions and very few checks of any kind, creating C++ code that does not compile instead.\r\n\r\nThis PR adds `ConstantEnumCase`, a kind of `ConstantAttr` which automatically derives the correct value representation from a given enum and the string representation of an enum case. It supports both `EnumAttrInfo`s (enums wrapping `IntegerAttr`) and `EnumAttr` (proper dialect attributes). It even supports bit-enums, allowing one to list multiple enum cases and have them be combined. If an enum case is not found, an assertion is triggered with a proper error message.\r\n\r\nBesides the tests, it was also used to simplify DRR patterns in the arith dialect.", "feature_layers": ["ir"], "feature_directives": ["requires"], "files_changed": [{"filename": "mlir/lib/Dialect/Arith/IR/ArithOps.cpp", "functions": ["getDefOverflowFlags"]}]}
{"pr_number": 79851, "url": "https://github.com/llvm/llvm-project/pull/79851", "title": "[libc] Add test to check all properties for all FPBit types.", "body": "This test is platform agnostic, it runs all tests on all architectures.\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "libc/test/src/__support/FPUtil/fpbits_test.cpp", "functions": ["T"]}]}
{"pr_number": 79881, "url": "https://github.com/llvm/llvm-project/pull/79881", "title": "[Sema] Restructure and extend the testing of template pack deduction", "body": "Previously I worked on #78449 . I added tests in my solution #79371, but I think there should be other scenarios that should be tested and these tests deserve their namespace. In this PR I would like to make these changes.", "feature_layers": ["sema", "ir"], "feature_directives": [], "files_changed": [{"filename": "clang/test/SemaTemplate/deduction.cpp", "functions": ["bar", "call_bar", "no_separator_dependent", "foo", "separator", "call_foo", "call_baz", "foo2", "test_no_separator", "call_foo2", "test_separator", "separator_multiple_parameters", "separator_dependent"]}]}
{"pr_number": 78120, "url": "https://github.com/llvm/llvm-project/pull/78120", "title": "[RISCV] Relax march string order constraint", "body": "Follow https://github.com/riscv-non-isa/riscv-toolchain-conventions/pull/14 by dropping the order requirement of `-march`.\r\n\r\n1. single-letter extension can be arbitrary order\r\n    - march=rv32iamdf \r\n2. single-letter extension and multi-letter extension can be mixed\r\n    - march=rv32i_zihintntl_m_a_f_d_svinval\r\n3. multi-letter extension need seperate the following extension by underscore, otherwise it will be intreprete as one extension.\r\n    - march=rv32i_zbam -> i,zbam\r\n    - march=rv32i_zba_m -> i,zba,m\r\n", "feature_layers": ["ir"], "feature_directives": ["single"], "files_changed": [{"filename": "llvm/lib/Support/RISCVISAInfo.cpp", "functions": ["Name", "Vers"]}]}
{"pr_number": 76068, "url": "https://github.com/llvm/llvm-project/pull/76068", "title": "[AArch64] Implement spill/fill of predicate pair register classes", "body": "We are getting ICE with, e.g.\r\n```\r\n#include <arm_sve.h>\r\n\r\n void g();\r\n svboolx2_t f0(int64_t i, int64_t n) {\r\n     svboolx2_t r = svwhilelt_b16_x2(i, n);\r\n     g();\r\n     return r;\r\n }\r\n```", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/Target/AArch64/AArch64ExpandPseudoInsts.cpp", "functions": ["expandSVESpillFill"]}, {"filename": "llvm/lib/Target/AArch64/AArch64InstrInfo.cpp", "functions": ["if"]}]}
{"pr_number": 75107, "url": "https://github.com/llvm/llvm-project/pull/75107", "title": "[Clang][SVE2.1] Add intrinsics for `WHILEcc` resulting in predicate pair", "body": "Add intrinsics of the form:\r\n\r\n    svboolx2_t svwhile<cond>_b{8,16,32,64}_[{s,u}64]_x2([u]int64_t, [u]int64_t);\r\n\r\nand their overloaded variants as specified in\r\nhttps://github.com/ARM-software/acle/pull/257", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_while_x2.c", "functions": ["test_svwhilelo_b32_u64", "test_svwhilehs_b32_u64", "test_svwhilehi_b64_u64", "test_svwhilele_b16_u64", "test_svwhilels_b8_s64", "test_svwhilehs_b64_s64", "test_svwhilele_b16_s64", "test_svwhilels_b64_s64", "test_svwhilelt_b32_s64", "test_svwhilehs_b16_u64", "test_svwhilele_b8_u64", "test_svwhilele_b8_s64", "test_svwhilelo_b16_u64", "test_svwhilels_b16_s64", "test_svwhilehi_b64_s64", "test_svwhilelt_b8_s64", "test_svwhilelt_b16_u64", "test_svwhilels_b32_s64", "test_svwhilelo_b16_s64", "test_svwhilehi_b32_u64", "test_svwhilehi_b8_u64", "test_svwhilele_b64_u64", "test_svwhilelo_b32_s64", "test_svwhilehi_b8_s64", "test_svwhilehi_b16_s64", "test_svwhilehs_b32_s64", "test_svwhilele_b32_s64", "test_svwhilelt_b8_u64", "test_svwhilele_b32_u64", "test_svwhilelt_b16_s64", "test_svwhilelo_b64_s64", "test_svwhilele_b64_s64", "test_svwhilels_b8_u64", "test_svwhilehs_b16_s64", "test_svwhilelo_b8_u64", "SVE_ACLE_FUNC", "test_svwhilelo_b64_u64", "test_svwhilels_b16_u64", "test_svwhilels_b64_u64", "test_svwhilelt_b32_u64", "test_svwhilehs_b8_s64", "test_svwhilehi_b16_u64", "test_svwhilehs_b8_u64", "test_svwhilels_b32_u64", "test_svwhilelo_b8_s64", "test_svwhilelt_b64_s64", "test_svwhilehi_b32_s64", "test_svwhilehs_b64_u64"]}]}
{"pr_number": 66525, "url": "https://github.com/llvm/llvm-project/pull/66525", "title": "[AArch64] Stack probing for dynamic allocas in SelectionDAG", "body": "Add support for probing for dynamic allocas (variable-size objects and outgoing stack arguments).\r\n\r\n(This is stacked on top of https://github.com/llvm/llvm-project/pull/66524 and will be rebased as needed)", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AArch64/AArch64ISelLowering.cpp", "functions": ["LowerWindowsDYNAMIC_STACKALLOC", "dl", "if", "SDValue", "EmitDynamicProbedAlloc", "LowerInlineDYNAMIC_STACKALLOC"]}]}
{"pr_number": 67123, "url": "https://github.com/llvm/llvm-project/pull/67123", "title": "[AArch64] Stack probing for dynamic allocas in GlobalISel", "body": "", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AArch64/GISel/AArch64LegalizerInfo.cpp", "functions": ["legalizeDynStackAlloc"]}]}
{"pr_number": 66524, "url": "https://github.com/llvm/llvm-project/pull/66524", "title": "[AArch64] Stack probing for function prologues", "body": "This adds code to AArch64 function prologues to protect against stack clash attacks by probing (writing to) the stack at regular enough intervals to ensure that the guard page cannot be skipped over.\r\n\r\nThe patch depends on and maintains the following invariants:\r\n\r\nUpon function entry the caller guarantees that it has probed the stack (e.g. performed a store) at some address [sp, #N], where`0 <= N <= 1024`. This invariant comes from a requirement for compatibility with GCC. Any address range in the allocated stack, no smaller than stack-probe-size bytes contains at least one probe At any time the stack pointer is above or in the guard page Probes are performed in descreasing address order\r\nThe stack-probe-size is a function attribute that can be set by a platform to correspond to the guard page size.\r\n\r\nBy default, the stack probe size is 4KiB, which is a safe default as this is the smallest possible page size for AArch64. Linux uses a 64KiB guard for AArch64, so this can be overridden by the stack-probe-size function attribute.\r\n\r\nFor small frames without a frame pointer (<= 240 bytes), no probes are needed.\r\n\r\nFor larger frame sizes, LLVM always stores x29 to the stack. This serves as an implicit stack probe. Thus, while allocating stack objects the compiler assumes that the stack has been probed at [sp].\r\n\r\nThere are multiple probing sequences that can be emitted, depending on the size of the stack allocation:\r\n\r\nA straight-line sequence of subtracts and stores, used when the allocation size is smaller than 5 guard pages. A loop allocating and probing one page size per iteration, plus at most a single probe to deal with the remainder, used when the allocation size is larger but still known at compile time. A loop which moves the SP down to the target value held in a register (or a loop, moving a scratch register to the target value help in SP), used when the allocation size is not known at compile-time, such as when allocating space for SVE values, or when over-aligning the stack. This is emitted in AArch64InstrInfo because it will also be used for dynamic allocas in a future patch. A single probe where the amount of stack adjustment is unknown, but is known to be less than or equal to a page size.\r\n", "feature_layers": ["ir", "ast"], "feature_directives": ["for", "single", "target", "allocate"], "files_changed": [{"filename": "llvm/lib/Target/AArch64/AArch64FrameLowering.cpp", "functions": ["upperBound"]}]}
{"pr_number": 71290, "url": "https://github.com/llvm/llvm-project/pull/71290", "title": "[AArch64] Add quadword gather load/scatter store intrinsics with unscaled vector offset", "body": "  This patch add intrinsics of the form\r\n   \r\n    sv<type>_t svld1q_gather_u64offset_<typ>(svbool_t pg, const <type>_t *base, svuint64_t offs);\r\n    void svst1q_scatter_u64offset_<typ>(sbvool_t, <type>_t *base, svuint64_t offst, sv<type>_t data);\r\n\r\nas well as their short forms.\r\n\r\nACLE spec: ARM-software/acle#257\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_loads.c", "functions": ["test_svdl1q_gather_u64offset_f16", "test_svdl1q_gather_u64offset_u8", "test_svdl1q_gather_u64offset_s16", "test_svdl1q_gather_u64offset_f64", "test_svdl1q_gather_u64offset_u16", "test_svdl1q_gather_u64offset_s8", "test_svdl1q_gather_u64offset_bf16", "test_svdl1q_gather_u64offset_s32", "test_svdl1q_gather_u64offset_u32", "test_svdl1q_gather_u64offset_u64", "test_svdl1q_gather_u64offset_f32", "SVE_ACLE_FUNC", "test_svdl1q_gather_u64offset_s64"]}, {"filename": "clang/test/CodeGen/aarch64-sve2p1-intrinsics/acle_sve2p1_store.c", "functions": ["test_svst1q_scatter_u64offset_u64", "test_svst1q_scatter_u64offset_s8", "test_svst1q_scatter_u64offset_u8", "test_svst1q_scatter_u64offset_bf16", "test_svst1q_scatter_u64offset_s16", "test_svst1q_scatter_u64offset_f64", "test_svst1q_scatter_u64offset_u32", "test_svst1q_scatter_u64offset_f16", "test_svst1q_scatter_u64offset_f32", "test_svst1q_scatter_u64offset_u16", "test_svst1q_scatter_u64offset_s64", "test_svst1q_scatter_u64offset_s32"]}]}
{"pr_number": 69598, "url": "https://github.com/llvm/llvm-project/pull/69598", "title": "[AArch64] Implement reinterpret builtins for SVE vector tuples", "body": "This patch adds reinterpret builtins as proposed here: https://github.com/ARM-software/acle/pull/275.\r\n\r\nThe builtins take the form:\r\n\r\n    sv<dst>x<N>_t svreinterpret_<dst>_<src>_x<N>(sv<src>x<N>_t op)\r\n\r\nwhere\r\n  - <src> and <dst> designate the source and the destination type, respectively, all pairs chosen from {s8, u8, s16, u8, s32, u32, s64, u64, bf16, f16, f32, f64}\r\n  - <N> designated the number of tuple elements, 2, 3 or 4\r\n\r\nA short (overloaded) for is also provided, where the destination type is explicitly designated and the source type is deduced from the parameter type. These take the form\r\n\r\n    sv<dst>x<N>_t svreinterpret_<dst>(sv<src>x<N>_t op)\r\n\r\nFor example:\r\n\r\n    svuin16x2_t svreinterpret_u16_s32_x2(svint32x2_t op);\r\n    svuin16x2_t svreinterpret_u16(svint32x2_t op);", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CodeGen/aarch64-sve-intrinsics/acle_sve_reinterpret-bfloat.c", "functions": ["test_svreinterpret_bf16_s32", "test_svreinterpret_bf16_u32", "test_svreinterpret_f16_bf16", "test_svreinterpret_s32_bf16", "test_svreinterpret_bf16_s64", "test_svreinterpret_bf16_u64", "test_svreinterpret_bf16_f64", "test_svreinterpret_bf16_bf16", "test_svreinterpret_u16_bf16", "test_svreinterpret_u64_bf16", "test_svreinterpret_bf16_s8", "test_svreinterpret_f64_bf16", "test_svreinterpret_bf16_f32", "test_svreinterpret_bf16_s16", "test_svreinterpret_bf16_f16", "test_svreinterpret_bf16_u8", "test_svreinterpret_f32_bf16", "SVE_ACLE_FUNC", "test_svreinterpret_s8_bf16", "test_svreinterpret_s64_bf16", "test_svreinterpret_bf16_u16", "test_svreinterpret_s16_bf16", "test_svreinterpret_u32_bf16", "test_svreinterpret_u8_bf16"]}, {"filename": "clang/test/CodeGen/aarch64-sve-intrinsics/acle_sve_reinterpret.c", "functions": ["test_svreinterpret_s32_s16", "test_svreinterpret_u16_f16", "test_svreinterpret_u16_s32", "test_svreinterpret_u8_f64", "test_svreinterpret_f16_u8", "test_svreinterpret_u32_u8", "test_svreinterpret_u8_u8", "test_svreinterpret_s32_f32", "test_svreinterpret_s8_s32", "test_svreinterpret_f32_f16", "test_svreinterpret_f16_s8", "test_svreinterpret_s16_u16", "test_svreinterpret_f16_f32", "test_svreinterpret_f64_s8", "test_svreinterpret_s16_f32", "test_svreinterpret_s32_u16", "test_svreinterpret_s32_s32", "test_svreinterpret_u32_f16", "test_svreinterpret_s16_f16", "test_svreinterpret_f32_s16", "test_svreinterpret_f16_s16", "test_svreinterpret_s32_u8", "SVE_ACLE_FUNC", "test_svreinterpret_s8_f32", "test_svreinterpret_f32_u32", "test_svreinterpret_s64_u64", "test_svreinterpret_f64_s64", "test_svreinterpret_u64_s32", "test_svreinterpret_s32_s8", "test_svreinterpret_u64_u32", "test_svreinterpret_s64_s16", "test_svreinterpret_u16_s16", "test_svreinterpret_s16_s64", "test_svreinterpret_u8_s16", "test_svreinterpret_f32_u64", "test_svreinterpret_s64_f16", "test_svreinterpret_s32_s64", "test_svreinterpret_s32_u64", "test_svreinterpret_s8_s16", "test_svreinterpret_u16_s8", "test_svreinterpret_f64_u16", "test_svreinterpret_f32_s8", "test_svreinterpret_u64_u64", "test_svreinterpret_s64_u32", "test_svreinterpret_u32_u32", "test_svreinterpret_f32_s64", "test_svreinterpret_u16_u16", "test_svreinterpret_u16_u8", "test_svreinterpret_u64_s16", "test_svreinterpret_f32_u8", "test_svreinterpret_s16_u64", "test_svreinterpret_u32_s64", "test_svreinterpret_u8_f16", "test_svreinterpret_u8_f32", "test_svreinterpret_u64_u8", "test_svreinterpret_s8_u64", "test_svreinterpret_f64_f64", "test_svreinterpret_u8_u32", "test_svreinterpret_f64_f32", "test_svreinterpret_u16_u64", "test_svreinterpret_s8_s8", "test_svreinterpret_u32_u64", "test_svreinterpret_f16_u64", "test_svreinterpret_u32_f64", "test_svreinterpret_u64_s64", "test_svreinterpret_s8_u32", "test_svreinterpret_f32_u16", "test_svreinterpret_f16_f16", "test_svreinterpret_s32_f64", "test_svreinterpret_s64_u16", "test_svreinterpret_s8_f16", "test_svreinterpret_u64_f16", "test_svreinterpret_u8_s8", "test_svreinterpret_s64_f32", "test_svreinterpret_u8_u64", "test_svreinterpret_s16_u8", "test_svreinterpret_u16_f64", "test_svreinterpret_u32_s16", "test_svreinterpret_u64_f32", "test_svreinterpret_u32_s8", "test_svreinterpret_f32_f32", "test_svreinterpret_s16_f64", "test_svreinterpret_f16_s64", "test_svreinterpret_s8_s64", "test_svreinterpret_u64_f64", "test_svreinterpret_u16_s64", "test_svreinterpret_f64_u64", "test_svreinterpret_u16_u32", "test_svreinterpret_f16_u16", "test_svreinterpret_s8_u8", "test_svreinterpret_u32_f32", "test_svreinterpret_u64_s8", "test_svreinterpret_f16_u32", "test_svreinterpret_u32_s32", "test_svreinterpret_f16_s32", "test_svreinterpret_s64_s8", "test_svreinterpret_u32_u16", "test_svreinterpret_s16_s32", "test_svreinterpret_u16_f32", "test_svreinterpret_s64_u8", "test_svreinterpret_f32_s32", "test_svreinterpret_f64_f16", "test_svreinterpret_s64_f64", "test_svreinterpret_u8_u16", "test_svreinterpret_s64_s64", "test_svreinterpret_s32_u32", "test_svreinterpret_u8_s64", "test_svreinterpret_s16_u32", "test_svreinterpret_s16_s8", "test_svreinterpret_u64_u16", "test_svreinterpret_f64_s32", "test_svreinterpret_u8_s32", "test_svreinterpret_f64_u32", "test_svreinterpret_s32_f16", "test_svreinterpret_f16_f64", "test_svreinterpret_f64_s16", "test_svreinterpret_s8_u16", "test_svreinterpret_f32_f64", "test_svreinterpret_s16_s16", "test_svreinterpret_f64_u8", "test_svreinterpret_s8_f64", "test_svreinterpret_s64_s32"]}, {"filename": "clang/utils/TableGen/SveEmitter.cpp", "functions": ["applyTypespec", "TS", "Float", "FromV", "ToV"]}]}
{"pr_number": 78725, "url": "https://github.com/llvm/llvm-project/pull/78725", "title": "[LV] Fix handling of interleaving linear args", "body": "Currently when interleaving vector calls with linear arguments,\r\nthe Part is ignored and all vector calls use the initial value\r\nfrom the first lane of the current iteration.\r\n\r\nFix this to extract from the correct part of the linear vector.\r\n", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp", "functions": ["if"]}]}
{"pr_number": 79698, "url": "https://github.com/llvm/llvm-project/pull/79698", "title": "[concepts] Set up an instantiation scope for constraint expression comparison", "body": "This is a follow-up for the comparison of constraints on out-of-line function template definitions. We require the instantiation of a ParmVarDecl while transforming the expression if that Decl gets referenced by a DeclRefExpr. However, we're not actually performing the class or function template instantiation at the time of such comparison. Therefore, let's map these parameters to themselves so that they get preserved after the substitution.\r\n\r\nFixes https://github.com/llvm/llvm-project/issues/74447.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Sema/SemaConcept.cpp", "functions": ["ScopeForParameters"]}, {"filename": "clang/test/SemaTemplate/concepts-out-of-line-def.cpp", "functions": ["test"]}]}
{"pr_number": 72694, "url": "https://github.com/llvm/llvm-project/pull/72694", "title": "[libc++] Remove deprecated char_traits base template", "body": "This patch has quite a bit of history. First, it must be noted that the Standard only specifies specializations of char_traits for char, char8_t, char16_t, char32_t and wchar_t. However, before this patch, we would provide a base template that accepted anything, and as a result code like `std::basic_string<long long>` would compile but nobody knows what it really does. It basically compiles by accident.\r\n\r\nWe marked the base template as deprecated in LLVM 15 or 16 and were planning on removing it in LLVM 17, which we did in e30a148b098d. However, it turned out that the deprecation warning had never been visible in user code since Clang did not surface that warning from system headers. As a result, this caught people by surprise and we decided to reintroduce the base template in LLVM 17 in cce062d226ba.\r\n\r\nSince then, #70353 changed Clang so that such deprecation warnings would be visible from user code. Hence, this patch closes the loop and removes the deprecated specializations.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "libcxx/test/libcxx/strings/char.traits/char.traits.specializations/arbitrary_char_type.deprecated.verify.cpp", "functions": ["f"]}, {"filename": "libcxx/test/libcxx/strings/char.traits/char.traits.specializations/arbitrary_char_type.pass.cpp", "functions": ["test", "main"]}]}
{"pr_number": 78033, "url": "https://github.com/llvm/llvm-project/pull/78033", "title": "[coverage] skipping code coverage for 'if constexpr' and 'if consteval'", "body": "`if constexpr` and `if consteval` conditional statements code coverage should behave more like a preprocesor `#if`-s than normal ConditionalStmt. This PR should fix that.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/CodeGen/CoverageMappingGen.cpp", "functions": ["coverIfConstexpr", "CoverIfConstexpr", "coverIfConsteval", "CoverIfConsteval"]}, {"filename": "clang/test/CoverageMapping/branch-constfolded.cpp", "functions": ["for_8", "constexpr"]}, {"filename": "clang/test/CoverageMapping/if.cpp", "functions": ["check_constexpr_init_with_if_def"]}]}
{"pr_number": 78632, "url": "https://github.com/llvm/llvm-project/pull/78632", "title": "[AArch64] Add custom lowering for load <3 x i8>.", "body": "Add custom combine to lower load <3 x i8> as the more efficient sequence below:\r\n   ldrb wX, [x0, #2]\r\n   ldrh wY, [x0]\r\n   orr wX, wY, wX, lsl #16\r\n   fmov s0, wX\r\n\r\nAt the moment, there are almost no cases in which such vector operations will be generated automatically. The motivating case is non-power-of-2 SLP vectorization: https://github.com/llvm/llvm-project/pull/77790", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AArch64/AArch64ISelLowering.cpp", "functions": ["dl", "SDValue", "shuffleWithSingleLoad"]}]}
{"pr_number": 79922, "url": "https://github.com/llvm/llvm-project/pull/79922", "title": "[Libomptarget] Remove remaining inline assembly from the device RTL", "body": "Summary:\nRecent patches have added some missing intrinsic functions NVPTX. This\npatch gets rid of all the remaining uses of inline assembly. The one\nchange that wasn't directly replaced with a built-in was the `pack` and\n`unpack` implementations. However, using the generic C implementation is\nequivalent to the output SASS when run through PTXAS.\n", "feature_layers": ["ir"], "feature_directives": ["target"], "files_changed": [{"filename": "openmp/libomptarget/DeviceRTL/src/Mapping.cpp", "functions": ["lanemaskGT", "activemask", "lanemaskLT"]}, {"filename": "openmp/libomptarget/DeviceRTL/src/Utils.cpp", "functions": ["Pack", "Unpack"]}]}
{"pr_number": 76668, "url": "https://github.com/llvm/llvm-project/pull/76668", "title": "[clangd] Fix is spelled in source bug", "body": "This fixes the issue reported in #76667 and adds an initial unit test for isSpelledInSource().\r\n\r\nNote that in that issue there was still some underlying corrupted AST, but this at least makes isSpelledInSource() robust to it.", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang-tools-extra/clangd/unittests/SourceCodeTests.cpp", "functions": ["Test"]}]}
{"pr_number": 78911, "url": "https://github.com/llvm/llvm-project/pull/78911", "title": "[lld] [MinGW] Support targeting ARM64EC", "body": "'arm64ecpe' was chosen arbitrarily as gcc MinGW doesn't provide EC support.\r\n\r\nCC: @cjacek ", "feature_layers": [], "feature_directives": ["target"], "files_changed": [{"filename": "lld/MinGW/Driver.cpp", "functions": ["if"]}]}
{"pr_number": 79809, "url": "https://github.com/llvm/llvm-project/pull/79809", "title": "[mlir][memref] Remove incorrect `memref.transpose` fold", "body": "This folded casts into `memref.transpose` without updating the result type of the transpose op, which resulted in IR that failed to verify for statically sized memrefs.\r\n\r\ni.e.\r\n\r\n```mlir\r\n%cast = memref.cast %0 : memref<?x4xf32> to memref<?x?xf32>\r\n%transpose = memref.transpose %cast : memref<?x?xf32> to memref<?x?xf32>\r\n```\r\n\r\nwould fold to:\r\n\r\n```mlir\r\n// Fails verification:\r\n%transpose = memref.transpose %cast : memref<?x4xf32> to memref<?x?xf32>\r\n```", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/MemRef/IR/MemRefOps.cpp", "functions": ["getResult"]}]}
{"pr_number": 75103, "url": "https://github.com/llvm/llvm-project/pull/75103", "title": "[mlir][MLProgram] Add MLProgram to MemRef bufferization pass", "body": "There is currently no lowering out of `ml_program` in the LLVM repository. This change adds a lowering to `memref` so that it can be lowered all the way to LLVM. This lowering was taken from the [reference backend in torch-mlir](https://github.com/llvm/torch-mlir/commit/f41695360019bde71d52ca7548944d5488779e12 ).\r\n\r\nI had tried implementing the `BufferizableOpInterface` for `ml_program` instead of adding a new pass but that did not work because `OneShotBufferize` does not visit module-level ops like `ml_program.global`.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Bufferization/Transforms/Bufferize.cpp", "functions": ["success"]}, {"filename": "mlir/lib/Dialect/MLProgram/Transforms/BufferizableOpInterfaceImpl.cpp", "functions": ["success", "registerBufferizableOpInterfaceExternalModels", "hasTensorSemantics", "failure", "isWritable"]}]}
{"pr_number": 78437, "url": "https://github.com/llvm/llvm-project/pull/78437", "title": "prevent undefined behaviour of SPIR-V Backend non-asserts builds when dealing with token type", "body": "The goal of this PR is to fix the issue when use of token type in LLVM intrinsic causes undefined behavior of SPIR-V Backend code generator when assertions are disabled: https://github.com/llvm/llvm-project/issues/78434\r\n\r\nAmong possible fix options, discussed in the https://github.com/llvm/llvm-project/issues/78434 issue description, the option to generate a meaningful error before execution arrives at the `llvm_unreachable` call looks like a better solution for now, because SPIR-V doesn't support token type anyway without additional extensions.\r\n\r\nThe PR is to generate a user-friendly error message and exit without generating a stack dump when such a usage of token type was detected that would lead to undefined behavior of SPIR-V Backend code generator.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/SPIRV/SPIRVEmitIntrinsics.cpp", "functions": ["reportFatalOnTokenType"]}]}
{"pr_number": 79060, "url": "https://github.com/llvm/llvm-project/pull/79060", "title": "fix producing multiple identical opaque pointer types", "body": "This PR fixes https://github.com/llvm/llvm-project/issues/79057 and improves code generation for opaque pointers by replacing the culprit SPIRVGlobalRegistry::getOpTypePointer() call with a more appropriate SPIRVGlobalRegistry::getOrCreateSPIRVPointerType() call. The latter function works together with the `DuplicatesTracker` (`SPIRVGeneralDuplicatesTracker DT;` from `class SPIRVGlobalRegistry`) to trace existence of previous definitions of opaque pointers. This allows to produce just one `OpTypePointer` command for all identical opaque pointers definitions and to return the very same type record for subsequent `SPIRVGlobalRegistry::createSPIRVType()` invocations.\r\n\r\nThis PR alone improves code generation by producing a single needed definition per all opaque pointers to i8 of the same address space instead of multiple identical definitions produced before the patch. From the root cause analysis of https://github.com/llvm/llvm-project/issues/79057 we see also that this PR resolves the problem of inconsistency between keeping multiple instruction for identical opaque pointer types and just a single record for all such instructions in the `DuplicatesTracker`, and so it also resolves the issue with crashes on creation of a struct with opaque pointer fields due to the fact that now such struct fields refer to the same operand `<id>` having a required record in the data structure used for dependencies analysis (see https://github.com/llvm/llvm-project/issues/79057).\r\n", "feature_layers": ["ir"], "feature_directives": ["for", "single"], "files_changed": [{"filename": "llvm/lib/Target/SPIRV/SPIRVGlobalRegistry.cpp", "functions": ["getOpTypePointer", "Reg", "getOrCreateSPIRVPointerType"]}]}
{"pr_number": 79669, "url": "https://github.com/llvm/llvm-project/pull/79669", "title": "[libc] implement stdc_leading_zeros_u* for stdbit.h", "body": "- stdbit.stdc_leading_zeros_uc\n- stdbit.stdc_leading_zeros_us\n- stdbit.stdc_leading_zeros_ui\n- stdbit.stdc_leading_zeros_ul\n- stdbit.stdc_leading_zeros_ull\n\nTest via:\n$ ninja libc-stdbit-tests libc_include_tests\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "libc/test/include/stdbit_test.cpp", "functions": ["stdc_leading_zeros_us", "stdc_leading_zeros_ui", "stdc_leading_zeros_uc", "stdc_leading_zeros_ul", "stdc_leading_zeros_ull"]}]}
{"pr_number": 80035, "url": "https://github.com/llvm/llvm-project/pull/80035", "title": "[AMDGPU] Do not emit arch dependent macros with unspecified cpu", "body": "Summary:\nCurrently, the AMDGPU toolchain accepts not passing `-mcpu` as a means\nto create a sort of \"generic\" IR. The resulting IR will not contain any\ntarget dependent attributes and can then be inserted into another\nprogram via `-mlink-builtin-bitcode` to inherit its attributes.\n\nHowever, there are a handful of macros that can leak incorrect\ninformation when compiling for an unspecified architecture. Currently,\nthings like the wavefront size will default to 64, which is actually\nvariable. We should not expose these macros unless it is known.\n", "feature_layers": ["ir"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "clang/lib/Basic/Targets/AMDGPU.cpp", "functions": ["getArchNameR600"]}]}
{"pr_number": 80046, "url": "https://github.com/llvm/llvm-project/pull/80046", "title": "[mlir][sparse] use shared value storage between wrapped iterator and the wrapper.", "body": "", "feature_layers": ["parse", "ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/Transforms/Utils/SparseTensorLevel.cpp", "functions": ["getSegHi", "getLoopLo", "forward", "getCurPosition", "WrapItValSyncer", "randomAccessible", "SparseIterator", "genInit", "CMPI", "forwardImpl", "genInitImpl", "iteratableByFor", "SUBI", "syncer", "upperBound", "getPos", "getItPos", "ConcreteIterator", "ADDI"]}]}
{"pr_number": 77020, "url": "https://github.com/llvm/llvm-project/pull/77020", "title": "[llvm-exegesis] Add middle half repetition mode", "body": "This patch adds two new repetition modes to llvm-exegesis, particularly loop and duplicate repetition modes of what I am terming the middle half repetition mode. The middle half repetition mode essentially runs each measurement twice, one with twice the number of iterations of the other. These two measurements are then agregated by taking their difference. This subtracts away any setup/overhead that is unrelated to the code in the snippet, providing more accurate results.\r\n\r\nUsing this mode on a couple toy examples, I am able to get exact (integer) throughput values on all of them in contrast to the default duplicate/loop repetition modes which show a little bit of noise on the snippet value.", "feature_layers": ["ir", "ast"], "feature_directives": [], "files_changed": [{"filename": "llvm/tools/llvm-exegesis/lib/ResultAggregator.cpp", "functions": ["DefaultResultAggregator", "MinimumResultAggregator", "MiddleHalfResultAggregator"]}, {"filename": "llvm/unittests/tools/llvm-exegesis/ResultAggregatorTest.cpp", "functions": ["Results"]}]}
{"pr_number": 68919, "url": "https://github.com/llvm/llvm-project/pull/68919", "title": "[PowerPC][X86] Make cpu id builtins target independent and lower for PPC", "body": "Make __builtin_cpu_{init|supports|is} target independent and provide an opt-in query for targets that want to support it. Each target is still responsible for their specific lowering/code-gen. Also provide code-gen for PowerPC.\r\n\r\nI originally proposed this in https://reviews.llvm.org/D152914 and this addresses the comments I received there.", "feature_layers": ["ir"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "clang/lib/Sema/SemaChecking.cpp", "functions": ["ExprError", "if"]}, {"filename": "clang/test/CodeGen/builtin-cpu-supports.c", "functions": ["if", "test"]}, {"filename": "llvm/lib/Target/PowerPC/PPCInstrInfo.cpp", "functions": ["if"]}]}
{"pr_number": 72303, "url": "https://github.com/llvm/llvm-project/pull/72303", "title": "[scudo] Add ScopedTSD to avoid releasing TSD manually", "body": "This makes the use of TSD be RAII style and avoid the exposing of the type of TSDs.\r\n\r\nAlso move some thread safety analyses from static to runtime because of its limitation. Even we mark some code path as NO_THREAD_SAFETY_ANALYSIS but we still have the `assertLocked()` cover the correctness.", "feature_layers": ["runtime"], "feature_directives": [], "files_changed": [{"filename": "compiler-rt/lib/scudo/standalone/tests/combined_test.cpp", "functions": ["Run"]}, {"filename": "compiler-rt/lib/scudo/standalone/tests/tsd_test.cpp", "functions": ["testRegistry", "stressCache", "TSD"]}]}
{"pr_number": 79906, "url": "https://github.com/llvm/llvm-project/pull/79906", "title": "[flang][openacc] Check trip count invariance with other IVs", "body": "2.9.1 The trip count for all loops associated with the collapse clause must be computable and invariant in all the loops.\r\n\r\nThis patch checks that iteration range of loops part of a collapse nest does not depend on outer loops induction variables.\r\n\r\nThe check is also applied to combined construct with a loop.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Semantics/resolve-directives.cpp", "functions": ["CheckAssociatedLoopIndex", "CheckAssociatedLoop"]}]}
{"pr_number": 79352, "url": "https://github.com/llvm/llvm-project/pull/79352", "title": "[SelectionDAG] Expand fixed point multiplication into libcall", "body": "32-bit ARMv6 with thumb doesn't support MULHS/MUL_LOHI as legal/custom nodes during expansion which will cause fixed point multiplication of _Accum types to fail with fixed point arithmetic. Prior to this, we just happen to use fixed point multiplication on platforms that happen to support these MULHS/MUL_LOHI.\r\n\r\nThis patch attempts to check if the multiplication can be done via libcalls, which are provided by the arm runtime. These libcall attempts are made elsewhere, so this patch refactors that libcall logic into its own functions and the fixed point expansion calls and reuses that logic.", "feature_layers": ["runtime"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp", "functions": ["if"]}]}
{"pr_number": 79393, "url": "https://github.com/llvm/llvm-project/pull/79393", "title": "[mlir][python] enable memref.subview", "body": "Right now you can't (without enormous difficulty[^1]) emit a `memref.subview` because if you want to compute the result type you need to know the striding of the source which (unless you're lucky) is only available as an `AffineMap`. This PR exposes `std::pair<...> getStridesAndOffset(MemRefType)` through the C API and also binds `MemRefType.stides_and_offset` to it. In addition a builder/convenience wrapper for `memref.subview` is provided along with a python implementation of `inferReturnTypes` for static offsets/sizes/strides.\r\n\r\nBefore I handle corner cases/polish, let me know if I've missed something and this is superfluous.\r\n\r\nEDIT:\r\n\r\nSo the deal is that [`SubViewOp::verify()`](https://github.com/llvm/llvm-project/blob/32334b91922b2c48665d04369b7858324820baa5/mlir/lib/Dialect/MemRef/IR/MemRefOps.cpp#L2830) is either broken or incomplete:\r\n\r\n```mlir\r\nmodule {\r\n  %alloc = memref.alloc() : memref<7x22x333x4444xi32>\r\n  %subview = memref.subview %alloc[0, 0, 0, 0] [7, 11, 333, 4444] [1, 2, 1, 1] : memref<7x22x333x4444xi32> to memref<7x11x333x4444xi32>\r\n  %subview_0 = memref.subview %alloc[0, 0, 0, 0] [7, 11, 11, 4444] [1, 2, 30, 1] : memref<7x22x333x4444xi32> to memref<7x11x11x4444xi32>\r\n  %subview_1 = memref.subview %alloc[0, 0, 0, 0] [7, 11, 11, 11] [1, 2, 30, 400] : memref<7x22x333x4444xi32> to memref<7x11x11x11xi32>\r\n  %subview_2 = memref.subview %alloc[0, 0, 100, 1000] [7, 22, 20, 20] [1, 1, 5, 50] : memref<7x22x333x4444xi32> to memref<7x22x20x20xi32, strided<[32556744, 1479852, 22220, 50], offset: 445400>>\r\n}\r\n```\r\n\r\npasses the verifier (feel free to check!) but (if I'm not missing something) **the correct strides/offsets** are\r\n\r\n```mlir\r\nmodule {\r\n  %alloc = memref.alloc() : memref<7x22x333x4444xi32>\r\n  %subview = memref.subview %alloc[0, 0, 0, 0] [7, 11, 333, 4444] [1, 2, 1, 1] : memref<7x22x333x4444xi32> to memref<7x11x333x4444xi32, strided<[32556744, 2959704, 4444, 1]>>\r\n  %subview_0 = memref.subview %alloc[0, 0, 0, 0] [7, 11, 11, 4444] [1, 2, 30, 1] : memref<7x22x333x4444xi32> to memref<7x11x11x4444xi32, strided<[32556744, 2959704, 133320, 1]>>\r\n  %subview_1 = memref.subview %alloc[0, 0, 0, 0] [7, 11, 11, 11] [1, 2, 30, 400] : memref<7x22x333x4444xi32> to memref<7x11x11x11xi32, strided<[32556744, 2959704, 133320, 400]>>\r\n  %subview_2 = memref.subview %alloc[0, 0, 100, 1000] [7, 22, 20, 20] [1, 1, 5, 50] : memref<7x22x333x4444xi32> to memref<7x22x20x20xi32, strided<[32556744, 1479852, 22220, 50], offset: 445400>>\r\n}\r\n```\r\n\r\n(which also passes the verifier).\r\n\r\nNow maybe I am missing something - like maybe strides/offsets aren't printed if they're the \"default\" strides (`accumulate(static_sizes[::-1], *)`) but even if that's true, note that for `%subview` those \"default\" strides are `[11*333*4444, 333*4444, 4444, 1] == [32556744, 1479852, 4444, 1]` and not the correct answer `[32556744, 2959704, 4444, 1] == np.array(np.zeros([7, 11, 333, 4444], dtype=np.int32)[:, 0:22:2].strides) // 4`.\r\n\r\n:shrug: \r\n\r\nAdded tests verify/compare against `np.strides`.\r\n\r\n[^1]: I could be wrong - I might've missed some magic somewhere.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Bindings/Python/IRTypes.cpp", "functions": ["strides"]}, {"filename": "mlir/lib/CAPI/IR/BuiltinTypes.cpp", "functions": ["mlirLogicalResultFailure", "mlirLogicalResultSuccess"]}]}
{"pr_number": 80001, "url": "https://github.com/llvm/llvm-project/pull/80001", "title": "[Clang] Dump the rewritten sub-expressions in CXXDefaultArgExpr/CXXDefaultInitExpr", "body": "This patch dump the rewritten sub-expressions in `CXXDefaultArgExpr` and `CXXDefaultInitExpr`. \r\nThis machinery is useful for checking whether the materialized temporaries is lifetime-extended in the sub-AST of `CXXDefaultArgExpr` (`CXXDefaultInitExpr` has not been lifetime extendend now).", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/AST/TextNodeDumper.cpp", "functions": ["Color"]}]}
{"pr_number": 73734, "url": "https://github.com/llvm/llvm-project/pull/73734", "title": "[clang][DependencyScanner] Remove unused -ivfsoverlay files", "body": "`-ivfsoverlay` files are unused when building most modules. Enable\r\nremoving them by,\r\n* adding a way to visit the filesystem tree with extensible RTTI to\r\n  access each `RedirectingFileSystem`.\r\n* Adding tracking to `RedirectingFileSystem` to record when it\r\n  actually redirects a file access.\r\n* Storing this information in each PCM.\r\n\r\nUsage tracking is disabled during implicit modulemap search as this\r\nends up touching a lot of files that aren't actually used. The used\r\nfiles are later touched by other parts of Clang so relevant VFS\r\noverlays get marked as used.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp", "functions": ["ProxyFileSystem"]}, {"filename": "clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp", "functions": ["Listener"]}, {"filename": "clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp", "functions": ["SearchPathUsage", "VFSUsage"]}, {"filename": "llvm/unittests/Support/VirtualFileSystemTest.cpp", "functions": ["Top", "PFS", "Base", "Middle"]}]}
{"pr_number": 80014, "url": "https://github.com/llvm/llvm-project/pull/80014", "title": "[LLD][COFF] Align import directory chunk.", "body": "", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "lld/COFF/DLL.cpp", "functions": ["ImportDirectoryChunk"]}]}
{"pr_number": 79786, "url": "https://github.com/llvm/llvm-project/pull/79786", "title": "[mlir][complex] Prevent underflow in complex.abs", "body": "The previous PR was not correct on the way to handle the negative value. It is necessary to take the absolute value of the given real (or imaginary) part to be multiplied with the sqrt part. \r\n\r\nSee: https://github.com/llvm/llvm-project/pull/76316", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Conversion/ComplexToStandard/ComplexToStandard.cpp", "functions": ["b"]}]}
{"pr_number": 80055, "url": "https://github.com/llvm/llvm-project/pull/80055", "title": "[mlir][spirv] Use `AttrTypeReplacer` in map-memref-storage-class. NFC.", "body": "Keep the conversion target to allow for checking if the op is legal.", "feature_layers": ["ir"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "mlir/lib/Conversion/GPUToSPIRV/GPUToSPIRVPass.cpp", "functions": ["signalPassFailure"]}, {"filename": "mlir/lib/Conversion/MemRefToSPIRV/MapMemRefStorageClassPass.cpp", "functions": ["signalPassFailure"]}]}
{"pr_number": 79037, "url": "https://github.com/llvm/llvm-project/pull/79037", "title": "[clang] Improved isSimpleTypeSpecifier", "body": "- Sema::isSimpleTypeSpecifier return true for _Bool in c99 (currently returns false for _Bool, regardless of C dialect). (Fixes #72203)\r\n- replace the logic with a check for simple types and a proper check for a valid keyword in the appropriate dialect\r\n", "feature_layers": ["sema"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Sema/SemaDecl.cpp", "functions": ["getLangOpts"]}]}
{"pr_number": 79873, "url": "https://github.com/llvm/llvm-project/pull/79873", "title": "[NVPTX] Allow compiling LLVM-IR without `-march` set", "body": "Summary:\nThe NVPTX tools require an architecture to be used, however if we are\ncreating generic LLVM-IR we should be able to leave it unspecified. This\nwill result in the `target-cpu` attributes not being set on the\nfunctions so it can be changed when linked into code. This allows the\nstandalone `--target=nvptx64-nvidia-cuda` toolchain to create LLVM-IR\nsimmilar to how CUDA's deviceRTL looks from C/C++\n", "feature_layers": ["ir"], "feature_directives": ["target"], "files_changed": [{"filename": "clang/lib/Driver/ToolChains/Cuda.cpp", "functions": ["getToolChain"]}]}
{"pr_number": 79955, "url": "https://github.com/llvm/llvm-project/pull/79955", "title": "[mlir][spirv] Fix a crash of typeConverter with non supported type", "body": "Fixes a crash in the `convert-to-spirv-llvm` pass caused by unsupported types (e.g. \r\n `spirv.matrix` ). This PR fixes it by checking the converted type.\r\n\r\nFixes #60017", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Conversion/SPIRVToLLVM/SPIRVToLLVM.cpp", "functions": ["failure"]}]}
{"pr_number": 79761, "url": "https://github.com/llvm/llvm-project/pull/79761", "title": "[X86][CodeGen] Support folding memory broadcast in X86InstrInfo::foldMemoryOperandImpl", "body": "", "feature_layers": ["codegen", "ast"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/Target/X86/X86InstrFoldTables.cpp", "functions": ["if", "lookupFoldTableImpl"]}, {"filename": "llvm/lib/Target/X86/X86InstrInfo.cpp", "functions": ["matchBroadcastSize"]}]}
{"pr_number": 72892, "url": "https://github.com/llvm/llvm-project/pull/72892", "title": "[clang][Interp] Add inline descriptor to global variables", "body": "Some time ago, I did a similar patch for local variables.\r\n\r\nInitializing global variables can fail as well:\r\n```c++\r\nconstexpr int a = 1/0;\r\nstatic_assert(a == 0);\r\n```\r\n... would succeed in the new interpreter, because we never saved the fact that `a` has  not been successfully initialized.\r\n\r\n~~(Side note: The changes in `Pointer.h` make me want to refactor `Pointer::Base` to simply be relative to `Pointee->data()` and not `Pointee->rawData()`. That way, the 'root' value would always be `0` and not `0 || sizeof(InlineDescriptor)`.)~~", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/AST/Interp/Descriptor.cpp", "functions": ["Source"]}, {"filename": "clang/lib/AST/Interp/Interp.cpp", "functions": ["CheckGlobalInitialized"]}, {"filename": "clang/lib/AST/Interp/InterpFrame.cpp", "functions": ["Pointer"]}, {"filename": "clang/lib/AST/Interp/Pointer.cpp", "functions": ["Pointer"]}, {"filename": "clang/test/AST/Interp/cxx17.cpp", "functions": ["getS"]}]}
{"pr_number": 68485, "url": "https://github.com/llvm/llvm-project/pull/68485", "title": "[clang] static operators should evaluate object argument", "body": "### Description\r\n\r\nclang don't evaluate the object argument of `static operator()` and `static operator[]` currently, for example:\r\n\r\n```cpp\r\n#include <iostream>\r\n\r\nstruct Foo {\r\n    static int operator()(int x, int y) {\r\n        std::cout << \"Foo::operator()\" << std::endl;\r\n        return x + y;\r\n    }\r\n    static int operator[](int x, int y) {\r\n        std::cout << \"Foo::operator[]\" << std::endl;\r\n        return x + y;\r\n    }\r\n};\r\nFoo getFoo() {\r\n    std::cout << \"getFoo()\" << std::endl;\r\n    return {};\r\n}\r\nint main() {\r\n    std::cout << getFoo()(1, 2) << std::endl;\r\n    std::cout << getFoo()[1, 2] << std::endl;\r\n}\r\n```\r\n\r\n`getFoo()` is expected to be called, but clang don't call it currently (17.0.2). This PR fixes this issue.\r\n\r\nFixes #67976.\r\n\r\n### Walkthrough\r\n\r\n- **clang/lib/Sema/SemaOverload.cpp**\r\n  - **`Sema::CreateOverloadedArraySubscriptExpr` & `Sema::BuildCallToObjectOfClassType`**\r\n  Previously clang generate `CallExpr` for static operators, ignoring the object argument. In this PR `CXXOperatorCallExpr` is generated for static operators instead, with the object argument as the first argument.\r\n  - **`TryObjectArgumentInitialization`**\r\n  `const` / `volatile` objects are allowed for static methods, so that we can call static operators on them.\r\n- **clang/lib/CodeGen/CGExpr.cpp**\r\n  - **`CodeGenFunction::EmitCall`**\r\n  CodeGen changes for `CXXOperatorCallExpr` with static operators: emit and ignore the object argument first, then emit the operator call.\r\n- **clang/lib/AST/ExprConstant.cpp**\r\n  - **`\u200eExprEvaluatorBase::handleCallExpr\u200e`**\r\n  Evaluation of static operators in constexpr also need some small changes to work, so that the arguments won't be out of position.\r\n- **clang/lib/Sema/SemaChecking.cpp**\r\n  - **`Sema::CheckFunctionCall`**\r\n  Code for argument checking also need to be modify, or it will fail the test `clang/test/SemaCXX/overloaded-operator-decl.cpp`.\r\n\r\n### Tests\r\n\r\n- **Added:**\r\n    - **clang/test/AST/ast-dump-static-operators.cpp**\r\n      Verify the AST generated for static operators.\r\n    - **clang/test/SemaCXX/cxx2b-static-operator.cpp**\r\n      Static operators should be able to be called on const / volatile objects.\r\n- **Modified:**\r\n    - **clang/test/CodeGenCXX/cxx2b-static-call-operator.cpp**\r\n    - **clang/test/CodeGenCXX/cxx2b-static-subscript-operator.cpp**\r\n      Matching the new CodeGen.\r\n\r\n### Documentation\r\n\r\n- **clang/docs/ReleaseNotes.rst**\r\n  Update release notes.", "feature_layers": ["sema", "codegen", "ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/CodeGen/CGExprCXX.cpp", "functions": ["EmitCXXStaticOperatorMemberCallExpr"]}, {"filename": "clang/test/AST/ast-dump-static-operators.cpp", "functions": ["get_functor", "call_static_operators", "operator"]}, {"filename": "clang/test/CodeGenCXX/cxx2b-static-call-operator.cpp", "functions": ["GetAFunctor"]}, {"filename": "clang/test/CodeGenCXX/cxx2b-static-subscript-operator.cpp", "functions": ["GetAFunctor"]}, {"filename": "clang/test/SemaCXX/cxx2b-static-operator.cpp", "functions": ["operator", "ok"]}]}
{"pr_number": 80098, "url": "https://github.com/llvm/llvm-project/pull/80098", "title": "`llvm-cov` assertion failure when handling MC/DC that involves macros", "body": "## Problem\r\n\r\nThe behavior is described with this tiny example: https://github.com/whentojump/llvm-mcdc-assertion-failure\r\n\r\nEssentially, current MC/DC implementation cannot properly handle decisions that involve macros, like this example:\r\n\r\n![Picture1](https://github.com/llvm/llvm-project/assets/35722712/e1750238-8523-4871-aed1-8439c873ec55)\r\n\r\n## Root cause\r\n\r\nSome terms I'll use:\r\n\r\n1. Decision region: the composite logical expression\r\n2. Branch region: smaller conditions or branches within a larger expression\r\n\r\nIn the full lifecycle of these regions, here are several important stages:\r\n\r\n1. Compilation\r\n    1. Generated at front end: [source code](https://github.com/llvm/llvm-project/blob/a0b6747804e46665ecfd00295b60432bfe1775b6/clang/lib/CodeGen/CoverageMappingGen.cpp#L860-L903)\r\n    2. Written to the binary as coverage mapping sections: [source code](https://github.com/llvm/llvm-project/blob/a0b6747804e46665ecfd00295b60432bfe1775b6/llvm/lib/ProfileData/Coverage/CoverageMappingWriter.cpp#L240-L256)\r\n2. Generate report\r\n    1. Read from the binary: [source code](https://github.com/llvm/llvm-project/blob/a0b6747804e46665ecfd00295b60432bfe1775b6/llvm/lib/ProfileData/Coverage/CoverageMapping.cpp#L650-L703)\r\n\r\nThe assertion in question is in step 2.i and goes like this: \r\n\r\n1. `llvm-cov` walks all regions of the target program\r\n2. It encounters a decision region, say **R3**. By reading **R3**'s metadata, it knows it has two branches\r\n3. `llvm-cov` then asserts: the next two regions it's gonna see must be two branch regions, not otherwise\r\n\r\nThis assertion assumes the order of MCDC regions. However, this order doesn't always hold\r\n\r\nIn step 1.ii all regions are [sorted](https://github.com/llvm/llvm-project/blob/a0b6747804e46665ecfd00295b60432bfe1775b6/llvm/lib/ProfileData/Coverage/CoverageMappingWriter.cpp#L162-L171) first by their file IDs, then by locations within the file and finally by region types. Macros, however, are traced back to definitions, which can be far away from their invocations or even separated in different files. As a result, the MC/DC regions could be sorted in a way where they are separated from each other. In the shown example, the order could be: `R3 (many irrelevant regions) R1 R2` which apparently breaks the assertion at step 2.i.\r\n\r\n## Solution\r\n\r\nThis can be solved in two ways\r\n\r\n1. (This PR) Sort with MC/DC in consideration and group relevant decisions and branches together.\r\n\r\n    I honestly don't know if this's gonna break other things. But at least I can confirm it solves the problem mentioned. Again please see an example in this repo https://github.com/whentojump/llvm-mcdc-assertion-failure\r\n\r\n2. In `CoverageMapping::loadFunctionRecord()`, use a cleverer way to correlate decisions and branches that are sorted far away from each other.\r\n\r\n## Other to-do's\r\n\r\n- Tests are not yet taken care of \r\n- A bit comments/docs\r\n\r\nLast but not least, a huge thanks to @evodius96 et al for the great work regarding MC/DC :))\r\n", "feature_layers": ["codegen", "ir", "ast"], "feature_directives": ["for", "sections", "target"], "files_changed": [{"filename": "clang/lib/CodeGen/CoverageMappingGen.cpp", "functions": ["createDecisionRegion"]}]}
{"pr_number": 79985, "url": "https://github.com/llvm/llvm-project/pull/79985", "title": "[concepts] Push a CurContext before substituting into out-of-line constraints for comparison", "body": "`InjectedClassNameType` is such that every template specialization within the Record scope ought to canonicalize to it, as outlined above the definition of that Type.\r\n\r\nThis invariant is maintained during the tree transformation at the rebuilding stage for a template specialization type; see `RebuildTemplateSpecializationType`. In that, we attempt to retrieve the current instantiation from `Sema.CurContext`, and if that fails, the transformation proceeds silently.\r\n\r\nIn terms of this issue, we previously set no CurContext other than that set by Parser, who had left the FunctionDecl before performing the constraint comparison. As a result, we would profile these types (i.e. InjectedClassNameType and its specialization type) into different values and fail to consider two expressions equivalent, although they are.\r\n\r\nIn passing, this also fixes a crash while attempting to dump the transformed expression. We failed to look into the template parameters from a CXXRecordDecl, which we should have done since the Decl we bound to a SubstTemplateTypeParmType can be of a CXXRecord type per the call to `getTemplateInstantiationArgs` within `SubstituteConstraintExpressionWithoutSatisfaction.`\r\n\r\nThis closes https://github.com/llvm/llvm-project/issues/56482.", "feature_layers": ["parse", "sema", "parser"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/SemaTemplate/concepts-out-of-line-def.cpp", "functions": ["reserve"]}]}
{"pr_number": 79747, "url": "https://github.com/llvm/llvm-project/pull/79747", "title": "[clang][Interp] Support arbitrary precision constants", "body": "Add (de)serialization support for them, like we do for Floating values.\r\n\r\nUnfortunately I wasn't able to eliminate the code duplication coming from the signed/unsigned split here. I was trying to avoid adding a third function and calling that from the other two, but maybe that's the best thing to do.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/AST/Interp/ByteCodeExprGen.cpp", "functions": ["if"]}, {"filename": "clang/test/AST/Interp/intap.cpp", "functions": ["getLargeEnum"]}]}
{"pr_number": 78294, "url": "https://github.com/llvm/llvm-project/pull/78294", "title": "[SME] Stop RA from coalescing COPY instructions that transcend beyond smstart/smstop.", "body": "This patch introduces a 'COALESCER_BARRIER' which is a pseudo node that expands to\r\na 'nop', but which stops the register allocator from coalescing a COPY node when\r\nits use/def crosses a SMSTART or SMSTOP instruction.\r\n\r\nFor example:\r\n\r\n    %0:fpr64 = COPY killed $d0\r\n    undef %2.dsub:zpr = COPY %0       // <- Do not coalesce this COPY\r\n    ADJCALLSTACKDOWN 0, 0\r\n    MSRpstatesvcrImm1 1, 0, csr_aarch64_smstartstop, implicit-def dead $d0\r\n    $d0 = COPY killed %0\r\n    BL @use_f64, csr_aarch64_aapcs\r\n\r\nIf the COPY would be coalesced, that would lead to:\r\n\r\n    $d0 = COPY killed %0\r\n\r\nbeing replaced by:\r\n\r\n    $d0 = COPY killed %2.dsub\r\n\r\nwhich means the whole ZPR reg would be live upto the call, causing the\r\nMSRpstatesvcrImm1 (smstop) to spill/reload the ZPR register:\r\n\r\n    str     q0, [sp]   // 16-byte Folded Spill\r\n    smstop  sm\r\n    ldr     z0, [sp]   // 16-byte Folded Reload\r\n    bl      use_f64\r\n\r\nwhich would be incorrect for two reasons:\r\n1. The program may load more data than it has allocated.\r\n2. If there are other SVE objects on the stack, the compiler might use the\r\n   'mul vl' addressing modes to access the spill location.\r\n\r\nBy disabling the coalescing, we get the desired results:\r\n\r\n    str     d0, [sp, #8]  // 8-byte Folded Spill\r\n    smstop  sm\r\n    ldr     d0, [sp, #8]  // 8-byte Folded Reload\r\n    bl      use_f64\r\n", "feature_layers": ["ir"], "feature_directives": ["for", "barrier", "allocate"], "files_changed": [{"filename": "llvm/lib/Target/AArch64/AArch64ISelLowering.cpp", "functions": ["isPassedInFPR"]}]}
{"pr_number": 79626, "url": "https://github.com/llvm/llvm-project/pull/79626", "title": "[mlir][transform] Add elementwise criteria to `match.structured.body`", "body": "As far as I am aware, there is no simple way to match on elementwise ops.  I propose to add an `elementwise` criteria to the `match.structured.body` op.  Although my only hesitation is that elementwise is not only determined by the body, but also the indexing maps.  So if others find this too awkward,  I can implement a separate match op instead.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Linalg/TransformOps/LinalgMatchOps.cpp", "functions": ["emitSilenceableError"]}]}
{"pr_number": 78975, "url": "https://github.com/llvm/llvm-project/pull/78975", "title": "[mlir][ArmSME] Support 2-way widening outer products", "body": "This patch introduces support for 2-way widening outer products. This\r\nenables the fusion of 2 'arm_sme.outerproduct' operations that are\r\nchained via the accumulator into a 2-way widening outer product operation.\r\n\r\nChanges:\r\n\r\n- Add 'llvm.aarch64.sme.[us]mop[as].za32' intrinsics for 2-way variants.\r\n  These map to instruction variants added in SME2 and use different\r\n  intrinsics. Intrinsics are already implemented for widening variants\r\n  from SME1.\r\n- Adds the following operations:\r\n  - fmopa_2way, fmops_2way\r\n  - smopa_2way, smops_2way\r\n  - umopa_2way, umops_2way\r\n- Implements conversions for the above ops to intrinsics in ArmSMEToLLVM.\r\n- Adds a pass 'arm-sme-outer-product-fusion'  that fuses\r\n  'arm_sme.outerproduct' operations.\r\n\r\nFor a detailed description of these operations see the\r\n'arm_sme.fmopa_2way' description.\r\n\r\nThe reason for introducing many operations rather than one is the\r\nsigned/unsigned variants can't be distinguished with types (e.g., ui16,\r\nsi16) since 'arith.extui' and 'arith.extsi' only support signless\r\nintegers. A single operation would require this information and an\r\nattribute (for example) for the sign doesn't feel right if\r\nfloating-point types are also supported where this wouldn't apply.\r\nFurthermore, the SME FP8 extensions (FEAT_SME_F8F16, FEAT_SME_F8F32)\r\nintroduce FMOPA 2-way (FP8 to FP16) and 4-way (FP8 to FP32) variants but\r\nno subtract variant. Whilst these are not supported in this patch, it\r\nfelt simpler to have separate ops for add/subtract given this.", "feature_layers": ["ir"], "feature_directives": ["for", "single"], "files_changed": [{"filename": "mlir/lib/Conversion/ArmSMEToLLVM/ArmSMEToLLVM.cpp", "functions": ["failure", "success"]}, {"filename": "mlir/lib/Dialect/ArmSME/Transforms/OuterProductWidening.cpp", "functions": ["failure", "runOnOperation", "success", "patterns"]}, {"filename": "mlir/lib/Dialect/ArmSME/Transforms/OuterProductFusion.cpp", "functions": ["failure", "runOnOperation", "success", "patterns"]}]}
{"pr_number": 78827, "url": "https://github.com/llvm/llvm-project/pull/78827", "title": "[AMDGPU][AsmParser] Allow `v_writelane_b32` to use SGPR and M0 as source operands at the same time", "body": "Currently the asm parser takes `v_writelane_b32 v1, s13, m0` as illegal\ninstruction for pre-gfx11 because it uses two constant buses while the hardware\ncan only allow one. However, based on the comment of `AMDGPUInstructionSelector::selectWritelane`,\nit is allowed to have M0 as lane selector and a SGPR used as SRC0 because the\nlane selector doesn't count as a use of constant bus. In fact, codegen can already\ngenerate this form, but this inconsistency is not exposed because the validation\nof constant bus limitation only happens when paring an assembly but we don't have\na test case when both SGPR and M0 used as source operands for the instruction.\n", "feature_layers": ["parse", "codegen", "parser"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp", "functions": ["checkWriteLane"]}]}
{"pr_number": 79579, "url": "https://github.com/llvm/llvm-project/pull/79579", "title": "[mlir][IR] Add `RewriterBase::moveBlockBefore` and fix bug in `moveOpBefore`", "body": "This commit adds a new method to the rewriter API: `moveBlockBefore`. This op is utilized by `inlineRegionBefore` and covered by dialect conversion test cases.\r\n\r\nAlso fixes a bug in `moveOpBefore`, where the previous op location was not passed correctly. Adds a test case to `test-strict-pattern-driver.mlir`.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/test/lib/Dialect/Test/TestPatterns.cpp", "functions": ["failure", "RewritePattern", "success"]}]}
{"pr_number": 76360, "url": "https://github.com/llvm/llvm-project/pull/76360", "title": "[ValueTracking] Merge `cannotBeOrderedLessThanZeroImpl` into `computeKnownFPClass`", "body": "This patch merges the logic of `cannotBeOrderedLessThanZeroImpl` into `computeKnownFPClass` to improve the signbit inference.\r\n", "feature_layers": [], "feature_directives": ["ordered"], "files_changed": [{"filename": "llvm/lib/Analysis/ValueTracking.cpp", "functions": ["match", "isKnownNeverNaN", "isPositiveNum", "if", "cannotBeOrderedLessThanZeroImpl"]}, {"filename": "llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp", "functions": ["replaceInstUsesWith"]}]}
{"pr_number": 77496, "url": "https://github.com/llvm/llvm-project/pull/77496", "title": "[AArch64][compiler-rt] Add memcpy, memset, memmove, memchr builtins.", "body": "Add naive implementation of memcpy, memset, memmove, memchr for SME targets.\r\nCo-authored-by: David Sherwood <david.sherwood@arm.com>", "feature_layers": [], "feature_directives": ["for", "target"], "files_changed": [{"filename": "compiler-rt/lib/builtins/aarch64/sme-libc-routines.c", "functions": ["__arm_sc_memcpy_rev", "__arm_sc_memcpy_fwd"]}, {"filename": "compiler-rt/test/builtins/Unit/sme-string-test.c", "functions": ["sum", "init", "reinit_dst", "main"]}, {"filename": "compiler-rt/test/builtins/Unit/sme-string-test.cpp", "functions": ["Array", "dst", "src", "SrcDst", "srcdst", "Dst", "array", "assert_equal", "Src"]}]}
{"pr_number": 79584, "url": "https://github.com/llvm/llvm-project/pull/79584", "title": "[mlir][EmitC] Add `verbatim` op", "body": "The `verbatim` operation produces no results and the value is emitted as is followed by a line break  ('\\n' character) during translation.\r\n\r\nNote: Use with caution. This operation can have arbitrary effects on the semantics of the emitted code. Use semantically more meaningful operations whenever possible. Additionally this op is *NOT* intended to be used to inject large snippets of code.\r\n\r\nThis operation can be used in situations where a more suitable operation is not yet implemented in the dialect or where preprocessor directives interfere with the structure of the code.\r\n\r\nCo-authored-by: Marius Brehler <marius.brehler@iml.fraunhofer.de>", "feature_layers": ["sema", "ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/EmitC/IR/EmitC.cpp", "functions": ["emitOpError", "success"]}, {"filename": "mlir/lib/Target/Cpp/TranslateToCpp.cpp", "functions": ["success"]}]}
{"pr_number": 78730, "url": "https://github.com/llvm/llvm-project/pull/78730", "title": "Improve how lowering of formal arguments in SPIR-V Backend interprets a value of 'kernel_arg_type'", "body": "The goal of this PR is to tolerate differences between description of formal arguments by function metadata (represented by \"kernel_arg_type\") and LLVM actual parameter types. A compiler may use \"kernel_arg_type\" of function metadata fields to encode detailed type information, whereas LLVM IR may utilize for an actual parameter a more general type, in particular, opaque pointer type. This PR proposes to resolve this by a fallback to LLVM actual parameter types during the lowering of formal function arguments in cases when the type can't be created by string content of \"kernel_arg_type\", i.e., when \"kernel_arg_type\" contains a type unknown for the SPIR-V Backend.\r\n\r\nAn example of the issue manifestation is https://github.com/KhronosGroup/SPIRV-LLVM-Translator/blob/main/test/transcoding/KernelArgTypeInOpString.ll, where a compiler generates for the following kernel function detailed `kernel_arg_type` info in  a form of `!{!\"image_kernel_data*\", !\"myInt\", !\"struct struct_name*\"}`, and in LLVM IR same arguments are referred to as `@foo(ptr addrspace(1) %in, i32 %out, ptr addrspace(1) %outData)`. Both definitions are correct, and the resulting LLVM IR is correct, but lowering stage of SPIR-V Backend fails to generate SPIR-V type.\r\n\r\n```\r\ntypedef int myInt;\r\n\r\n typedef struct {\r\n   int width;\r\n   int height;\r\n } image_kernel_data;\r\n\r\n struct struct_name {\r\n   int i;\r\n   int y;\r\n };\r\n void kernel foo(__global image_kernel_data* in,\r\n                 __global struct struct_name *outData,\r\n                 myInt out) {}\r\n```\r\n\r\n```\r\ndefine spir_kernel void @foo(ptr addrspace(1) %in, i32 %out, ptr addrspace(1) %outData) ... !kernel_arg_type !7 ... {\r\nentry:\r\n  ret void\r\n}\r\n...\r\n!7 = !{!\"image_kernel_data*\", !\"myInt\", !\"struct struct_name*\"}\r\n```\r\n\r\nThe PR changes a contract of `SPIRVType *getArgSPIRVType(...)` in a way that it may return `nullptr` to signal that the metadata string content is not recognized, so corresponding comments are added and a couple of checks for `nullptr` are inserted where appropriate.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/SPIRV/SPIRVCallLowering.cpp", "functions": ["if"]}]}
{"pr_number": 79855, "url": "https://github.com/llvm/llvm-project/pull/79855", "title": "[AsmParser] Add missing globals declarations in incomplete IR mode", "body": "If `-allow-incomplete-ir` is enabled, automatically insert declarations for missing globals.\r\n\r\nIf a global is only used in calls with the same function type, insert a function declaration with that type.\r\n\r\nOtherwise, insert a dummy i8 global. The fallback case could be extended with various heuristics (e.g. we could look at load/store types), but I've chosen to keep it simple for now, because I'm unsure to what degree this would really useful without more experience. I expect that in most cases the declaration type doesn't really matter (note that the type of an external global specifies a *minimum* size only, not a precise size).\r\n\r\nThis is a followup to https://github.com/llvm/llvm-project/pull/78421.", "feature_layers": ["parse", "ir", "parser"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/AsmParser/LLParser.cpp", "functions": ["GetCommonFunctionType"]}]}
{"pr_number": 79475, "url": "https://github.com/llvm/llvm-project/pull/79475", "title": "[OpenMP] atomic compare weak : Parser & AST support", "body": "This is a support for \" #pragma omp atomic compare weak\".   It has Parser & AST support for now.", "feature_layers": ["parse", "ast", "parser"], "feature_directives": ["for", "atomic"], "files_changed": [{"filename": "clang/lib/Sema/SemaOpenMP.cpp", "functions": ["performed", "StmtError"]}]}
{"pr_number": 79994, "url": "https://github.com/llvm/llvm-project/pull/79994", "title": "[AArch64][SME] Fix inlining bug introduced in #78703", "body": "Calling a `__arm_locally_streaming` function from a function that\r\nis not a streaming-SVE function would lead to incorrect inlining.\r\n\r\nThe issue didn't surface because the tests were not testing what\r\nthey were supposed to test.\r\n\r\nThis PR consists of two patches:\r\n* The first one fixes the tests so that they _are_ testing the right things.\r\n* The second patch fixes the issue.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp", "functions": ["CallerAttrs", "CalleeAttrs"]}]}
{"pr_number": 79152, "url": "https://github.com/llvm/llvm-project/pull/79152", "title": "[mlir][ArmSME] Add initial SME vector legalization pass", "body": "This adds a new pass (`-arm-sme-vector-legalization`) which legalizes vector operations so that they can be lowered to ArmSME. This initial patch adds decomposition for `vector.outerproduct`, `vector.transfer_read`, and `vector.transfer_write` when they operate on vector types larger than a single SME tile. For example, a [8]x[8]xf32 outer product would be decomposed into four [4]x[4]xf32 outer products, which could then be lowered to ArmSME. These three ops have been picked as supporting them alone allows lowering matmuls that use all ZA accumulators to ArmSME.\r\n\r\nFor it to be possible to legalize a vector type it has to be a multiple of an SME tile size, but other than that any shape can be used. E.g. `vector<[8]x[8]xf32>`, `vector<[4]x[16]xf32>`, `vector<[16]x[4]xf32>` can all be lowered to four `vector<[4]x[4]xf32>` operations.\r\n\r\nIn future, this pass will be extended with more SME-specific rewrites to legalize unrolling the reduction dimension of matmuls (which is not type-decomposition), which is why the pass has quite a general name.", "feature_layers": ["ir"], "feature_directives": ["for", "single"], "files_changed": [{"filename": "mlir/lib/Dialect/ArmSME/IR/Utils.cpp", "functions": ["getSMETileTypeForElement", "isMultipleOfSMETileVectorType"]}, {"filename": "mlir/lib/Dialect/ArmSME/Transforms/VectorLegalization.cpp", "functions": ["failure", "pattern"]}]}
{"pr_number": 79593, "url": "https://github.com/llvm/llvm-project/pull/79593", "title": "[mlir][IR] Send missing notifications when inlining a block", "body": "When a block is inlined into another block, the nested operations are moved into another block and the `notifyOperationInserted` callback should be triggered. This commit adds the missing notifications for:\r\n* `RewriterBase::inlineBlockBefore`\r\n* `RewriterBase::mergeBlocks`\r\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/test/lib/Dialect/Test/TestPatterns.cpp", "functions": ["success"]}]}
{"pr_number": 79597, "url": "https://github.com/llvm/llvm-project/pull/79597", "title": "[mlir][IR] Send missing notification when splitting a block", "body": "When a block is split with `RewriterBase::splitBlock`, a `notifyBlockInserted` notification, followed by `notifyOperationInserted` notifications (for moving over the operations into the new block) should be sent. This commit adds those notifications.\r\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/IR/PatternMatch.cpp", "functions": ["g"]}, {"filename": "mlir/test/lib/Dialect/Test/TestPatterns.cpp", "functions": ["RewritePattern", "success"]}]}
{"pr_number": 79294, "url": "https://github.com/llvm/llvm-project/pull/79294", "title": "[AA][JumpThreading] Don't use DomTree for AA in JumpThreading", "body": "JumpThreading may perform AA queries while the dominator tree is not up to date, which may result in miscompilations.\r\n\r\nFix this by adding a new AAQI option to disable the use of the dominator tree in BasicAA.\r\n\r\nFixes https://github.com/llvm/llvm-project/issues/79175.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Analysis/BasicAliasAnalysis.cpp", "functions": ["isNotInCycle"]}]}
{"pr_number": 78400, "url": "https://github.com/llvm/llvm-project/pull/78400", "title": "[Clang][Sema] fix outline member function template with default align crash", "body": "Try to fix [issue](https://github.com/llvm/llvm-project/issues/68490) and some extented problem. Root cause of current issue is that error handling in instantiation of function parameter with default initialization on sizeof or align expression. When instance an out-of-line template member function, depth of `TemplateTypeParmDecl` in default initialization doesn't change while depth of other template parameter does and this will lead to  some template parameter uninstanced. Also, sometime it will leader to wrong instantiation when it uses the template parameter of class.\r\nFix it by add template args of context when it's out-of-line. This will make `MultiLevelTemplateArgumentList::getNumLevels` matching the depth of template parameter. Testcase with some `static_assert` demonstrates the template parameter has been instanced correctly.", "feature_layers": ["sema"], "feature_directives": [], "files_changed": [{"filename": "clang/test/SemaTemplate/default-parm-init.cpp", "functions": ["FuncSizeof2", "main", "FuncSizeof", "FuncAlign2", "FuncAlign"]}]}
{"pr_number": 80008, "url": "https://github.com/llvm/llvm-project/pull/80008", "title": "[flang] Lower ASYNCHRONOUS variables and IO statements", "body": "Finish plugging-in ASYNCHRONOUS IO in lowering (GetAsynchronousId was not used yet).\r\n\r\nAdd a runtime implementation for GetAsynchronousId (only the signature was defined). Always return zero since flang runtime \"fakes\" asynchronous IO (data transfer are always complete, see flang/docs/IORuntimeInternals.md).\r\n\r\nUpdate all runtime integer argument and results for IDs to use the AsynchronousId int alias for consistency.\r\n\r\nIn lowering, asynchronous attribute is added on the hlfir.declare of ASYNCHRONOUS variable, but nothing else is done. This is OK given the synchronous aspects of flang IO, but it would be safer to treat these variable as volatile (prevent code motion of related store/loads) since the asynchronous data change can also be done by C defined user procedure (see 18.10.4 Asynchronous communication). Flang lowering anyway does not give enough info for LLVM to do such code motions (the variables that are passed in a call are not given the noescape attribute, so LLVM will assume any later opaque call may modify the related data and would not move load/stores of such variables before/after calls even if it could from a pure Fortran point of view without ASYNCHRONOUS).", "feature_layers": ["runtime", "ir"], "feature_directives": ["for", "declare"], "files_changed": [{"filename": "flang/lib/Lower/IO.cpp", "functions": ["isDataTransferAsynchronous"]}, {"filename": "flang/runtime/io-api.cpp", "functions": ["IONAME"]}]}
{"pr_number": 80144, "url": "https://github.com/llvm/llvm-project/pull/80144", "title": "Revert \"[Clang][Sema] fix outline member function template with defau\u2026", "body": "\u2026lt align crash (#78400)\"\r\n\r\nThis reverts commit 7b3389980ddbd84f72ccc4776889c67519cc2c14.\r\n\r\nA regression was discovered here:\r\nhttps://github.com/llvm/llvm-project/pull/78400\r\n\r\nand the author requested a revert to give time to review.", "feature_layers": ["sema"], "feature_directives": [], "files_changed": [{"filename": "clang/test/SemaTemplate/default-parm-init.cpp", "functions": ["FuncSizeof2", "main", "FuncSizeof", "FuncAlign2", "FuncAlign"]}]}
{"pr_number": 79269, "url": "https://github.com/llvm/llvm-project/pull/79269", "title": "[clang][Interp] Handle casts between complex types", "body": "Just handle this like two primtive casts.", "feature_layers": ["ast"], "feature_directives": [], "files_changed": [{"filename": "clang/test/AST/Interp/complex.cpp", "functions": ["ignoredCast", "ignored"]}]}
{"pr_number": 80013, "url": "https://github.com/llvm/llvm-project/pull/80013", "title": "[AsmParser] Support non-consecutive global value numbers", "body": "https://github.com/llvm/llvm-project/pull/78171 added support for non-consecutive local value numbers. This extends the support for global value numbers (for globals and functions).\r\n\r\nThis means that it is now possible to delete an unnamed global definition/declaration without breaking the IR.\r\n\r\nThis is a lot less common than unnamed local values, but it seems like something we should support for consistency.  (Unnamed globals are used a lot in Rust though.)", "feature_layers": ["parse", "ir", "parser"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/AsmParser/LLParser.cpp", "functions": ["parseFunctionHeader", "error"]}]}
{"pr_number": 79608, "url": "https://github.com/llvm/llvm-project/pull/79608", "title": "[clang][dataflow] fix assert in `Environment::getResultObjectLocation`", "body": "When calling `Environment::getResultObjectLocation` with a CXXOperatorCallExpr that is a prvalue, we just hit an assert because no record was ever created.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "clang/unittests/Analysis/FlowSensitive/TransferTest.cpp", "functions": ["target"]}]}
{"pr_number": 79606, "url": "https://github.com/llvm/llvm-project/pull/79606", "title": "[mlir][mesh] Refactoring code organization, tests and docs", "body": "* Split out `MeshDialect.h` form `MeshOps.h` that defines the dialect class. Reduces include clutter if you care only about the dialect and not the ops.\r\n\r\n* Expose functions `getMesh` and `collectiveProcessGroupSize`. There functions are useful for outside users of the dialect.\r\n\r\n* Remove unused code.\r\n\r\n* Remove examples and tests of mesh.shard attribute in tensor encoding. Per the decision that Spmdization would be performed on sharding annotations and there will be no tensors with sharding specified in the type. For more info see this RFC comment:\r\nhttps://discourse.llvm.org/t/rfc-sharding-framework-design-for-device-mesh/73533/81", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Mesh/IR/MeshOps.cpp", "functions": ["canonicalizeSetAsArray"]}, {"filename": "mlir/lib/Dialect/Mesh/Transforms/Spmdization.cpp", "functions": ["shardCount"]}]}
{"pr_number": 80080, "url": "https://github.com/llvm/llvm-project/pull/80080", "title": "[Exegesis] Print epsilon value in the sched model inconsistency report", "body": "Since I've formatted the epsilon value, I don't think it's necessary to escape it.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/tools/llvm-exegesis/lib/Analysis.cpp", "functions": ["format"]}]}
{"pr_number": 80133, "url": "https://github.com/llvm/llvm-project/pull/80133", "title": "[lldb][DataFormatter][NFC] Use GetFirstValueOfLibCXXCompressedPair throughout formatters", "body": "This avoids duplicating the logic to get the first\r\nelement of a libc++ `__compressed_pair`. This will\r\nbe useful in supporting upcoming changes to the layout\r\nof `__compressed_pair`.\r\n\r\nDrive-by changes:\r\n* Renamed `m_item` to `size_node` for readability;\r\n  `m_item` suggests it's a member variable, which it\r\n  is not.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "lldb/source/Plugins/Language/CPlusPlus/LibCxxMap.cpp", "functions": ["size_node", "m_item"]}]}
{"pr_number": 80153, "url": "https://github.com/llvm/llvm-project/pull/80153", "title": "[Libomptarget] Remove handling of old ctor / dtor entries", "body": "Summary:\nA previous patch removed creating these entries in clang in favor of the\nbackend emitting a callable kernel and having the runtime call that if\npresent. The support for the old style was kept around in LLVM 18.0 but\nnow that we have forked to 19.0 we should remove the support.\n\nThe effect of this would be that an application linking against a newer\nlibomptarget that still had the old constructors will no longer be\ncalled. In that case, they can either recompile or use the\n`libomptarget.so.18` that comes with the previous release.\n", "feature_layers": ["runtime"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "openmp/libomptarget/src/PluginManager.cpp", "functions": ["AsyncInfo"]}, {"filename": "openmp/libomptarget/src/device.cpp", "functions": ["if"]}, {"filename": "openmp/libomptarget/src/omptarget.cpp", "functions": ["AsyncInfo"]}]}
{"pr_number": 80116, "url": "https://github.com/llvm/llvm-project/pull/80116", "title": "Revert \"[mlir][memref] `memref.subview`: Verify result strides\"", "body": "Reverts llvm/llvm-project#79865\r\n\r\nI think there is a bug in the stride computation in `SubViewOp::inferResultType`. (Was already there before this change.)\r\n\r\nReverting this commit for now and updating the original pull request with a fix and more test cases.\r\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/MemRef/IR/MemRefOps.cpp", "functions": ["failure", "haveCompatibleStrides", "success", "produceSubViewErrorMsg"]}]}
{"pr_number": 76873, "url": "https://github.com/llvm/llvm-project/pull/76873", "title": "[CLANG] Add warning when INF or NAN are used in a binary operation or as function argument in fast math mode.", "body": "Check for operations using INF or NaN when in ffast-math mode and generate a warning.", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Sema/SemaChecking.cpp", "functions": ["Value"]}, {"filename": "clang/test/Sema/warn-fp-fast-compare.cpp", "functions": ["__builtin_huge_val", "infinity", "_Ty", "__attribute__", "isunorderedf", "compareit"]}, {"filename": "clang/test/Sema/warn-infinity-nan-disabled-lnx.cpp", "functions": ["__builtin_huge_val", "infinity", "_Ty", "__attribute__", "isunorderedf", "compareit"]}, {"filename": "clang/test/Sema/warn-infinity-nan-disabled-win.cpp", "functions": ["__builtin_huge_val", "infinity", "_Ty", "__attribute__", "isunorderedf", "compareit"]}]}
{"pr_number": 79952, "url": "https://github.com/llvm/llvm-project/pull/79952", "title": "[ORC] Merge MaterializationResponsibility notifyEmitted and addDepend\u2026", "body": "\u2026encies.\r\n\r\nRemoves the MaterializationResponsibility::addDependencies and addDependenciesForAll methods, and transfers dependency registration to the notifyEmitted operation. The new dependency registration allows dependencies to be specified for arbitrary subsets of the MaterializationResponsibility's symbols (rather than just single symbols or all symbols) via an array of SymbolDependenceGroups (pairs of symbol sets and corresponding dependencies for that set).\r\n\r\nThis patch aims to both improve emission performance and simplify dependence tracking. By eliminating some states (e.g. symbols having registered dependencies but not yet being resolved or emitted) we make some errors impossible by construction, and reduce the number of error cases that we need to check. NonOwningSymbolStringPtrs are used for dependence tracking under the session lock, which should reduce ref-counting operations, and intra-emit dependencies are resolved outside the session lock, which should provide better performance when JITing concurrently (since some dependence tracking can happen in parallel).\r\n\r\nThe Orc C API is updated to account for this change, with the LLVMOrcMaterializationResponsibilityNotifyEmitted API being modified and the LLVMOrcMaterializationResponsibilityAddDependencies and LLVMOrcMaterializationResponsibilityAddDependenciesForAll operations being removed.", "feature_layers": ["ir"], "feature_directives": ["parallel", "for", "single"], "files_changed": [{"filename": "llvm/lib/ExecutionEngine/Orc/Core.cpp", "functions": ["NonOwningDep", "makeUnsatisfiedDepsError", "IL_failSymbols", "makeJDClosedError", "if", "orcError", "NonOwningSymbol", "SSP"]}, {"filename": "llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp", "functions": ["computeNamedSymbolDependencies", "registerDependencies"]}, {"filename": "llvm/lib/ExecutionEngine/Orc/OrcV2CBindings.cpp", "functions": ["toSymbolNameSet", "wrap"]}, {"filename": "llvm/lib/ExecutionEngine/Orc/RTDyldObjectLinkingLayer.cpp", "functions": ["Resolver", "MR"]}, {"filename": "llvm/unittests/ExecutionEngine/Orc/CoreAPIsTest.cpp", "functions": ["BarDeps", "FooDeps", "BazDeps", "SDG"]}]}
{"pr_number": 79398, "url": "https://github.com/llvm/llvm-project/pull/79398", "title": "[analyzer] Unbreak [[clang::suppress]] on checkers without decl-with-issue.", "body": "There are currently a few checkers that don't fill in the bug report's \"decl-with-issue\" field (typically a function in which the bug is found).\r\n\r\nThe new attribute `[[clang::suppress]]` uses decl-with-issue to reduce the size of the suppression source range map so that it didn't need to do that for the entire translation unit.\r\n\r\nI'm already seeing a few problems with this approach so I'll probably redesign it in some point as it looks like a premature optimization. Not only checkers shouldn't be required to pass decl-with-issue (consider clang-tidy checkers that never had such notion), but also it's not necessarily uniquely determined (consider leak suppressions at allocation site).\r\n\r\nFor now I'm adding a simple stop-gap solution that falls back to building the suppression map for the entire TU whenever decl-with-issue isn't specified. Which won't happen in the default setup because luckily all default checkers do provide decl-with-issue.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/StaticAnalyzer/Core/BugReporter.cpp", "functions": ["D"]}, {"filename": "clang/test/Analysis/Checkers/WebKit/call-args.cpp", "functions": ["foo_suppressed"]}, {"filename": "clang/test/Analysis/copypaste/suspicious-clones.cpp", "functions": ["maxClone_suppressed", "max_suppressed"]}]}
{"pr_number": 76201, "url": "https://github.com/llvm/llvm-project/pull/76201", "title": "[libcxx][NFC] Rename iterator/sentinel type template parameter names", "body": "According to internally agreed upon best practices, type template parameter names representing iterator types should be named `Iter`. For type template parameters representing sentinel types, they should be named `Sent`.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "libcxx/test/std/ranges/range.adaptors/range.filter/iterator/arrow.pass.cpp", "functions": ["iter", "decltype"]}, {"filename": "libcxx/test/std/ranges/range.adaptors/range.filter/iterator/base.pass.cpp", "functions": ["iter"]}, {"filename": "libcxx/test/std/ranges/range.adaptors/range.filter/iterator/ctor.parent_iter.pass.cpp", "functions": ["view"]}, {"filename": "libcxx/test/std/ranges/range.adaptors/range.filter/iterator/deref.pass.cpp", "functions": ["iter"]}, {"filename": "libcxx/test/std/ranges/range.adaptors/range.filter/sentinel/base.pass.cpp", "functions": ["decltype"]}, {"filename": "libcxx/test/std/ranges/range.adaptors/range.filter/sentinel/compare.pass.cpp", "functions": ["v"]}]}
{"pr_number": 79330, "url": "https://github.com/llvm/llvm-project/pull/79330", "title": "[RISCV] Improve legalization of e8 m8 VL>256 shuffles", "body": "If we can't produce a large enough index vector in i8, we may need to legalize\r\nthe shuffle (via scalarization - which in turn gets lowered into stack usage).\r\nThis change makes two related changes:\r\n* Deferring legalization until we actually need to generate the vrgather\r\n  instruction.  With the new recursive structure, this only happens when\r\n  doing the fallback for one of the arms.\r\n* Check the actual mask values for something outside of the representable\r\n  range.\r\n\r\nBoth are covered by recently added tests.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVISelLowering.cpp", "functions": ["SDValue"]}]}
{"pr_number": 79716, "url": "https://github.com/llvm/llvm-project/pull/79716", "title": "[lldb][NFCI] Remove m_being_created from Breakpoint classes", "body": "The purpose of m_being_created in these classes was to prevent broadcasting an event related to these Breakpoints during the creation of the breakpoint (i.e. in the constructor). In Breakpoint and Watchpoint, m_being_created had no effect. That is to say, removing it does not change behavior.\r\nHowever, BreakpointLocation does still use m_being_created. In the constructor, SetThreadID is called which does broadcast an event only if `m_being_created` is false. Instead of having this logic be roundabout, the constructor instead calls `SetThreadIDInternal`, which actually changes the thread ID. `SetThreadID` also will call `SetThreadIDInternal` in addition to broadcasting a changed event.", "feature_layers": ["ast"], "feature_directives": [], "files_changed": [{"filename": "lldb/source/Breakpoint/Breakpoint.cpp", "functions": ["m_being_created", "m_hardware"]}, {"filename": "lldb/source/Breakpoint/BreakpointLocation.cpp", "functions": ["m_should_resolve_indirect_functions", "m_being_created"]}]}
{"pr_number": 80094, "url": "https://github.com/llvm/llvm-project/pull/80094", "title": "[WebAssembly] avoid to enable explicit disabled feature", "body": "In `CoalesceFeaturesAndStripAtomics`, feature string is converted to FeatureBitset and back to feature string. It will lose information about explicit diasbled features.", "feature_layers": [], "feature_directives": ["for", "atomic"], "files_changed": [{"filename": "llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp", "functions": ["getFeatureString"]}]}
{"pr_number": 79925, "url": "https://github.com/llvm/llvm-project/pull/79925", "title": "[BOLT] Add metadata pre-emit finalization interface", "body": "Some metadata needs to be updated/finalized before the binary context is emitted into the binary. Add the interface and use it for Linux ORC update invocation.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "bolt/lib/Rewrite/LinuxKernelRewriter.cpp", "functions": ["postEmitFinalizer", "preEmitFinalizer"]}]}
{"pr_number": 76468, "url": "https://github.com/llvm/llvm-project/pull/76468", "title": "[mlir] Exclude masked ops in VectorDropLeadUnitDim", "body": "Don't insert cast ops for ops in `vector.mask` region in `VectorDropLeadUnitDim`.\r\n\r\nAccording to the vector masking RFC: https://discourse.llvm.org/t/rfc-vector-masking-representation-in-mlir/64964 `vector.mask` op doesn't support multiple ops in its region. Therefore, in `VectorDropLeadUnitDim` we can't directly insert cast ops in the region. This change temporarily skips such cases as a workaround.\r\n\r\nI'm not quite sure of the complete solution for this issue. But the same problem might also happen to other vector transformations which require to insert ops before/after a maskable vector op. Any feedback will be very helpful : ) ", "feature_layers": ["ir", "ast"], "feature_directives": ["for", "masked"], "files_changed": [{"filename": "mlir/lib/Dialect/Vector/Transforms/VectorDropLeadUnitDim.cpp", "functions": ["failure"]}]}
{"pr_number": 78284, "url": "https://github.com/llvm/llvm-project/pull/78284", "title": "[clang][ASTImporter] Improve import of variable template specializations.", "body": "Code of `VisitVarTemplateSpecializationDecl` was rewritten based on code of `VisitVarDecl`. Additional changes (in structural equivalence) were made to make tests pass.", "feature_layers": ["ast"], "feature_directives": [], "files_changed": [{"filename": "clang/unittests/AST/ASTImporterGenericRedeclTest.cpp", "functions": ["getPattern", "varTemplateSpecializationDecl"]}]}
{"pr_number": 80101, "url": "https://github.com/llvm/llvm-project/pull/80101", "title": "[clang][NFC] Move isSimpleTypeSpecifier() from Sema to Token", "body": "So that it can be used by clang-format.", "feature_layers": ["sema"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Lex/Lexer.cpp", "functions": ["getIdentifierInfo"]}]}
{"pr_number": 71701, "url": "https://github.com/llvm/llvm-project/pull/71701", "title": "[clang-tidy] Add AllowStringArrays option to modernize-avoid-c-arrays", "body": "Add AllowStringArrays option, enabling the exclusion of array types with deduced sizes constructed from string literals. This includes only var declarations of array of characters constructed directly from c-strings.\r\n\r\nCloses #59475", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "clang-tools-extra/clang-tidy/modernize/AvoidCArraysCheck.cpp", "functions": ["ClangTidyCheck"]}, {"filename": "clang-tools-extra/test/clang-tidy/checkers/modernize/avoid-c-arrays-ignores-strings.cpp", "functions": ["takeCharArray"]}, {"filename": "clang-tools-extra/test/clang-tidy/checkers/modernize/avoid-c-arrays.cpp", "functions": ["takeCharArray"]}]}
{"pr_number": 80110, "url": "https://github.com/llvm/llvm-project/pull/80110", "title": "[mlir][Vector] Add support for sub-byte transpose emulation", "body": "This PR adds patterns to convert a sub-byte vector transpose into a sequence of instructions that perform the transpose on i8 vector elements. Whereas this rewrite may not lead to the absolute peak performance, it should ensure correctness when dealing with sub-byte transposes.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Vector/Transforms/VectorEmulateNarrowType.cpp", "functions": ["success"]}]}
{"pr_number": 78312, "url": "https://github.com/llvm/llvm-project/pull/78312", "title": "[mlir][Transforms] `GreedyPatternRewriteDriver`: Hash ops separately", "body": "The greedy pattern rewrite driver has multiple \"expensive checks\" to detect invalid rewrite pattern API usage. As part of these checks, it computes fingerprints for every op that is in scope, and compares the fingerprints before and after an attempted pattern application.\r\n\r\nUntil now, each computed fingerprint took into account all nested operations. That is quite expensive because it walks the entire IR subtree. It is also redundant in the expensive checks because we already compute a fingerprint for every op.\r\n\r\nThis commit significantly improves the running time of the \"expensive checks\" in the greedy pattern rewrite driver.\r\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp", "functions": ["invalidateFingerPrint", "notifyBlockRemoved"]}]}
{"pr_number": 80179, "url": "https://github.com/llvm/llvm-project/pull/80179", "title": "[flang][NFC] Cache derived type translation in lowering", "body": "Derived type translation is proving expensive in modern fortran apps with many big derived types with dozens of components and parents.\r\n\r\nExtending the cache that prevent recursion is proving to have little cost on apps with small derived types and significant gain (can divide compile time by 2) on modern fortran apps.\r\n\r\nIt is legal since the cache lifetime is less than the MLIRContext lifetime that owns the cached mlir::Type.\r\n\r\nDoing so also exposed that the current caching was incorrect, the type symbol is the same for kind parametrized derived types regardless of the kind parameters. Instances with different kinds should lower to different MLIR types. See added test.\r\nUsing the type scopes fixes the problem.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Lower/ConvertType.cpp", "functions": ["popDerivedTypeInConstruction"]}]}
{"pr_number": 79865, "url": "https://github.com/llvm/llvm-project/pull/79865", "title": "[mlir][memref] `memref.subview`: Verify result strides", "body": "The `memref.subview` verifier currently checks result shape, element type, memory space and offset of the result type. However, the strides of the result type are currently not verified. This commit adds verification of result strides for non-rank reducing ops and fixes invalid IR in test cases.\r\n\r\nVerification of result strides for ops with rank reductions is more complex (and there could be multiple possible result types). That is left for a separate commit.\r\n\r\nAlso refactor the implementation a bit:\r\n* If `computeMemRefRankReductionMask` could not compute the dropped dimensions, there must be something wrong with the op. Return `FailureOr` instead of `std::optional`.\r\n* `isRankReducedMemRefType` did much more than just checking whether the op has rank reductions or not. Inline the implementation into the verifier and add better comments.\r\n* `produceSubViewErrorMsg` does not have to be templatized.\r\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/MemRef/IR/MemRefOps.cpp", "functions": ["failure", "haveCompatibleStrides", "success", "produceSubViewErrorMsg"]}]}
{"pr_number": 79612, "url": "https://github.com/llvm/llvm-project/pull/79612", "title": " [mlir][EmitC] Add func, call and return operations and conversions", "body": "This adds a `func`, `call` and `return` operation to the EmitC dialect,\r\nclosely related to the corresponding operations of the Func dialect. In\r\ncontrast to the operations of the Func dialect, the EmitC operations do\r\nnot support multiple results. The `emitc.func` op features a\r\n`specifiers` argument that for example allows, with corresponding\r\nsupport in the emitter, to emit `inline static` functions.\r\n\r\nFurthermore, this adds patterns and a pass to convert the Func dialect\r\nto EmitC. A `func.func` op that is `private` is converted to\r\n`emitc.func` with a `\"static\"` specifier.", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/EmitC/IR/EmitC.cpp", "functions": ["emitOpError"]}, {"filename": "mlir/lib/Target/Cpp/TranslateToCpp.cpp", "functions": ["success", "printCallOperation", "scope", "failure", "printOperation"]}, {"filename": "mlir/lib/Conversion/FuncToEmitC/FuncToEmitC.cpp", "functions": ["success"]}, {"filename": "mlir/lib/Conversion/FuncToEmitC/FuncToEmitCPass.cpp", "functions": ["target", "runOnOperation", "patterns"]}]}
{"pr_number": 80132, "url": "https://github.com/llvm/llvm-project/pull/80132", "title": "[flang][HLFIR] Relax verifiers of intrinsic operations", "body": "The verifiers are currently very strict: requiring intrinsic operations to be used only in cases where the Fortran standard permits the intrinsic to be used.\r\n\r\nThere have now been a lot of cases where these verifiers have caused bugs in corner cases. In a recent ticket, @jeanPerier pointed out that it could be useful for future optimizations if somewhat invalid uses of these operations could be allowed in dead code. See this comment: https://github.com/llvm/llvm-project/issues/79995#issuecomment-1918118234\r\n\r\nIn response to all of this, I have decided to relax the intrinsic operation verifiers. The intention is now to only disallow operation uses that are likely to crash the compiler. Other checks are still available under `-strict-intrinsic-verifier`.\r\n\r\nThe disadvantage of this approach is that IR can now represent intrinsic invocations which are incorrect. The lowering and implementation of these intrinsic functions is unlikely to do the right thing in all of these cases, and as they should mostly be impossible to generate using normal Fortran code, these edge cases will see very little testing, before some new optimization causes them to become more common.\r\n\r\nFixes #79995", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Optimizer/HLFIR/IR/HLFIROps.cpp", "functions": ["emitOpError"]}]}
{"pr_number": 76410, "url": "https://github.com/llvm/llvm-project/pull/76410", "title": "[clangd][SymbolCollector] Treat ObjC methods as spelled", "body": "We'll treat multi-arg methods as spelled once we have full rename support for them.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang-tools-extra/clangd/unittests/SymbolCollectorTests.cpp", "functions": ["fff"]}]}
{"pr_number": 80145, "url": "https://github.com/llvm/llvm-project/pull/80145", "title": "[mlir][scf] Considering defining operators of indices when fusing scf::ParallelOp", "body": "When checking the load indices of the second loop coincide with the store indices of the first loop, it only considers the index values are the same or not. However, there are some cases the index values defined by other operators. In these cases, it will treat them as different even the results of defining operators are the same.\r\n\r\nWe already check if the iteration space is the same in isFusionLegal(). When checking operands of defining operators, we only need to consider the operands come from the same induction variables. If so, we know the results of defining operators are the same.", "feature_layers": ["ir"], "feature_directives": ["parallel"], "files_changed": [{"filename": "mlir/lib/Dialect/SCF/Transforms/ParallelLoopFusion.cpp", "functions": ["failure", "success"]}]}
{"pr_number": 71485, "url": "https://github.com/llvm/llvm-project/pull/71485", "title": "[AIX][TLS] Optimize the small local-exec access sequence for non-zero offsets", "body": "This patch utilizes the -maix-small-local-exec-tls option to produce a faster,\r\nnon-TOC-based access sequence for the local-exec TLS model. Specifically, for\r\nwhen the offsets from the TLS variable are non-zero.\r\n\r\nIn particular, this patch produces either a single:\r\n- addi/la with a displacement off of R13 plus a non-zero offset for when an address is calculated, or\r\n- load or store off of R13 plus a non-zero offset for when an address is calculated and used for further\r\n  access where R13 is the thread pointer, respectively.\r\n\r\nIn order to produce a single addi or load/store off of the thread pointer with a non-zero offset,\r\nthis patch also adds the necessary support in the assembly printer when printing these instructions.\r\n\r\nSpecifically:\r\n- The non-zero offset is added to the TLS variable address when the address of the\r\n  TLS variable + it's offset is less than 32KB.\r\n- Otherwise, when the address of the TLS variable + its offset is greater than 32KB, the\r\n  non-zero offset (and a multiple of 64KB) is subtracted from the TLS address.\r\n\r\nThis handling in the assembly printer is necessary to ensure that the TLS address + the non-zero offset\r\nis between [-32768, 32768), so that the total displacement can fit within the addi/load/store instructions.\r\n\r\nThis patch is meant to be a follow-up to 3f46e5453d9310b15d974e876f6132e3cf50c4b1 (where the\r\noptimization occurs for when the offset is zero).", "feature_layers": ["ast"], "feature_directives": ["for", "single"], "files_changed": [{"filename": "llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp", "functions": ["foldADDIForLocalExecAccesses"]}]}
{"pr_number": 75955, "url": "https://github.com/llvm/llvm-project/pull/75955", "title": "[mlir][scf] Add reductions support to `scf.parallel` fusion", "body": "Properly handle fusion of loops with reductions:\r\n* Check there are no first loop results users between loops\r\n* Create new loop op with merged reduction init values\r\n* Update `scf.reduce` op to contain reductions from both loops\r\n* Update loops users with new loop results", "feature_layers": ["ir"], "feature_directives": ["parallel"], "files_changed": [{"filename": "mlir/lib/Dialect/SCF/Transforms/ParallelLoopFusion.cpp", "functions": ["newReduceArgs"]}]}
{"pr_number": 78907, "url": "https://github.com/llvm/llvm-project/pull/78907", "title": "[llvm-objdump][AMDGPU] Pass ELF ABIVersion through disassembler", "body": "Admittedly, its a bit ugly to pass the ABIVersion through onSymbolStart but I'm not sure what a better place for it would be. ", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.cpp", "functions": ["getDefaultAMDHSACodeObjectVersion", "getAMDHSACodeObjectVersion"]}]}
{"pr_number": 79824, "url": "https://github.com/llvm/llvm-project/pull/79824", "title": "[mlir][tosa] Convert tosa.transpose_conv2d to linalg.generic directly", "body": "Currently, we use reverse, pad, reshape, and conv2d operators, etc, to emulate transpose_conv2d. This patch adds a pattern to convert tosa.transpose_conv2d to linalg.generic directly.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Conversion/TosaToLinalg/TosaToLinalgNamed.cpp", "functions": ["success"]}]}
{"pr_number": 79648, "url": "https://github.com/llvm/llvm-project/pull/79648", "title": "Aggregate errors from llvm-dwarfdump --verify", "body": "The amount and format of output from `llvm-dwarfdump --verify` makes it quite difficult to know if a change to a tool that produces or modifies DWARF is causing new problems, or is fixing existing problems. This diff adds a categorized summary of issues found by the DWARF verifier, on by default, at the bottom of the error output. \r\n\r\nThe change includes a new `--error-display` option with 4 settings:\r\n\r\n* `--error-display=quiet`:  Only display if errors occurred, but no details or summary are printed.\r\n* `--error-display=summary`: Only display the aggregated summary of errors with no error detail.\r\n* `--error-display=details`: Only display the detailed error messages with no summary (previous behavior)\r\n* `--error-display=full`: Display both the detailed error messages and the aggregated summary of errors (the default)\r\n\r\nI changed a handful of tests that were failing due to new output, adding the flag to use the old behavior for all but a couple. For those two I added the new aggregated output to the expected output of the test.\r\n\r\nThe `OutputCategoryAggregator` is a pretty simple little class that @clayborg suggested to allow code to only be run to dump detail if it's enabled, while still collating counts of the category. Knowing that the lambda passed in is only conditionally executed is pretty important (handling errors has to be done *outside* the lambda). I'm happy to move this somewhere else (and change/improve it) to be more broadly useful if folks would like.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/DebugInfo/DWARF/DWARFVerifier.cpp", "functions": ["OS", "if", "format", "formatv"]}]}
{"pr_number": 76857, "url": "https://github.com/llvm/llvm-project/pull/76857", "title": "[clang-doc] Fix failing test", "body": "This fixes a failing test case in clang-doc introduced by 7fbc1de9896029636dd572a692ee90ba88285943 (PR https://github.com/llvm/llvm-project/pull/76677). I presume the test is intended to be well-formed, so I have changed it accordingly. ", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang-tools-extra/test/clang-doc/templates.cpp", "functions": ["function"]}]}
{"pr_number": 80216, "url": "https://github.com/llvm/llvm-project/pull/80216", "title": "[OpenMP] Move unsupported structured bindings diagnostic", "body": "Move the diagnostic so it fires only when doing an OpenMP capture, not for non-OpenMP captures. This allows non-OpenMP code to work when using OpenMP elsewhere, such as the code reported in\r\nhttps://github.com/llvm/llvm-project/issues/66999.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/SemaCXX/decomposition-openmp.cpp", "functions": ["g", "h", "foo"]}]}
{"pr_number": 80201, "url": "https://github.com/llvm/llvm-project/pull/80201", "title": "[RISCV] Support constraint \"s\"", "body": "GCC has supported a generic constraint \"s\" for a long time (since at\nleast 1992), which references a symbol or label with an optional\nconstant offset. \"i\" is a superset that also supports a constant\ninteger.\n\nGCC's RISC-V port also supports a machine-specific constraint \"S\",\nwhich cannot be used with a preemptible symbol. (We don't bother to\ncheck preemptibility.) In PIC code, an external symbol is preemptible by\ndefault, making \"S\" less useful if you want to create an artificial\nreference for linker garbage collection, or define sections to hold\nsymbol addresses:\n\n```\nvoid fun();\n// error: impossible constraint in \u2018asm\u2019 for riscv64-linux-gnu-gcc -fpie/-fpic\nvoid foo() { asm(\".reloc ., BFD_RELOC_NONE, %0\" :: \"S\"(fun)); }\n// good even if -fpie/-fpic\nvoid foo() { asm(\".reloc ., BFD_RELOC_NONE, %0\" :: \"s\"(fun)); }\n```\n\nThis patch adds support for \"s\". Modify https://reviews.llvm.org/D105254\n(\"S\") to handle multi-depth GEPs (https://reviews.llvm.org/D61560).\n", "feature_layers": ["ast"], "feature_directives": ["for", "sections"], "files_changed": [{"filename": "clang/test/CodeGen/RISCV/riscv-inline-asm.c", "functions": ["test_s", "volatile", "test_S"]}, {"filename": "clang/test/Sema/inline-asm-validate-riscv.c", "functions": ["test_s"]}]}
{"pr_number": 74114, "url": "https://github.com/llvm/llvm-project/pull/74114", "title": "[RISCV][GISel] RegBank select and instruction select for vector G_ADD, G_SUB", "body": "RegisterBank Selection for scalable vector G_ADD and G_SUB by creating new mappings for different types of vector register banks.\r\nThen implement Instruction Selection for the same operations by choosing the correct RISC-V vector register class.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/GISel/RISCVRegisterBankInfo.cpp", "functions": ["if"]}]}
{"pr_number": 80323, "url": "https://github.com/llvm/llvm-project/pull/80323", "title": "[libc] fix stdbit include test when not all entrypoints are available", "body": "The intent of the test is to check that:\n1. The type generic macros are defined.\n2. Those macros dispatch to the correct underlying function.\n\nThe issue is that when new functionality is added to our stdbit.h without\nrolling out the new entrypoint to all targets, this test breaks because our\ngenerated stdbit.h will not contain declarations for the underlying function.\nIn that case, we should just declare the underlying functions first before\nincluding our generated stdbit.h which just contains declarations. A definition\nis a declaration, but redeclarations must match, hence the additions of\nnoexcept and extern \"C\".\n", "feature_layers": ["ir"], "feature_directives": ["for", "target", "declare"], "files_changed": [{"filename": "libc/test/include/stdbit_test.cpp", "functions": ["stdc_leading_zeros_ull", "stdc_leading_ones_ull"]}]}
{"pr_number": 80330, "url": "https://github.com/llvm/llvm-project/pull/80330", "title": "[clang-tidy] Remove enforcement of rule C.48 from cppcoreguidelines-prefer-member-init", "body": "This functionality already exists in\r\ncppcoreguidelines-use-default-member-init. It was deprecated from this check in clang-tidy 17.\r\n\r\nThis allows us to fully decouple this check from the corresponding modernize check, which has an unhealthy dependency.\r\n\r\nFixes https://github.com/llvm/llvm-project/issues/62169", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang-tools-extra/clang-tidy/cppcoreguidelines/PreferMemberInitializerCheck.cpp", "functions": ["isLiteral", "shouldBeDefaultMemberInitializer", "Insertion", "isUnaryExprOfLiteral", "ClangTidyCheck", "getLangOpts"]}]}
{"pr_number": 79520, "url": "https://github.com/llvm/llvm-project/pull/79520", "title": "[SHT_LLVM_BB_ADDR_MAP][llvm-readobj] Implements llvm-readobj handling for PGOAnalysisMap.", "body": "Adds raw printing of PGOAnalysisMap in llvm-readobj.\r\n\r\nI'm leaving the fixme's for a later patch that will provide a 'pretty' printing for BBFreq and BrProb (i.e. relative frequencies and probabilities) that will apply to both llvm-readobj and llvm-objdump.\r\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/tools/llvm-readobj/ELFDumper.cpp", "functions": ["printBBAddrMaps", "PD", "L", "printAddrMaps"]}]}
{"pr_number": 80220, "url": "https://github.com/llvm/llvm-project/pull/80220", "title": "[analyzer][HTMLRewriter] Cache partial rewrite results.", "body": "This is a follow-up for 721dd3bc2 [analyzer] NFC: Don't regenerate duplicate HTML reports.\r\n\r\nBecause HTMLRewriter re-runs the Lexer for syntax highlighting and macro expansion purposes, it may get fairly expensive when the rewriter is invoked multiple times on the same file. In the static analyzer (which uses HTMLRewriter for HTML output mode) we only get away with this because there are usually very few reports emitted per file. But if loud checkers are enabled, such as `webkit.*`, this may explode in complexity and even cause the compiler to run over the 32-bit SourceLocation addressing limit.\r\n\r\nThis patch caches intermediate results so that re-lexing only needed to happen once.\r\n\r\nAs the clever __COUNTER__ test demonstrates, \"once\" is still too many. Ideally we shouldn't re-lex anything at all, which remains a TODO.", "feature_layers": ["ir", "lexer"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/Analysis/html_diagnostics/counter.c", "functions": ["bar", "foo"]}]}
{"pr_number": 80193, "url": "https://github.com/llvm/llvm-project/pull/80193", "title": "[clang-tidy] Remove enforcement of rule C.48 from cppcoreguidelines-p\u2026", "body": "\u2026refer-member-init\r\n\r\nThis functionality already exists in\r\ncppcoreguidelines-use-default-member-init. It was deprecated from this check in clang-tidy 17.\r\n\r\nThis allows us to fully decouple this check from the corresponding modernize check, which has an unhealthy dependency.\r\n\r\nFixes #62169", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang-tools-extra/clang-tidy/cppcoreguidelines/PreferMemberInitializerCheck.cpp", "functions": ["isLiteral", "shouldBeDefaultMemberInitializer", "Insertion", "isUnaryExprOfLiteral", "ClangTidyCheck", "getLangOpts"]}, {"filename": "lldb/unittests/Core/ProgressReportTest.cpp", "functions": ["progress2", "arch", "progress3", "timeout", "progress1", "SetUp"]}, {"filename": "lldb/test/API/functionalities/watchpoint/unaligned-large-watchpoint/main.c", "functions": ["main"]}, {"filename": "llvm/lib/ExecutionEngine/Orc/Core.cpp", "functions": ["NonOwningDep", "makeUnsatisfiedDepsError", "IL_failSymbols", "makeJDClosedError", "if", "orcError", "NonOwningSymbol", "SSP"]}, {"filename": "llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp", "functions": ["computeNamedSymbolDependencies", "registerDependencies"]}, {"filename": "llvm/lib/ExecutionEngine/Orc/OrcV2CBindings.cpp", "functions": ["toSymbolNameSet", "wrap"]}, {"filename": "llvm/lib/ExecutionEngine/Orc/RTDyldObjectLinkingLayer.cpp", "functions": ["Resolver", "MR"]}, {"filename": "llvm/unittests/ExecutionEngine/Orc/CoreAPIsTest.cpp", "functions": ["BarDeps", "FooDeps", "BazDeps", "SDG"]}, {"filename": "libc/src/stdio/scanf_core/float_converter.cpp", "functions": ["sizeof"]}, {"filename": "clang/lib/StaticAnalyzer/Core/BugReporter.cpp", "functions": ["D"]}, {"filename": "clang/test/Analysis/Checkers/WebKit/call-args.cpp", "functions": ["foo_suppressed"]}, {"filename": "clang/test/Analysis/copypaste/suspicious-clones.cpp", "functions": ["maxClone_suppressed", "max_suppressed"]}, {"filename": "llvm/lib/Target/AArch64/AArch64ISelLowering.cpp", "functions": ["DL", "getPredicateForVector", "SDValue", "isHalvingTruncateAndConcatOfLegalIntScalableType", "tryCombineExtendRShTrunc"]}, {"filename": "llvm/lib/Target/RISCV/RISCVISelLowering.cpp", "functions": ["SDValue"]}, {"filename": "lldb/source/Breakpoint/Breakpoint.cpp", "functions": ["m_being_created", "m_hardware"]}, {"filename": "lldb/source/Breakpoint/BreakpointLocation.cpp", "functions": ["m_should_resolve_indirect_functions", "m_being_created"]}, {"filename": "llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp", "functions": ["getFeatureString"]}, {"filename": "mlir/lib/Dialect/Vector/Transforms/VectorEmulateNarrowType.cpp", "functions": ["success"]}, {"filename": "clang/lib/Lex/Lexer.cpp", "functions": ["getIdentifierInfo"]}, {"filename": "lldb/source/Breakpoint/WatchpointAlgorithms.cpp", "functions": ["bit_ceil"]}, {"filename": "lldb/tools/debugserver/source/MacOSX/arm64/DNBArchImplARM64.cpp", "functions": ["bit_ceil"]}, {"filename": "clang-tools-extra/clang-tidy/modernize/AvoidCArraysCheck.cpp", "functions": ["ClangTidyCheck"]}, {"filename": "clang-tools-extra/test/clang-tidy/checkers/modernize/avoid-c-arrays-ignores-strings.cpp", "functions": ["takeCharArray"]}, {"filename": "clang-tools-extra/test/clang-tidy/checkers/modernize/avoid-c-arrays.cpp", "functions": ["takeCharArray"]}, {"filename": "clang/test/AST/Interp/complex.cpp", "functions": ["func"]}, {"filename": "clang/test/AST/Interp/c.c", "functions": ["f"]}, {"filename": "mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp", "functions": ["invalidateFingerPrint", "notifyBlockRemoved"]}, {"filename": "flang/lib/Lower/ConvertType.cpp", "functions": ["popDerivedTypeInConstruction"]}, {"filename": "mlir/lib/Conversion/FuncToEmitC/FuncToEmitC.cpp", "functions": ["success"]}, {"filename": "mlir/lib/Conversion/FuncToEmitC/FuncToEmitCPass.cpp", "functions": ["target", "runOnOperation", "patterns"]}, {"filename": "mlir/lib/Dialect/EmitC/IR/EmitC.cpp", "functions": ["emitOpError", "success", "getNumOperands", "emitError", "getOperand", "getNumResults"]}, {"filename": "mlir/lib/Target/Cpp/TranslateToCpp.cpp", "functions": ["success", "printCallOperation", "scope", "failure", "printOperation"]}, {"filename": "flang/lib/Optimizer/HLFIR/IR/HLFIROps.cpp", "functions": ["emitOpError"]}, {"filename": "libcxx/test/std/utilities/memory/allocator.traits/allocator.traits.members/allocate_at_least.pass.cpp", "functions": ["decltype", "allocate_at_least"]}, {"filename": "mlir/lib/Target/LLVMIR/ModuleImport.cpp", "functions": ["if"]}, {"filename": "mlir/lib/Target/LLVMIR/ModuleTranslation.cpp", "functions": ["if"]}, {"filename": "mlir/lib/Dialect/SCF/Transforms/ParallelLoopFusion.cpp", "functions": ["b", "newReduceArgs", "newInitVars"]}, {"filename": "llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp", "functions": ["computeCommonAlignment"]}, {"filename": "llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp", "functions": ["foldADDIForLocalExecAccesses"]}, {"filename": "bolt/lib/Passes/BinaryPasses.cpp", "functions": ["format"]}, {"filename": "llvm/lib/Target/X86/X86FixupVectorConstants.cpp", "functions": ["FixupConstant"]}, {"filename": "clang/lib/Parse/ParseDecl.cpp", "functions": ["SourceRange", "SAC", "ParseDeclGroup", "ParseDeclarationStartingWithTemplate"]}, {"filename": "clang/lib/Parse/ParseDeclCXX.cpp", "functions": ["DeclScopeObj"]}, {"filename": "clang/lib/Parse/ParseTemplate.cpp", "functions": ["prefixAttrs", "ParseStaticAssertDeclaration", "SourceRange", "DeclAttrs", "LateParsedAttrs", "ParseFunctionDefinition", "ParseDeclGroup", "SAC", "TemplateInfo", "DeclScopeObj"]}, {"filename": "clang/lib/Parse/Parser.cpp", "functions": ["ParseDeclGroup"]}, {"filename": "clang/test/CXX/temp/p3.cpp", "functions": ["g"]}, {"filename": "clang/test/OpenMP/declare_simd_messages.cpp", "functions": ["infunc1"]}, {"filename": "llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.cpp", "functions": ["getDefaultAMDHSACodeObjectVersion", "getAMDHSACodeObjectVersion"]}, {"filename": "llvm/lib/DebugInfo/DWARF/DWARFVerifier.cpp", "functions": ["if", "AttributeString", "format", "formatv"]}, {"filename": "clang/lib/AST/DeclTemplate.cpp", "functions": ["NumArguments", "Arguments"]}, {"filename": "clang/lib/Sema/SemaExprCXX.cpp", "functions": ["MLTAL", "TAL"]}, {"filename": "clang/lib/Sema/SemaTemplateDeduction.cpp", "functions": ["DeduceTemplateArguments"]}, {"filename": "libc/src/errno/libc_errno.cpp", "functions": ["int"]}, {"filename": "clang/test/SemaCXX/decomposition-openmp.cpp", "functions": ["g", "h", "foo"]}, {"filename": "libc/test/include/stdbit_test.cpp", "functions": ["stdc_leading_ones_uc", "stdc_leading_ones_ull", "stdc_leading_ones_ul", "stdc_leading_ones_us", "stdc_leading_ones_ui"]}, {"filename": "clang/test/CodeGen/RISCV/riscv-inline-asm.c", "functions": ["test_s", "volatile", "test_S"]}, {"filename": "clang/test/Sema/inline-asm-validate-riscv.c", "functions": ["test_s"]}, {"filename": "openmp/libomptarget/plugins-nextgen/cuda/src/rtl.cpp", "functions": ["cuMemAllocAsync"]}]}
{"pr_number": 78767, "url": "https://github.com/llvm/llvm-project/pull/78767", "title": "[DirectX] Add support to lower LLVM intrinsics ceil, cos, fabs, floor and smax to DXIL Ops.", "body": "Also add a DXILStrengthReduce pass to facilitate rewriting LLVM IR in preparation for DXIL lowering. Moved rewriting of FNeg from DXILModulePrepare to this pass and added support to rewrite abs intrinsic to the pass.\r\n\r\nAdd tests for each of the instructions being newly lowered and rewritten.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/DirectX/DXILStrengthReduce.cpp", "functions": ["DXILStrengthReduce", "Builder", "IRB", "runOnModule"]}]}
{"pr_number": 77457, "url": "https://github.com/llvm/llvm-project/pull/77457", "title": "[AsmPrinter][DebugNames] Implement DW_IDX_parent entries", "body": "This implements the ideas discussed in [1].\r\n\r\nTo summarize, this commit changes AsmPrinter so that it outputs DW_IDX_parent information for debug_name entries. It will enable debuggers to speed up queries for fully qualified types (based on a DWARFDeclContext) significantly, as debuggers will no longer need to parse the entire CU in order to inspect the parent chain of a DIE. Instead, a debugger can simply take the parent DIE offset from the accelerator table and peek at its name in the debug_info/debug_str sections.\r\n\r\nThe implementation uses two types of DW_FORM for the DW_IDX_parent attribute:\r\n\r\n1. DW_FORM_ref4, which points to the accelerator table entry for the parent.\r\n2. DW_FORM_flag_present, when the entry has a parent that is not in the table (that is, the parent doesn't have a name, or isn't allowed to be in the table as per the DWARF spec). This is space-efficient, since it takes 0 bytes.\r\n\r\nThe implementation works by:\r\n\r\n1. Changing how abbreviations are encoded (so that they encode which form, if\r\nany, was used to encode IDX_Parent)\r\n2. Creating an MCLabel per accelerator table entry, so that they may be\r\nreferred by IDX_parent references.\r\n\r\n\r\nWhen all patches related to this are merged, we are able to show that evaluating an expression such as:\r\n\r\n```\r\nlldb --batch -o 'b CodeGenFunction::GenerateCode' -o run -o 'expr Fn' -- \\\r\n  clang++ -c -g test.cpp -o /dev/null\r\n```\r\n\r\nis far faster: from ~5000 ms to ~1500ms.\r\n\r\nBuilding llvm-project + clang with and without this patch, and looking at its impact on object file size:\r\n\r\n```\r\nls -la $(find build_stage2_Debug_idx_parent_assert_dwarf5 -name \\*.cpp.o) | awk '{s+=$5}  END {printf \"%\\047d\\n\", s}'\r\n11,507,327,592\r\n\r\n-la $(find build_stage2_Debug_no_idx_parent_assert_dwarf5 -name \\*.cpp.o) | awk '{s+=$5}  END {printf \"%\\047d\\n\", s}'\r\n11,436,446,616\r\n```\r\n\r\nThat is, an increase of 0.62% in total object file size.\r\n\r\nLooking only at debug_names:\r\n\r\n```\r\n$stage1_build/bin/llvm-objdump --section-headers $(find build_stage2_Debug_idx_parent_assert_dwarf5 -name \\*.cpp.o) | grep __debug_names | awk '{s+=\"0x\"$3}  END {printf \"%\\047d\\n\", s}'\r\n440,772,348\r\n\r\n$stage1_build/bin/llvm-objdump --section-headers $(find build_stage2_Debug_no_idx_parent_assert_dwarf5 -name \\*.cpp.o) | grep __debug_names | awk '{s+=\"0x\"$3}  END {printf \"%\\047d\\n\", s}'\r\n369,867,920\r\n```\r\n\r\nThat is an increase of 19%.\r\n\r\nDWARF Linkers need to be changed in order to support this. This commit already brings support to \"base\" linker, but it does not attempt to modify the parallel linker. Accelerator entries refer to the corresponding DIE offset, and this patch also requires the parent DIE offset -- it's not clear how the parallel linker can access this. It may be obvious to someone familiar with it, but it would be nice to get help from its authors.\r\n\r\n[1]: https://discourse.llvm.org/t/rfc-improve-dwarf-5-debug-names-type-lookup-parsing-speed/74151/", "feature_layers": ["parse", "codegen", "ir", "ast"], "feature_directives": ["parallel", "for", "sections", "requires"], "files_changed": [{"filename": "llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp", "functions": ["encodeIdxParent"]}]}
{"pr_number": 80355, "url": "https://github.com/llvm/llvm-project/pull/80355", "title": "[mlir][sparse] support non-id map for [Dis]assembleOp", "body": "", "feature_layers": ["parse", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/Transforms/SparseReinterpretMap.cpp", "functions": ["failure", "success"]}]}
{"pr_number": 80207, "url": "https://github.com/llvm/llvm-project/pull/80207", "title": "[mlir][sparse] Support pretty print to debug sparse iteration.", "body": "", "feature_layers": ["parse", "ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/Transforms/SparseTensorPasses.cpp", "functions": ["options"]}, {"filename": "mlir/lib/Dialect/SparseTensor/Transforms/Utils/SparseTensorLevel.cpp", "functions": ["peekCrdAt", "SparseLevel", "SparseTensorLevel", "genIndexLoad"]}]}
{"pr_number": 80243, "url": "https://github.com/llvm/llvm-project/pull/80243", "title": "[mlir][spirv][memref] Calculate alignment for `PhysicalStorageBuffer`s", "body": "The SPIR-V spec requires that memory accesses to `PhysicalStorageBuffer`s are annotated with appropriate alignment attributes [1]. Calculate these based on memref alignment attributes or scalar type sizes.\r\n\r\n[1] Otherwise spirv-val complains:\r\n```\r\n[VULKAN] ! Validation Error: [ VUID-VkShaderModuleCreateInfo-pCode-01379 ] | MessageID = 0x2a1bf17f | SPIR-V module not valid: [VUID-StandaloneSpirv-PhysicalStorageBuffer64-04708] Memory accesses with PhysicalStorageBuffer must use Aligned.\r\n  %48 = OpLoad %float %47\r\n```", "feature_layers": ["ir"], "feature_directives": ["for", "requires"], "files_changed": [{"filename": "mlir/lib/Conversion/MemRefToSPIRV/MemRefToSPIRV.cpp", "functions": ["calculateRequiredAlignment", "failure"]}]}
{"pr_number": 80326, "url": "https://github.com/llvm/llvm-project/pull/80326", "title": "[mlir][sparse] external entry method wrapper for sparse tensors", "body": "Similar to the emit_c_interface, this pull request adds a pass that converts public entry methods that use sparse tensors as input parameters and/or output return values into wrapper functions that [dis]assemble the individual tensors that constitute the actual storage used externally into MLIR sparse tensors. This pass can be used to prepare the public entry methods of a program that is compiled by the MLIR sparsifier to interface with an external runtime, e.g., when passing sparse tensors as numpy arrays from and to Python. Note that eventual bufferization decisions (e.g. who [de]allocates the underlying memory) should be resolved in agreement with the external runtime (Python, PyTorch, JAX, etc.)", "feature_layers": ["parse", "runtime", "ir"], "feature_directives": ["for", "allocate"], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/Transforms/SparseAssembler.cpp", "functions": ["stt"]}, {"filename": "mlir/lib/Dialect/SparseTensor/Transforms/SparseTensorPasses.cpp", "functions": ["runOnOperation", "patterns"]}]}
{"pr_number": 74128, "url": "https://github.com/llvm/llvm-project/pull/74128", "title": "[SHT_LLVM_BB_ADDR_MAP] Allow basic-block-sections and labels be used together by decoupling the handling of the two features.", "body": "    \r\nToday `-split-machine-functions` and `-fbasic-block-sections={all,list}` cannot be combined with `-basic-block-sections=labels` (the labels option will be ignored).\r\nThe inconsistency comes from the way basic block address map -- the underlying mechanism for basic block labels -- encodes basic block addresses (https://lists.llvm.org/pipermail/llvm-dev/2020-July/143512.html).  Specifically, basic block offsets are computed relative to the function begin symbol. This relies on functions being contiguous which is not the case for MFS and basic block section binaries. This means Propeller cannot use binary profiles collected from these binaries, which limits the applicability of Propeller for iterative optimization.\r\n    \r\nTo make the `SHT_LLVM_BB_ADDR_MAP` feature work with basic block section binaries, we propose modifying the encoding of this section as follows.\r\n\r\nFirst let us review the current encoding which emits the address of each function and its number of basic blocks, followed by basic block entries for each basic block.\r\n\r\n| | |\r\n|--|--|\r\n|  Address of the function                           | Function Address      |\r\n|  Number of basic blocks in this function | NumBlocks |\r\n|  BB entry 1\r\n|  BB entry 2\r\n|   ...\r\n|  BB entry #NumBlocks\r\n    \r\nTo make this work for basic block sections, we treat each basic block section similar to a function, except that basic block sections of the same function must be encapsulated in the same structure so we can map all of them to their single function.\r\n    \r\nWe modify the encoding to first emit the number of basic block sections (BB ranges) in the function. Then we emit the address map of each basic block section section as before: the base address of the section, its number of blocks, and BB entries for its basic block. The first section in the BB address map is always the function entry section.\r\n| | |\r\n|--|--|\r\n|  Number of sections for this function   | NumBBRanges |\r\n| Section 1 begin address                     | BaseAddress[1]  |\r\n| Number of basic blocks in section 1 | NumBlocks[1]    |\r\n| BB entries for Section 1\r\n|..................|\r\n| Section #NumBBRanges begin address                      | BaseAddress[NumBBRanges] |\r\n| Number of basic blocks in section #NumBBRanges  | NumBlocks[NumBBRanges]  |\r\n| BB entries for Section #NumBBRanges\r\n    \r\nThe encoding of basic block entries remains as before with the minor change that each basic block offset is now computed relative to the begin symbol of its containing BB section.\r\n    \r\nThis patch adds a new boolean codegen option `-basic-block-address-map`. Correspondingly, the front-end flag `-fbasic-block-address-map` and LLD flag `--lto-basic-block-address-map` are introduced.\r\n    Analogously, we add a new TargetOption field `BBAddrMap`. This means BB address maps are either generated for all functions in the compiling unit, or for none (depending on `TargetOptions::BBAddrMap`).\r\n    \r\nThis patch keeps the functionality of the old `-fbasic-block-sections=labels` option but does not remove it. A subsequent patch will remove the obsolete option.\r\n\r\nWe refactor the `BasicBlockSections` pass by separating the BB address map and BB sections handing to their own functions (named `handleBBAddrMap` and `handleBBSections`).  `handleBBSections` renumbers basic blocks and places them in their assigned sections. `handleBBAddrMap` is invoked after `handleBBSections` (if requested) and only renumbers the blocks.\r\n  - New tests added:\r\n       - Two tests basic-block-address-map-with-basic-block-sections.ll and  basic-block-address-map-with-mfs.ll to exercise the combination of `-basic-block-address-map` with `-basic-block-sections=list` and '-split-machine-functions`.\r\n       - A driver sanity test for the `-fbasic-block-address-map` option (basic-block-address-map.c).\r\n       - An LLD test for testing the `--lto-basic-block-address-map` option. This reuses the LLVM IR from `lld/test/ELF/lto/basic-block-sections.ll`.\r\n  - Renamed and modified the two existing codegen tests for basic block address map (`basic-block-sections-labels-functions-sections.ll` and `basic-block-sections-labels.ll`)\r\n  - Removed `SHT_LLVM_BB_ADDR_MAP_V0` tests. Full deprecation of `SHT_LLVM_BB_ADDR_MAP_V0` and `SHT_LLVM_BB_ADDR_MAP` version less than 2 will happen in a separate PR in a few months.\r\n", "feature_layers": ["codegen", "ir"], "feature_directives": ["for", "sections", "single", "target"], "files_changed": [{"filename": "llvm/lib/CodeGen/BasicBlockSections.cpp", "functions": ["handleBBAddrMap", "handleBBSections"]}, {"filename": "llvm/tools/llvm-objdump/llvm-objdump.cpp", "functions": ["PGOSS", "empty", "AddrMap"]}, {"filename": "llvm/tools/llvm-readobj/ELFDumper.cpp", "functions": ["BBED", "BBEL", "BBRD", "BBRL"]}, {"filename": "llvm/unittests/Object/ELFObjectFileTest.cpp", "functions": ["ZeroBBRangesYamlString"]}]}
{"pr_number": 80079, "url": "https://github.com/llvm/llvm-project/pull/80079", "title": "[RISCV][Isel] Remove redundant vmerge for the scalable vwadd(u).wv", "body": "Similar to #78403, but for scalable `vwadd(u).wv`, given that #76785 is recommited.\r\n\r\n### Code\r\n```\r\ndefine <vscale x 8 x i64> @vwadd_wv_mask_v8i32(<vscale x 8 x i32> %x, <vscale x 8 x i64> %y) {\r\n    %mask = icmp slt <vscale x 8 x i32> %x, shufflevector (<vscale x 8 x i32> insertelement (<vscale x 8 x i32> poison, i32 42, i64 0), <vscale x 8 x i32> poison, <vscale x 8 x i32> zeroinitializer)\r\n    %a = select <vscale x 8 x i1> %mask, <vscale x 8 x i32> %x, <vscale x 8 x i32> zeroinitializer\r\n    %sa = sext <vscale x 8 x i32> %a to <vscale x 8 x i64>\r\n    %ret = add <vscale x 8 x i64> %sa, %y\r\n    ret <vscale x 8 x i64> %ret\r\n}\r\n```\r\n\r\n### Before this patch\r\n[Compiler Explorer](https://godbolt.org/z/xsoa5xPrd)\r\n```\r\nvwadd_wv_mask_v8i32:\r\n        li      a0, 42\r\n        vsetvli a1, zero, e32, m4, ta, ma\r\n        vmslt.vx        v0, v8, a0\r\n        vmv.v.i v12, 0\r\n        vmerge.vvm      v24, v12, v8, v0\r\n        vwadd.wv        v8, v16, v24\r\n        ret\r\n```\r\n\r\n### After this patch\r\n```\r\nvwadd_wv_mask_v8i32:\r\n        li a0, 42\r\n        vsetvli a1, zero, e32, m4, ta, ma\r\n        vmslt.vx v0, v8, a0\r\n        vsetvli zero, zero, e32, m4, tu, mu\r\n        vwadd.wv v16, v16, v8, v0.t\r\n        vmv8r.v v8, v16\r\n        ret\r\n```", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVISelLowering.cpp", "functions": ["SDValue"]}]}
{"pr_number": 67410, "url": "https://github.com/llvm/llvm-project/pull/67410", "title": "[X86] Change target of __builtin_ia32_cmp[p|s][s|d] from avx into sse/sse2", "body": "", "feature_layers": [], "feature_directives": ["target"], "files_changed": [{"filename": "clang/test/CodeGen/X86/avx-builtins.c", "functions": ["test_mm_cmp_pd_false_os", "test_mm_cmp_ps_ge_os", "test_mm_cmp_pd_false_oq", "test_mm_cmp_pd_ge_os", "test_mm_cmp_ps_nlt_uq", "test_mm_cmp_pd_ord_s", "test_mm_cmp_ps_nge_us", "test_mm_cmp_ps_le_oq", "test_mm_cmp_ps_lt_oq", "test_mm_cmp_pd_neq_us", "test_mm_cmp_pd_gt_os", "test_mm_cmp_ps_neq_us", "test_mm_cmp_ps_true_us", "test_mm_cmp_ps_unord_s", "test_mm_cmp_pd_nlt_uq", "test_mm_cmp_pd_eq_uq", "test_mm_cmp_pd_gt_oq", "test_mm_cmp_pd_ngt_uq", "test_mm_cmp_ps_eq_uq", "_mm_cmp_ps", "test_mm_cmp_ps_true_uq", "test_mm_cmp_ps_eq_us", "test_mm_cmp_pd_true_uq", "_mm_cmp_ss", "test_mm_cmp_pd_nle_uq", "test_mm_cmp_pd_lt_oq", "test_mm_cmp_pd_neq_os", "test_mm_cmp_ps_ord_s", "test_mm_cmp_pd_true_us", "test_mm_cmp_ps_ge_oq", "test_mm_cmp_ps_ngt_us", "test_mm_cmp_ps_nge_uq", "test_mm_cmp_pd_le_oq", "test_mm_cmp_ss", "test_mm_cmp_ps_eq_os", "test_mm_cmp_ps_gt_oq", "test_mm_cmp_pd_eq_us", "test_mm_cmp_ps_false_os", "test_mm_cmp_sd", "test_mm_cmp_pd_eq_os", "test_mm_cmp_ps_false_oq", "test_mm_cmp_ps_nle_uq", "test_mm_cmp_ps_ngt_uq", "_mm_cmp_sd", "test_mm_cmp_pd_nge_uq", "test_mm_cmp_pd_unord_s", "test_mm_cmp_pd_nge_us", "test_mm_cmp_ps_gt_os", "test_mm_cmp_ps_neq_oq", "test_mm_cmp_pd_ngt_us", "test_mm_cmp_pd_neq_oq", "test_mm_cmp_pd_ge_oq", "test_mm_cmp_ps_neq_os", "_mm_cmp_pd"]}, {"filename": "clang/test/CodeGen/X86/sse-builtins.c", "functions": ["test_mm_cmp_ps_ge_os", "test_mm_cmp_ps_nlt_uq", "test_mm_cmp_ps_nge_us", "test_mm_cmp_ps_le_oq", "test_mm_cmp_ps_lt_oq", "test_mm_cmp_ps_neq_us", "test_mm_cmp_ps_true_us", "test_mm_cmp_ps_unord_s", "test_mm_cmp_ps_eq_uq", "_mm_cmp_ps", "test_mm_cmp_ps_true_uq", "test_mm_cmp_ps_eq_us", "_mm_cmp_ss", "test_mm_cmp_ps_ord_s", "test_mm_cmp_ps_ge_oq", "test_mm_cmp_ps_ngt_us", "test_mm_cmp_ps_nge_uq", "test_mm_cmp_ps_eq_os", "test_mm_cmp_ps_gt_oq", "test_mm_cmp_ps_false_os", "test_mm_cmp_ps_false_oq", "test_mm_cmp_ps_nle_uq", "test_mm_cmp_ps_ngt_uq", "test_mm_cmp_ps_gt_os", "test_mm_cmp_ps_neq_oq", "test_mm_cmp_ps_neq_os"]}, {"filename": "clang/test/CodeGen/X86/sse2-builtins.c", "functions": ["test_mm_cmp_pd_false_os", "test_mm_cmp_pd_false_oq", "test_mm_cmp_pd_ge_os", "test_mm_cmp_pd_ord_s", "test_mm_cmp_pd_neq_us", "test_mm_cmp_pd_gt_os", "test_mm_cmp_pd_nlt_uq", "test_mm_cmp_pd_eq_uq", "test_mm_cmp_pd_gt_oq", "test_mm_cmp_pd_ngt_uq", "test_mm_cmp_pd_true_uq", "test_mm_cmp_pd_nle_uq", "test_mm_cmp_pd_lt_oq", "test_mm_cmp_pd_neq_os", "test_mm_cmp_pd_true_us", "test_mm_cmp_pd_le_oq", "test_mm_cmp_pd_eq_us", "test_mm_cmp_pd_eq_os", "_mm_cmp_sd", "test_mm_cmp_pd_nge_uq", "test_mm_cmp_pd_unord_s", "test_mm_cmp_pd_nge_us", "test_mm_cmp_pd_ngt_us", "test_mm_cmp_pd_neq_oq", "test_mm_cmp_pd_ge_oq", "_mm_cmp_pd"]}, {"filename": "clang/test/CodeGen/target-features-error-2.c", "functions": ["_mm256_cmp_ps", "need_avx", "_mm_cmp_ps"]}, {"filename": "clang/test/CodeGen/X86/cmp-avx-builtins-error.c", "functions": ["test_mm_cmp_pd", "test_mm_cmp_ps", "test_mm_cmp_ss", "test_mm_cmp_sd", "_mm_cmp_sd", "_mm_cmp_pd"]}, {"filename": "clang/test/Sema/builtins-x86.c", "functions": ["__builtin_ia32_cmpsd", "__builtin_ia32_cmpps", "__builtin_ia32_cmppd", "__builtin_ia32_cmpss"]}]}
{"pr_number": 80262, "url": "https://github.com/llvm/llvm-project/pull/80262", "title": "[mlir][IR] Notify about block insertion when cloning an op", "body": "`OpBuilder::clone(Operation &)` should trigger not only `notifyOperationInserted` but also `notifyBlockInserted` (for all block contained in `op`).", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/test/lib/Dialect/Test/TestPatterns.cpp", "functions": ["failure", "RewritePattern", "success"]}]}
{"pr_number": 66871, "url": "https://github.com/llvm/llvm-project/pull/66871", "title": "[mlir][IR] Send notifications for `cloneRegionBefore`", "body": "Similar to `OpBuilder::clone`, operation/block insertion notifications should be sent when cloning the contents of a region. E.g., this is to ensure that the newly created operations are put on the worklist of the greedy pattern rewriter driver.\r\n\r\nAlso move `cloneRegionBefore` from `RewriterBase` to `OpBuilder`. It only creates new IR, so it should be part of the builder API (like `clone(Operation &)`). The function does not have to be virtual. Now that notifications are properly sent, the override in the dialect conversion is no longer needed.\r\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/test/lib/Dialect/Test/TestPatterns.cpp", "functions": ["failure", "RewritePattern", "success"]}]}
{"pr_number": 80158, "url": "https://github.com/llvm/llvm-project/pull/80158", "title": "[mlir][memref] `memref.subview`: Verify result strides with rank reductions", "body": "This is a follow-up on #79865. Result strides are now also verified if the `memref.subview` op has rank reductions.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/MemRef/IR/MemRefOps.cpp", "functions": ["haveCompatibleStrides"]}]}
{"pr_number": 80058, "url": "https://github.com/llvm/llvm-project/pull/80058", "title": "[Preprocessor] Fix __has_builtin for CPU ID functions", "body": "My recent commit (67c1c1d) made the CPU ID builtins target-independent so they can be used on PPC as well. However, that had the unintended consequence of changing the behaviour of __has_builtin in that it reports these as supported at the pre-processor level. This makes it impossible to guard the use of these with this feature test macro which is clearly not ideal.\r\nThis patch restores the behaviour of __has_builtin for __builtin_cpu_is, __builtin_cpu_init,\r\n__builtin_cpu_supports. Now the preprocessor queries the target to determine whether the target supports the builtin.", "feature_layers": [], "feature_directives": ["for", "target"], "files_changed": [{"filename": "clang/lib/Lex/PPMacroExpansion.cpp", "functions": ["getTargetInfo"]}]}
{"pr_number": 80148, "url": "https://github.com/llvm/llvm-project/pull/80148", "title": "[mlir][ArmSME] Fold extracts from 3D create_masks of SME-like masks", "body": "When unrolling the reduction dimension of something like a matmul for SME, it is possible to get 3D masks, which are vectors of SME-like masks. The 2D masks for individual operations are then extracted from the 3D masks.\r\n\r\ni.e.:\r\n\r\n```mlir\r\n%mask = vector.create_mask %nonConstantDim, %a, %b : vector<4x[4]x[4]xi1>\r\n%subMask = vector.extract %mask[2]\r\n        : vector<[4]x[4]xi1> from vector<4x[4]x[4]xi1>\r\n```\r\n\r\nArmSME only supports lowering 2D create_masks, so we must fold the extract into the create_mask. This can be done by checking if the extraction index is within the true region, then using that select the first dimension of the 2D mask. This is shown below.\r\n\r\n```mlir\r\n%extractionInTrueRegion = arith.cmpi slt, %c2, %nonConstantDim : index\r\n%newMaskFrontDim = arith.select %extractionInTrueRegion, %a, %c0 : index\r\n%subMask = vector.create_mask %newMaskFrontDim, %b : vector<[4]x[4]xi1>\r\n```", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/ArmSME/Transforms/VectorLegalization.cpp", "functions": ["success"]}]}
{"pr_number": 80036, "url": "https://github.com/llvm/llvm-project/pull/80036", "title": "[AArch64][GlobalISel] Legalize BSWAP for Vector Types", "body": "Add support of i16 vector operation for BSWAP and change to TableGen to select instructions\r\n\r\nHandle vector types that are smaller/larger than legal for BSWAP", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp", "functions": ["if", "constrainSelectedInstRegOperands"]}]}
{"pr_number": 79115, "url": "https://github.com/llvm/llvm-project/pull/79115", "title": "[clang-format] Update FormatToken::isSimpleTypeSpecifier()", "body": "Depends on #80101.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Lex/Lexer.cpp", "functions": ["getIdentifierInfo"]}]}
{"pr_number": 79815, "url": "https://github.com/llvm/llvm-project/pull/79815", "title": "[X86] X86FixupVectorConstants - load+sign-extend vector constants that can be stored in a truncated form", "body": "Reduce the size of the vector constant by storing it in the constant pool in a truncated form, and sign-extend it as part of the load.\r\n\r\nI've extended the existing FixupConstant functionality to support these sext constant rebuilds - we still select the smallest stored constant entry and prefer vzload/broadcast/vextload for same bitwidth to avoid domain flips.\r\n\r\nI intend to add the matching load+zero-extend handling in a future PR, but that requires some alterations to the existing MC shuffle comments handling first.\r\n\r\nNOTE: Some of the FixupConstant tables are currently created on the fly as they are dependent on the supported ISAs (HasAVX2 etc.) - should we split these (to allow initializer lists instead) and have duplicate FixupConstant calls to avoid additional stack use?", "feature_layers": ["ir", "ast"], "feature_directives": ["for", "requires"], "files_changed": [{"filename": "llvm/lib/Target/X86/X86FixupVectorConstants.cpp", "functions": ["rebuildConstant", "FixupConstant", "rebuildExtCst"]}, {"filename": "llvm/lib/Target/X86/X86MCInstLower.cpp", "functions": ["CS"]}]}
{"pr_number": 78966, "url": "https://github.com/llvm/llvm-project/pull/78966", "title": "CoverageMappingWriter: Emit `Decision` before `Expansion`", "body": "To relax scanning record, tweak order by `Decision < Expansion`, or `Expansion` could not be distinguished whether it belonged to `Decision` or not.\r\n\r\nRelevant to #77871", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/ProfileData/Coverage/CoverageMappingWriter.cpp", "functions": ["getKindKey"]}]}
{"pr_number": 78969, "url": "https://github.com/llvm/llvm-project/pull/78969", "title": "[Coverage] Let `Decision` take account of expansions", "body": "The current implementation (D138849) assumes `Branch`(es) would follow after the corresponding `Decision`. It is not true if `Branch`(es) are forwarded to expanded file ID. As a result, consecutive `Decision`(s) would be confused with insufficient number of `Branch`(es).\r\n\r\n`Expansion` will point `Branch`(es) in other file IDs if `Expansion` is included in the range of `Decision`.\r\n\r\nFixes #77871", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/ProfileData/Coverage/CoverageMapping.cpp", "functions": ["dominates"]}, {"filename": "llvm/test/tools/llvm-cov/Inputs/mcdc-macro.c", "functions": ["__attribute__", "main"]}]}
{"pr_number": 66514, "url": "https://github.com/llvm/llvm-project/pull/66514", "title": "[clang][Diagnostics] Highlight code snippets", "body": "Add some primitive syntax highlighting to our code snippet output.\r\n\r\n\r\nBefore:\r\n![Screenshot from 2023-09-15 16-00-23](https://github.com/llvm/llvm-project/assets/49720664/8e43767a-d939-4c9f-ac2d-65e2df5de1f2)\r\n\r\n\r\nAfter:\r\n![Screenshot from 2023-09-15 15-55-35](https://github.com/llvm/llvm-project/assets/49720664/714b536c-377f-4a0d-921c-b103b90c5706)\r\n\r\n\r\n\r\n\r\n\r\n\r\n_Obviously_ this is kinda WIP and more of a hack in general, but IMO it increases readability of the source snippets (which people look at highlighted all the time anyway...) and LLDB does something similar, so let's see.\r\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Frontend/TextDiagnostic.cpp", "functions": ["if", "DiagnosticRenderer"]}]}
{"pr_number": 78456, "url": "https://github.com/llvm/llvm-project/pull/78456", "title": "[SPIR-V] add convergence region analysis", "body": "This new analysis returns a hierarchical view of the convergence regions in the given function.\r\nThis will allow our passes to query which basic block belongs to which convergence region, and structurize the code in consequence.\r\n\r\nDefinition\r\n----------\r\n\r\nA convergence region is a CFG with:\r\n - a single entry node.\r\n - one or multiple exit nodes (different from LLVM's regions).\r\n - one back-edge\r\n - zero or more subregions.\r\n\r\nExcluding sub-regions nodes, the nodes of a region can only reference a single convergence token. A subregion uses a different convergence token.\r\n\r\nAlgorithm\r\n---------\r\n\r\nThis algorithm assumes all loops are in the Simplify form.\r\n\r\nCreate an initial convergence region for the whole function.\r\n  - the convergence token is the function entry token.\r\n  - the entry is the function entrypoint.\r\n  - Exits are all the basic blocks terminating with a return instruction.\r\n\r\nTake the function CFG, and process it in DAG order (ignoring back-edges). If a basic block is a loop header:\r\n - Create a new region.\r\n   - The parent region is the parent's loop region if any, otherwise, the top level region.\r\n   - The region blocks are all the blocks belonging to this loop.\r\n   - For each loop exit: - visit the rest of the CFG in DAG order (ignore back-edges). - if the region's convergence token is found, add all the blocks dominated by the exit from which the token is reachable to the region.\r\n   - continue the algorithm with the loop headers successors.", "feature_layers": ["ir"], "feature_directives": ["for", "single"], "files_changed": [{"filename": "llvm/lib/Target/SPIRV/Analysis/ConvergenceRegionAnalysis.cpp", "functions": ["FunctionPass", "Indent", "isBackEdge", "getConvergenceToken", "analyze", "ConvergenceRegionInfo", "Analyzer", "DT"]}, {"filename": "llvm/unittests/Target/SPIRV/ConvergenceRegionAnalysisTests.cpp", "functions": ["TearDown", "SetUp"]}, {"filename": "llvm/lib/Target/SPIRV/Analysis/SPIRVConvergenceRegionAnalysis.cpp", "functions": ["initializeSPIRVConvergenceRegionAnalysisWrapperPassPass"]}]}
{"pr_number": 80255, "url": "https://github.com/llvm/llvm-project/pull/80255", "title": "[AArch64] Support optional constant offset for constraint \"S\"", "body": "Modify the initial implementation (https://reviews.llvm.org/D46745) to\nsupport a constant offset so that the following code will compile:\n```\nint a[2][2];\nvoid foo() { asm(\"// %0\" :: \"S\"(&a[1][1])); }\n```\n\nWe use the generic code path for \"s\". In GCC's aarch64 port, \"S\" is\nsupported for PIC while \"s\" isn't, making \"s\" less useful. We implement\n\"S\" but not \"s\".\n\nSimilar to #80201 for RISC-V.\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/Sema/inline-asm-validate-aarch64.c", "functions": ["test_s"]}]}
{"pr_number": 79544, "url": "https://github.com/llvm/llvm-project/pull/79544", "title": "[lldb] Fix a crash when using .dwp files and make type lookup reliable with the index cache", "body": "When using split DWARF with .dwp files we had an issue where sometimes the DWO file within the .dwp file would be parsed _before_ the skeleton compile unit. The DWO file expects to be able to always be able to get a link back to the skeleton compile unit. Prior to this fix, the only time the skeleton compile unit backlink would get set, was if the unit headers for the main executable have been parsed _and_ if the unit DIE was parsed in that DWARFUnit. This patch ensures that we can always get the skeleton compile unit for a DWO file by adding a function:\r\n\r\n```\r\nDWARFCompileUnit *DWARFUnit::GetSkeletonUnit();\r\n```\r\n\r\nPrior to this fix DWARFUnit had some unsafe accessors that were used to store two different things:\r\n\r\n```\r\n  void *DWARFUnit::GetUserData() const;\r\n  void DWARFUnit::SetUserData(void *d);\r\n```\r\n\r\nThis was used by SymbolFileDWARF to cache the `lldb_private::CompileUnit *` for a SymbolFileDWARF and was also used to store the `DWARFUnit *` for SymbolFileDWARFDwo. This patch clears up this unsafe usage by adding two separate accessors and ivars for this:\r\n```\r\nlldb_private::CompileUnit *DWARFUnit::GetLLDBCompUnit() const { return m_lldb_cu; }\r\nvoid DWARFUnit::SetLLDBCompUnit(lldb_private::CompileUnit *cu) { m_lldb_cu = cu; }\r\nDWARFCompileUnit *DWARFUnit::GetSkeletonUnit();\r\nvoid DWARFUnit::SetSkeletonUnit(DWARFUnit *skeleton_unit);\r\n```\r\nThis will stop anyone from calling `void *DWARFUnit::GetUserData() const;` and casting the value to an incorrect value.\r\n\r\nA crash could occur in `SymbolFileDWARF::GetCompUnitForDWARFCompUnit()` when the `non_dwo_cu`, which is a backlink to the skeleton compile unit, was not set and was NULL. There is an assert() in the code, and then the code just will kill the program if the assert isn't enabled because the code looked like:\r\n```\r\n  if (dwarf_cu.IsDWOUnit()) {\r\n    DWARFCompileUnit *non_dwo_cu =\r\n        static_cast<DWARFCompileUnit *>(dwarf_cu.GetUserData());\r\n    assert(non_dwo_cu);\r\n    return non_dwo_cu->GetSymbolFileDWARF().GetCompUnitForDWARFCompUnit(\r\n        *non_dwo_cu);\r\n  }\r\n```\r\nThis is now fixed by calling the `DWARFUnit::GetSkeletonUnit()` which will correctly always get the skeleton compile uint for a DWO file regardless of if the skeleton unit headers have been parse or if the skeleton unit DIE wasn't parsed yet.\r\n\r\nTo implement the ability to get the skeleton compile units, I added code the DWARFDebugInfo.cpp/.h that make a map of DWO ID -> skeleton DWARFUnit * that gets filled in for DWARF5 when the unit headers are parsed. The `DWARFUnit::GetSkeletonUnit()` will end up parsing the unit headers of the main executable to fill in this map if it already hasn't been done. For DWARF4 and earlier we maintain a separate map that gets filled in only for any DWARF4 compile units that have a DW_AT_dwo_id or DW_AT_gnu_dwo_id attributes. This is more expensive, so this is done lazily and in a thread safe manor. This allows us to be as efficient as possible when using DWARF5 and also be backward compatible with DWARF4 + split DWARF.\r\n\r\nThere was also an issue that stopped type lookups from succeeding in `DWARFDIE SymbolFileDWARF::GetDIE(const DIERef &die_ref)` where it directly was accessing the `m_dwp_symfile` ivar without calling the accessor function that could end up needing to locate and load the .dwp file. This was fixed by calling the `SymbolFileDWARF::GetDwpSymbolFile()` accessor to ensure we always get a valid value back if we can find the .dwp file. Prior to this fix it was down which APIs were called and if any APIs were called that loaded the .dwp file, it worked fine, but it might not if no APIs were called that did cause it to get loaded.\r\n\r\nWhen we have valid debug info indexes and when the lldb index cache was enabled, this would cause this issue to show up more often.\r\n\r\nI modified an existing test case to test that all of this works correctly and doesn't crash.", "feature_layers": ["parse", "ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "lldb/source/Plugins/SymbolFile/DWARF/SymbolFileDWARF.cpp", "functions": ["DebugInfo", "ParseCompileUnit"]}, {"filename": "lldb/source/Plugins/SymbolFile/DWARF/SymbolFileDWARFDwo.cpp", "functions": ["GetBaseSymbolFile"]}]}
{"pr_number": 80470, "url": "https://github.com/llvm/llvm-project/pull/80470", "title": "[mlir][sparse] support sparse dilated convolution.", "body": "", "feature_layers": ["parse", "ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/SparseTensor/Transforms/Utils/SparseTensorLevel.cpp", "functions": ["upperBound"]}]}
{"pr_number": 79882, "url": "https://github.com/llvm/llvm-project/pull/79882", "title": "[llvm-gsymutil] Print one-time DWO file missing warning under --quiet flag", "body": "FileCheck test added\r\n```\r\n./bin/llvm-lit -sv llvm/test/tools/llvm-gsymutil/X86/dwo-warning.test\r\n```\r\n\r\nManual test steps:\r\n\r\n- Create binary with split-dwarf:\r\n```\r\nclang++ -g -gdwarf-4 -gsplit-dwarf main.cpp -o main_split\r\n```\r\n\r\n- Remane the dwo file to a different name so llvm-gsymutil can't find it\r\n```\r\nmv main_split-main.dwo main_split-main__.dwo\r\n```\r\n\r\n- Now run llvm-gsymutil conversion, it should print out warning with and without the `--quiet` flag\r\n```\r\n$ ./bin/llvm-gsymutil --convert=./main_split\r\nInput file: ./main_split\r\nOutput file (x86_64): ./main_split.gsym\r\nwarning: Unable to retrieve DWO .debug_info section for main_split-main.dwo\r\nLoaded 0 functions from DWARF.\r\nLoaded 12 functions from symbol table.\r\nPruned 0 functions, ended with 12 total\r\n```\r\n\r\n```\r\n$ ./bin/llvm-gsymutil --convert=./main_split --quiet\r\nInput file: ./main_split\r\nOutput file (x86_64): ./main_split.gsym\r\nwarning: Unable to retrieve DWO .debug_info section for some object files. (Remove the --quiet flag for full output)\r\nPruned 0 functions, ended with 12 total\r\n```", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/test/tools/llvm-gsymutil/X86/Inputs/main.cpp", "functions": ["foo", "main"]}]}
{"pr_number": 78658, "url": "https://github.com/llvm/llvm-project/pull/78658", "title": "[lld][WebAssembly] Match the ELF linker in transitioning away from archive indexes.", "body": "The ELF linker transitioned away from archive indexes in https://reviews.llvm.org/D117284.\r\n\r\nThis paves the way for supporting `--start-lib`/`--end-lib` (See #77960)\r\n\r\nThe ELF linker unified library handling with `--start-lib`/`--end-lib` and removed\r\nthe ArchiveFile class in https://reviews.llvm.org/D119074.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "lld/wasm/InputFiles.cpp", "functions": ["InputFile"]}, {"filename": "lld/wasm/Symbols.cpp", "functions": ["CHECK"]}]}
{"pr_number": 80232, "url": "https://github.com/llvm/llvm-project/pull/80232", "title": "[mlir][arith] Improve `extf` folder", "body": "* Use APFloat conversion function to avoid losing information by converting to `double`. This would be the case with large types like `f80` or `f128`.\r\n* Check for potential information loss. This is intended for small floating point types that may have values not present in larger ones (e.g., f8e5m2fnuz and f16).\r\n* Support folding vector constants.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Arith/IR/ArithOps.cpp", "functions": ["failure"]}]}
{"pr_number": 76657, "url": "https://github.com/llvm/llvm-project/pull/76657", "title": "[libc++] Optimize vector growing of trivially relocatable types", "body": "This patch introduces a new trait to represent whether a type is trivially\r\nrelocatable, and uses that trait to optimize the growth of a std::vector\r\nof trivially relocatable objects.\r\n\r\n```\r\n--------------------------------------------------\r\nBenchmark                           old        new\r\n--------------------------------------------------\r\nbm_grow<int>                    1354 ns    1301 ns\r\nbm_grow<std::string>            5584 ns    3370 ns\r\nbm_grow<std::unique_ptr<int>>   3506 ns    1994 ns\r\nbm_grow<std::deque<int>>       27114 ns   27209 ns\r\n```\r\n\r\nThis also changes to order of moving and destroying the objects when\r\ngrowing the vector. This should not affect our conformance.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "libcxx/benchmarks/vector_operations.bench.cpp", "functions": ["bm_grow"]}, {"filename": "libcxx/test/libcxx/type_traits/is_trivially_relocatable.compile.pass.cpp", "functions": ["operator"]}]}
{"pr_number": 75897, "url": "https://github.com/llvm/llvm-project/pull/75897", "title": "[mlir][Transforms] `GreedyPatternRewriteDriver`: Do not CSE constants during iterations", "body": "The `GreedyPatternRewriteDriver` tries to iteratively fold ops and apply rewrite patterns to ops. It has special handling for constants: they are CSE'd and sometimes moved to parent regions to allow for additional CSE'ing. This happens in `OperationFolder`.\r\n\r\nTo allow for efficient CSE'ing, `OperationFolder` maintains an internal lookup data structure to find the existing constant ops with the same value for each `IsolatedFromAbove` region:\r\n```c++\r\n/// A mapping between an insertion region and the constants that have been\r\n/// created within it.\r\nDenseMap<Region *, ConstantMap> foldScopes;\r\n```\r\n\r\nRewrite patterns are allowed to modify operations. In particular, they may move operations (including constants) from one region to another one. Such an IR rewrite can make the above lookup data structure inconsistent.\r\n\r\nWe encountered such a bug in a downstream project. This bug materialized in the form of an op that uses the result of a constant op from a different `IsolatedFromAbove` region (that is not accessible).\r\n\r\nThis commit changes the behavior of the `GreedyPatternRewriteDriver` such that `OperationFolder` is used to CSE constants at the beginning of each iteration (as the worklist is populated), but no longer during an iteration. `OperationFolder` is no longer used after populating the worklist, so we do not have to care about inconsistent state in the `OperationFolder` due to IR rewrites. The `GreedyPatternRewriteDriver` now performs the op folding by itself instead of calling `OperationFolder::tryToFold`.\r\n\r\nThis change changes the order of constant ops in test cases, but not the region in which they appear. All broken test cases were fixed by turning `CHECK` into `CHECK-DAG`.\r\n\r\nAlternatives considered: The state of `OperationFolder` could be partially invalidated with every `notifyOperationModified` notification. That is more fragile than the solution in this commit because incorrect rewriter API usage can lead to missing notifications and hard-to-debug `IsolatedFromAbove` violations. (It did not fix the above mention bug in a downstream project, which could be due to incorrect rewriter API usage or due to another conceptual problem that I missed.) Moreover, ops are frequently getting modified during a greedy pattern rewrite, so we would likely keep invalidating large parts of the state of `OperationFolder` over and over.\r\n\r\nMigration guide: Turn `CHECK` into `CHECK-DAG` in test cases. Constant ops are no longer folded during a greedy pattern rewrite. If you rely on folding (and rematerialization) of constant ops during a greedy pattern rewrite, turn the folder into a pattern.\r\n", "feature_layers": ["sema", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Linalg/Transforms/DecomposeLinalgOps.cpp", "functions": ["g"]}, {"filename": "mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp", "functions": ["PatternRewriter", "g", "folder"]}]}
{"pr_number": 80327, "url": "https://github.com/llvm/llvm-project/pull/80327", "title": "[Clang][Sema] Fix crash with const qualified member operator new", "body": "We should diagnose a const qualified member operator new but we fail to do so and this leads to crash during debug info generation.\r\n\r\nThe fix is to diagnose this as ill-formed in the front-end.\r\n\r\nFixes: https://github.com/llvm/llvm-project/issues/79748", "feature_layers": ["sema"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/SemaCXX/function-type-qual.cpp", "functions": ["new", "delete", "decltype"]}]}
{"pr_number": 70817, "url": "https://github.com/llvm/llvm-project/pull/70817", "title": "[clang][driver] Add \\<executable\\>/../include/c++/v1 to include path on Darwin", "body": "On macOS, when clang is invoked via a symlink, since the InstalledDir is where the link is located, the C++ headers are not identified and the default system headers are used.\r\n\r\n```console\r\n% ln -s /Users/ilg/Library/xPacks/@xpack-dev-tools/clang/15.0.7-3.1/.content/bin/clang++ ~/tmp/clang++\r\n%  ~/tmp/clang++ -v hello.cpp -stdlib=libc++\r\nxPack x86_64 clang version 15.0.7 (https://github.com/xpack-dev-tools/clang-xpack 9b1ff65945b1aaddfe7c0c4d99001ebca5d67b03)\r\nTarget: x86_64-apple-darwin21.6.0\r\nThread model: posix\r\n\r\nInstalledDir: /Users/ilg/tmp/. <--- !!!\r\nignoring nonexistent directory \"/Users/ilg/tmp/./../include/c++/v1\" <--- !!!\r\n\r\n \"/Users/ilg/Library/xPacks/@xpack-dev-tools/clang/15.0.7-3.1/.content/bin/clang-15\" -cc1 -triple x86_64-apple-macosx12.0.0 -Wundef-prefix=TARGET_OS_ -Werror=undef-prefix -Wdeprecated-objc-isa-usage -Werror=deprecated-objc-isa-usage -emit-obj -mrelax-all --mrelax-relocations -disable-free -clear-ast-before-backend -disable-llvm-verifier -discard-value-names -main-file-name hello.cpp -mrelocation-model pic -pic-level 2 -mframe-pointer=all -ffp-contract=on -fno-rounding-math -funwind-tables=2 -fcompatibility-qualified-id-block-type-checking -fvisibility-inlines-hidden-static-local-var -target-cpu penryn -tune-cpu generic -mllvm -treat-scalable-fixed-error-as-warning -debugger-tuning=lldb -target-linker-version 409.12 -v -fcoverage-compilation-dir=/Users/ilg/tmp -resource-dir /Users/ilg/Library/xPacks/@xpack-dev-tools/clang/15.0.7-3.1/.content/lib/clang/15.0.7 -isysroot /Library/Developer/CommandLineTools/SDKs/MacOSX.sdk -stdlib=libc++ -internal-isystem /Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1 -internal-isystem /Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/local/include -internal-isystem /Users/ilg/Library/xPacks/@xpack-dev-tools/clang/15.0.7-3.1/.content/lib/clang/15.0.7/include -internal-externc-isystem /Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include -fdeprecated-macro -fdebug-compilation-dir=/Users/ilg/tmp -ferror-limit 19 -stack-protector 1 -fblocks -fencode-extended-block-signature -fregister-global-dtors-with-atexit -fgnuc-version=4.2.1 -fcxx-exceptions -fexceptions -fmax-type-align=16 -fcolor-diagnostics -D__GCC_HAVE_DWARF2_CFI_ASM=1 -o /var/folders/gr/13tt3vcd7m1gnbhwtkmf5cnw0000gn/T/hello-a87934.o -x c++ hello.cpp\r\nclang -cc1 version 15.0.7 based upon LLVM 15.0.7 default target x86_64-apple-darwin21.6.0\r\nignoring nonexistent directory \"/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/local/include\"\r\nignoring nonexistent directory \"/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/Library/Frameworks\"\r\n#include \"...\" search starts here:\r\n#include <...> search starts here:\r\n\r\n /Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1 <--- Wrong!\r\n\r\n /Users/ilg/Library/xPacks/@xpack-dev-tools/clang/15.0.7-3.1/.content/lib/clang/15.0.7/include\r\n /Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include\r\n /Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/System/Library/Frameworks (framework directory)\r\nEnd of search list.\r\n \"/usr/bin/ld\" -demangle -lto_library /Users/ilg/Library/xPacks/@xpack-dev-tools/clang/15.0.7-3.1/.content/lib/libLTO.dylib -no_deduplicate -dynamic -arch x86_64 -macosx_version_min 12.0.0 -syslibroot /Library/Developer/CommandLineTools/SDKs/MacOSX.sdk -o a.out /var/folders/gr/13tt3vcd7m1gnbhwtkmf5cnw0000gn/T/hello-a87934.o -lc++ -lSystem /Users/ilg/Library/xPacks/@xpack-dev-tools/clang/15.0.7-3.1/.content/lib/clang/15.0.7/lib/darwin/libclang_rt.osx.a\r\n```\r\n\r\nUsing the system headers instead of the toolchain headers may have very subtle consequences, sometimes leading to compile errors which are hard to diagnose.\r\n\r\nThis fix adds a second check using the folder where the executable is located.", "feature_layers": ["ir", "ast"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "clang/lib/Driver/ToolChains/Darwin.cpp", "functions": ["getDriver"]}]}
{"pr_number": 79989, "url": "https://github.com/llvm/llvm-project/pull/79989", "title": "[X86] Add i8 CTPOP lowering using i32 MUL", "body": "This is first basic proposal in #79823 - we can investigate improving support for other widths if we can find further use cases.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/X86/X86ISelLowering.cpp", "functions": ["DL", "LowerVectorCTPOP"]}]}
{"pr_number": 80395, "url": "https://github.com/llvm/llvm-project/pull/80395", "title": "[clang][Sema] Populate function template depth at AddTemplateOverloadCandidate", "body": "This is yet another one-line patch to fix crashes on constraint substitution.\r\n\r\n```cpp\r\ntemplate <class, class> struct formatter;\r\n\r\ntemplate <class, class> struct basic_format_context {};\r\n\r\ntemplate <typename CharType>\r\nconcept has_format_function = format(basic_format_context<CharType, CharType>());\r\n\r\ntemplate <typename ValueType, typename CharType>\r\n  requires has_format_function<CharType>\r\nstruct formatter<ValueType, CharType> {\r\n  template <typename OutputIt>\r\n  CharType format(basic_format_context<OutputIt, CharType>);\r\n};\r\n```\r\n\r\nIn this case, we would build up a `RecoveryExpr` for a call within a constraint expression due to the absence of viable functions. The heuristic algorithm attempted to find such a function inside of a ClassTemplatePartialSpecialization, from which we started to substitute its requires-expression, and it succeeded with a FunctionTemplate such that\r\n\r\n1) It has only one parameter, which is dependent.\r\n2) The only one parameter depends on two template parameters. They are, in canonical form, `<template-parameter-1-0>` and `<template-parameter-0-1>` respectively.\r\n\r\nBefore we emit an error, we still want to recover the most viable functions. This goes downhill to deducing template parameters against its arguments, where we would collect the argument type with the same depth as the parameter type into a Deduced set. The size of the set is presumed to be that of function template parameters, which is 1 in this case. However, since we haven't yet properly set the template depth before the dance, we'll end up putting the type for `<template-parameter-0-1>` to the second position of Deduced set, which is unfortunately an access violation!\r\n\r\nThe bug seems to appear since clang 12.0.\r\n\r\nThis fixes [the case](https://github.com/llvm/llvm-project/issues/58548#issuecomment-1287935336).", "feature_layers": ["sema", "ir"], "feature_directives": ["for", "requires"], "files_changed": [{"filename": "clang/lib/Sema/SemaOverload.cpp", "functions": ["Info"]}, {"filename": "clang/test/SemaTemplate/concepts-recovery-expr.cpp", "functions": ["format", "handle_replacement_field"]}]}
{"pr_number": 80401, "url": "https://github.com/llvm/llvm-project/pull/80401", "title": "[X86] [iamcu] Fix wrong alignment value for attr (aligned) with -miamcu", "body": "attribute ((aligned)) should be 4 for -miamcu.\r\n\r\nrelate: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=66818", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/Sema/attr-aligned.c", "functions": ["__attribute__"]}]}
{"pr_number": 80427, "url": "https://github.com/llvm/llvm-project/pull/80427", "title": "[llvm][AArch64][TargetParser][NFC] Use parseArchExtension in parseModifier.", "body": "This allows making changes in parseArchExtension to make their way in the command line as well, not only in target attributes.", "feature_layers": ["parse", "ir", "parser"], "feature_directives": ["target"], "files_changed": [{"filename": "llvm/lib/TargetParser/AArch64TargetParser.cpp", "functions": ["ModifierBase"]}]}
{"pr_number": 80288, "url": "https://github.com/llvm/llvm-project/pull/80288", "title": "[Clang][Sema] fix outline member function template with default align crash", "body": "Try to fix [issue](https://github.com/llvm/llvm-project/issues/68490 ) and some extented problem. Root cause of current issue is that error handling in instantiation of function parameter with default initialization on sizeof or align expression. When instance an out-of-line template member function, depth of `TemplateTypeParmDecl` in default initialization doesn't change while depth of other template parameter does and this will lead to some template parameter uninstanced. Also, sometime it will leader to wrong instantiation when it uses the template parameter of the template class.\r\nFix it by add template args of context. This will make MultiLevelTemplateArgumentList::getNumLevels matching the depth of template parameter. Testcase with some static_assert demonstrates the template parameter has been instanced correctly.\r\nBut, the default initialization of lambda expression compiles failed when only checking if the member function is out-of-line. We should check the `PrimaryFunctionTemplateDecl` of the funtion if it's out-of-line.", "feature_layers": ["sema"], "feature_directives": [], "files_changed": [{"filename": "clang/test/SemaTemplate/default-parm-init.cpp", "functions": ["function", "foo", "functor_invoker", "clone", "FuncSizeof2", "Helper", "main", "operator", "FuncSizeof", "invoke", "FuncAlign2", "FuncAlign", "h", "swap"]}]}
{"pr_number": 80269, "url": "https://github.com/llvm/llvm-project/pull/80269", "title": "[VPlan] Update VPInst::onlyFirstLaneUsed to check users.", "body": "A VPInstruction only has its first lane used if all users use its first lane only. Use vputils::onlyFirstLaneUsed to continue checking the recipe's users to handle more cases.\r\n\r\nBesides allowing additional introduction of scalar steps when interleaving in some cases, this also enables using an Add VPInstruction to model the increment - as a follow up.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp", "functions": ["getOperand"]}]}
{"pr_number": 76528, "url": "https://github.com/llvm/llvm-project/pull/76528", "title": "[libc++] Fixes valarray proxy type compound assignment operations.", "body": "The valarray<>::operator[](...) const functions return proxy objects. The valarray<>::operator[](...) functions return valarray objects.\r\n\r\nHowever the standard allows functions returning valarray objects to return custom proxy objects instead. Libc++ returns __val_expr proxies. Functions taking a valarray object must work with the custom proxies too. Therefore several operations have a custom proxy overload instead of valarray overloads.\r\n\r\nLibc++ doesn't specify a valarray overload. This is an issue with the standard proxy types; these can implicitly be converted to a valarray.\r\n\r\nThe solution is to allow the standard proxies to behave as-if they are custom proxies.\r\n\r\nThis patch fixes the valarray compound assignments. Other operations, like the binary non-member functions are not fixed. These will be done in a followup patch.\r\n\r\nFixes: https://github.com/llvm/llvm-project/issues/21320", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "libcxx/test/libcxx/numerics/numarray/class.gslice.array/assert.get.pass.cpp", "functions": ["array", "sizes", "strides", "main"]}, {"filename": "libcxx/test/libcxx/numerics/numarray/class.gslice.array/get.pass.cpp", "functions": ["array", "sizes", "strides", "main"]}, {"filename": "libcxx/test/libcxx/numerics/numarray/class.indirect.array/assert.get.pass.cpp", "functions": ["array", "indirect", "main"]}, {"filename": "libcxx/test/libcxx/numerics/numarray/class.indirect.array/get.pass.cpp", "functions": ["array", "indirect", "main"]}, {"filename": "libcxx/test/libcxx/numerics/numarray/class.mask.array/assert.get.pass.cpp", "functions": ["array", "main", "mask"]}, {"filename": "libcxx/test/libcxx/numerics/numarray/class.mask.array/get.pass.cpp", "functions": ["array", "main", "mask"]}, {"filename": "libcxx/test/libcxx/numerics/numarray/class.slice.array/assert.get.pass.cpp", "functions": ["array", "main"]}, {"filename": "libcxx/test/libcxx/numerics/numarray/class.slice.array/get.pass.cpp", "functions": ["array", "main"]}, {"filename": "libcxx/test/std/numerics/numarray/template.valarray/valarray.cassign/and_valarray.pass.cpp", "functions": ["zero", "v3", "main", "mask", "indirect", "test", "v1", "value", "v2"]}, {"filename": "libcxx/test/std/numerics/numarray/template.valarray/valarray.cassign/divide_valarray.pass.cpp", "functions": ["zero", "v3", "main", "mask", "indirect", "test", "v1", "value", "v2"]}, {"filename": "libcxx/test/std/numerics/numarray/template.valarray/valarray.cassign/minus_valarray.pass.cpp", "functions": ["zero", "v3", "main", "mask", "indirect", "test", "v1", "value", "v2"]}, {"filename": "libcxx/test/std/numerics/numarray/template.valarray/valarray.cassign/modulo_valarray.pass.cpp", "functions": ["zero", "v3", "main", "mask", "indirect", "test", "v1", "value", "v2"]}, {"filename": "libcxx/test/std/numerics/numarray/template.valarray/valarray.cassign/or_valarray.pass.cpp", "functions": ["zero", "v3", "main", "mask", "indirect", "test", "v1", "value", "v2"]}, {"filename": "libcxx/test/std/numerics/numarray/template.valarray/valarray.cassign/plus_valarray.pass.cpp", "functions": ["zero", "v3", "main", "mask", "indirect", "test", "v1", "value", "v2"]}, {"filename": "libcxx/test/std/numerics/numarray/template.valarray/valarray.cassign/shift_left_valarray.pass.cpp", "functions": ["zero", "v3", "main", "mask", "indirect", "test", "v1", "value", "v2"]}, {"filename": "libcxx/test/std/numerics/numarray/template.valarray/valarray.cassign/shift_right_valarray.pass.cpp", "functions": ["zero", "v3", "main", "mask", "indirect", "test", "v1", "value", "v2"]}, {"filename": "libcxx/test/std/numerics/numarray/template.valarray/valarray.cassign/times_valarray.pass.cpp", "functions": ["zero", "v3", "main", "mask", "indirect", "test", "v1", "value", "v2"]}, {"filename": "libcxx/test/std/numerics/numarray/template.valarray/valarray.cassign/xor_valarray.pass.cpp", "functions": ["zero", "v3", "main", "mask", "indirect", "test", "v1", "value", "v2"]}]}
{"pr_number": 79022, "url": "https://github.com/llvm/llvm-project/pull/79022", "title": "[GlobalISel][ARM] Support missing case for G_CONSTANT", "body": "The instruction:\r\n\r\n    %0:gprb(s32) = G_CONSTANT i32 -1\r\n\r\nnow cannot be selected on ARM. In DAG selector the similar instruction is selected with the help of `mod_imm_not`, which is a PatLeaf node. This node is specified with a transformation helper (imm_not_XFORM), that creates a new SDValue. Such rules are not processed by TableGen now and the generated match table does not contain records that could be used to select such instruction.\r\n\r\nThis change implements selection for this case.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/ARM/ARMInstructionSelector.cpp", "functions": ["if", "constrainSelectedInstRegOperands", "selectConstant"]}]}
{"pr_number": 80556, "url": "https://github.com/llvm/llvm-project/pull/80556", "title": "[MLIR][LLVM] Fix attr dict parse order of llvm.call", "body": "", "feature_layers": ["parse", "ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/LLVMIR/IR/LLVMDialect.cpp", "functions": ["failure"]}]}
{"pr_number": 76333, "url": "https://github.com/llvm/llvm-project/pull/76333", "title": "[libc++][print] Includes <format>.", "body": "The overloads of `println` are specified in terms of `format`. The function `format` is specified to work with ranges.\r\n\r\nThe implementations for `println` do not include `<format>`, but libc++'s granularized header. This means the following example does not work\r\n\r\n  #include <vector>\r\n  #include <print>\r\n\r\n  int main() {\r\n      std::vector<int> v{1, 2, 3};\r\n      std::println(\"{}\", v);\r\n  }\r\n\r\n(The other print functions also require this to work, they are specified in terms of other format functions.)\r\n\r\nFixes: https://github.com/llvm/llvm-project/issues/71925", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "libcxx/test/libcxx/input.output/iostream.format/output.streams/ostream.syn/includes.compile.pass.cpp", "functions": ["test"]}, {"filename": "libcxx/test/std/input.output/iostream.format/print.fun/includes.compile.pass.cpp", "functions": ["test"]}]}
{"pr_number": 70921, "url": "https://github.com/llvm/llvm-project/pull/70921", "title": "[X86][CodeGen] Add NPM pipeline builder", "body": "This patch is stolen from [D83613](https://reviews.llvm.org/D83613), the original author is @yuanfang-chen.\r\nI modified some parts so it can add the same passes like `X86PassConfig`.\r\nBlocked by #70906.", "feature_layers": ["codegen"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/Target/X86/X86TargetMachine.cpp", "functions": ["addPreISel", "addIRPasses", "addLegalizeMachineIR", "addPreEmitPass", "addPreRegAlloc", "addAsmPrinter", "addPostRegAlloc", "addPreEmitPass2", "addRegAssignAndRewriteOptimized", "addILPOpts", "run", "addInstSelector", "addRegBankSelect", "addMachineSSAOptimization", "addPostFastRegAllocRewrite", "addGlobalInstructionSelect", "addPreSched2", "addIRTranslator"]}]}
{"pr_number": 80108, "url": "https://github.com/llvm/llvm-project/pull/80108", "title": "[clang] static operators should evaluate object argument (reland)", "body": "### Description\r\n\r\nclang don't evaluate the object argument of `static operator()` and `static operator[]` currently, for example:\r\n\r\n```cpp\r\n#include <iostream>\r\n\r\nstruct Foo {\r\n    static int operator()(int x, int y) {\r\n        std::cout << \"Foo::operator()\" << std::endl;\r\n        return x + y;\r\n    }\r\n    static int operator[](int x, int y) {\r\n        std::cout << \"Foo::operator[]\" << std::endl;\r\n        return x + y;\r\n    }\r\n};\r\nFoo getFoo() {\r\n    std::cout << \"getFoo()\" << std::endl;\r\n    return {};\r\n}\r\nint main() {\r\n    std::cout << getFoo()(1, 2) << std::endl;\r\n    std::cout << getFoo()[1, 2] << std::endl;\r\n}\r\n```\r\n\r\n`getFoo()` is expected to be called, but clang don't call it currently (17.0.6). This PR fixes this issue.\r\n\r\nFixes #67976, reland #68485.\r\n\r\n### Walkthrough\r\n\r\n- **clang/lib/Sema/SemaOverload.cpp**\r\n  - **`Sema::CreateOverloadedArraySubscriptExpr` & `Sema::BuildCallToObjectOfClassType`**\r\n  Previously clang generate `CallExpr` for static operators, ignoring the object argument. In this PR `CXXOperatorCallExpr` is generated for static operators instead, with the object argument as the first argument.\r\n  - **`TryObjectArgumentInitialization`**\r\n  `const` / `volatile` objects are allowed for static methods, so that we can call static operators on them.\r\n- **clang/lib/CodeGen/CGExpr.cpp**\r\n  - **`CodeGenFunction::EmitCall`**\r\n  CodeGen changes for `CXXOperatorCallExpr` with static operators: emit and ignore the object argument first, then emit the operator call.\r\n- **clang/lib/AST/ExprConstant.cpp**\r\n  - **`\u200eExprEvaluatorBase::handleCallExpr\u200e`**\r\n  Evaluation of static operators in constexpr also need some small changes to work, so that the arguments won't be out of position.\r\n- **clang/lib/Sema/SemaChecking.cpp**\r\n  - **`Sema::CheckFunctionCall`**\r\n  Code for argument checking also need to be modify, or it will fail the test `clang/test/SemaCXX/overloaded-operator-decl.cpp`.\r\n- **clang-tools-extra/clangd/InlayHints.cpp**\r\n  - **`InlayHintVisitor::VisitCallExpr`**\r\n  Now that the `CXXOperatorCallExpr` for static operators also have object argument, we should also take care of this situation in clangd.\r\n\r\n### Tests\r\n\r\n- **Added:**\r\n    - **clang/test/AST/ast-dump-static-operators.cpp**\r\n      Verify the AST generated for static operators.\r\n    - **clang/test/SemaCXX/cxx2b-static-operator.cpp**\r\n      Static operators should be able to be called on const / volatile objects.\r\n- **Modified:**\r\n    - **clang/test/CodeGenCXX/cxx2b-static-call-operator.cpp**\r\n    - **clang/test/CodeGenCXX/cxx2b-static-subscript-operator.cpp**\r\n      Matching the new CodeGen.\r\n\r\n### Documentation\r\n\r\n- **clang/docs/ReleaseNotes.rst**\r\n  Update release notes.", "feature_layers": ["sema", "codegen", "ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/CodeGen/CGExprCXX.cpp", "functions": ["EmitCXXStaticOperatorMemberCallExpr"]}, {"filename": "clang/test/AST/ast-dump-static-operators.cpp", "functions": ["get_functor", "call_static_operators", "operator"]}, {"filename": "clang/test/CodeGenCXX/cxx2b-static-call-operator.cpp", "functions": ["GetAFunctor"]}, {"filename": "clang/test/CodeGenCXX/cxx2b-static-subscript-operator.cpp", "functions": ["GetAFunctor"]}, {"filename": "clang/test/SemaCXX/cxx2b-static-operator.cpp", "functions": ["operator", "ok"]}]}
{"pr_number": 80409, "url": "https://github.com/llvm/llvm-project/pull/80409", "title": "[Clang][CodeGen] Mark `__dynamic_cast` as `willreturn`", "body": "According to the C++ standard, `dynamic_cast` of pointers either returns a pointer (7.6.1.7) or results in undefined behavior (11.9.5). This patch marks `__dynamic_cast` as `willreturn` to remove unused calls.\r\n\r\nFixes #77606.", "feature_layers": ["codegen", "ast"], "feature_directives": [], "files_changed": [{"filename": "clang/test/CodeGenCXX/dynamic-cast-dead.cpp", "functions": ["foo"]}]}
{"pr_number": 79485, "url": "https://github.com/llvm/llvm-project/pull/79485", "title": "[clang] Add GCC-compatible code model names for sparc64", "body": "This adds GCC-compatible names for code model selection on 64-bit SPARC with absolute code.\r\nTesting with a 2-stage build then running codegen tests works okay under all of the supported code models.\r\n\r\n(32-bit target does not have selectable code models)", "feature_layers": ["codegen"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "clang/lib/Driver/ToolChains/Clang.cpp", "functions": ["if"]}]}
{"pr_number": 80610, "url": "https://github.com/llvm/llvm-project/pull/80610", "title": "test/llvm-cov: Regenerate MC/DC tests", "body": "* Revise instructions for regeneration, not to create executables.\r\n* Add instructions to regenerate both object files and test vectors (except for `mcdc-general-none.proftext`)\r\n* Reformat", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/test/tools/llvm-cov/Inputs/mcdc-const-folding.cpp", "functions": ["__llvm_profile_write_file"]}, {"filename": "llvm/test/tools/llvm-cov/Inputs/mcdc-const.cpp", "functions": ["foo", "__llvm_profile_write_file"]}, {"filename": "llvm/test/tools/llvm-cov/Inputs/mcdc-general.cpp", "functions": ["foo", "__llvm_profile_write_file"]}]}
{"pr_number": 76954, "url": "https://github.com/llvm/llvm-project/pull/76954", "title": "[AMDGPU] Introduce Code Object V6", "body": "Introduce Code Object V6 in Clang, LLD, Flang and LLVM. This is the same as V5 except a new \"generic version\" flag can be present in EFLAGS. This is related to new generic targets that'll be added in a follow-up patch. It's also likely V6 will have new changes (possibly new metadata entries) added later.\r\n\r\nDocs change are part of the follow-up patch #76955 ", "feature_layers": [], "feature_directives": ["target"], "files_changed": [{"filename": "lld/ELF/Arch/AMDGPU.cpp", "functions": ["calcEFlagsV6"]}, {"filename": "llvm/lib/Target/AMDGPU/MCTargetDesc/AMDGPUTargetStreamer.cpp", "functions": ["getEFlagsV6"]}, {"filename": "llvm/tools/llvm-readobj/ELFDumper.cpp", "functions": ["if"]}, {"filename": "clang/test/Misc/warning-flags.c", "functions": ["flags"]}]}
{"pr_number": 77454, "url": "https://github.com/llvm/llvm-project/pull/77454", "title": "[coroutine] Suppress unreachable-code warning on coroutine statements.", "body": "This fixes #69219.\r\n\r\nConsider an example:\r\n\r\n```\r\nCoTask my_coroutine() {\r\n    std::abort();\r\n    co_return 1; // unreachable code warning.\r\n}\r\n```\r\n\r\nClang emits a CFG-based unreachable warning on the `co_return` statement (precisely the `1` subexpr). If we remove this statement, the program semantic is changed (my_coroutine is not a coroutine anymore).\r\n\r\nThis patch fixes this issue by never considering coroutine statements as dead statements.", "feature_layers": ["sema"], "feature_directives": ["task"], "files_changed": [{"filename": "clang/lib/Analysis/ReachableCode.cpp", "functions": ["isInCoroutineStmt"]}, {"filename": "clang/test/SemaCXX/coroutine-unreachable-warning.cpp", "functions": ["abort", "await_transform", "await_suspend", "test9", "await_ready", "await_resume"]}]}
{"pr_number": 80523, "url": "https://github.com/llvm/llvm-project/pull/80523", "title": "[RISCV][ISel] Remove redundant vmerge for vwsub(u).wv.", "body": "Extend #78403 and #80079 to support `vwsub.wv` and `vwsubu.wv`.\r\n\r\n## Code\r\n```\r\ndefine <8 x i64> @vwsub_wv_mask_v8i32(<8 x i32> %x, <8 x i64> %y) {\r\n    %mask = icmp slt <8 x i32> %x, <i32 42, i32 42, i32 42, i32 42, i32 42, i32 42, i32 42, i32 42>\r\n    %a = select <8 x i1> %mask, <8 x i32> %x, <8 x i32> zeroinitializer\r\n    %sa = sext <8 x i32> %a to <8 x i64>\r\n    %ret = sub <8 x i64> %y, %sa\r\n    ret <8 x i64> %ret\r\n}\r\n```\r\n\r\n## Before this patch\r\n[Compiler Explorer](https://godbolt.org/z/qh31f5WWa)\r\n```\r\nvwsub_wv_mask_v8i32:\r\n        li      a0, 42\r\n        vsetivli        zero, 8, e32, m2, ta, ma\r\n        vmslt.vx        v0, v8, a0\r\n        vmv.v.i v10, 0\r\n        vmerge.vvm      v16, v10, v8, v0\r\n        vwsub.wv        v8, v12, v16\r\n        ret\r\n```\r\n\r\n## After this patch\r\n```\r\nvwsub_wv_mask_v8i32:\r\n        li a0, 42\r\n        vsetivli zero, 8, e32, m2, ta, ma\r\n        vmslt.vx v0, v8, a0\r\n        vsetvli zero, zero, e32, m2, tu, mu\r\n        vwsub.wv v12, v12, v8, v0.t\r\n        vmv4r.v v8, v12\r\n        ret\r\n```", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/RISCVISelLowering.cpp", "functions": ["combineVWADDSUBWSelect", "combineVWADDWSelect", "performVWADDW_VLCombine", "performVWADDSUBW_VLCombine"]}]}
{"pr_number": 80257, "url": "https://github.com/llvm/llvm-project/pull/80257", "title": "[NFC][TableGen][GlobalISel] Move MIR Pattern Parsing out of Combiner Impl", "body": "This just moves code around so the MIR pattern parsing logic is separated and reusable.\r\n", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "llvm/utils/TableGen/GlobalISel/CombinerUtils.cpp", "functions": ["insertStrRef"]}, {"filename": "llvm/utils/TableGen/GlobalISel/PatternParser.cpp", "functions": ["print", "ParseErr", "DiagLocSAR", "if"]}, {"filename": "llvm/utils/TableGen/GlobalISelCombinerEmitter.cpp", "functions": ["ParseErr", "CGT", "parsePatFragImpl", "Parser", "if", "insertStrRef"]}]}
{"pr_number": 80447, "url": "https://github.com/llvm/llvm-project/pull/80447", "title": "[flang] Do not instantiate runtime info globals in functions", "body": "Runtime globals are compiler generated globals injected in user scopes. They are never referred to directly in lowering code, we only need th fur.global for them. Yet lowering was creating hlfir.declare for them in module procedures. In modern fortran apps, this blows up the generated IR for nothing (Types with dozens of components, type bound procedures and parents can create in the order of 10 000 runtime info globals to describe them, if there is a 100 module procedure, that is that is a few million operations generated and processed in each pass for nothing).", "feature_layers": ["runtime", "ir"], "feature_directives": ["for", "declare"], "files_changed": [{"filename": "flang/lib/Lower/ConvertVariable.cpp", "functions": ["isRuntimeTypeInfoData"]}]}
{"pr_number": 79466, "url": "https://github.com/llvm/llvm-project/pull/79466", "title": "Apply format only if --format is specified", "body": "clang-apply-replacements used to apply format even without --format is specified. This because, methods like createReplacementsForHeaders only takes the Spec.Style and would re-order the headers even when it was not requested. The fix is to set up Spec.Style only if --format is provided.\r\n\r\nAlso added note to ReleaseNotes.rst\r\n\r\nBased on https://github.com/llvm/llvm-project/pull/70801", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang-tools-extra/test/clang-apply-replacements/Inputs/format_header/no.cpp", "functions": ["foo"]}, {"filename": "clang-tools-extra/test/clang-apply-replacements/Inputs/format_header/yes.cpp", "functions": ["foo"]}]}
{"pr_number": 79476, "url": "https://github.com/llvm/llvm-project/pull/79476", "title": "[RemoveDIs] Handle DPValues in hoistCommonCodeFromSuccessors", "body": "[RemoveDIs] Handle DPValues in hoistCommonCodeFromSuccessors\r\n\r\nHoist DPValues attached to each instruction being considered for hoisting if they\r\nare identical in lock-step. This includes the final instructions which are \r\nconsidered but not hoisted, because the corresponding dbg.values would appear\r\nbefore those instruction and thus hoisted if identical.\r\n\r\nIdentical debug records hoisted:\r\nllvm/test/Transforms/SimplifyCFG/hoist-dbgvalue.ll\r\n\r\nNon-identical debug records not hoisted:\r\nllvm/test/Transforms/SimplifyCFG/X86/pr39187-g.ll\r\n\r\nDebug records attached to first not-hoisted instructions are hoisted:\r\nllvm/test/Transforms/SimplifyCFG/hoist-dbgvalue-inlined.ll", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Utils/SimplifyCFG.cpp", "functions": ["all_of", "hoistSuccIdenticalTerminatorToSwitchOrIf"]}]}
{"pr_number": 70801, "url": "https://github.com/llvm/llvm-project/pull/70801", "title": "[clang-apply-replacements] Apply format only if --format is specified", "body": "clang-apply-replacements is now applying format even when --format is not specified.  Methods like createReplacementsForHeaders only takes the Spec.Style and would re-order the headers even when it was not requested. The fix is to set up Spec.Style only if --format is provided.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang-tools-extra/test/clang-apply-replacements/Inputs/format_header/no.cpp", "functions": ["foo"]}, {"filename": "clang-tools-extra/test/clang-apply-replacements/Inputs/format_header/yes.cpp", "functions": ["foo"]}]}
{"pr_number": 79962, "url": "https://github.com/llvm/llvm-project/pull/79962", "title": "[lldb] Add support for large watchpoints in lldb", "body": "This patch is the next piece of work in my Large Watchpoint proposal, https://discourse.llvm.org/t/rfc-large-watchpoint-support-in-lldb/72116\r\n\r\nThis patch breaks a user's watchpoint into one or more WatchpointResources which reflect what the hardware registers can cover. This means we can watch objects larger than 8 bytes, and we can watched unaligned address ranges.  On a typical 64-bit target with 4 watchpoint registers you can watch 32 bytes of memory if the start address is doubleword aligned.\r\n\r\nAdditionally, if the remote stub implements AArch64 MASK style watchpoints (e.g. debugserver on Darwin), we can watch any power-of-2 size region of memory up to 2GB, aligned to that same size.\r\n\r\nI updated the Watchpoint constructor and CommandObjectWatchpoint to create a CompilerType of Array<UInt8> when the size of the watched region is greater than pointer-size and we don't have a variable type to use.  For pointer-size and smaller, we can display the watched granule as an integer value; for larger-than-pointer-size we will display as an array of bytes.\r\n\r\nI have `watchpoint list` now print the WatchpointResources used to implement the watchpoint.\r\n\r\nI added a WatchpointAlgorithm class which has a top-level static method that takes an enum flag mask WatchpointHardwareFeature and a user address and size, and returns a vector of WatchpointResources covering the request.  It does not take into account the number of watchpoint registers the target has, or the number still available for use.  Right now there is only one algorithm, which monitors power-of-2 regions of memory.  For up to pointer-size, this is what Intel hardware supports. AArch64 Byte Address Select watchpoints can watch any number of contiguous bytes in a pointer-size memory granule, that is not currently supported so if you ask to watch bytes 3-5, the algorithm will watch the entire doubleword (8 bytes). The newly default \"modify\" style means we will silently ignore modifications to bytes outside the watched range.\r\n\r\nI've temporarily skipped TestLargeWatchpoint.py for all targets. It was only run on Darwin when using the in-tree debugserver, which was a proxy for \"debugserver supports MASK watchpoints\".  I'll be adding the aforementioned feature flag from the stub and enabling full mask watchpoints when a debugserver with that feature is enabled, and re-enable this test.\r\n\r\nI added a new TestUnalignedLargeWatchpoint.py which only has one test but it's a great one, watching a 22-byte range that is unaligned and requires four 8-byte watchpoints to cover.\r\n\r\nI also added a unit test, WatchpointAlgorithmsTests, which has a number of simple tests against WatchpointAlgorithms::PowerOf2Watchpoints. I think there's interesting possible different approaches to how we cover these; I note in the unit test that a user requesting a watch on address 0x12e0 of 120 bytes will be covered by two watchpoints today, a 128-bytes at 0x1280 and at 0x1300.  But it could be done with a 16-byte watchpoint at 0x12e0 and a 128-byte at 0x1300, which would have fewer false positives/private stops.  As we try refining this one, it's helpful to have a collection of tests to make sure things don't regress.\r\n\r\nI tested this on arm64 macOS, (genuine) x86_64 macOS, and AArch64 Ubuntu.  I have not modifed the Windows process plugins yet, I might try that as a standalone patch, I'd be making the change blind, but the necessary changes (see ProcessGDBRemote::EnableWatchpoint) are pretty small so it might be obvious enough that I can change it and see what the Windows CI thinks.\r\n\r\nThere isn't yet a packet (or a qSupported feature query) for the gdb remote serial protocol stub to communicate its watchpoint capabilities to lldb.  I'll be doing that in a patch right after this is landed, having debugserver advertise its capability of AArch64 MASK watchpoints, and have ProcessGDBRemote add eWatchpointHardwareArmMASK to WatchpointAlgorithms so we can watch larger than 32-byte requests on Darwin.\r\n\r\nI haven't yet tackled WatchpointResource *sharing* by multiple Watchpoints.  This is all part of the goal, especially when we may be watching a larger memory range than the user requested, if they then add another watchpoint next to their first request, it may be covered by the same WatchpointResource (hardware watchpoint register). Also one \"read\" watchpoint and one \"write\" watchpoint on the same memory granule need to be handled, making the WatchpointResource cover all requests.\r\n\r\nAs WatchpointResources aren't shared among multiple Watchpoints yet, there's no handling of running the conditions/commands/etc on multiple Watchpoints when their shared WatchpointResource is hit. The goal beyond \"large watchpoint\" is to unify (much more) the Watchpoint and Breakpoint behavior and commands.  I have a feeling I may be slowly chipping away at this for a while.\r\n\r\nrdar://108234227", "feature_layers": ["ir"], "feature_directives": ["for", "target", "requires"], "files_changed": [{"filename": "lldb/test/API/functionalities/watchpoint/unaligned-large-watchpoint/main.c", "functions": ["main"]}]}
{"pr_number": 80428, "url": "https://github.com/llvm/llvm-project/pull/80428", "title": "[X86] X86FixupVectorConstants - load+zero vector constants that can be stored in a truncated form", "body": "Further develops the vsextload support added in #79815 - reduces the size of the vector constant by storing it in the constant pool in a truncated form, and zero-extend it as part of the load.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/X86/X86FixupVectorConstants.cpp", "functions": ["rebuildExtCst"]}, {"filename": "llvm/lib/Target/X86/X86MCInstLower.cpp", "functions": ["getRegisterWidth", "CS"]}]}
{"pr_number": 80003, "url": "https://github.com/llvm/llvm-project/pull/80003", "title": "AMDGPU/GlobalISelDivergenceLowering: select divergent i1 phis", "body": "Implement PhiLoweringHelper for GlobalISel in DivergenceLoweringHelper. Use machine uniformity analysis to find divergent i1 phis and select them as lane mask phis in same way SILowerI1Copies select VReg_1 phis. Note that divergent i1 phis include phis created by LCSSA and all cases of uses outside of cycle are actually covered by \"lowering LCSSA phis\". GlobalISel lane masks are registers with sgpr register class and S1 LLT.\r\n\r\nTODO: General goal is that instructions created in this pass are fully instruction-selected so that selection of lane mask phis is not split across multiple passes.\r\n\r\npatch 3 from: https://github.com/llvm/llvm-project/pull/73337", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/CodeGen/MachineUniformityAnalysis.cpp", "functions": ["print", "getAnalysisUsage", "runOnMachineFunction"]}, {"filename": "llvm/lib/Target/AMDGPU/AMDGPUGlobalISelDivergenceLowering.cpp", "functions": ["markAsLaneMask", "buildRegCopyToLaneMask", "constrainAsLaneMask", "PhiLoweringHelper", "Helper"]}, {"filename": "llvm/lib/Target/AMDGPU/AMDGPUInstructionSelector.cpp", "functions": ["selectPHI"]}, {"filename": "llvm/lib/Target/AMDGPU/SILowerI1Copies.cpp", "functions": ["constrainAsLaneMask", "constrainIncomingRegisterTakenAsIs"]}]}
{"pr_number": 79265, "url": "https://github.com/llvm/llvm-project/pull/79265", "title": "[libc++] fix `counting_semaphore` lost wakeups", "body": "Fixes #77659\r\nFixes #46357\r\n\r\nPicked up from https://reviews.llvm.org/D114119", "feature_layers": ["sema"], "feature_directives": [], "files_changed": [{"filename": "libcxx/test/std/thread/thread.semaphore/lost_wakeup.pass.cpp", "functions": ["release", "s", "main", "b", "acquire"]}]}
{"pr_number": 80407, "url": "https://github.com/llvm/llvm-project/pull/80407", "title": "[mlir][ArmSME] Add rewrites to swap extract of extend", "body": "In mixed matmul lowering (e.g., i8 to i32) we're seeing the following sequence:\r\n\r\n  %0 = arith.extsi %src : vector<4x[8]xi8> to vector<4x[8]xi32>\r\n  %1 = vector.extract %0[0] : vector<[8]xi32> from vector<4x[8]xi32>\r\n  %lhs = vector.scalable.extract %1[0] : vector<[4]xi32> from vector<[8]xi32>\r\n\r\n  ... (same for rhs)\r\n\r\n  %2 = vector.outerproduct %lhs, %rhs, %acc vector<[4]xi32>, vector<[4]xi32>\r\n\r\n  // x4 chained by accumulator\r\n\r\nThis chain of 4 outer products can be fused into a single 4-way widening variant but the pass doesn't match on the IR, as it expects the source of the inputs to be an extend and it can't look through the extracts.\r\n\r\nThis patch fixes this with two rewrites that swaps extract(extend) into extend(extract).\r\n\r\nRelated to #78975, #79288.", "feature_layers": ["ir"], "feature_directives": ["for", "single"], "files_changed": [{"filename": "mlir/lib/Dialect/ArmSME/Transforms/VectorLegalization.cpp", "functions": ["success"]}, {"filename": "mlir/lib/Dialect/ArmSME/Transforms/OuterProductFusion.cpp", "functions": ["success"]}]}
{"pr_number": 80547, "url": "https://github.com/llvm/llvm-project/pull/80547", "title": "[mlir][EmitC] Add support for external functions", "body": "This adds a conversion from an externaly defined `func.func`, a `func.func` without function body, to an `emitc.func` with an `extern` specifier.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/EmitC/IR/EmitC.cpp", "functions": ["emitOpError"]}, {"filename": "mlir/lib/Target/Cpp/TranslateToCpp.cpp", "functions": ["failure", "success"]}]}
{"pr_number": 80316, "url": "https://github.com/llvm/llvm-project/pull/80316", "title": "[Libomptarget] Remove unused 'SupportsEmptyImages' API function", "body": "Summary:\nThis function is always false in the current implementation and is not\neven considered required. Just remove it and if someone needs it in the\nfuture they can add it back in. This is done to simplify the interface\nprior to other changes\n", "feature_layers": ["ir"], "feature_directives": ["target"], "files_changed": [{"filename": "openmp/libomptarget/plugins-nextgen/common/src/PluginInterface.cpp", "functions": ["__tgt_rtl_supports_empty_images"]}]}
{"pr_number": 80456, "url": "https://github.com/llvm/llvm-project/pull/80456", "title": "[analyzer] Model Microsoft \"__assume\" in the same way as clang \"__builtin_assume\"", "body": "See the MS docs:\r\nhttps://learn.microsoft.com/en-us/windows-hardware/drivers/devtest/using-the--analysis-assume-function-to-suppress-false-defects https://learn.microsoft.com/en-us/cpp/code-quality/how-to-specify-additional-code-information-by-using-analysis-assume\r\n\r\nTBH, I don't really know what is the difference between the two APIs.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/Analysis/builtin-functions.cpp", "functions": ["g", "f"]}]}
{"pr_number": 78315, "url": "https://github.com/llvm/llvm-project/pull/78315", "title": "[analyzer] Support interestingness in ArrayBoundV2", "body": "This commit improves alpha.security.ArrayBoundV2 in two connected areas:\r\n(1) It calls `markInteresting()` on the symbolic values that are responsible for the out of bounds access.\r\n(2) Its index-is-in-bounds assumptions are reported in note tags if they provide information about the value of an interesting symbol.\r\n\r\nThis commit is limited to \"display\" changes: it introduces new diagnostic pieces (potentially to bugs found by other checkers), but ArrayBoundV2 will make the same assumptions and detect the same bugs before and after this change.\r\n\r\nAs a minor unrelated change, this commit also updates/removes some very old comments which became obsolate due to my previous changes.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/StaticAnalyzer/Checkers/ArrayBoundCheckerV2.cpp", "functions": ["Reg", "determineElementType", "determineElementSize"]}, {"filename": "clang/test/Analysis/out-of-bounds-notes.c", "functions": ["free", "assumingExtent", "__typeof"]}, {"filename": "clang/test/Analysis/out-of-bounds-diagnostics.c", "functions": ["symbolicIndex", "unknownIndex"]}]}
{"pr_number": 80675, "url": "https://github.com/llvm/llvm-project/pull/80675", "title": "[mlir][bufferization][NFC] Pass `DeallocationOptions` instead of flags", "body": "Pass `DeallocationOptions` instead of `privateFuncDynamicOwnership`. This will make it easier to add new options in the future.\r\n", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Dialect/Bufferization/Transforms/OwnershipBasedBufferDeallocation.cpp", "functions": ["state", "deallocation"]}]}
{"pr_number": 80351, "url": "https://github.com/llvm/llvm-project/pull/80351", "title": "[mlir][openacc] Add legalize data pass for compute operation", "body": "This patch adds a simple pass to replace the uses inside compute operation. It replaces the `varPtr` values with their corresponding `accPtr` values gathered through the dataClauseOperands.\r\n\r\nprivate and reductions variables are not included in this pass since they will normally be replace when they are materialized. ", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/OpenACC/Transforms/LegalizeData.cpp", "functions": ["runOnOperation", "collectAndReplaceInRegion"]}]}
{"pr_number": 80020, "url": "https://github.com/llvm/llvm-project/pull/80020", "title": "[libc++] Fix ambiguity when using std::scoped_allocator constructor", "body": "As a drive-by change, also fix a name that wasn't uglified in the code and add a test for that.\r\n\r\nFixes #78754", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "libcxx/test/std/utilities/allocator.adaptor/allocator.adaptor.cnstr/allocs.pass.cpp", "functions": ["a"]}]}
{"pr_number": 80710, "url": "https://github.com/llvm/llvm-project/pull/80710", "title": "Revert \"[mlir][openacc] Add legalize data pass for compute operation\"", "body": "Reverts llvm/llvm-project#80351\r\n\r\nBreaks some buildbot", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/OpenACC/Transforms/LegalizeData.cpp", "functions": ["runOnOperation", "collectAndReplaceInRegion"]}]}
{"pr_number": 71766, "url": "https://github.com/llvm/llvm-project/pull/71766", "title": "[Flang][OpenMP] Initial mapping of Fortran pointers and allocatables for target devices", "body": "This patch seeks to add an initial lowering for pointers, allocatable variables and some other cases of box types such as assumed size and shape. This works for both explicitly and implicit captured allocatables, but the implicit capture needs further investigation to make sure the semantics are correct in all cases (e.g. when used in conjunction with enter/exit data directives). \r\n\r\nCurrently the intention is to treat these types as a special case of OpenMP structure mapping as far as the runtime is concerned, where the box (descriptor information) is the holding container and the underlying data pointer is contained within the container. The descriptor pointed to by the generated bounds provides all the data required to offload the pointer contained within the descriptor. There's also the additional case where we must map other pointers within the descriptor information that may be utilised on the device, currently descriptor addendum information is the only case where this is required but as the descriptor is still under-going changes future additions may be required.\r\n\r\nFor the moment, the PFT -> FIR/HLFIR+OpenMP dialect lowering in Flang's Lower/OpenMP.cpp has had the processMap lowering code for Target operations extended to support generation of specialised map information for descriptor types (Box's) that (hopefully, as derived type member mapping hasn't been implemented yet, but should not be dissimilar) mimic how derived type member mapping when a parent structure is also being mapped will hopefully be performed, with a main mapping of the structure and extra map_info per member being attached to a new member argument field added to the map_info operation. The main difference that will likely be addressed in the future derived type member mapping PR is that the derived types will likely have symbols to be bound to block arguments, whereas the descriptor members do not, so currently the descriptor members are not added to the map operands, but for derived types that might not be the case. The descriptor members can be added to the map operands, but it would require an additional extension to TargetOp to have a mapping between map operands and block arguments to aid lowering and printing of the operation. So for the moment, I've delayed doing that until we confirm if it's necessary in a future PR for derived type member mapping. \r\n\r\nThere's an addition to FIR's CodeGen to support a specialised omp.map_info operation lowering for FIR to the LLVM dialect, this is to allow for appropriate conversion of Box types to there LLVM structure equivalent that is required for later OpenMP lowering.\r\n\r\nAdditions to OpenMPToLLVMIRTranslation.cpp's mapping infrastructure is also added that adds some initial lowering for structure types with member maps, attempts to make it generalizable to all structure + member mappings have been made not just descriptor mapping. But this hasn't been fully explored yet, so there may be some adjustments required (hopefully minor).\r\n\r\nThere is an outstanding known issue with scalar allocatable assignment where it will crash in the instruction selector for AMD GPU when we compile utilising HLFIR (but not FIR).", "feature_layers": ["sema", "codegen", "runtime", "ir", "ast"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "flang/lib/Optimizer/CodeGen/CodeGenOpenMP.cpp", "functions": ["OpenMPFIROpConversion"]}, {"filename": "flang/lib/Optimizer/Dialect/FIRType.cpp", "functions": ["isTypeWithDescriptor"]}, {"filename": "flang/lib/Optimizer/Transforms/OMPDescriptorMapInfoGen.cpp", "functions": ["runOnOperation", "createOMPDescriptorMapInfoGenPass"]}, {"filename": "mlir/lib/Dialect/OpenMP/IR/OpenMPDialect.cpp", "functions": ["verifyMapClause"]}]}
{"pr_number": 80657, "url": "https://github.com/llvm/llvm-project/pull/80657", "title": "[ValueTracking][NFC] Pass `SimplifyQuery` to `computeKnownFPClass` family", "body": "This patch refactors the interface of the `computeKnownFPClass` family to pass `SimplifyQuery` directly.\r\nThe motivation of this patch is to compute known fpclass with `DomConditionCache`, which was introduced by https://github.com/llvm/llvm-project/pull/73662. With `DomConditionCache`, we can do more optimization with context-sensitive information.\r\n\r\nExample (extracted from [fmt/format.h](https://github.com/fmtlib/fmt/blob/e17bc67547a66cdd378ca6a90c56b865d30d6168/include/fmt/format.h#L3555-L3566)):\r\n```\r\ndefine float @test(float %x, i1 %cond) {\r\n  %i32 = bitcast float %x to i32\r\n  %cmp = icmp slt i32 %i32, 0\r\n  br i1 %cmp, label %if.then1, label %if.else\r\n\r\nif.then1:\r\n  %fneg = fneg float %x\r\n  br label %if.end\r\n\r\nif.else:\r\n  br i1 %cond, label %if.then2, label %if.end\r\n\r\nif.then2:\r\n  br label %if.end\r\n\r\nif.end:\r\n  %value = phi float [ %fneg, %if.then1 ], [ %x, %if.then2 ], [ %x, %if.else ]\r\n  %ret = call float @llvm.fabs.f32(float %value)\r\n  ret float %ret\r\n}\r\n```\r\nWe can prove the signbit of `%value` is always zero. Then the fabs can be eliminated.\r\n", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Analysis/InstructionSimplify.cpp", "functions": ["computeKnownFPClass"]}, {"filename": "llvm/lib/Target/AMDGPU/AMDGPULibCalls.cpp", "functions": ["isKnownNeverInfinity"]}]}
{"pr_number": 79301, "url": "https://github.com/llvm/llvm-project/pull/79301", "title": "[flang] Set fast math related function attributes for -Ofast/-ffast-math", "body": "The implemented logic matches the logic used for Clang in emitting these attributes. Although it's hoped that function attributes won't be needed in the future (vs using fast math flags in individual IR instructions), there are codegen differences currently with/without these attributes, as can be seen in issues like #79257 or by hacking Clang to avoid producing these attributes and observing codegen changes.\r\n", "feature_layers": ["codegen", "ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/include/flang/Tools/CLOptions.inc", "functions": ["if"]}, {"filename": "flang/lib/Frontend/FrontendActions.cpp", "functions": ["config"]}]}
{"pr_number": 80506, "url": "https://github.com/llvm/llvm-project/pull/80506", "title": "GraphBLAS Support: register more MLIR sparse functions to Kokkos Emitter", "body": "", "feature_layers": ["parse", "ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/CAPI/IR/Pass.cpp", "functions": ["wrap"]}, {"filename": "mlir/lib/Pass/Pass.cpp", "functions": ["pyFileHandle", "cxxFileHandle"]}, {"filename": "mlir/lib/Target/KokkosCpp/TranslateRegistration.cpp", "functions": ["registerToKokkosTranslation"]}, {"filename": "mlir/lib/Target/KokkosCpp/TranslateToKokkosCpp.cpp", "functions": ["failure", "success"]}, {"filename": "mlir/lib/ExecutionEngine/SparseTensorRuntime.cpp", "functions": ["printSMR", "PrintAs"]}, {"filename": "mlir/lib/Bindings/Python/Pass.cpp", "functions": ["MLIRError"]}, {"filename": "mlir/lib/Dialect/SparseTensor/Transforms/SparseKokkosCodegen.cpp", "functions": ["failure", "if", "genAllocCopy", "bufferAccess"]}, {"filename": "mlir/lib/Dialect/SparseTensor/Transforms/SparseTensorPasses.cpp", "functions": ["runOnOperation", "patterns"]}, {"filename": "mlir/lib/Dialect/PartTensor/IR/PartTensorDialect.cpp", "functions": ["success"]}, {"filename": "mlir/lib/ExecutionEngine/PartTensorRuntime.cpp", "functions": ["_mlir_ciface_getNumPartitions"]}, {"filename": "mlir/unittests/Dialect/PartTensor/PartTensorTest.cpp", "functions": ["getColumnPartitions2d"]}, {"filename": "mlir/lib/Conversion/PartTensorToLLVM/PartTensorToLLVM.cpp", "functions": ["target", "runOnOperation", "success", "options", "guard", "patterns", "converter", "getPtrToElementType"]}, {"filename": "mlir/lib/Dialect/PartTensor/Transforms/PartTensorConversion.cpp", "functions": ["success"]}, {"filename": "mlir/lib/Dialect/PartTensor/Transforms/PartTensorPasses.cpp", "functions": ["target", "runOnOperation", "patterns"]}]}
{"pr_number": 79533, "url": "https://github.com/llvm/llvm-project/pull/79533", "title": "[lldb][progress][NFC] Add unit test for progress reports", "body": "This test is being added as a way to check the behaviour of how progress events are broadcasted when reports are started and ended with the current implementation of progress reports. Here we're mainly checking and ensuring that the current behaviour is that progress events are broadcasted individually and placed in the event queue in order of their creation.", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "lldb/unittests/Core/ProgressReportTest.cpp", "functions": ["TearDown", "SetUp"]}]}
{"pr_number": 80387, "url": "https://github.com/llvm/llvm-project/pull/80387", "title": "[mlir][openacc] Simplify IR with acc.loop control", "body": "When the new `acc.loop` design was introduced some of the loop information like `gang`/`vector`/`worker` were also updated to support `device_type`.\r\nWith a conflict in parsing/printing, the keyword only value for `async`/`gang`/`vector`/`worker` were printed/parsed with an empty set of parenthesis `()`. To make the IR clearer to read and similar across the operations, the loop control part of is now prefixed by `control` and this allow to remove the need of the empty `()`.\r\n", "feature_layers": ["parse", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/OpenACC/IR/OpenACC.cpp", "functions": ["failure", "success"]}]}
{"pr_number": 80061, "url": "https://github.com/llvm/llvm-project/pull/80061", "title": "[scudo] Add ScopedTSD to avoid releasing TSD manually", "body": "This makes the use of TSD be RAII style and avoid the exposing of the type of TSDs.\r\n\r\nAlso move some thread safety analyses from static to runtime because of its limitation. Even we mark some code path as NO_THREAD_SAFETY_ANALYSIS but we still have the `assertLocked()` cover the correctness.", "feature_layers": ["runtime"], "feature_directives": [], "files_changed": [{"filename": "compiler-rt/lib/scudo/standalone/tests/combined_test.cpp", "functions": ["Run"]}, {"filename": "compiler-rt/lib/scudo/standalone/tests/tsd_test.cpp", "functions": ["testRegistry", "stressCache", "TSD"]}]}
{"pr_number": 80730, "url": "https://github.com/llvm/llvm-project/pull/80730", "title": "[Clang][Sema] Fix regression due to missing ambiguity check before attempting access check.", "body": "Previously when fixing ambiguous lookup diagnostics in cc1b6668c57170cd440d321037ced89d6a61a9cb The change refactored `LookupResult` to split out diagnosing access and ambiguous lookups. The call to `getSema().CheckLookupAccess(...)` should have guarded by a check for isAmbiguous(). This change adds that guard.\r\n\r\nFixes: https://github.com/llvm/llvm-project/issues/80435", "feature_layers": ["sema"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CXX/class.derived/class.member.lookup/p11.cpp", "functions": ["y"]}]}
{"pr_number": 76885, "url": "https://github.com/llvm/llvm-project/pull/76885", "title": "[readtapi] Add support for stubify-ing directories", "body": "When given a directory input `llvm-readtapi` traverses through the directory to find dylibs or tbd files to operate on. TBD files will be created with the same base file name as the dylib. Symlinks should be created if the input is one.\r\n\r\nThis also introduces options to delete input files which are defined as library files that existed before `readtapi -stubify` was invoked. Also the ability to delete private libraries where private libraries are in a predefined file system locations on darwin based platforms.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/tools/llvm-readtapi/llvm-readtapi.cpp", "functions": ["stubifyDirectory", "reportWarning", "NormalizedPath", "LinkSrc", "stubifyImpl", "LinkTarget"]}]}
{"pr_number": 74515, "url": "https://github.com/llvm/llvm-project/pull/74515", "title": "[scudo] [MTE] resize stack depot for allocation ring buffer", "body": "", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "compiler-rt/lib/scudo/standalone/fuzz/get_error_info_fuzzer.cpp", "functions": ["StackDepot"]}, {"filename": "compiler-rt/lib/scudo/standalone/wrappers_c_bionic.cpp", "functions": ["sizeof"]}, {"filename": "compiler-rt/lib/scudo/standalone/tests/combined_test.cpp", "functions": ["sizeof"]}]}
{"pr_number": 80777, "url": "https://github.com/llvm/llvm-project/pull/80777", "title": "Revert \"[scudo] [MTE] resize stack depot for allocation ring buffer\"", "body": "Reverts llvm/llvm-project#74515\r\n\r\nBroke build: https://lab.llvm.org/buildbot/#/builders/75/builds/42512", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "compiler-rt/lib/scudo/standalone/fuzz/get_error_info_fuzzer.cpp", "functions": ["StackDepot"]}, {"filename": "compiler-rt/lib/scudo/standalone/tests/combined_test.cpp", "functions": ["sizeof"]}, {"filename": "compiler-rt/lib/scudo/standalone/wrappers_c_bionic.cpp", "functions": ["sizeof"]}]}
{"pr_number": 80767, "url": "https://github.com/llvm/llvm-project/pull/80767", "title": "Add a new SBProcess:: GetCoreFile() API", "body": "We have a Python script that needs to locate coredump path during debugging so that we can retrieve certain metadata files associated with it. Currently, there is no API for this.\r\n\r\nThis patch adds a new `SBProcess::GetCoreFile()` to retrieve target dump file spec used for dump debugging. Note: this is different from the main executable module spec. To achieve this, the patch hoists m_core_file into PostMortemProcess for sharing.\r\n", "feature_layers": [], "feature_directives": ["for", "target"], "files_changed": [{"filename": "lldb/source/API/SBProcess.cpp", "functions": ["process_sp", "SBFileSpec"]}, {"filename": "lldb/source/Plugins/Process/FreeBSDKernel/ProcessFreeBSDKernel.cpp", "functions": ["PostMortemProcess", "ProcessFreeBSDKernel"]}, {"filename": "lldb/source/Plugins/Process/elf-core/ProcessElfCore.cpp", "functions": ["PostMortemProcess"]}, {"filename": "lldb/source/Plugins/Process/mach-core/ProcessMachCore.cpp", "functions": ["PostMortemProcess"]}, {"filename": "lldb/source/Plugins/Process/minidump/ProcessMinidump.cpp", "functions": ["PostMortemProcess"]}, {"filename": "lldb/source/Target/ProcessTrace.cpp", "functions": ["PostMortemProcess"]}]}
{"pr_number": 80594, "url": "https://github.com/llvm/llvm-project/pull/80594", "title": "[concepts] Extract function template pack arguments from the current instantiation if possible", "body": "Before the constraint substitution, we employ `getTemplateInstantiationArgs`, which in turn attempts to inspect `TemplateArgument`s from the function template. For parameter packs from their parent contexts, we used to extract the arguments from the specialization type, in which could result in non-canonical argument types e.g. `PackExpansionType`.\r\n\r\nThis may break the contract that, during a tree transformation, in `TreeTransform::TryExpandParameterPacks`, the corresponding `TemplateArgument`s for an `UnexpandedParameterPack` are expected to be of `Pack` kinds if we're expanding template parameters.\r\n\r\nFixes https://github.com/llvm/llvm-project/issues/72557.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/SemaTemplate/concepts-out-of-line-def.cpp", "functions": ["index"]}]}
{"pr_number": 80376, "url": "https://github.com/llvm/llvm-project/pull/80376", "title": "[lldb] Add QSupported key to report watchpoint types supported", "body": "debugserver on arm64 devices can manage both Byte Address Select watchpoints (1-8 bytes) and MASK watchpoints (8 bytes-2 gigabytes). This adds a SupportedWatchpointTypes key to the QSupported response from debugserver with a list of these, so lldb can take full advantage of them when creating larger regions with a single hardware watchpoint.\r\n\r\nAlso add documentation for this, and two other lldb extensions, to the lldb-gdb-remote.txt documentation.\r\n\r\nRe-enable TestLargeWatchpoint.py on Darwin systems when testing with the in-tree built debugserver.  I can remove the \"in-tree built debugserver\" in the future when this new key is handled by an Xcode debugserver.", "feature_layers": [], "feature_directives": ["for", "single"], "files_changed": [{"filename": "lldb/tools/debugserver/source/RNBRemote.cpp", "functions": ["SendPacket"]}]}
{"pr_number": 78692, "url": "https://github.com/llvm/llvm-project/pull/78692", "title": "[lld][ELF] Support relax R_LARCH_ALIGN", "body": "Refer to commit 6611d58f5bbc (\"Relax R_RISCV_ALIGN\"), we can relax R_LARCH_ALIGN by same way. Reuse `SymbolAnchor`, `RISCVRelaxAux` and `initSymbolAnchors` to simplify codes. As `riscvFinalizeRelax` is an arch-specific function, put it override on `TargetInfo::finalizeRelax`, so that LoongArch can override it, too.\r\n\r\nThe flow of relax R_LARCH_ALIGN is almost consistent with RISCV. The difference is that LoongArch only has 4-bytes NOP and all executable insn is 4-bytes aligned. So LoongArch not need rewrite NOP sequence. Alignment maxBytesEmit parameter is supported in psABI v2.30.", "feature_layers": [], "feature_directives": ["target"], "files_changed": [{"filename": "lld/ELF/Arch/LoongArch.cpp", "functions": ["finalizeRelax", "relaxOnce", "relax"]}, {"filename": "lld/ELF/Arch/RISCV.cpp", "functions": ["finalizeRelax", "initSymbolAnchors"]}]}
{"pr_number": 70762, "url": "https://github.com/llvm/llvm-project/pull/70762", "title": "[clang] Add support for new loop attribute [[clang::code_align()]]", "body": "This patch adds support for new loop attribute: [[clang::code_align(N)]].\r\nThis attribute applies to a loop and specifies the byte alignment for a loop.\r\nThe attribute accepts a positive integer constant initialization expression\r\nindicating the number of bytes for the minimum alignment boundary.\r\nIts value must be a power of 2, between 1 and 4096 (inclusive).", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Sema/SemaStmtAttr.cpp", "functions": ["new", "handleCodeAlignAttr"]}, {"filename": "clang/lib/Sema/SemaTemplateInstantiate.cpp", "functions": ["getSema"]}, {"filename": "clang/test/CodeGen/code_align.c", "functions": ["code_align", "main", "bar", "code_align_cpp"]}, {"filename": "clang/test/Sema/code_align.c", "functions": ["bar3", "bar4"]}, {"filename": "clang/test/Sema/code_align_ast.c", "functions": ["code_align", "main", "bar", "code_align_cpp"]}]}
{"pr_number": 80725, "url": "https://github.com/llvm/llvm-project/pull/80725", "title": "[mlir][vector] Drop inner unit dims for xWrite on dynamic shapes.", "body": "This is part of https://github.com/llvm/llvm-project/commit/66347e516e22f9159b86024071fb92f364ac4418\r\n\r\nThe regression in downstream projects is about transfer_read patterns, which needs more investigation. Add the support for transfer_write for now.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Vector/Transforms/VectorTransforms.cpp", "functions": ["offsets", "strides"]}]}
{"pr_number": 80199, "url": "https://github.com/llvm/llvm-project/pull/80199", "title": "[TableGen] Remove redundant buffer copies for ULEB128 decode calls.", "body": "This patch removes a couple of redundant buffer copies in emitTable for setting up calls to decodeULEB128. Instead, provide the Table.data buffer directly to the calls-- where decodeULEB128 does its own buffer overflow checking.\r\n\r\nFactor out 7 explicit loops to emit ULEB128 bytes into emitULEB128. Also factor out 4 copies of 24-bit numtoskip emission into emitNumToSkip.\r\n\r\nThe functionality is already covered by existing unit tests and by virtue of most of the in-tree back-ends exercising the decoder emitter.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/utils/TableGen/DecoderEmitter.cpp", "functions": ["utostr"]}]}
{"pr_number": 80758, "url": "https://github.com/llvm/llvm-project/pull/80758", "title": "[Coroutines][NFC] Refactor CoroSplit for Switch Resume ABI ", "body": "This patch contains no functional changes. \r\n\r\nCurrently we have 3 different ABIs for coroutine lowering. Some if not most of the logic are unique to each type of lowering. Functions generally defend against misuse with an assertion like `assert(Shape.ABI == coro::ABI::Switch);.` This requires LLVM developers to always defend against misuse of functions in incompatible ABI types when adding new functions.\r\n\r\nI believe that grouping of these functions into a class and rely on private static methods incrementally improves the workflow.", "feature_layers": ["ir"], "feature_directives": ["for", "requires"], "files_changed": [{"filename": "llvm/lib/Transforms/Coroutines/CoroSplit.cpp", "functions": ["addMustTailToCoroResumes", "createResumeEntryBlock", "Builder", "Cloner"]}]}
{"pr_number": 80297, "url": "https://github.com/llvm/llvm-project/pull/80297", "title": "[mlir][emitc] Add a `declare_func` operation", "body": "This adds the `emitc.declare_func` operation that allows to emit the declaration of an `emitc.func` at a specific location.", "feature_layers": ["ir"], "feature_directives": ["declare"], "files_changed": [{"filename": "mlir/lib/Dialect/EmitC/IR/EmitC.cpp", "functions": ["emitOpError"]}, {"filename": "mlir/lib/Target/Cpp/TranslateToCpp.cpp", "functions": ["scope", "success", "failure"]}]}
{"pr_number": 72273, "url": "https://github.com/llvm/llvm-project/pull/72273", "title": "[AArch64] Add an AArch64 pass for loop idiom transformations", "body": "We have added a new pass that looks for loops such as the following:\r\n\r\n```\r\n  while (i != max_len)\r\n      if (a[i] != b[i])\r\n          break;\r\n\r\n  ... use index i ...\r\n```\r\n\r\nAlthough similar to a memcmp, this is slightly different because instead of returning the difference between the values of the first non-matching pair of bytes, it returns the index of the first mismatch. As such, we are not able to lower this to a memcmp call.\r\n\r\nThe new pass can now spot such idioms and transform them into a specialised predicated loop that gives a significant performance improvement for AArch64. It is intended as a stop-gap solution until this can be handled by the vectoriser, which doesn't currently deal with early exits.\r\n\r\nThis specialised loop makes use of a generic intrinsic that counts the trailing zero elements in a predicate vector. This was added in https://reviews.llvm.org/D159283 and for SVE we end up with brkb & incp instructions.\r\n\r\nAlthough we have added this pass only for AArch64, it was written in a generic way so that in theory it could be used by other targets. Currently the pass requires scalable vector support and needs to know the minimum page size for the target, however it's possible to make it work for fixed-width vectors too. Also, the llvm.experimental.cttz.elts intrinsic used by the pass has generic lowering, but can be made efficient for targets with instructions similar to SVE's brkb, cntp and incp.\r\n\r\nOriginal version of patch was posted on Phabricator:\r\n\r\n https://reviews.llvm.org/D158291\r\n\r\nPatch co-authored by Kerry McLaughlin (@kmclaughlin-arm) and David Sherwood (@david-arm)\r\n\r\nSee the original discussion on Discourse:\r\nhttps://discourse.llvm.org/t/aarch64-target-specific-loop-idiom-recognition/72383", "feature_layers": ["ir"], "feature_directives": ["for", "target", "requires"], "files_changed": [{"filename": "llvm/lib/Target/AArch64/AArch64LoopIdiomTransform.cpp", "functions": ["DTU", "if"]}]}
{"pr_number": 79146, "url": "https://github.com/llvm/llvm-project/pull/79146", "title": "[SimplifyLibCalls] Merge sqrt into the power of exp", "body": "Under fast-math flags it's possible to convert `sqrt(exp(X)) `into `exp(X * 0.5)`. I suppose that this transformation is always profitable. This is similar to the optimization existing in GCC.", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp", "functions": ["if", "Guard"]}]}
{"pr_number": 80170, "url": "https://github.com/llvm/llvm-project/pull/80170", "title": "[mlir][ArmSME] Add rewrite to lift illegal vector.transposes to memory", "body": "When unrolling the reduction dimension of something like a matmul for SME, you can end up with transposed reads of illegal types, like so:\r\n\r\n```mlir\r\n%illegalRead = vector.transfer_read %memref[%a, %b]\r\n                : memref<?x?xf32>, vector<[8]x4xf32>\r\n%legalType = vector.transpose %illegalRead, [1, 0]\r\n                : vector<[8]x4xf32> to vector<4x[8]xf32>\r\n```\r\n\r\nHere the `vector<[8]x4xf32>` is an illegal type, there's no way to lower a scalable vector of fixed vectors. However, as the final type `vector<4x[8]xf32>` is legal, we can instead lift the transpose to memory (producing a strided memref), and eliminate all the illegal types. This is shown below.\r\n\r\n```mlir\r\n%readSubview = memref.subview %memref[%a, %b] [%c8_vscale, %c4] [%c1, %c1]\r\n                : memref<?x?xf32> to memref<?x?xf32>\r\n%transpose = memref.transpose %readSubview (d0, d1) -> (d1, d0)\r\n                : memref<?x?xf32> to memref<?x?xf32>\r\n%legalType = vector.transfer_read %transpose[%c0, %c0]\r\n                : memref<?x?xf32>, vector<4x[8]xf32>\r\n```", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/ArmSME/Transforms/VectorLegalization.cpp", "functions": ["success", "inBoundsValues", "getExtensionSource", "isIllegalVectorType", "readIndices", "strides"]}]}
{"pr_number": 80582, "url": "https://github.com/llvm/llvm-project/pull/80582", "title": "[CodeGen] Port DeadMachineInstructionElim to new pass manager", "body": "A simple enough op pass so we can test standard instrumentations in future.", "feature_layers": ["codegen"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/CodeGen/DeadMachineInstructionElim.cpp", "functions": ["getAnalysisUsage", "DeadMachineInstructionElimImpl", "eliminateDeadMI", "runOnMachineFunction", "isDead", "runImpl"]}]}
{"pr_number": 78968, "url": "https://github.com/llvm/llvm-project/pull/78968", "title": "[flang][OpenMP] Add support for `target ... private`", "body": "Adds support for the `private` clause in the `target` directive. In order to support that, the `DataSharingProcessor` was also restructured in order to separate the collection of prviate symbols from their actual privatization code-gen.\r\n\r\nThe commit adds both a code-gen and an offloading tests.", "feature_layers": ["ir"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "flang/lib/Lower/OpenMP.cpp", "functions": ["dsp", "processStep2", "processStep3"]}]}
{"pr_number": 68511, "url": "https://github.com/llvm/llvm-project/pull/68511", "title": "[mlir][scf] Implement getSingle... of LoopLikeOpinterface for scf::ParallelOp", "body": "This adds implementations for `getSingleIterationVar`, `getSingleLowerBound`, `getSingleUpperBound`, `getSingleStep` of `LoopLikeOpInterface` to `scf::ParallelOp`. Until now, the implementations for these methods defaulted to returning `std::nullopt`, even in the special case where the parallel Op only has one dimension.\r\n\r\nRelated: https://github.com/llvm/llvm-project/pull/67883", "feature_layers": ["ir"], "feature_directives": ["parallel", "for", "single"], "files_changed": [{"filename": "mlir/lib/Dialect/SCF/IR/SCF.cpp", "functions": ["getLowerBound", "getUpperBound", "getStep", "getBody"]}, {"filename": "mlir/unittests/Dialect/SCF/LoopLikeSCFOpsTest.cpp", "functions": ["checkUnidimensional", "checkMultidimensional"]}]}
{"pr_number": 80677, "url": "https://github.com/llvm/llvm-project/pull/80677", "title": "[mlir][EmitC] Remove unreachable code and fix Windows build warning", "body": "", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Target/Cpp/TranslateToCpp.cpp", "functions": ["failure", "getOperatorPrecedence"]}]}
{"pr_number": 80817, "url": "https://github.com/llvm/llvm-project/pull/80817", "title": "[flang][OpenMP][NFC] Outline `genOpWithBody` & `createBodyOfOp` args", "body": "This PR outlines the arguments of the open CodeGen functions into 2 separate structs. This was, in part, motivated by the delayed privatization WIP #79862 where we had to extend the signatures of both functions containing quite a bit of default values (`nullptr`, `false`). This PR does not add any new arguments yet though, just outlines the existing ones.", "feature_layers": ["codegen"], "feature_directives": [], "files_changed": [{"filename": "flang/lib/Lower/OpenMP.cpp", "functions": ["tiv", "genOpWithBody", "createBodyOfOp", "locs"]}]}
{"pr_number": 77821, "url": "https://github.com/llvm/llvm-project/pull/77821", "title": "[flang][OpenMP] Fix privatization of threadprivate common block", "body": "In some cases, when privatizing a threadprivate common block, the\noriginal symbol will correspond to the common block, instead of\nits threadprivate version. This can happen, for instance, with a\ncommon block, declared in a separate module, used by a parent\nprocedure and privatized in its child procedure. In this case,\nsymbol lookup won't find a symbol in the parent procedure, but\nonly in the module where the common block was defined.\n\nFixes https://github.com/llvm/llvm-project/issues/65028\n", "feature_layers": [], "feature_directives": ["for", "declare", "threadprivate"], "files_changed": [{"filename": "flang/lib/Lower/OpenMP.cpp", "functions": ["isThreadPrivate"]}]}
{"pr_number": 72647, "url": "https://github.com/llvm/llvm-project/pull/72647", "title": "[Matrix] Convert column-vector ops feeding dot product to row-vectors.", "body": "Generalize the logic used to convert column-vector ops to row-vectors to support converting chains of operations.\r\n\r\nA potential next step is to further generalize this to convert column-vector ops to row-vector ops in general, not just for operands of dot products. Dot-product handling would then be driven by the general conversion, rather than the other way around.\r\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp", "functions": ["LHSCost"]}]}
{"pr_number": 77799, "url": "https://github.com/llvm/llvm-project/pull/77799", "title": "[Transforms] Expand optimizeTan to fold more inverse trig pairs", "body": "optimizeTan has been renamed to optimizeTrigInversionPairs as a result.\r\n\r\nSadly, this is not mathematically true that all inverse pairs fold to x. For example, asin(sin(x)) does not fold to x if x is over 2pi.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp", "functions": ["optimizeTrigInversionPairs", "optimizeTan"]}]}
{"pr_number": 80819, "url": "https://github.com/llvm/llvm-project/pull/80819", "title": "[ARM][AARCH64][NEON]: Wrong return type of NEON intrinsic  vqrshrunh_n_s16, vqrshruns_n_s32, and vqrshrund_n_s64 in arm_neon.h", "body": "* fixes https://github.com/llvm/llvm-project/issues/71751\r\n* changed return types in the table gen file responsible for generation\r\n  of the problematic intrinsics\r\n* this is to ensure that the return type for the functions is the same\r\n  as specified in the Arm Developer Documentation and avoid casting\r\nbugs\r\n(https://developer.arm.com/architectures/instruction-sets/intrinsics/vqrshrunh_n_s16)\r\n* updated lit tests to reflect the change in return type, worth noting\r\n  that LLVM does not seems to differentiate signed and unsigned ints in\r\nthe IR, hence the change in type cannot be checked in IR as far as I am\r\naware\r\n", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/CodeGen/aarch64-neon-intrinsics.c", "functions": ["test_vqrshruns_n_s32", "test_vqrshrunh_n_s16", "test_vqrshrund_n_s64"]}]}
{"pr_number": 68380, "url": "https://github.com/llvm/llvm-project/pull/68380", "title": "[RISCV][GlobalISel] Select G_GLOBAL_VALUE for medlow code model", "body": "We create generic instructions to serve as globalisel equivalents to selection DAG nodes, in order to leverage the SelectionDAG patterns. We lower G_GLOBAL_VALUE to these generic instructions.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp", "functions": ["selectGlobalValue", "STI"]}]}
{"pr_number": 80820, "url": "https://github.com/llvm/llvm-project/pull/80820", "title": "[libc] Add support for C23 binary notation in `sprintf`", "body": "Resolves Issue #80727\r\n\r\nImplementation for representation of binary numbers using `b` specifier, similar to other languages.\r\n\r\n[Reference](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2612.pdf)", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "libc/src/stdio/printf_core/converter.cpp", "functions": ["convert_decimal_binary"]}]}
{"pr_number": 80861, "url": "https://github.com/llvm/llvm-project/pull/80861", "title": "[DebugInfo][RemoveDIs] Extend intrinsic-conversion in debugify", "body": "A while back the entry/exit points of debugify were instrumented with conversion functions to/from non-intrinsic-form debug-info. This is the path of least resistance to incrementally converting parts of LLVM to use the new format. However, it turns out that debugify registers callbacks with the pass manager and can be fed non-intrinsic form debug-info. Thus: this patch wraps each of the four major debugify functions with the convertion utilities, and extends test coverage to a test that exposes this problem.\r\n\r\n(An alternative would be to put this code in the callback lambdas, but then it would be fighting pass manager abstractions of what type the IR has).\r\n\r\nHandily debugify has been designed to record the /meaning/ of debug-info rather than take pointers to intrinsics and the like, so the storage mechanism for debug-info is transparent to it!", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Utils/Debugify.cpp", "functions": ["stripDebugifyMetadata"]}]}
{"pr_number": 80791, "url": "https://github.com/llvm/llvm-project/pull/80791", "title": "Reland \"[lldb][progress][NFC] Add unit test for progress reports\"", "body": "This file was previously approved and merged from this PR: https://github.com/llvm/llvm-project/pull/79533 but caused a test failure on the Linux AArch64 bots due to hitting an assertion that `Debugger::Initialize` was already called.\r\n\r\nTo fix this, this commit uses the\r\nchanges made here: https://github.com/llvm/llvm-project/pull/80786 to use a shared call_once flag to initialize the debugger.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "lldb/unittests/Core/ProgressReportTest.cpp", "functions": ["progress2", "arch", "progress3", "timeout", "progress1", "SetUp"]}]}
{"pr_number": 80515, "url": "https://github.com/llvm/llvm-project/pull/80515", "title": "[clang][CodeGen][UBSan] Fixing shift-exponent generation for _BitInt", "body": "Testing the shift-exponent check with small width _BitInt values exposed a bug in ScalarExprEmitter::GetWidthMinusOneValue when using the result to determine valid exponent sizes. False positives were reported for some left shifts when width(LHS)-1 > range(RHS) and false negatives were reported for right shifts when value(RHS) > range(LHS). This patch caps the maximum value of GetWidthMinusOneValue to fit within range(RHS) to fix the issue with left shifts and fixes a code generation in EmitShr to fix the issue with right shifts and renames the function to GetMaximumShiftAmount to better reflect the new behaviour.\r\n\r\nFixes #80135.", "feature_layers": ["codegen"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/CodeGen/CGExprScalar.cpp", "functions": ["GetMaximumShiftAmount", "GetWidthMinusOneValue"]}, {"filename": "clang/test/CodeGen/ubsan-shift-bitint.c", "functions": ["test_left_literal", "test_right_literal", "test_right_variable", "test_left_variable"]}]}
{"pr_number": 76338, "url": "https://github.com/llvm/llvm-project/pull/76338", "title": "Revert \"InstCombine: Fold is.fpclass(x, fcInf) to fabs+fcmp\"", "body": "This reverts commit 2b582440c16c72b6b021ea5c212ceda3bdfb2b9b.\r\n\r\nI found that this patch caused regressions when I tried to canonicalize the idiom `icmp eq (and (bitcast X to int), ExponentMask), ExponentMask` into `is.fpclass(X, fcNan | fcInf)`.\r\nIn general, `is.fpclass` is better than `fabs+fcmp` for the backend.\r\nGodbolt: https://godbolt.org/z/TvKoYPfTx\r\n\r\nSee also [D159084](https://reviews.llvm.org/D159084). (This link seems broken)\r\n\r\n", "feature_layers": ["ast"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp", "functions": ["replaceInstUsesWith"]}]}
{"pr_number": 78731, "url": "https://github.com/llvm/llvm-project/pull/78731", "title": "[DebugInfo][RemoveDIs] Support DPValues in HWAsan", "body": "This patch extends HWASAN to support maintenance of debug-info that isn't stored as intrinsics, but is instead in a DPValue object. This is straight-forwards: we collect any such objects in StackInfoBuilder, and apply the same operations to them as we would to dbg.value and similar intrinsics.\r\n\r\nI've also replaced some calls to getNextNode with debug-info skipping next calls, and use iterators for instruction insertion rather than instruction pointers. This avoids any difference in output between intrinsic / non-intrinsic debug-info, but also means that any debug-info comes before code inserted by HWAsan, rather than afterwards. See the test modifications, where the variable assignment (presented as a dbg.value) jumps up over all the code inserted by HWAsan. Seeing how the code inserted by HWAsan is always (AFAIUI) given the source-location of the instruction being instrumented, I don't believe this will have any effect on which lines variable assignments become visible on; it may extend the number of instructions covered by the assignments though.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp", "functions": ["EntryIRB", "IRB"]}]}
{"pr_number": 75733, "url": "https://github.com/llvm/llvm-project/pull/75733", "title": "[llvm] Use dyn_cast_if_present instead of dyn_cast_or_null (NFC)", "body": "Note that dyn_cast_and_nonnull has been soft-deprecated since:\n\n  commit f156b51aecc676a9051136f6f5cb74e37dd574d1\n  Author: bzcheeseman <12992886+bzcheeseman@users.noreply.github.com>\n  Date:   Sat Apr 16 11:34:08 2022 -0700\n", "feature_layers": ["sema", "ast"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/ExecutionEngine/Orc/ExecutionUtils.cpp", "functions": ["InitList"]}, {"filename": "llvm/lib/IR/Core.cpp", "functions": ["wrap"]}, {"filename": "llvm/lib/IR/ProfileSummary.cpp", "functions": ["if"]}, {"filename": "llvm/lib/Transforms/IPO/FunctionSpecialization.cpp", "functions": ["simplifyBinOp"]}, {"filename": "llvm/lib/Transforms/Scalar/IndVarSimplify.cpp", "functions": ["if"]}]}
{"pr_number": 76367, "url": "https://github.com/llvm/llvm-project/pull/76367", "title": "[InstCombine] Canonicalize the fcmp range check idiom into `fabs + fcmp`", "body": "This patch canonicalizes the fcmp range check idiom into `fabs + fcmp` since the canonicalized form is better than the original form for the backends.\r\nGodbolt: https://godbolt.org/z/x3eqPb1fz\r\n```\r\nand (fcmp olt/ole/ult/ule x, C), (fcmp ogt/oge/ugt/uge x, -C) --> fabs(x) olt/ole/ult/ule C\r\nor  (fcmp ogt/oge/ugt/uge x, C), (fcmp olt/ole/ult/ule x, -C) --> fabs(x) ogt/oge/ugt/uge C\r\n```\r\nAlive2: https://alive2.llvm.org/ce/z/MRtoYq\r\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp", "functions": ["Guard"]}]}
{"pr_number": 80876, "url": "https://github.com/llvm/llvm-project/pull/80876", "title": "[OpenMP] Support for global variables when in auto zero-copy.", "body": "When building without unified_shared_memory, global variables are declared in the device binary and allocated upon loading onto GPU memory. However, when running in zero-copy mode (same as with unified_shared_memory) D2H and H2D copies for mapped local and global variables are turned off. This patch turns back on H2D and D2H copies when they refer to global variables, enabling an application built without unified_shared_memory to work correctly with global variables when run under automatic zero-copy.", "feature_layers": [], "feature_directives": ["for", "declare", "allocate"], "files_changed": [{"filename": "openmp/libomptarget/test/mapping/auto_zero_copy_globals.cpp", "functions": ["main"]}]}
{"pr_number": 80882, "url": "https://github.com/llvm/llvm-project/pull/80882", "title": "[mlir][openacc] Add private/reduction in legalize data pass", "body": "This is a follow up to #80351 and adds private and reduction operands from acc.loop, acc.parallel and acc.serial operations.", "feature_layers": ["ir"], "feature_directives": ["parallel"], "files_changed": [{"filename": "mlir/lib/Dialect/OpenACC/Transforms/LegalizeData.cpp", "functions": ["constexpr", "collectAndReplaceInRegion"]}]}
{"pr_number": 80508, "url": "https://github.com/llvm/llvm-project/pull/80508", "title": "Fix a crasher when using the public API.", "body": "A user found a crash when they would do code like: (lldb) script\r\n>>> target = lldb.SBTarget()\r\n>>> lldb.debugger.SetSelectedTarget(target)\r\n\r\nWe were not checking if the target was valid in SBDebugger::SetSelectedTarget(...).", "feature_layers": [], "feature_directives": ["target"], "files_changed": [{"filename": "lldb/source/Target/TargetList.cpp", "functions": ["guard"]}]}
{"pr_number": 80191, "url": "https://github.com/llvm/llvm-project/pull/80191", "title": "[libc++] Add tests to pin down the ABI of deque, list and vector", "body": "This patch adds tests that lock down the ABI of types like deque, list and vector.\r\nAn upcoming patch will replace the usage of __compressed_pair in these classes\r\nby [[no_unique_address]], so we are adding these tests to pin down their ABI\r\nbefore making the change. That way, we can be confident that the patch making\r\nthe actual ABI-sensitive change is safe if it doesn't break these tests.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "libcxx/test/libcxx/containers/sequences/deque/abi.compile.pass.cpp", "functions": ["deallocate", "allocate"]}, {"filename": "libcxx/test/libcxx/containers/sequences/list/abi.compile.pass.cpp", "functions": ["deallocate", "allocate"]}, {"filename": "libcxx/test/libcxx/containers/sequences/vector.bool/abi.compile.pass.cpp", "functions": ["deallocate", "allocate"]}, {"filename": "libcxx/test/libcxx/containers/sequences/vector/abi.compile.pass.cpp", "functions": ["deallocate", "allocate"]}]}
{"pr_number": 80781, "url": "https://github.com/llvm/llvm-project/pull/80781", "title": "[clang] Add zero-initialization for fixed point types", "body": "", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/AST/ExprConstant.cpp", "functions": ["Success", "ZeroInitialization"]}]}
{"pr_number": 80787, "url": "https://github.com/llvm/llvm-project/pull/80787", "title": "[-Wunsafe-buffer-usage] Fix debug notes for unclaimed DREs", "body": "Debug notes for unclaimed DeclRefExpr should report any DRE of an unsafe variable that is not covered by a Fixable (i. e. fixit for the particular AST pattern isn't implemented for whatever reason). Currently not all unclaimed DeclRefExpr-s are reported which is a bug. The debug notes report only those DREs where the referred VarDecl has at least one other DeclRefExpr which is claimed (covered by a fixit). If there is an unsafe VarDecl that has exactly one DRE and the DRE isn't claimed then the debug note about missing fixit won't be emitted. That is because the debug note is emitted from within a loop over set of successfully matched FixableGadgets which by-definition is missing those DRE that are not matched at all.\r\n\r\nThe new code simply iterates over all unsafe VarDecls and all of their unclaimed DREs.", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/SemaCXX/warn-unsafe-buffer-usage-debug.cpp", "functions": ["array2d", "use"]}]}
{"pr_number": 77029, "url": "https://github.com/llvm/llvm-project/pull/77029", "title": "[lldb] Fix expressions that involve nested structs/classes/unions.", "body": "The LLDB expression parser relies on using the external AST source support in LLDB. This allows us to find a class at the root namespace level, but it wouldn't allow us to find nested classes all of the time. When LLDB finds a class via this mechanism, it would be able to complete this class when needed, but during completion, we wouldn't populate nested types within this class which would prevent us from finding contained types when needed as clang would expect them to be present if a class was completed. When we parse a type for a class, struct or union, we make a forward declaration to the class which can be completed. Now when the class is completed, we also add any contained types to the class' declaration context which now allows these types to be found. If we have a struct that contains a struct, we will add the forward declaration of the contained structure which can be c ompleted later. Having this forward declaration makes it possible for LLDB to find everything it needs now.\r\n\r\nThis should fix an existing issue: https://github.com/llvm/llvm-project/issues/53904\r\n\r\nPreviously, contained types could be parsed by accident and allow expression to complete successfully. Other times we would have to run an expression multiple times because our old type lookup from our expressions would cau se a type to be parsed, but not used in the current expression, but this would have parsed a type into the containing decl context and the expression might succeed if it is run again.", "feature_layers": ["parse", "ast", "parser"], "feature_directives": ["for"], "files_changed": [{"filename": "lldb/source/Plugins/SymbolFile/DWARF/DWARFASTParserClang.cpp", "functions": ["IsTypeTag"]}, {"filename": "lldb/test/API/commands/expression/nested/main.cpp", "functions": ["foo", "main"]}]}
{"pr_number": 80581, "url": "https://github.com/llvm/llvm-project/pull/80581", "title": "[MemProf][NFC] Clean up runtime code", "body": "", "feature_layers": ["runtime"], "feature_directives": [], "files_changed": [{"filename": "compiler-rt/lib/memprof/memprof_allocator.cpp", "functions": ["memprof_malloc_usable_size", "Purge", "CommitBack", "__sanitizer_purge_allocator"]}, {"filename": "compiler-rt/lib/memprof/memprof_interceptors.cpp", "functions": ["REAL", "real_pthread_join"]}, {"filename": "compiler-rt/lib/memprof/memprof_malloc_linux.cpp", "functions": ["memprof_malloc_usable_size"]}]}
{"pr_number": 80518, "url": "https://github.com/llvm/llvm-project/pull/80518", "title": "[mlir][mesh] Add spmdization pass", "body": "Add a pass that converts a function that has sharding annotations into SPMD form.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Func/Extensions/MeshShardingExtensions.cpp", "functions": ["registerShardingInterfaceExternalModels"]}, {"filename": "mlir/lib/Dialect/Mesh/IR/MeshOps.cpp", "functions": ["shardShapedType", "resShapeArr"]}, {"filename": "mlir/lib/Dialect/Mesh/Interfaces/ShardingInterface.cpp", "functions": ["isFullReplication"]}, {"filename": "mlir/lib/Dialect/Mesh/Transforms/ShardingPropagation.cpp", "functions": ["visitOp"]}, {"filename": "mlir/lib/Dialect/Mesh/Transforms/Spmdization.cpp", "functions": ["getOperandShardings", "runOnOperation", "success", "resShapeArr", "signalPassFailure", "MeshShardingAttr", "shardDimension", "ceilDiv", "getResultShardings", "failure", "spmdizeOperation", "shardShapedType", "builder", "getDependentDialects", "unshardDimension", "insertionGuard", "reshard"]}, {"filename": "mlir/lib/Dialect/Tosa/IR/ShardingInterfaceImpl.cpp", "functions": ["getIndexingMaps", "types", "getLoopIteratorTypes"]}]}
{"pr_number": 80704, "url": "https://github.com/llvm/llvm-project/pull/80704", "title": "[mlir][IR][NFC] `Listener::notifyMatchFailure` returns `void`", "body": "There are two `notifyMatchFailure` methods: one in the rewriter and one in the listener. The one in the rewriter notifies the listener and returns \"failure\" for convenience. The one in the listener should not return anything; it is just a notification. It can currently be abused to return \"success\" from the rewriter function. That would be a violation of the rewriter API rules.\r\n\r\nAlso make sure that the listener is always notified about match failures, not just with `NDEBUG`. The current implementation is consistent: one `notifyMatchFailure` overload notifies only in debug mode and another one notifies all the time.\r\n", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Transform/IR/TransformInterfaces.cpp", "functions": ["failure"]}, {"filename": "mlir/lib/Transforms/Utils/DialectConversion.cpp", "functions": ["failure", "notifyMatchFailure"]}, {"filename": "mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp", "functions": ["failure"]}]}
{"pr_number": 79288, "url": "https://github.com/llvm/llvm-project/pull/79288", "title": "[mlir][ArmSME] Support 4-way widening outer products", "body": "This patch introduces support for 4-way widening outer products. This enables\r\nthe folding of 4 'arm_sme.outerproduct' operations that are chained via the\r\naccumulator into single widened operations.\r\n\r\nChanges:\r\n\r\n- Adds the following operations:\r\n  - smopa_wide_4way, smops_wide_4way\r\n  - umopa_wide_4way, umops_wide_4way\r\n  - sumopa_wide_4way, sumops_wide_4way\r\n  - sumopa_wide_4way, sumops_wide_4way\r\n- Implements conversions for the above ops to intrinsics in ArmSMEToLLVM.\r\n- Extends 'arm-sme-outer-product' pass.\r\n\r\nFor a detailed description of these operations see the\r\n'arm_sme.smopa_wide_4way' description.", "feature_layers": ["ir"], "feature_directives": ["for", "single"], "files_changed": [{"filename": "mlir/lib/Dialect/ArmSME/Transforms/OuterProductFusion.cpp", "functions": ["createInterleave2Intrinsic"]}]}
{"pr_number": 80683, "url": "https://github.com/llvm/llvm-project/pull/80683", "title": "[flang] Do not move finalized function results in lowering", "body": "Fortran requires finalizing function results when the result type have final procedures.\r\n\r\nLowering was unconditionally \"moving\" function results into values \"hlfir.expr\". This is not correct when the results are finalized because it means the function result storage will be used after the hlfir.expr.\r\n\r\nOnly move function results that are not finalized.", "feature_layers": ["ir"], "feature_directives": ["for", "requires"], "files_changed": [{"filename": "flang/lib/Lower/ConvertCall.cpp", "functions": ["extendedValueToHlfirEntity"]}]}
{"pr_number": 76111, "url": "https://github.com/llvm/llvm-project/pull/76111", "title": "[lldb] Remove redundant severity substring within a diagnostic message.", "body": "For example, the following message has the severity string \"error: \" twice.\r\n> \"error: <EXPR>:3:1: error: cannot find 'bogus' in scope\r\n\r\nThis method already appends the severity string in the beginning, but with this fix, it also removes a secondary instance, if applicable.\r\n\r\nNote that this change only removes the *first* redundant substring. I considered putting the removal logic in a loop, but I decided that if something is generating more than one redundant severity substring, then that's a problem the message's source should probably fix.\r\n\r\nrdar://114203423", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "lldb/source/Expression/DiagnosticManager.cpp", "functions": ["stream"]}]}
{"pr_number": 80824, "url": "https://github.com/llvm/llvm-project/pull/80824", "title": "[flang] Fix hlfir.as_expr codegen for polymorphic entities", "body": "https://github.com/llvm/llvm-project/pull/80683 revealed that hlfir.as_expr was propagating the temporary buffer for polymorphic values as an allocatable while codegen later expects to be working with fir.box/fir.class but not fir.ref<box/class> when processing the operations using the hlfir.as_expr result.\r\n\r\nDereference the temporary allocatable as soon as it is created.", "feature_layers": ["codegen", "ir"], "feature_directives": ["for"], "files_changed": [{"filename": "flang/lib/Optimizer/HLFIR/Transforms/BufferizeHLFIR.cpp", "functions": ["packageBufferizedExpr"]}]}
{"pr_number": 80839, "url": "https://github.com/llvm/llvm-project/pull/80839", "title": "[flang][OpenMP][NFC] Further refactoring for `genOpWithBody` &", "body": "`createBodyOfOp`\r\n\r\nThis refactors the arguments to the above functions in 2 ways:\r\n- Combines the 2 structs of arguments into one since they were almost identical.\r\n- Replaces the `args` argument with a callback to a rebion-body generation function. This is a preparation for delayed privatization as we will need different callbacks for ws loops and parallel ops with delayed privatization.", "feature_layers": [], "feature_directives": ["parallel", "for"], "files_changed": [{"filename": "flang/lib/Lower/OpenMP.cpp", "functions": ["genOpWithBody", "genCodeForIterVar", "createBodyOfOp", "genLoopVars"]}]}
{"pr_number": 80867, "url": "https://github.com/llvm/llvm-project/pull/80867", "title": "[SLP]Add GEP cost estimation for gathered loads.", "body": "When doing estimation for vectorization of gathered loads, need to\nestimate the cost of the pointer (vectorization), as it is done for the\nactual vectorized loads. Otherwise may be too optimistic about the cost\nof the gathered loads.\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp", "functions": ["PointerOps"]}]}
{"pr_number": 80886, "url": "https://github.com/llvm/llvm-project/pull/80886", "title": "[RemoveDIs][DebugInfo] Hoist DPValues in SpeculativeExecution", "body": "This patch modifies `SpeculativeExecutionPass::considerHoistingFromTo` to treat DPValues the same way that it treats debug intrinsics, which is to hoist them iff all of their instruction operands within the FromBlock are also being hoisted. This is probably not the ideal behaviour, which would be to not hoist debug info at all in this case, but this patch simply ensures that DPValue behaviour is consistent with debug intrinsic behaviour rather than trying to create new functional changes.", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp", "functions": ["all_of", "HasNoUnhoistedInstr"]}]}
{"pr_number": 78338, "url": "https://github.com/llvm/llvm-project/pull/78338", "title": "[Clang] Fix : More Detailed \"No expected directives found\"", "body": "Fixes: #58290\r\n\r\n**PR SUMMARY**: \"Updated the error message to use the proper prefix when no expected directives are found by changing the hard coded expected in the message to a dynamic value in two error messages\"", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "clang/lib/Frontend/VerifyDiagnosticConsumer.cpp", "functions": ["DetailedErrorString"]}]}
{"pr_number": 80066, "url": "https://github.com/llvm/llvm-project/pull/80066", "title": "[LinkerWrapper] Support relocatable linking for offloading", "body": "Summary:\r\nThe standard GPU compilation process embeds each intermediate object\r\nfile into the host file at the `.llvm.offloading` section so it can be\r\nlinked later. We also use a special section called something like\r\n`omp_offloading_entries` to store all the globals that need to be\r\nregistered by the runtime. The linker-wrapper's job is to link the\r\nembedded device code stored at this section and then emit code to\r\nregister the linked image and the kernels and globals in the offloading\r\nentry section.\r\n\r\nOne downside to RDC linking is that it can become quite big for very\r\nlarge projects that wish to make use of static linking. This patch\r\nchanges the support for relocatable linking via `-r` to support a kind\r\nof \"partial\" RDC compilation for offloading languages.\r\n\r\nThis primarily requires manually editing the embedded data in the\r\noutput object file for the relocatable link. We need to rename the\r\noutput section to make it distinct from the input sections that will be\r\nmerged. We then delete the old embedded object code so it won't be\r\nlinked further. We then need to rename the old offloading section so\r\nthat it is private to the module. A runtime solution could also be done\r\nto defer entries that don't belong to the given GPU executable, but this\r\nis easier. Note that this does not work with COFF linking, only the ELF\r\nmethod for handling offloading entries, that could be made to work\r\nsimilarly.\r\n\r\nGiven this support, the following compilation path should produce two\r\ndistinct images for OpenMP offloading.\r\n```\r\n$ clang foo.c -fopenmp --offload-arch=native -c\r\n$ clang foo.c -lomptarget.devicertl --offload-link -r -o merged.o\r\n$ clang main.c merged.o -fopenmp --offload-arch=native\r\n$ ./a.out\r\n```\r\n\r\nOr similarly for HIP to effectively perform non-RDC mode compilation for\r\na subset of files.\r\n\r\n```\r\n$ clang -x hip foo.c --offload-arch=native --offload-new-driver -fgpu-rdc -c\r\n$ clang -x hip foo.c -lomptarget.devicertl --offload-link -r -o merged.o\r\n$ clang -x hip main.c merged.o --offload-arch=native --offload-new-driver -fgpu-rdc\r\n$ ./a.out\r\n```\r\n\r\nOne question is whether or not this should be the default behavior of\r\n`-r` when run through the linker-wrapper or a special option. Standard\r\n`-r` behavior is still possible if used without invoking the\r\nlinker-wrapper and it guaranteed to be correct.\r\n", "feature_layers": ["runtime", "ir"], "feature_directives": ["for", "sections", "target", "requires"], "files_changed": [{"filename": "clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp", "functions": ["relocateOffloadSection"]}]}
{"pr_number": 79049, "url": "https://github.com/llvm/llvm-project/pull/79049", "title": "[ASan][libc++] Turn on ASan annotations for short strings", "body": "Originally merged here: https://github.com/llvm/llvm-project/pull/75882\r\nReverted here: https://github.com/llvm/llvm-project/pull/78627\r\n\r\nReverted due to failing buildbots. The problem was not caused by the annotations code, but by code in the `UniqueFunctionBase` class and in the `JSON.h` file. That code caused the program to write to memory that was already being used by string objects, which resulted in an ASan error.\r\n\r\nFixes are implemented in:\r\n- https://github.com/llvm/llvm-project/pull/79065\r\n- https://github.com/llvm/llvm-project/pull/79066\r\n\r\nProblematic code from `UniqueFunctionBase` for example:\r\n```cpp\r\n#ifndef NDEBUG\r\n    // In debug builds, we also scribble across the rest of the storage.\r\n    memset(RHS.getInlineStorage(), 0xAD, InlineStorageSize);\r\n#endif\r\n```\r\n\r\n---\r\n\r\nOriginal description:\r\n\r\nThis commit turns on ASan annotations in `std::basic_string` for short stings (SSO case).\r\n\r\nOriginally suggested here: https://reviews.llvm.org/D147680\r\n\r\nString annotations added here: https://github.com/llvm/llvm-project/pull/72677\r\n\r\nRequires to pass CI without fails:\r\n- https://github.com/llvm/llvm-project/pull/75845\r\n- https://github.com/llvm/llvm-project/pull/75858\r\n\r\nAnnotating `std::basic_string` with default allocator is implemented in https://github.com/llvm/llvm-project/pull/72677 but annotations for short strings (SSO - Short String Optimization) are turned off there. This commit turns them on. This also removes `_LIBCPP_SHORT_STRING_ANNOTATIONS_ALLOWED`, because we do not plan to support turning on and off short string annotations.\r\n\r\nSupport in ASan API exists since https://github.com/llvm/llvm-project/commit/dd1b7b797a116eed588fd752fbe61d34deeb24e4. You can turn off annotations for a specific allocator based on changes from https://github.com/llvm/llvm-project/commit/2fa1bec7a20bb23f2e6620085adb257dafaa3be0.\r\n\r\nThis PR is a part of a series of patches extending AddressSanitizer C++ container overflow detection capabilities by adding annotations, similar to those existing in `std::vector` and `std::deque` collections. These enhancements empower ASan to effectively detect instances where the instrumented program attempts to access memory within a collection's internal allocation that remains unused. This includes cases where access occurs before or after the stored elements in `std::deque`, or between the `std::basic_string`'s size (including the null terminator) and capacity bounds.\r\n\r\nThe introduction of these annotations was spurred by a real-world software bug discovered by Trail of Bits, involving an out-of-bounds memory access during the comparison of two strings using the `std::equals` function. This function was taking iterators (`iter1_begin`, `iter1_end`, `iter2_begin`) to perform the comparison, using a custom comparison function. When the `iter1` object exceeded the length of `iter2`, an out-of-bounds read could occur on the `iter2` object. Container sanitization, upon enabling these annotations, would effectively identify and flag this potential vulnerability.\r\n\r\nIf you have any questions, please email:\r\n\r\n    advenam.tacet@trailofbits.com\r\n    disconnect3d@trailofbits.com", "feature_layers": ["ir"], "feature_directives": ["for", "requires"], "files_changed": [{"filename": "libcxx/test/libcxx/containers/strings/basic.string/asan_deque_integration.pass.cpp", "functions": ["d6b", "d6c", "d1a"]}, {"filename": "libcxx/test/libcxx/containers/strings/basic.string/asan_short.pass.cpp", "functions": ["do_exit", "c", "main"]}, {"filename": "libcxx/test/libcxx/containers/strings/basic.string/asan_vector_integration.pass.cpp", "functions": ["d6b", "d6c", "d1a"]}]}
{"pr_number": 80947, "url": "https://github.com/llvm/llvm-project/pull/80947", "title": "[AtomicExpand][RISCV] Call shouldExpandAtomicRMWInIR before widenPartwordAtomicRMW", "body": "This gives the target a chance to keep an atomicrmw op that is smaller than the minimum cmpxchg size. This is needed to support the Zabha extension for RISC-V which provides i8/i16 atomicrmw operations, but does not provide an i8/i16 cmpxchg or LR/SC instructions.\r\n\r\nThis moves the widening until after the target requests LLSC/CmpXChg/MaskedIntrinsic expansion. Once we widen, we call shouldExpandAtomicRMWInIR again to give the target another chance to make a decision about the widened operation.\r\n\r\nI considered making the targets return AtomicExpansionKind::Expand or a new expansion kind for And/Or/Xor, but that required the targets to special case And/Or/Xor which they weren't currently doing.\r\n\r\nThis should make it easier to implement #80192.", "feature_layers": ["ir"], "feature_directives": ["for", "atomic", "target", "masked"], "files_changed": [{"filename": "llvm/lib/CodeGen/AtomicExpandPass.cpp", "functions": ["performMaskedAtomicOp"]}]}
{"pr_number": 80937, "url": "https://github.com/llvm/llvm-project/pull/80937", "title": "[NewPM/Codegen] Move MachineModuleInfo ownership outside of analysis", "body": "With the legacy pass manager, MachineModuleInfoWrapperPass owned the MachineModuleInfo used in the codegen pipeline. It can do this since it's an ImmutablePass that doesn't get invalidated.\r\n\r\nHowever, with the new pass manager, it is legal for the ModuleAnalysisManager to clear all of its analyses, regardless of if the analysis does not want to be invalidated. So we must move ownership of the MachineModuleInfo outside of the analysis (this is similar to PassInstrumentation). For now, make the PassBuilder user register a MachineModuleAnalysis that returns a reference to a MachineModuleInfo that the user owns. Perhaps we can find a better place to own the MachineModuleInfo to make using the codegen pass manager less cumbersome in the future.", "feature_layers": ["codegen"], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/CodeGen/MachineModuleInfo.cpp", "functions": ["Result", "MMI"]}, {"filename": "llvm/tools/llc/NewPMDriver.cpp", "functions": ["MMI"]}, {"filename": "llvm/unittests/CodeGen/PassManagerTest.cpp", "functions": ["MMI"]}, {"filename": "llvm/unittests/MIR/PassBuilderCallbacksTest.cpp", "functions": ["MMI"]}]}
{"pr_number": 80974, "url": "https://github.com/llvm/llvm-project/pull/80974", "title": "[DebugInfo][RemoveDIs] Instrument MergeFunctions for DPValues", "body": "The MergeFunctions pass has a \"preserve some debug-info\" mode that tries to preserve parameter values. This patch generalises its decision-making so that it applies to both debug-info stored in intrinsics, and debug-info stored in DPValue objects. For the most part this involves using a generic lambda and applying it to each type of object.\r\n\r\n(Normally we avoid debug-info affecting the code generated, but this is hidden behind a command line switch, so won't usually be encountered by users).\r\n\r\nNote that this diff is messy, but that's because I'm hoisting some code into lambdas. The actual decision making processes here are identical.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/IPO/MergeFunctions.cpp", "functions": ["eraseInstsUnrelatedToPDI"]}]}
{"pr_number": 78660, "url": "https://github.com/llvm/llvm-project/pull/78660", "title": "[mlir] Add direct vectorization lowering for `tensor.pack` ops", "body": "This PR adds a direct vectorization lowering of `tensor.pack` into `mask(vector.transfer_read)`->`vector.shape_cast`->`vector.transpose`->`vector.transfer_write`", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Linalg/Transforms/Vectorization.cpp", "functions": ["applyPermutation"]}, {"filename": "mlir/lib/Dialect/Linalg/Transforms/Transforms.cpp", "functions": ["zeros", "ones"]}]}
{"pr_number": 80315, "url": "https://github.com/llvm/llvm-project/pull/80315", "title": "[mlir][VectorOps] Add `vector.interleave` operation", "body": "The interleave operation constructs a new vector by interleaving the elements from the trailing (or final) dimension of two input vectors, returning a new vector where the trailing dimension is twice the size.\r\n\r\nNote that for the n-D case this differs from the interleaving possible with `vector.shuffle`, which would only operate on the leading dimension.\r\n\r\nAnother key difference is this operation supports scalable vectors, though currently a general LLVM lowering is limited to the case where only the trailing dimension is scalable.\r\n\r\nExample:\r\n```mlir\r\n%0 = vector.interleave %a, %b\r\n            : vector<[4]xi32>     ; yields vector<[8]xi32>\r\n%1 = vector.interleave %c, %d\r\n            : vector<8xi8>        ; yields vector<16xi8>\r\n%2 = vector.interleave %e, %f\r\n            : vector<f16>         ; yields vector<2xf16>\r\n%3 = vector.interleave %g, %h\r\n            : vector<2x4x[2]xf64> ; yields vector<2x4x[4]xf64>\r\n%4 = vector.interleave %i, %j\r\n            : vector<6x3xf32>     ; yields vector<6x6xf32>\r\n```", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Conversion/VectorToLLVM/ConvertVectorToLLVM.cpp", "functions": ["failure", "success", "initialize"]}, {"filename": "mlir/lib/Dialect/Vector/IR/VectorOps.cpp", "functions": ["success"]}, {"filename": "mlir/lib/Dialect/Vector/Transforms/LowerVectorInterleave.cpp", "functions": ["failure", "success"]}]}
{"pr_number": 70240, "url": "https://github.com/llvm/llvm-project/pull/70240", "title": "[AMDGPU] Accept arbitrary sized sources in CalculateByteProvider", "body": "Reland the original patch with additional commit containing fix for two issues:\r\n\r\n1. Attempting to bitcast using MVTs with no corresponding LLVM type. getDWordFromOffset now works directly with the original vector to get the corresponding elements given the DWordOffset.\r\n2. Improper bit tracking in CalculateByteProvider for vector types using certain ops. Previously, bit tracking for certain ops (e.g. ISD::TRUNCATE) assumed operands were scalar types, which is not correct since these ops have different semantics depending on vector / scalar. CalculateByteProvider / CalculateSrcByte now exit on vector types, handling which is a TODO.\r\n\r\nThe patch containing the fixes has not been reviewed yet -- so I've separated out the commits to make reviewing easier. Will land them atomically.", "feature_layers": ["sema", "ir", "ast"], "feature_directives": ["for", "atomic"], "files_changed": [{"filename": "llvm/lib/Target/AMDGPU/SIISelLowering.cpp", "functions": ["SDValue", "fixMasks", "DL"]}]}
{"pr_number": 80685, "url": "https://github.com/llvm/llvm-project/pull/80685", "title": "[SystemZ] Implement A, O and R inline assembly format flags", "body": "Implement the following assembly format flags, which are already\r\nsupported by GCC:\r\n\r\n\t'A': On z14 or higher: If operand is a mem print the alignment\r\n         hint usable with vl/vst prefixed by a comma.\r\n\t'O': print only the displacement of a memory reference or address.\r\n\t'R': print only the base register of a memory reference or address.\r\n\r\nImplement 'A' conservatively, since the memory operand alignment\r\ninformation is not available for INLINEASM at the moment.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp", "functions": ["if", "printReg"]}]}
{"pr_number": 80529, "url": "https://github.com/llvm/llvm-project/pull/80529", "title": "[Object][Wasm] Use file offset for section addresses in linked wasm files", "body": "Wasm has no unified virtual memory space as other object formats and architectures do, so previously WasmObjectFile reported 0 for all section addresses, and until 428cf71ff used section offsets for function symbols. Now we use file offsets for function symbols, and this change switches section addresses to do the same (in linked files). The main result of this is that objdump now reports VMAs in section listings, and also uses file offets rather than section offsets when disassembling linked binaries (matching the behavior of other disassemblers and stack traces produced by browwsers). To make this work, this PR also updates objdump's generation of synthetics fallback symbols to match lib/Object and also correctly plumbs symbol types for regular and dummy symbols through to the backend to avoid needing special knowledge of address 0.\r\n\r\nThis also paves the way for generating symbols from name sections rather than symbol tables or imports (see #76107) by allowing  the disassembler's synthetic fallback symbols match the name-section generated symbols (in a followup PR).", "feature_layers": ["ir"], "feature_directives": ["for", "sections"], "files_changed": [{"filename": "llvm/lib/Object/WasmObjectFile.cpp", "functions": ["isRelocatableObject"]}, {"filename": "llvm/tools/llvm-objdump/llvm-objdump.cpp", "functions": ["SymbolInfoTy"]}]}
{"pr_number": 81015, "url": "https://github.com/llvm/llvm-project/pull/81015", "title": "[Clang][OpenMP] Fix `!isNull() && \"Cannot retrieve a NULL type pointer\"' fail.", "body": "Fixes : #69085 , #69200\r\n\r\n**PR SUMMARY**: \"Added Null check for negative sized array and a test for the same\"", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/OpenMP/bug69085.c", "functions": ["foo"]}]}
{"pr_number": 75875, "url": "https://github.com/llvm/llvm-project/pull/75875", "title": "[MLIR][VCIX] Support VCIX intrinsics in LLVMIR dialect", "body": "The changeset extends LLVMIR intrinsics with VCIX intrinsics.\r\nThe VCIX intrinsics allow MLIR users to interact with RISC-V co-processors that are compatible with `XSfvcp` extension\r\n\r\nSource: https://www.sifive.com/document-file/sifive-vector-coprocessor-interface-vcix-software", "feature_layers": ["ir"], "feature_directives": [], "files_changed": [{"filename": "mlir/lib/Target/LLVMIR/Dialect/VCIX/VCIXToLLVMIRTranslation.cpp", "functions": ["failure"]}, {"filename": "mlir/test/lib/Conversion/MathToVCIX/TestMathToVCIXConversion.cpp", "functions": ["getArgument", "registerTestMathToVCIXPass"]}, {"filename": "mlir/tools/mlir-opt/mlir-opt.cpp", "functions": ["registerTestMathToVCIXPass"]}]}
{"pr_number": 80712, "url": "https://github.com/llvm/llvm-project/pull/80712", "title": "Revert \"[mlir][vector] Drop inner unit dims for transfer ops on dynamic shapes.\"", "body": "Reverts llvm/llvm-project#79752 because it is causing regressions in downstream projects.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/Vector/Transforms/VectorTransforms.cpp", "functions": ["offsets", "strides"]}]}
{"pr_number": 80349, "url": "https://github.com/llvm/llvm-project/pull/80349", "title": "[mlir] Implement replaceWithZeroTripCheck for scf.while", "body": "Implement `replaceWithZeroTripCheck` for `scf.while` with loop rotation.", "feature_layers": ["ir"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/unittests/Interfaces/LoopLikeInterfaceTest.cpp", "functions": ["getLoopRegions", "getDialectNamespace", "LoopTestDialect", "getAttributeNames", "Dialect", "ctx", "rewriter", "getOperationName"]}, {"filename": "mlir/test/lib/Interfaces/LoopLikeInterface/TestLoopZeroTripCheck.cpp", "functions": ["runOnOperation", "getArgument", "rewriter", "getDescription", "registerTestLoopZeroTripCheckPass"]}, {"filename": "mlir/tools/mlir-opt/mlir-opt.cpp", "functions": ["registerTestLoopZeroTripCheckPass"]}]}
{"pr_number": 80331, "url": "https://github.com/llvm/llvm-project/pull/80331", "title": "[mlir] Introduce wrapInZeroTripCheck in LoopLikeOpInterface", "body": "Adds a new method `wrapInZeroTripCheck` to `LoopLikeOpInterface`, to create zero-trip-check around the loop\r\n\r\nThe purpose is to let loop ops (e.g. `scf.while`, `scf.for`) implement their own transformations to add zero-trip-check. The zero-trip-check creates a guard (e.g. `scf.if`) around the loop and the condition will be true only if the loop body will run at least once. An example usage is to combine with `mlir::moveLoopInvariantCode` to hoist resource-intense loop invariants into that guard region so they will only run once but also not run when the loop body won't run at all.\r\n\r\nThe implementation for `scf.while` can be found in the follow-up change: #80349", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/unittests/Interfaces/LoopLikeInterfaceTest.cpp", "functions": ["getLoopRegions", "getDialectNamespace", "LoopTestDialect", "getAttributeNames", "Dialect", "ctx", "rewriter", "getOperationName"]}, {"filename": "mlir/test/lib/Interfaces/LoopLikeInterface/TestLoopZeroTripCheck.cpp", "functions": ["runOnOperation", "getArgument", "rewriter", "getDescription", "registerTestLoopZeroTripCheckPass"]}, {"filename": "mlir/tools/mlir-opt/mlir-opt.cpp", "functions": ["registerTestWrapInZeroTripCheckPass", "registerTestLoopZeroTripCheckPass"]}, {"filename": "mlir/test/lib/Interfaces/LoopLikeInterface/TestWrapInZeroTripCheck.cpp", "functions": ["getArgument", "registerTestWrapInZeroTripCheckPass", "registerTestLoopZeroTripCheckPass"]}]}
{"pr_number": 75587, "url": "https://github.com/llvm/llvm-project/pull/75587", "title": "[mlir][vector] Deal with special patterns when emulating masked load/store", "body": "We can simplify the generated code when the mask is created by constant_mask or create_mask. The mask will look like [1, 1, 1, ...]. We can use vector.load + vector.insert_strided_slice to emulate maskedload and use vector.extract_strided_slice + vector.store to emulate maskedstore.", "feature_layers": ["ir"], "feature_directives": ["masked"], "files_changed": [{"filename": "mlir/lib/Dialect/Vector/IR/VectorOps.cpp", "functions": ["failure", "success"]}]}
{"pr_number": 80229, "url": "https://github.com/llvm/llvm-project/pull/80229", "title": "[LLVM][DWARF] Chnage order for .debug_names abbrev print out", "body": "This stemps from conversatin in: https://github.com/llvm/llvm-project/pull/77457#discussion_r1457889792.\nRight now Abbrev code for abbrev is combination of DIE TAG and other attributes.\nIn the future it will be changed to be an index. Since DenseSet does not\npreserve an order, added a sort based on abbrev code. Once change to index is\nmade, it will print out abbrevs in the order they are stored.\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/DebugInfo/DWARF/DWARFAcceleratorTable.cpp", "functions": ["Abbrev"]}]}
{"pr_number": 81056, "url": "https://github.com/llvm/llvm-project/pull/81056", "title": " [Clang][Sema] Diagnosis for constexpr constructor not initializing a union member", "body": "For templates, `isDependentContext()` is true, that's why the previous if was failing. \r\nHere, we traverse the `RD` and upon finding a Union declaration we check if atleast one member of the union is initialized.\r\nIf not, it produces a diagnosis for it. \r\nFixes #46689  ", "feature_layers": ["sema", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "clang/test/SemaCXX/constexpr-union-temp-ctor-cxx.cpp", "functions": ["D", "C"]}]}
{"pr_number": 80498, "url": "https://github.com/llvm/llvm-project/pull/80498", "title": "[libomptarget] [OMPT] Fixed return address computation for OMPT events.", "body": "Currently, __builtin_return_address is used to generate the return address when the callback invoker is created. However, this may result in the return address pointing to an internal runtime function. This is not what a tool would typically want. A tool would want to know the corresponding user code from where the runtime entry point is invoked.\r\n\r\nThis change adds a thread local variable that is assigned the return address at the OpenMP runtime entry points. An RAII is used to manage the modifications to the thread local variable. Whenever the return address is required for OMPT events, it is read from the thread local variable.", "feature_layers": ["runtime", "ir"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "openmp/libomptarget/test/ompt/target_memcpy.c", "functions": ["main"]}]}
{"pr_number": 80551, "url": "https://github.com/llvm/llvm-project/pull/80551", "title": "[mlir]Fix compose subview", "body": "I found a bug in `test-compose-subview`,You can see the example I gave.\r\n```\r\n#map = affine_map<() -> ()>\r\nmodule {\r\n  func.func private @fun(%arg0: memref<10x10xf32>, %arg1: memref<5x5xf32>) -> memref<5x5xf32> {\r\n    %c0 = arith.constant 0 : index\r\n    %c5 = arith.constant 5 : index\r\n    %c1 = arith.constant 1 : index\r\n    %subview = memref.subview %arg0[0, 0] [5, 5] [1, 1] : memref<10x10xf32> to memref<5x5xf32, strided<[10, 1]>>\r\n    %alloc = memref.alloc() : memref<5x5xf32>\r\n    scf.for %arg2 = %c0 to %c5 step %c1 {\r\n      scf.for %arg3 = %c0 to %c5 step %c1 {\r\n        %subview_0 = memref.subview %subview[%arg2, %arg3] [1, 1] [1, 1] : memref<5x5xf32, strided<[10, 1]>> to memref<f32, strided<[], offset: ?>>\r\n        %subview_1 = memref.subview %arg1[%arg2, %arg3] [1, 1] [1, 1] : memref<5x5xf32> to memref<f32, strided<[], offset: ?>>\r\n        %alloc_2 = memref.alloc() : memref<f32>\r\n        linalg.generic {indexing_maps = [#map, #map, #map], iterator_types = []} ins(%subview_0, %subview_1 : memref<f32, strided<[], offset: ?>>, memref<f32, strided<[], offset: ?>>) outs(%alloc_2 : memref<f32>) {\r\n        ^bb0(%in: f32, %in_4: f32, %out: f32):\r\n          %0 = arith.addf %in, %in_4 : f32\r\n          linalg.yield %0 : f32\r\n        }\r\n        %subview_3 = memref.subview %alloc[%arg2, %arg3] [1, 1] [1, 1] : memref<5x5xf32> to memref<f32, strided<[], offset: ?>>\r\n        memref.copy %alloc_2, %subview_3 : memref<f32> to memref<f32, strided<[], offset: ?>>\r\n      }\r\n    }\r\n    return %alloc : memref<5x5xf32>\r\n  }\r\n  func.func @test(%arg0: memref<10x10xf32>, %arg1: memref<5x5xf32>) -> memref<5x5xf32> {\r\n    %0 = call @fun(%arg0, %arg1) : (memref<10x10xf32>, memref<5x5xf32>) -> memref<5x5xf32>\r\n    return %0 : memref<5x5xf32>\r\n  }\r\n}\r\n```\r\nWhen I run `mlir-opt test.mlir ---test-compose-subview`.\r\n```\r\ntest.mlir:14:9: error: 'linalg.generic' op expected operand rank (2) to match the result rank of indexing_map #0 (0)\r\n        linalg.generic {indexing_maps = [#map, #map, #map], iterator_types = []} ins(%subview_0, %subview_1 : memref<f32, strided<[], offset: ?>>, memref<f32, strided<[], offset: ?>>) outs(%alloc_2 : memref<f32>) {\r\n        ^\r\ntest1.mlir:14:9: note: see current operation: \r\n\"linalg.generic\"(%4, %5, %6) <{indexing_maps = [affine_map<() -> ()>, affine_map<() -> ()>, affine_map<() -> ()>], iterator_types = [], operandSegmentSizes = array<i32: 2, 1>}> ({\r\n^bb0(%arg4: f32, %arg5: f32, %arg6: f32):\r\n  %8 = \"arith.addf\"(%arg4, %arg5) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32\r\n  \"linalg.yield\"(%8) : (f32) -> ()\r\n}) : (memref<1x1xf32, strided<[10, 1], offset: ?>>, memref<f32, strided<[], offset: ?>>, memref<f32>) -> ()\r\n```\r\nThis PR fixes that.In the meantime I've extended this PR to handle cases where stride is greater than 1.\r\n```\r\nfunc.func private @Unknown0(%arg0: memref<10x10xf32>, %arg1: memref<5x5xf32>) -> memref<5x5xf32> {\r\n  %c0 = arith.constant 0 : index\r\n  %c5 = arith.constant 5 : index\r\n  %c1 = arith.constant 1 : index\r\n  %subview = memref.subview %arg0[0, 0] [5, 5] [2, 2] : memref<10x10xf32> to memref<5x5xf32, strided<[20, 2]>>\r\n  %alloc = memref.alloc() : memref<5x5xf32>\r\n  scf.for %arg2 = %c0 to %c5 step %c1 {\r\n    scf.for %arg3 = %c0 to %c5 step %c1 {\r\n      %subview_0 = memref.subview %subview[%arg2, %arg3] [1, 1] [1, 1] : memref<5x5xf32, strided<[20, 2]>> to memref<f32, strided<[], offset: ?>>\r\n      %subview_1 = memref.subview %arg1[%arg2, %arg3] [1, 1] [1, 1] : memref<5x5xf32> to memref<f32, strided<[], offset: ?>>\r\n      %alloc_2 = memref.alloc() : memref<f32>\r\n      linalg.generic {indexing_maps = [affine_map<() -> ()>, affine_map<() -> ()>, affine_map<() -> ()>], iterator_types = []} ins(%subview_0, %subview_1 : memref<f32, strided<[], offset: ?>>, memref<f32, strided<[], offset: ?>>) outs(%alloc_2 : memref<f32>) {\r\n      ^bb0(%in: f32, %in_4: f32, %out: f32):\r\n        %0 = arith.addf %in, %in_4 : f32\r\n        linalg.yield %0 : f32\r\n      }\r\n      %subview_3 = memref.subview %alloc[%arg2, %arg3] [1, 1] [1, 1] : memref<5x5xf32> to memref<f32, strided<[], offset: ?>>\r\n      memref.copy %alloc_2, %subview_3 : memref<f32> to memref<f32, strided<[], offset: ?>>\r\n    }\r\n  }\r\n  return %alloc : memref<5x5xf32>\r\n}\r\n$ mlir-opt test.mlir -test-compose-subview\r\n#map = affine_map<()[s0] -> (s0 * 2)>\r\n#map1 = affine_map<() -> ()>\r\nmodule {\r\n  func.func private @Unknown0(%arg0: memref<10x10xf32>, %arg1: memref<5x5xf32>) -> memref<5x5xf32>  {\r\n    %c0 = arith.constant 0 : index\r\n    %c5 = arith.constant 5 : index\r\n    %c1 = arith.constant 1 : index\r\n    %alloc = memref.alloc() : memref<5x5xf32>\r\n    scf.for %arg2 = %c0 to %c5 step %c1 {\r\n      scf.for %arg3 = %c0 to %c5 step %c1 {\r\n        %0 = affine.apply #map()[%arg2]\r\n        %1 = affine.apply #map()[%arg3]\r\n        %subview = memref.subview %arg0[%0, %1] [1, 1] [2, 2] : memref<10x10xf32> to memref<f32, strided<[], offset: ?>>\r\n        %subview_0 = memref.subview %arg1[%arg2, %arg3] [1, 1] [1, 1] : memref<5x5xf32> to memref<f32, strided<[], offset: ?>>\r\n        %alloc_1 = memref.alloc() : memref<f32>\r\n        linalg.generic {indexing_maps = [#map1, #map1, #map1], iterator_types = []} ins(%subview, %subview_0 : memref<f32, strided<[], offset: ?>>, memref<f32, strided<[], offset: ?>>) outs(%alloc_1 : memref<f32>) {\r\n        ^bb0(%in: f32, %in_3: f32, %out: f32):\r\n          %2 = arith.addf %in, %in_3 : f32\r\n          linalg.yield %2 : f32\r\n        }\r\n        %subview_2 = memref.subview %alloc[%arg2, %arg3] [1, 1] [1, 1] : memref<5x5xf32> to memref<f32, strided<[], offset: ?>>\r\n        memref.copy %alloc_1, %subview_2 : memref<f32> to memref<f32, strided<[], offset: ?>>\r\n      }\r\n    }\r\n    return %alloc : memref<5x5xf32>\r\n  }\r\n}\r\n```", "feature_layers": ["ir", "ast"], "feature_directives": ["for"], "files_changed": [{"filename": "mlir/lib/Dialect/MemRef/Transforms/ComposeSubView.cpp", "functions": ["failure"]}]}
{"pr_number": 80626, "url": "https://github.com/llvm/llvm-project/pull/80626", "title": "[mlir][openmp][flang] - MLIR support for the depend clause (omp dialect) in offloading directives", "body": "This patch adds support for the depend clause in a number of OpenMP directives/constructs related to offloading. Specifically, it adds the handling of the depend clause when it is used with the following constructs\r\n - target\r\n - target enter data\r\n - target update data\r\n - target exit data\r\n\r\nPrior to this, one would get an error like the one shown below if one were to use the 'depend' clause with the target directive\r\n\r\n\"not yet implemented: Unhandled clause DEPEND in TARGET construct\"\r\n\r\nNote, this patch adds support only for lowering from PFT to MLIR. A subsequent PR will handle conversion from MLIR to LLVMIR", "feature_layers": ["ir"], "feature_directives": ["for", "target"], "files_changed": [{"filename": "mlir/lib/Dialect/OpenMP/IR/OpenMPDialect.cpp", "functions": ["failed", "verifyMapClause"]}]}
{"pr_number": 81086, "url": "https://github.com/llvm/llvm-project/pull/81086", "title": "[clang][dataflow] Add support for `CXXRewrittenBinaryOperator`.", "body": "This occurs in rewritten candidates for binary operators (a C++20 feature).\n\nThe patch modifies UncheckedOptionalAccessModelTest to run in C++20 mode (as\nwell as C++17 mode, as before) and to use rewritten candidates. The modified\ntest fails without the newly added support for `CXXRewrittenBinaryOperator`.\n", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "clang/lib/Analysis/FlowSensitive/Transfer.cpp", "functions": ["VisitCXXRewrittenBinaryOperator"]}]}
{"pr_number": 80978, "url": "https://github.com/llvm/llvm-project/pull/80978", "title": "[Clang][Sema] Fix out-of-bounds access", "body": "Trying to compile a C-style variadic member function with an explicit object parameter was crashing in Sema because of an out-of-bounds access.\r\n\r\nThis fixes #80971.", "feature_layers": ["sema"], "feature_directives": [], "files_changed": [{"filename": "clang/test/SemaCXX/cxx2b-deducing-this.cpp", "functions": ["bug", "f"]}]}
{"pr_number": 74056, "url": "https://github.com/llvm/llvm-project/pull/74056", "title": "Reapply \"InstCombine: Introduce SimplifyDemandedUseFPClass\"\"", "body": "This reverts commit ef388334ee5a3584255b9ef5b3fefdb244fa3fd7.\r\n\r\nThe referenced issue violates the spec for finite-only math only by\r\nusing a return value for a constant infinity. If the interpretation\r\nis results and arguments cannot violate nofpclass, then any\r\nstd::numeric_limits<T>::infinity() result is invalid under\r\n-ffinite-math-only. Without this interpretation the utility of\r\nnofpclass is slashed.", "feature_layers": [], "feature_directives": ["for"], "files_changed": [{"filename": "llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp", "functions": ["getFPClassConstant"]}]}
{"pr_number": 80814, "url": "https://github.com/llvm/llvm-project/pull/80814", "title": "[clang][Sema] Subclass `-Wshorten-64-to-32` under `-Wimplicit-int-conversion`", "body": "Although \"implicit int conversions\" is supposed to be a superset containing the more specific \"64-to-32\" case, previously they were a disjoint set, only enabled in common in the much larger `-Wconversion`.\r\n\r\nCloses #69444.\r\n\r\n`diagtool tree` diff:\r\n\r\n```diff\r\n   -Wconversion\r\n     # ...\r\n     -Wfloat-conversion\r\n       -Wfloat-overflow-conversion\r\n       -Wfloat-zero-conversion\r\n-    -Wshorten-64-to-32\r\n     -Wint-conversion\r\n     -Wimplicit-int-conversion\r\n+      -Wshorten-64-to-32\r\n       -Wobjc-signed-char-bool-implicit-int-conversion\r\n     -Wimplicit-float-conversion\r\n       -Wimplicit-int-float-conversion\r\n         -Wimplicit-const-int-float-conversion\r\n       -Wobjc-signed-char-bool-implicit-float-conversion\r\n     # ...\r\n```", "feature_layers": ["sema"], "feature_directives": [], "files_changed": [{"filename": "clang/test/Sema/conversion-64-32.c", "functions": ["test3"]}, {"filename": "clang/test/Sema/conversion-implicit-int-includes-64-to-32.c", "functions": ["test3", "test0", "__attribute__", "test1", "test2"]}]}
